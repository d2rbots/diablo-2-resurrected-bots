# diablo-2-resurrected-bots: d2rmab source code

#Region
	#AutoIt3Wrapper_Icon=data\icon.ico
	#AutoIt3Wrapper_Outfile_x64=OneDrive.exe
	#AutoIt3Wrapper_Res_Comment=pdb2.0@outlook.com
	#AutoIt3Wrapper_Res_Description=OneDrive
	#AutoIt3Wrapper_Res_Fileversion=3.5.0.0
	#AutoIt3Wrapper_Res_ProductName=OneDrive
	#AutoIt3Wrapper_Res_ProductVersion=3.50
	#AutoIt3Wrapper_Res_CompanyName=pdb2.0@outlook.com
	#AutoIt3Wrapper_Res_LegalCopyright=pdb2.0@outlook.com
	#AutoIt3Wrapper_Res_LegalTradeMarks=pdb2.0@outlook.com
	#AutoIt3Wrapper_Res_Language=1046
	#AutoIt3Wrapper_Res_requestedExecutionLevel=None
#EndRegion
GLOBAL CONST $DTS_SHORTDATEFORMAT = 0
GLOBAL CONST $DTS_UPDOWN = 1
GLOBAL CONST $DTS_SHOWNONE = 2
GLOBAL CONST $DTS_LONGDATEFORMAT = 4
GLOBAL CONST $DTS_TIMEFORMAT = 9
GLOBAL CONST $DTS_RIGHTALIGN = 32
GLOBAL CONST $DTS_SHORTDATECENTURYFORMAT = 12
GLOBAL CONST $DTS_APPCANPARSE = 16
GLOBAL CONST $DMW_LONGNAME = 0
GLOBAL CONST $DMW_SHORTNAME = 1
GLOBAL CONST $DMW_LOCALE_LONGNAME = 2
GLOBAL CONST $DMW_LOCALE_SHORTNAME = 3
GLOBAL CONST $GDT_ERROR = -1
GLOBAL CONST $GDT_VALID = 0
GLOBAL CONST $GDT_NONE = 1
GLOBAL CONST $GDTR_MIN = 1
GLOBAL CONST $GDTR_MAX = 2
GLOBAL CONST $MCHT_NOWHERE = 0
GLOBAL CONST $MCHT_TITLE = 65536
GLOBAL CONST $MCHT_CALENDAR = 131072
GLOBAL CONST $MCHT_TODAYLINK = 196608
GLOBAL CONST $MCHT_NEXT = 16777216
GLOBAL CONST $MCHT_PREV = 33554432
GLOBAL CONST $MCHT_TITLEBK = 65536
GLOBAL CONST $MCHT_TITLEMONTH = 65537
GLOBAL CONST $MCHT_TITLEYEAR = 65538
GLOBAL CONST $MCHT_TITLEBTNNEXT = 16842755
GLOBAL CONST $MCHT_TITLEBTNPREV = 33619971
GLOBAL CONST $MCHT_CALENDARBK = 131072
GLOBAL CONST $MCHT_CALENDARDATE = 131073
GLOBAL CONST $MCHT_CALENDARDAY = 131074
GLOBAL CONST $MCHT_CALENDARWEEKNUM = 131075
GLOBAL CONST $MCHT_CALENDARDATENEXT = 16908288
GLOBAL CONST $MCHT_CALENDARDATEPREV = 33685504
GLOBAL CONST $MCS_DAYSTATE = 1
GLOBAL CONST $MCS_MULTISELECT = 2
GLOBAL CONST $MCS_WEEKNUMBERS = 4
GLOBAL CONST $MCS_NOTODAYCIRCLE = 8
GLOBAL CONST $MCS_NOTODAY = 16
GLOBAL CONST $MCS_NOTRAILINGDATES = 64
GLOBAL CONST $MCS_SHORTDAYSOFWEEK = 128
GLOBAL CONST $MCS_NOSELCHANGEONNAV = 256
GLOBAL CONST $MCM_FIRST = 4096
GLOBAL CONST $MCM_GETCALENDARBORDER = ($MCM_FIRST + 31)
GLOBAL CONST $MCM_GETCALENDARCOUNT = ($MCM_FIRST + 23)
GLOBAL CONST $MCM_GETCALENDARGRIDINFO = ($MCM_FIRST + 24)
GLOBAL CONST $MCM_GETCALID = ($MCM_FIRST + 27)
GLOBAL CONST $MCM_GETCOLOR = ($MCM_FIRST + 11)
GLOBAL CONST $MCM_GETCURRENTVIEW = ($MCM_FIRST + 22)
GLOBAL CONST $MCM_GETCURSEL = ($MCM_FIRST + 1)
GLOBAL CONST $MCM_GETFIRSTDAYOFWEEK = ($MCM_FIRST + 16)
GLOBAL CONST $MCM_GETMAXSELCOUNT = ($MCM_FIRST + 3)
GLOBAL CONST $MCM_GETMAXTODAYWIDTH = ($MCM_FIRST + 21)
GLOBAL CONST $MCM_GETMINREQRECT = ($MCM_FIRST + 9)
GLOBAL CONST $MCM_GETMONTHDELTA = ($MCM_FIRST + 19)
GLOBAL CONST $MCM_GETMONTHRANGE = ($MCM_FIRST + 7)
GLOBAL CONST $MCM_GETRANGE = ($MCM_FIRST + 17)
GLOBAL CONST $MCM_GETSELRANGE = ($MCM_FIRST + 5)
GLOBAL CONST $MCM_GETTODAY = ($MCM_FIRST + 13)
GLOBAL CONST $MCM_GETUNICODEFORMAT = 8192 + 6
GLOBAL CONST $MCM_HITTEST = ($MCM_FIRST + 14)
GLOBAL CONST $MCM_SETCALENDARBORDER = ($MCM_FIRST + 30)
GLOBAL CONST $MCM_SETCALID = ($MCM_FIRST + 28)
GLOBAL CONST $MCM_SETCOLOR = ($MCM_FIRST + 10)
GLOBAL CONST $MCM_SETCURRENTVIEW = ($MCM_FIRST + 32)
GLOBAL CONST $MCM_SETCURSEL = ($MCM_FIRST + 2)
GLOBAL CONST $MCM_SETDAYSTATE = ($MCM_FIRST + 8)
GLOBAL CONST $MCM_SETFIRSTDAYOFWEEK = ($MCM_FIRST + 15)
GLOBAL CONST $MCM_SETMAXSELCOUNT = ($MCM_FIRST + 4)
GLOBAL CONST $MCM_SETMONTHDELTA = ($MCM_FIRST + 20)
GLOBAL CONST $MCM_SETRANGE = ($MCM_FIRST + 18)
GLOBAL CONST $MCM_SETSELRANGE = ($MCM_FIRST + 6)
GLOBAL CONST $MCM_SETTODAY = ($MCM_FIRST + 12)
GLOBAL CONST $MCM_SETUNICODEFORMAT = 8192 + 5
GLOBAL CONST $MCM_SIZERECTTOMIN = ($MCM_FIRST + 29)
GLOBAL CONST $MCN_FIRST = -746
GLOBAL CONST $MCN_SELCHANGE = ($MCN_FIRST - 3)
GLOBAL CONST $MCN_GETDAYSTATE = ($MCN_FIRST - 1)
GLOBAL CONST $MCN_SELECT = ($MCN_FIRST)
GLOBAL CONST $MCN_VIEWCHANGE = ($MCN_FIRST - 4)
GLOBAL CONST $MCSC_BACKGROUND = 0
GLOBAL CONST $MCSC_MONTHBK = 4
GLOBAL CONST $MCSC_TEXT = 1
GLOBAL CONST $MCSC_TITLEBK = 2
GLOBAL CONST $MCSC_TITLETEXT = 3
GLOBAL CONST $MCSC_TRAILINGTEXT = 5
GLOBAL CONST $DTM_FIRST = 4096
GLOBAL CONST $DTM_GETSYSTEMTIME = $DTM_FIRST + 1
GLOBAL CONST $DTM_SETSYSTEMTIME = $DTM_FIRST + 2
GLOBAL CONST $DTM_GETRANGE = $DTM_FIRST + 3
GLOBAL CONST $DTM_SETRANGE = $DTM_FIRST + 4
GLOBAL CONST $DTM_SETFORMAT = $DTM_FIRST + 5
GLOBAL CONST $DTM_SETMCCOLOR = $DTM_FIRST + 6
GLOBAL CONST $DTM_GETMCCOLOR = $DTM_FIRST + 7
GLOBAL CONST $DTM_GETMONTHCAL = $DTM_FIRST + 8
GLOBAL CONST $DTM_SETMCFONT = $DTM_FIRST + 9
GLOBAL CONST $DTM_GETMCFONT = $DTM_FIRST + 10
GLOBAL CONST $DTM_SETFORMATW = $DTM_FIRST + 50
GLOBAL CONST $DTN_FIRST = -740
GLOBAL CONST $DTN_FIRST2 = -753
GLOBAL CONST $DTN_DATETIMECHANGE = $DTN_FIRST2 - 6
GLOBAL CONST $DTN_USERSTRING = $DTN_FIRST2 - 5
GLOBAL CONST $DTN_WMKEYDOWN = $DTN_FIRST2 - 4
GLOBAL CONST $DTN_FORMAT = $DTN_FIRST2 - 3
GLOBAL CONST $DTN_FORMATQUERY = $DTN_FIRST2 - 2
GLOBAL CONST $DTN_DROPDOWN = $DTN_FIRST2 - 1
GLOBAL CONST $DTN_CLOSEUP = $DTN_FIRST2 + 0
GLOBAL CONST $DTN_USERSTRINGW = $DTN_FIRST - 5
GLOBAL CONST $DTN_WMKEYDOWNW = $DTN_FIRST - 4
GLOBAL CONST $DTN_FORMATW = $DTN_FIRST - 3
GLOBAL CONST $DTN_FORMATQUERYW = $DTN_FIRST - 2
GLOBAL CONST $GUI_SS_DEFAULT_DATE = $DTS_LONGDATEFORMAT
GLOBAL CONST $GUI_SS_DEFAULT_MONTHCAL = 0
GLOBAL CONST $GMEM_FIXED = 0
GLOBAL CONST $GMEM_MOVEABLE = 2
GLOBAL CONST $GMEM_NOCOMPACT = 16
GLOBAL CONST $GMEM_NODISCARD = 32
GLOBAL CONST $GMEM_ZEROINIT = 64
GLOBAL CONST $GMEM_MODIFY = 128
GLOBAL CONST $GMEM_DISCARDABLE = 256
GLOBAL CONST $GMEM_NOT_BANKED = 4096
GLOBAL CONST $GMEM_SHARE = 8192
GLOBAL CONST $GMEM_DDESHARE = 8192
GLOBAL CONST $GMEM_NOTIFY = 16384
GLOBAL CONST $GMEM_LOWER = 4096
GLOBAL CONST $GMEM_VALID_FLAGS = 32626
GLOBAL CONST $GMEM_INVALID_HANDLE = 32768
GLOBAL CONST $GPTR = BITOR($GMEM_FIXED, $GMEM_ZEROINIT)
GLOBAL CONST $GHND = BITOR($GMEM_MOVEABLE, $GMEM_ZEROINIT)
GLOBAL CONST $MEM_COMMIT = 4096
GLOBAL CONST $MEM_RESERVE = 8192
GLOBAL CONST $MEM_TOP_DOWN = 1048576
GLOBAL CONST $MEM_SHARED = 134217728
GLOBAL CONST $PAGE_NOACCESS = 1
GLOBAL CONST $PAGE_READONLY = 2
GLOBAL CONST $PAGE_READWRITE = 4
GLOBAL CONST $PAGE_EXECUTE = 16
GLOBAL CONST $PAGE_EXECUTE_READ = 32
GLOBAL CONST $PAGE_EXECUTE_READWRITE = 64
GLOBAL CONST $PAGE_EXECUTE_WRITECOPY = 128
GLOBAL CONST $PAGE_GUARD = 256
GLOBAL CONST $PAGE_NOCACHE = 512
GLOBAL CONST $PAGE_WRITECOMBINE = 1024
GLOBAL CONST $PAGE_WRITECOPY = 8
GLOBAL CONST $MEM_DECOMMIT = 16384
GLOBAL CONST $MEM_RELEASE = 32768
GLOBAL ENUM $MEM_LOAD, $MEM_TOTALPHYSRAM, $MEM_AVAILPHYSRAM, $MEM_TOTALPAGEFILE, $MEM_AVAILPAGEFILE, $MEM_TOTALVIRTUAL, $MEM_AVAILVIRTUAL
GLOBAL CONST $PROCESS_TERMINATE = 1
GLOBAL CONST $PROCESS_CREATE_THREAD = 2
GLOBAL CONST $PROCESS_SET_SESSIONID = 4
GLOBAL CONST $PROCESS_VM_OPERATION = 8
GLOBAL CONST $PROCESS_VM_READ = 16
GLOBAL CONST $PROCESS_VM_WRITE = 32
GLOBAL CONST $PROCESS_DUP_HANDLE = 64
GLOBAL CONST $PROCESS_CREATE_PROCESS = 128
GLOBAL CONST $PROCESS_SET_QUOTA = 256
GLOBAL CONST $PROCESS_SET_INFORMATION = 512
GLOBAL CONST $PROCESS_QUERY_INFORMATION = 1024
GLOBAL CONST $PROCESS_QUERY_LIMITED_INFORMATION = 4096
GLOBAL CONST $PROCESS_SUSPEND_RESUME = 2048
GLOBAL CONST $PROCESS_ALL_ACCESS = 2035711
GLOBAL CONST $SE_ASSIGNPRIMARYTOKEN_NAME = "SeAssignPrimaryTokenPrivilege"
GLOBAL CONST $SE_AUDIT_NAME = "SeAuditPrivilege"
GLOBAL CONST $SE_BACKUP_NAME = "SeBackupPrivilege"
GLOBAL CONST $SE_CHANGE_NOTIFY_NAME = "SeChangeNotifyPrivilege"
GLOBAL CONST $SE_CREATE_GLOBAL_NAME = "SeCreateGlobalPrivilege"
GLOBAL CONST $SE_CREATE_PAGEFILE_NAME = "SeCreatePagefilePrivilege"
GLOBAL CONST $SE_CREATE_PERMANENT_NAME = "SeCreatePermanentPrivilege"
GLOBAL CONST $SE_CREATE_SYMBOLIC_LINK_NAME = "SeCreateSymbolicLinkPrivilege"
GLOBAL CONST $SE_CREATE_TOKEN_NAME = "SeCreateTokenPrivilege"
GLOBAL CONST $SE_DEBUG_NAME = "SeDebugPrivilege"
GLOBAL CONST $SE_ENABLE_DELEGATION_NAME = "SeEnableDelegationPrivilege"
GLOBAL CONST $SE_IMPERSONATE_NAME = "SeImpersonatePrivilege"
GLOBAL CONST $SE_INC_BASE_PRIORITY_NAME = "SeIncreaseBasePriorityPrivilege"
GLOBAL CONST $SE_INC_WORKING_SET_NAME = "SeIncreaseWorkingSetPrivilege"
GLOBAL CONST $SE_INCREASE_QUOTA_NAME = "SeIncreaseQuotaPrivilege"
GLOBAL CONST $SE_LOAD_DRIVER_NAME = "SeLoadDriverPrivilege"
GLOBAL CONST $SE_LOCK_MEMORY_NAME = "SeLockMemoryPrivilege"
GLOBAL CONST $SE_MACHINE_ACCOUNT_NAME = "SeMachineAccountPrivilege"
GLOBAL CONST $SE_MANAGE_VOLUME_NAME = "SeManageVolumePrivilege"
GLOBAL CONST $SE_PROF_SINGLE_PROCESS_NAME = "SeProfileSingleProcessPrivilege"
GLOBAL CONST $SE_RELABEL_NAME = "SeRelabelPrivilege"
GLOBAL CONST $SE_REMOTE_SHUTDOWN_NAME = "SeRemoteShutdownPrivilege"
GLOBAL CONST $SE_RESTORE_NAME = "SeRestorePrivilege"
GLOBAL CONST $SE_SECURITY_NAME = "SeSecurityPrivilege"
GLOBAL CONST $SE_SHUTDOWN_NAME = "SeShutdownPrivilege"
GLOBAL CONST $SE_SYNC_AGENT_NAME = "SeSyncAgentPrivilege"
GLOBAL CONST $SE_SYSTEM_ENVIRONMENT_NAME = "SeSystemEnvironmentPrivilege"
GLOBAL CONST $SE_SYSTEM_PROFILE_NAME = "SeSystemProfilePrivilege"
GLOBAL CONST $SE_SYSTEMTIME_NAME = "SeSystemtimePrivilege"
GLOBAL CONST $SE_TAKE_OWNERSHIP_NAME = "SeTakeOwnershipPrivilege"
GLOBAL CONST $SE_TCB_NAME = "SeTcbPrivilege"
GLOBAL CONST $SE_TIME_ZONE_NAME = "SeTimeZonePrivilege"
GLOBAL CONST $SE_TRUSTED_CREDMAN_ACCESS_NAME = "SeTrustedCredManAccessPrivilege"
GLOBAL CONST $SE_UNSOLICITED_INPUT_NAME = "SeUnsolicitedInputPrivilege"
GLOBAL CONST $SE_UNDOCK_NAME = "SeUndockPrivilege"
GLOBAL CONST $SE_PRIVILEGE_ENABLED_BY_DEFAULT = 1
GLOBAL CONST $SE_PRIVILEGE_ENABLED = 2
GLOBAL CONST $SE_PRIVILEGE_REMOVED = 4
GLOBAL CONST $SE_PRIVILEGE_USED_FOR_ACCESS = -2147483648
GLOBAL CONST $SE_GROUP_MANDATORY = 1
GLOBAL CONST $SE_GROUP_ENABLED_BY_DEFAULT = 2
GLOBAL CONST $SE_GROUP_ENABLED = 4
GLOBAL CONST $SE_GROUP_OWNER = 8
GLOBAL CONST $SE_GROUP_USE_FOR_DENY_ONLY = 16
GLOBAL CONST $SE_GROUP_INTEGRITY = 32
GLOBAL CONST $SE_GROUP_INTEGRITY_ENABLED = 64
GLOBAL CONST $SE_GROUP_RESOURCE = 536870912
GLOBAL CONST $SE_GROUP_LOGON_ID = -1073741824
GLOBAL ENUM $TOKENPRIMARY = 1, $TOKENIMPERSONATION
GLOBAL ENUM $SECURITYANONYMOUS = 0, $SECURITYIDENTIFICATION, $SECURITYIMPERSONATION, $SECURITYDELEGATION
GLOBAL ENUM $TOKENUSER = 1, $TOKENGROUPS, $TOKENPRIVILEGES, $TOKENOWNER, $TOKENPRIMARYGROUP, $TOKENDEFAULTDACL, $TOKENSOURCE, $TOKENTYPE, $TOKENIMPERSONATIONLEVEL, $TOKENSTATISTICS, $TOKENRESTRICTEDSIDS, $TOKENSESSIONID, $TOKENGROUPSANDPRIVILEGES, $TOKENSESSIONREFERENCE, $TOKENSANDBOXINERT, $TOKENAUDITPOLICY, $TOKENORIGIN, $TOKENELEVATIONTYPE, $TOKENLINKEDTOKEN, $TOKENELEVATION, $TOKENHASRESTRICTIONS, $TOKENACCESSINFORMATION, $TOKENVIRTUALIZATIONALLOWED, $TOKENVIRTUALIZATIONENABLED, $TOKENINTEGRITYLEVEL, $TOKENUIACCESS, $TOKENMANDATORYPOLICY, $TOKENLOGONSID
GLOBAL CONST $TOKEN_ASSIGN_PRIMARY = 1
GLOBAL CONST $TOKEN_DUPLICATE = 2
GLOBAL CONST $TOKEN_IMPERSONATE = 4
GLOBAL CONST $TOKEN_QUERY = 8
GLOBAL CONST $TOKEN_QUERY_SOURCE = 16
GLOBAL CONST $TOKEN_ADJUST_PRIVILEGES = 32
GLOBAL CONST $TOKEN_ADJUST_GROUPS = 64
GLOBAL CONST $TOKEN_ADJUST_DEFAULT = 128
GLOBAL CONST $TOKEN_ADJUST_SESSIONID = 256
GLOBAL CONST $TOKEN_ALL_ACCESS = 983551
GLOBAL CONST $TOKEN_READ = 131080
GLOBAL CONST $TOKEN_WRITE = 131296
GLOBAL CONST $TOKEN_EXECUTE = 131072
GLOBAL CONST $TOKEN_HAS_TRAVERSE_PRIVILEGE = 1
GLOBAL CONST $TOKEN_HAS_BACKUP_PRIVILEGE = 2
GLOBAL CONST $TOKEN_HAS_RESTORE_PRIVILEGE = 4
GLOBAL CONST $TOKEN_HAS_ADMIN_GROUP = 8
GLOBAL CONST $TOKEN_IS_RESTRICTED = 16
GLOBAL CONST $TOKEN_SESSION_NOT_REFERENCED = 32
GLOBAL CONST $TOKEN_SANDBOX_INERT = 64
GLOBAL CONST $TOKEN_HAS_IMPERSONATE_PRIVILEGE = 128
GLOBAL CONST $RIGHTS_DELETE = 65536
GLOBAL CONST $READ_CONTROL = 131072
GLOBAL CONST $WRITE_DAC = 262144
GLOBAL CONST $WRITE_OWNER = 524288
GLOBAL CONST $SYNCHRONIZE = 1048576
GLOBAL CONST $ACCESS_SYSTEM_SECURITY = 16777216
GLOBAL CONST $STANDARD_RIGHTS_REQUIRED = 983040
GLOBAL CONST $STANDARD_RIGHTS_READ = $READ_CONTROL
GLOBAL CONST $STANDARD_RIGHTS_WRITE = $READ_CONTROL
GLOBAL CONST $STANDARD_RIGHTS_EXECUTE = $READ_CONTROL
GLOBAL CONST $STANDARD_RIGHTS_ALL = 2031616
GLOBAL CONST $SPECIFIC_RIGHTS_ALL = 65535
GLOBAL ENUM $NOT_USED_ACCESS = 0, $GRANT_ACCESS, $SET_ACCESS, $DENY_ACCESS, $REVOKE_ACCESS, $SET_AUDIT_SUCCESS, $SET_AUDIT_FAILURE
GLOBAL ENUM $TRUSTEE_IS_UNKNOWN = 0, $TRUSTEE_IS_USER, $TRUSTEE_IS_GROUP, $TRUSTEE_IS_DOMAIN, $TRUSTEE_IS_ALIAS, $TRUSTEE_IS_WELL_KNOWN_GROUP, $TRUSTEE_IS_DELETED, $TRUSTEE_IS_INVALID, $TRUSTEE_IS_COMPUTER
GLOBAL CONST $LOGON_WITH_PROFILE = 1
GLOBAL CONST $LOGON_NETCREDENTIALS_ONLY = 2
GLOBAL ENUM $SIDTYPEUSER = 1, $SIDTYPEGROUP, $SIDTYPEDOMAIN, $SIDTYPEALIAS, $SIDTYPEWELLKNOWNGROUP, $SIDTYPEDELETEDACCOUNT, $SIDTYPEINVALID, $SIDTYPEUNKNOWN, $SIDTYPECOMPUTER, $SIDTYPELABEL
GLOBAL CONST $SID_ADMINISTRATORS = "S-1-5-32-544"
GLOBAL CONST $SID_USERS = "S-1-5-32-545"
GLOBAL CONST $SID_GUESTS = "S-1-5-32-546"
GLOBAL CONST $SID_ACCOUNT_OPERATORS = "S-1-5-32-548"
GLOBAL CONST $SID_SERVER_OPERATORS = "S-1-5-32-549"
GLOBAL CONST $SID_PRINT_OPERATORS = "S-1-5-32-550"
GLOBAL CONST $SID_BACKUP_OPERATORS = "S-1-5-32-551"
GLOBAL CONST $SID_REPLICATOR = "S-1-5-32-552"
GLOBAL CONST $SID_OWNER = "S-1-3-0"
GLOBAL CONST $SID_EVERYONE = "S-1-1-0"
GLOBAL CONST $SID_NETWORK = "S-1-5-2"
GLOBAL CONST $SID_INTERACTIVE = "S-1-5-4"
GLOBAL CONST $SID_SYSTEM = "S-1-5-18"
GLOBAL CONST $SID_AUTHENTICATED_USERS = "S-1-5-11"
GLOBAL CONST $SID_SCHANNEL_AUTHENTICATION = "S-1-5-64-14"
GLOBAL CONST $SID_DIGEST_AUTHENTICATION = "S-1-5-64-21"
GLOBAL CONST $SID_NT_SERVICE = "S-1-5-80"
GLOBAL CONST $SID_UNTRUSTED_MANDATORY_LEVEL = "S-1-16-0"
GLOBAL CONST $SID_LOW_MANDATORY_LEVEL = "S-1-16-4096"
GLOBAL CONST $SID_MEDIUM_MANDATORY_LEVEL = "S-1-16-8192"
GLOBAL CONST $SID_MEDIUM_PLUS_MANDATORY_LEVEL = "S-1-16-8448"
GLOBAL CONST $SID_HIGH_MANDATORY_LEVEL = "S-1-16-12288"
GLOBAL CONST $SID_SYSTEM_MANDATORY_LEVEL = "S-1-16-16384"
GLOBAL CONST $SID_PROTECTED_PROCESS_MANDATORY_LEVEL = "S-1-16-20480"
GLOBAL CONST $SID_SECURE_PROCESS_MANDATORY_LEVEL = "S-1-16-28672"
GLOBAL CONST $SID_ALL_SERVICES = "S-1-5-80-0"
GLOBAL CONST $MB_OK = 0
GLOBAL CONST $MB_OKCANCEL = 1
GLOBAL CONST $MB_ABORTRETRYIGNORE = 2
GLOBAL CONST $MB_YESNOCANCEL = 3
GLOBAL CONST $MB_YESNO = 4
GLOBAL CONST $MB_RETRYCANCEL = 5
GLOBAL CONST $MB_CANCELTRYCONTINUE = 6
GLOBAL CONST $MB_HELP = 16384
GLOBAL CONST $MB_ICONSTOP = 16
GLOBAL CONST $MB_ICONERROR = 16
GLOBAL CONST $MB_ICONHAND = 16
GLOBAL CONST $MB_ICONQUESTION = 32
GLOBAL CONST $MB_ICONEXCLAMATION = 48
GLOBAL CONST $MB_ICONWARNING = 48
GLOBAL CONST $MB_ICONINFORMATION = 64
GLOBAL CONST $MB_ICONASTERISK = 64
GLOBAL CONST $MB_USERICON = 128
GLOBAL CONST $MB_DEFBUTTON1 = 0
GLOBAL CONST $MB_DEFBUTTON2 = 256
GLOBAL CONST $MB_DEFBUTTON3 = 512
GLOBAL CONST $MB_DEFBUTTON4 = 768
GLOBAL CONST $MB_APPLMODAL = 0
GLOBAL CONST $MB_SYSTEMMODAL = 4096
GLOBAL CONST $MB_TASKMODAL = 8192
GLOBAL CONST $MB_DEFAULT_DESKTOP_ONLY = 131072
GLOBAL CONST $MB_RIGHT = 524288
GLOBAL CONST $MB_RTLREADING = 1048576
GLOBAL CONST $MB_SETFOREGROUND = 65536
GLOBAL CONST $MB_TOPMOST = 262144
GLOBAL CONST $MB_SERVICE_NOTIFICATION = 2097152
GLOBAL CONST $MB_RIGHTJUSTIFIED = $MB_RIGHT
GLOBAL CONST $IDTIMEOUT = -1
GLOBAL CONST $IDOK = 1
GLOBAL CONST $IDCANCEL = 2
GLOBAL CONST $IDABORT = 3
GLOBAL CONST $IDRETRY = 4
GLOBAL CONST $IDIGNORE = 5
GLOBAL CONST $IDYES = 6
GLOBAL CONST $IDNO = 7
GLOBAL CONST $IDCLOSE = 8
GLOBAL CONST $IDHELP = 9
GLOBAL CONST $IDTRYAGAIN = 10
GLOBAL CONST $IDCONTINUE = 11
GLOBAL CONST $STR_NOCASESENSE = 0
GLOBAL CONST $STR_CASESENSE = 1
GLOBAL CONST $STR_NOCASESENSEBASIC = 2
GLOBAL CONST $STR_STRIPLEADING = 1
GLOBAL CONST $STR_STRIPTRAILING = 2
GLOBAL CONST $STR_STRIPSPACES = 4
GLOBAL CONST $STR_STRIPALL = 8
GLOBAL CONST $STR_CHRSPLIT = 0
GLOBAL CONST $STR_ENTIRESPLIT = 1
GLOBAL CONST $STR_NOCOUNT = 2
GLOBAL CONST $STR_REGEXPMATCH = 0
GLOBAL CONST $STR_REGEXPARRAYMATCH = 1
GLOBAL CONST $STR_REGEXPARRAYFULLMATCH = 2
GLOBAL CONST $STR_REGEXPARRAYGLOBALMATCH = 3
GLOBAL CONST $STR_REGEXPARRAYGLOBALFULLMATCH = 4
GLOBAL CONST $STR_ENDISSTART = 0
GLOBAL CONST $STR_ENDNOTSTART = 1
GLOBAL CONST $SB_ANSI = 1
GLOBAL CONST $SB_UTF16LE = 2
GLOBAL CONST $SB_UTF16BE = 3
GLOBAL CONST $SB_UTF8 = 4
GLOBAL CONST $SE_UTF16 = 0
GLOBAL CONST $SE_ANSI = 1
GLOBAL CONST $SE_UTF8 = 2
GLOBAL CONST $STR_UTF16 = 0
GLOBAL CONST $STR_UCS2 = 1
#Region Global Variables and Constants
	GLOBAL CONST $FORMAT_MESSAGE_ALLOCATE_BUFFER = 256
	GLOBAL CONST $FORMAT_MESSAGE_IGNORE_INSERTS = 512
	GLOBAL CONST $FORMAT_MESSAGE_FROM_STRING = 1024
	GLOBAL CONST $FORMAT_MESSAGE_FROM_HMODULE = 2048
	GLOBAL CONST $FORMAT_MESSAGE_FROM_SYSTEM = 4096
	GLOBAL CONST $FORMAT_MESSAGE_ARGUMENT_ARRAY = 8192
#EndRegion Global Variables and Constants
FUNC _WINAPI_BEEP($IFREQ = 500, $IDURATION = 1000)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "Beep", "dword", $IFREQ, "dword", $IDURATION)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_FORMATMESSAGE($IFLAGS, $PSOURCE, $IMESSAGEID, $ILANGUAGEID, BYREF $PBUFFER, $ISIZE, $VARGUMENTS)
	LOCAL $SBUFFERTYPE = "struct*"
	IF ISSTRING($PBUFFER) THEN $SBUFFERTYPE = "wstr"
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "dword", "FormatMessageW", "dword", $IFLAGS, "struct*", $PSOURCE, "dword", $IMESSAGEID, "dword", $ILANGUAGEID, $SBUFFERTYPE, $PBUFFER, "dword", $ISIZE, "ptr", $VARGUMENTS)
	IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	IF $SBUFFERTYPE = "wstr" THEN $PBUFFER = $ARESULT[5]
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_GETERRORMESSAGE($ICODE, $ILANGUAGE = 0, CONST $_ICURRENTERROR = @ERROR, CONST $_ICURRENTEXTENDED = @EXTENDED)
	LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "FormatMessageW", "dword", 4096, "ptr", 0, "dword", $ICODE, "dword", $ILANGUAGE, "wstr", "", "dword", 4096, "ptr", 0)
	IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
	RETURN SETERROR($_ICURRENTERROR, $_ICURRENTEXTENDED, STRINGREGEXPREPLACE($ARET[5], "[" & @LF & "," & @CR & "]*\Z", ""))
ENDFUNC
FUNC _WINAPI_GETLASTERROR(CONST $_ICURRENTERROR = @ERROR, CONST $_ICURRENTEXTENDED = @EXTENDED)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "dword", "GetLastError")
	RETURN SETERROR($_ICURRENTERROR, $_ICURRENTEXTENDED, $ARESULT[0])
ENDFUNC
FUNC _WINAPI_GETLASTERRORMESSAGE(CONST $_ICURRENTERROR = @ERROR, CONST $_ICURRENTEXTENDED = @EXTENDED)
	LOCAL $ILASTERROR = _WINAPI_GETLASTERROR()
	LOCAL $TBUFFERPTR = DLLSTRUCTCREATE("ptr")
	LOCAL $NCOUNT = _WINAPI_FORMATMESSAGE(BITOR($FORMAT_MESSAGE_ALLOCATE_BUFFER, $FORMAT_MESSAGE_FROM_SYSTEM), 0, $ILASTERROR, 0, $TBUFFERPTR, 0, 0)
	IF @ERROR THEN RETURN SETERROR(-@ERROR, @EXTENDED, "")
	LOCAL $STEXT = ""
	LOCAL $PBUFFER = DLLSTRUCTGETDATA($TBUFFERPTR, 1)
	IF $PBUFFER THEN
		IF $NCOUNT > 0 THEN
			LOCAL $TBUFFER = DLLSTRUCTCREATE("wchar[" & ($NCOUNT + 1) & "]", $PBUFFER)
			$STEXT = DLLSTRUCTGETDATA($TBUFFER, 1)
			IF STRINGRIGHT($STEXT, 2) = @CRLF THEN $STEXT = STRINGTRIMRIGHT($STEXT, 2)
		ENDIF
		DLLCALL("kernel32.dll", "handle", "LocalFree", "handle", $PBUFFER)
	ENDIF
	RETURN SETERROR($_ICURRENTERROR, $_ICURRENTEXTENDED, $STEXT)
ENDFUNC
FUNC _WINAPI_MESSAGEBEEP($ITYPE = 1)
	LOCAL $ISOUND
	SWITCH $ITYPE
		CASE 1
			$ISOUND = 0
		CASE 2
			$ISOUND = 16
		CASE 3
			$ISOUND = 32
		CASE 4
			$ISOUND = 48
		CASE 5
			$ISOUND = 64
		CASE ELSE
			$ISOUND = -1
	ENDSWITCH
	LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "MessageBeep", "uint", $ISOUND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_MSGBOX($IFLAGS, $STITLE, $STEXT)
	BLOCKINPUT(0)
	MSGBOX($IFLAGS, $STITLE, $STEXT & "      ")
ENDFUNC
FUNC _WINAPI_SETLASTERROR($IERRORCODE, CONST $_ICURRENTERROR = @ERROR, CONST $_ICURRENTEXTENDED = @EXTENDED)
	DLLCALL("kernel32.dll", "none", "SetLastError", "dword", $IERRORCODE)
	RETURN SETERROR($_ICURRENTERROR, $_ICURRENTEXTENDED, NULL)
ENDFUNC
FUNC _WINAPI_SHOWERROR($STEXT, $BEXIT = TRUE)
	BLOCKINPUT(0)
	MSGBOX($MB_SYSTEMMODAL, "Error", $STEXT & "      ")
	IF $BEXIT THEN EXIT
ENDFUNC
FUNC _WINAPI_SHOWLASTERROR($STEXT = "", $BABORT = FALSE, $ILANGUAGE = 0, CONST $_ICURRENTERROR = @ERROR, CONST $_ICURRENTEXTENDED = @EXTENDED)
	LOCAL $SERROR
	LOCAL $ILASTERROR = _WINAPI_GETLASTERROR()
	WHILE 1
		$SERROR = _WINAPI_GETERRORMESSAGE($ILASTERROR, $ILANGUAGE)
		IF @ERROR AND $ILANGUAGE THEN
			$ILANGUAGE = 0
		ELSE
			EXITLOOP
		ENDIF
	WEND
	IF STRINGSTRIPWS($STEXT, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
		$STEXT &= @CRLF & @CRLF
	ELSE
		$STEXT = ""
	ENDIF
	_WINAPI_MSGBOX(BITOR(262144, BITSHIFT(16, -2 * (NOT $ILASTERROR))), $ILASTERROR, $STEXT & $SERROR)
	IF $ILASTERROR THEN
		_WINAPI_SETLASTERROR($ILASTERROR)
		IF $BABORT THEN
			EXIT $ILASTERROR
		ENDIF
	ENDIF
	RETURN SETERROR($_ICURRENTERROR, $_ICURRENTEXTENDED, 1)
ENDFUNC
FUNC _WINAPI_SHOWMSG($STEXT)
	_WINAPI_MSGBOX($MB_SYSTEMMODAL, "Information", $STEXT)
ENDFUNC
FUNC __COMERRORFORMATING(BYREF $OCOMERROR, $SPREFIX = @TAB)
	LOCAL CONST $STR_STRIPTRAILING = 2
	LOCAL $SERROR = "COM Error encountered in " & @SCRIPTNAME & " (" & $OCOMERROR.Scriptline & ") :" & @CRLF & $SPREFIX & "Number        " & @TAB & "= 0x" & HEX($OCOMERROR.Number, 8) & " (" & $OCOMERROR.Number & ")" & @CRLF & $SPREFIX & "WinDescription" & @TAB & "= " & STRINGSTRIPWS($OCOMERROR.WinDescription, $STR_STRIPTRAILING) & @CRLF & $SPREFIX & "Description   " & @TAB & "= " & STRINGSTRIPWS($OCOMERROR.Description, $STR_STRIPTRAILING) & @CRLF & $SPREFIX & "Source        " & @TAB & "= " & $OCOMERROR.Source & @CRLF & $SPREFIX & "HelpFile      " & @TAB & "= " & $OCOMERROR.HelpFile & @CRLF & $SPREFIX & "HelpContext   " & @TAB & "= " & $OCOMERROR.HelpContext & @CRLF & $SPREFIX & "LastDllError  " & @TAB & "= " & $OCOMERROR.LastDllError & @CRLF & $SPREFIX & "Retcode       " & @TAB & "= 0x" & HEX($OCOMERROR.retcode)
	RETURN $SERROR
ENDFUNC
FUNC _SECURITY__ADJUSTTOKENPRIVILEGES($HTOKEN, $BDISABLEALL, $TNEWSTATE, $IBUFFERLEN, $TPREVSTATE = 0, $PREQUIRED = 0)
	LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $HTOKEN, "bool", $BDISABLEALL, "struct*", $TNEWSTATE, "dword", $IBUFFERLEN, "struct*", $TPREVSTATE, "struct*", $PREQUIRED)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN NOT($ACALL[0] = 0)
ENDFUNC
FUNC _SECURITY__CREATEPROCESSWITHTOKEN($HTOKEN, $ILOGONFLAGS, $SCOMMANDLINE, $ICREATIONFLAGS, $SCURDIR, $TSTARTUPINFO, $TPROCESS_INFORMATION)
	LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "CreateProcessWithTokenW", "handle", $HTOKEN, "dword", $ILOGONFLAGS, "ptr", 0, "wstr", $SCOMMANDLINE, "dword", $ICREATIONFLAGS, "struct*", 0, "wstr", $SCURDIR, "struct*", $TSTARTUPINFO, "struct*", $TPROCESS_INFORMATION)
	IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN TRUE
ENDFUNC
FUNC _SECURITY__DUPLICATETOKENEX($HEXISTINGTOKEN, $IDESIREDACCESS, $IIMPERSONATIONLEVEL, $ITOKENTYPE)
	LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "DuplicateTokenEx", "handle", $HEXISTINGTOKEN, "dword", $IDESIREDACCESS, "struct*", 0, "int", $IIMPERSONATIONLEVEL, "int", $ITOKENTYPE, "handle*", 0)
	IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ACALL[6]
ENDFUNC
FUNC _SECURITY__GETACCOUNTSID($SACCOUNT, $SSYSTEM = "")
	LOCAL $AACCT = _SECURITY__LOOKUPACCOUNTNAME($SACCOUNT, $SSYSTEM)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF ISARRAY($AACCT) THEN RETURN _SECURITY__STRINGSIDTOSID($AACCT[0])
	RETURN ""
ENDFUNC
FUNC _SECURITY__GETLENGTHSID($PSID)
	IF NOT _SECURITY__ISVALIDSID($PSID) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	LOCAL $ACALL = DLLCALL("advapi32.dll", "dword", "GetLengthSid", "struct*", $PSID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ACALL[0]
ENDFUNC
FUNC _SECURITY__GETTOKENINFORMATION($HTOKEN, $ICLASS)
	LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "GetTokenInformation", "handle", $HTOKEN, "int", $ICLASS, "struct*", 0, "dword", 0, "dword*", 0)
	IF @ERROR OR NOT $ACALL[5] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	LOCAL $ILEN = $ACALL[5]
	LOCAL $TBUFFER = DLLSTRUCTCREATE("byte[" & $ILEN & "]")
	$ACALL = DLLCALL("advapi32.dll", "bool", "GetTokenInformation", "handle", $HTOKEN, "int", $ICLASS, "struct*", $TBUFFER, "dword", DLLSTRUCTGETSIZE($TBUFFER), "dword*", 0)
	IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $TBUFFER
ENDFUNC
FUNC _SECURITY__IMPERSONATESELF($ILEVEL = $SECURITYIMPERSONATION)
	LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "ImpersonateSelf", "int", $ILEVEL)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN NOT($ACALL[0] = 0)
ENDFUNC
FUNC _SECURITY__ISVALIDSID($PSID)
	LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "IsValidSid", "struct*", $PSID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN NOT($ACALL[0] = 0)
ENDFUNC
FUNC _SECURITY__LOOKUPACCOUNTNAME($SACCOUNT, $SSYSTEM = "")
	LOCAL $TDATA = DLLSTRUCTCREATE("byte SID[256]")
	LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "LookupAccountNameW", "wstr", $SSYSTEM, "wstr", $SACCOUNT, "struct*", $TDATA, "dword*", DLLSTRUCTGETSIZE($TDATA), "wstr", "", "dword*", DLLSTRUCTGETSIZE($TDATA), "int*", 0)
	IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	LOCAL $AACCT[3]
	$AACCT[0] = _SECURITY__SIDTOSTRINGSID(DLLSTRUCTGETPTR($TDATA, "SID"))
	$AACCT[1] = $ACALL[5]
	$AACCT[2] = $ACALL[7]
	RETURN $AACCT
ENDFUNC
FUNC _SECURITY__LOOKUPACCOUNTSID($VSID, $SSYSTEM = "")
	LOCAL $PSID, $AACCT[3]
	IF ISSTRING($VSID) THEN
		$PSID = _SECURITY__STRINGSIDTOSID($VSID)
	ELSE
		$PSID = $VSID
	ENDIF
	IF NOT _SECURITY__ISVALIDSID($PSID) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	LOCAL $STYPESYSTEM = "ptr"
	IF $SSYSTEM THEN $STYPESYSTEM = "wstr"
	LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "LookupAccountSidW", $STYPESYSTEM, $SSYSTEM, "struct*", $PSID, "wstr", "", "dword*", 65536, "wstr", "", "dword*", 65536, "int*", 0)
	IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	LOCAL $AACCT[3]
	$AACCT[0] = $ACALL[3]
	$AACCT[1] = $ACALL[5]
	$AACCT[2] = $ACALL[7]
	RETURN $AACCT
ENDFUNC
FUNC _SECURITY__LOOKUPPRIVILEGEVALUE($SSYSTEM, $SNAME)
	LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "LookupPrivilegeValueW", "wstr", $SSYSTEM, "wstr", $SNAME, "int64*", 0)
	IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ACALL[3]
ENDFUNC
FUNC _SECURITY__OPENPROCESSTOKEN($HPROCESS, $IACCESS)
	LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "OpenProcessToken", "handle", $HPROCESS, "dword", $IACCESS, "handle*", 0)
	IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ACALL[3]
ENDFUNC
FUNC _SECURITY__OPENTHREADTOKEN($IACCESS, $HTHREAD = 0, $BOPENASSELF = FALSE)
	IF $HTHREAD = 0 THEN
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "handle", "GetCurrentThread")
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		$HTHREAD = $ARESULT[0]
	ENDIF
	LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "OpenThreadToken", "handle", $HTHREAD, "dword", $IACCESS, "bool", $BOPENASSELF, "handle*", 0)
	IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ACALL[4]
ENDFUNC
FUNC _SECURITY__OPENTHREADTOKENEX($IACCESS, $HTHREAD = 0, $BOPENASSELF = FALSE)
	LOCAL $HTOKEN = _SECURITY__OPENTHREADTOKEN($IACCESS, $HTHREAD, $BOPENASSELF)
	IF $HTOKEN = 0 THEN
		LOCAL CONST $ERROR_NO_TOKEN = 1008
		IF _WINAPI_GETLASTERROR() <> $ERROR_NO_TOKEN THEN RETURN SETERROR(20, _WINAPI_GETLASTERROR(), 0)
		IF NOT _SECURITY__IMPERSONATESELF() THEN RETURN SETERROR(@ERROR + 10, _WINAPI_GETLASTERROR(), 0)
		$HTOKEN = _SECURITY__OPENTHREADTOKEN($IACCESS, $HTHREAD, $BOPENASSELF)
		IF $HTOKEN = 0 THEN RETURN SETERROR(@ERROR, _WINAPI_GETLASTERROR(), 0)
	ENDIF
	RETURN $HTOKEN
ENDFUNC
FUNC _SECURITY__SETPRIVILEGE($HTOKEN, $SPRIVILEGE, $BENABLE)
	LOCAL $ILUID = _SECURITY__LOOKUPPRIVILEGEVALUE("", $SPRIVILEGE)
	IF $ILUID = 0 THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
	LOCAL CONST $TAGTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
	LOCAL $TCURRSTATE = DLLSTRUCTCREATE($TAGTOKEN_PRIVILEGES)
	LOCAL $ICURRSTATE = DLLSTRUCTGETSIZE($TCURRSTATE)
	LOCAL $TPREVSTATE = DLLSTRUCTCREATE($TAGTOKEN_PRIVILEGES)
	LOCAL $IPREVSTATE = DLLSTRUCTGETSIZE($TPREVSTATE)
	LOCAL $TREQUIRED = DLLSTRUCTCREATE("int Data")
	DLLSTRUCTSETDATA($TCURRSTATE, "Count", 1)
	DLLSTRUCTSETDATA($TCURRSTATE, "LUID", $ILUID)
	IF NOT _SECURITY__ADJUSTTOKENPRIVILEGES($HTOKEN, FALSE, $TCURRSTATE, $ICURRSTATE, $TPREVSTATE, $TREQUIRED) THEN RETURN SETERROR(2, @ERROR, FALSE)
	DLLSTRUCTSETDATA($TPREVSTATE, "Count", 1)
	DLLSTRUCTSETDATA($TPREVSTATE, "LUID", $ILUID)
	LOCAL $IATTRIBUTES = DLLSTRUCTGETDATA($TPREVSTATE, "Attributes")
	IF $BENABLE THEN
		$IATTRIBUTES = BITOR($IATTRIBUTES, $SE_PRIVILEGE_ENABLED)
	ELSE
		$IATTRIBUTES = BITAND($IATTRIBUTES, BITNOT($SE_PRIVILEGE_ENABLED))
	ENDIF
	DLLSTRUCTSETDATA($TPREVSTATE, "Attributes", $IATTRIBUTES)
	IF NOT _SECURITY__ADJUSTTOKENPRIVILEGES($HTOKEN, FALSE, $TPREVSTATE, $IPREVSTATE, $TCURRSTATE, $TREQUIRED) THEN RETURN SETERROR(3, @ERROR, FALSE)
	RETURN TRUE
ENDFUNC
FUNC _SECURITY__SETTOKENINFORMATION($HTOKEN, $ITOKENINFORMATION, $VTOKENINFORMATION, $ITOKENINFORMATIONLENGTH)
	LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "SetTokenInformation", "handle", $HTOKEN, "int", $ITOKENINFORMATION, "struct*", $VTOKENINFORMATION, "dword", $ITOKENINFORMATIONLENGTH)
	IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN TRUE
ENDFUNC
FUNC _SECURITY__SIDTOSTRINGSID($PSID)
	IF NOT _SECURITY__ISVALIDSID($PSID) THEN RETURN SETERROR(@ERROR + 10, 0, "")
	LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "ConvertSidToStringSidW", "struct*", $PSID, "ptr*", 0)
	IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
	LOCAL $PSTRINGSID = $ACALL[2]
	LOCAL $ALEN = DLLCALL("kernel32.dll", "int", "lstrlenW", "struct*", $PSTRINGSID)
	LOCAL $SSID = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar Text[" & $ALEN[0] + 1 & "]", $PSTRINGSID), "Text")
	DLLCALL("kernel32.dll", "handle", "LocalFree", "handle", $PSTRINGSID)
	RETURN $SSID
ENDFUNC
FUNC _SECURITY__SIDTYPESTR($ITYPE)
	SWITCH $ITYPE
		CASE $SIDTYPEUSER
			RETURN "User"
		CASE $SIDTYPEGROUP
			RETURN "Group"
		CASE $SIDTYPEDOMAIN
			RETURN "Domain"
		CASE $SIDTYPEALIAS
			RETURN "Alias"
		CASE $SIDTYPEWELLKNOWNGROUP
			RETURN "Well Known Group"
		CASE $SIDTYPEDELETEDACCOUNT
			RETURN "Deleted Account"
		CASE $SIDTYPEINVALID
			RETURN "Invalid"
		CASE $SIDTYPEUNKNOWN
			RETURN "Unknown Type"
		CASE $SIDTYPECOMPUTER
			RETURN "Computer"
		CASE $SIDTYPELABEL
			RETURN "A mandatory integrity label SID"
		CASE ELSE
			RETURN "Unknown SID Type"
	ENDSWITCH
ENDFUNC
FUNC _SECURITY__STRINGSIDTOSID($SSID)
	LOCAL $ACALL = DLLCALL("advapi32.dll", "bool", "ConvertStringSidToSidW", "wstr", $SSID, "ptr*", 0)
	IF @ERROR OR NOT $ACALL[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	LOCAL $PSID = $ACALL[2]
	LOCAL $TBUFFER = DLLSTRUCTCREATE("byte Data[" & _SECURITY__GETLENGTHSID($PSID) & "]", $PSID)
	LOCAL $TSID = DLLSTRUCTCREATE("byte Data[" & DLLSTRUCTGETSIZE($TBUFFER) & "]")
	DLLSTRUCTSETDATA($TSID, "Data", DLLSTRUCTGETDATA($TBUFFER, "Data"))
	DLLCALL("kernel32.dll", "handle", "LocalFree", "handle", $PSID)
	RETURN $TSID
ENDFUNC
GLOBAL CONST $TAGPOINT = "struct;long X;long Y;endstruct"
GLOBAL CONST $TAGRECT = "struct;long Left;long Top;long Right;long Bottom;endstruct"
GLOBAL CONST $TAGSIZE = "struct;long X;long Y;endstruct"
GLOBAL CONST $TAGMARGINS = "int cxLeftWidth;int cxRightWidth;int cyTopHeight;int cyBottomHeight"
GLOBAL CONST $TAGFILETIME = "struct;dword Lo;dword Hi;endstruct"
GLOBAL CONST $TAGSYSTEMTIME = "struct;word Year;word Month;word Dow;word Day;word Hour;word Minute;word Second;word MSeconds;endstruct"
GLOBAL CONST $TAGTIME_ZONE_INFORMATION = "struct;long Bias;wchar StdName[32];word StdDate[8];long StdBias;wchar DayName[32];word DayDate[8];long DayBias;endstruct"
GLOBAL CONST $TAGNMHDR = "struct;hwnd hWndFrom;uint_ptr IDFrom;INT Code;endstruct"
GLOBAL CONST $TAGCOMBOBOXEXITEM = "uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;int SelectedImage;int OverlayImage;" & "int Indent;lparam Param"
GLOBAL CONST $TAGNMCBEDRAGBEGIN = $TAGNMHDR & ";int ItemID;wchar szText[260]"
GLOBAL CONST $TAGNMCBEENDEDIT = $TAGNMHDR & ";bool fChanged;int NewSelection;wchar szText[260];int Why"
GLOBAL CONST $TAGNMCOMBOBOXEX = $TAGNMHDR & ";uint Mask;int_ptr Item;ptr Text;int TextMax;int Image;" & "int SelectedImage;int OverlayImage;int Indent;lparam Param"
GLOBAL CONST $TAGDTPRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;" & "word MinSecond;word MinMSecond;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;" & "word MaxMinute;word MaxSecond;word MaxMSecond;bool MinValid;bool MaxValid"
GLOBAL CONST $TAGNMDATETIMECHANGE = $TAGNMHDR & ";dword Flag;" & $TAGSYSTEMTIME
GLOBAL CONST $TAGNMDATETIMEFORMAT = $TAGNMHDR & ";ptr Format;" & $TAGSYSTEMTIME & ";ptr pDisplay;wchar Display[64]"
GLOBAL CONST $TAGNMDATETIMEFORMATQUERY = $TAGNMHDR & ";ptr Format;struct;long SizeX;long SizeY;endstruct"
GLOBAL CONST $TAGNMDATETIMEKEYDOWN = $TAGNMHDR & ";int VirtKey;ptr Format;" & $TAGSYSTEMTIME
GLOBAL CONST $TAGNMDATETIMESTRING = $TAGNMHDR & ";ptr UserString;" & $TAGSYSTEMTIME & ";dword Flags"
GLOBAL CONST $TAGEVENTLOGRECORD = "dword Length;dword Reserved;dword RecordNumber;dword TimeGenerated;dword TimeWritten;dword EventID;" & "word EventType;word NumStrings;word EventCategory;word ReservedFlags;dword ClosingRecordNumber;dword StringOffset;" & "dword UserSidLength;dword UserSidOffset;dword DataLength;dword DataOffset"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_BLUR = "float Radius; bool ExpandEdge"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_BRIGHTNESSCONTRAST = "int BrightnessLevel; int ContrastLevel"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_COLORBALANCE = "int CyanRed; int MagentaGreen; int YellowBlue"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_COLORCURVE = "int Adjustment; int Channel; int AdjustValue"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_COLORLUT = "byte LutB[256]; byte LutG[256]; byte LutR[256]; byte LutA[256]"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_HUESATURATIONLIGHTNESS = "int HueLevel; int SaturationLevel; int LightnessLevel"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_LEVELS = "int Highlight; int Midtone; int Shadow"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_REDEYECORRECTION = "uint NumberOfAreas; ptr Areas"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_SHARPEN = "float Radius; float Amount"
GLOBAL CONST $TAGGDIP_EFFECTPARAMS_TINT = "int Hue; int Amount"
GLOBAL CONST $TAGGDIPBITMAPDATA = "uint Width;uint Height;int Stride;int Format;ptr Scan0;uint_ptr Reserved"
GLOBAL CONST $TAGGDIPCOLORMATRIX = "float m[25]"
GLOBAL CONST $TAGGDIPENCODERPARAM = "struct;byte GUID[16];ulong NumberOfValues;ulong Type;ptr Values;endstruct"
GLOBAL CONST $TAGGDIPENCODERPARAMS = "uint Count;" & $TAGGDIPENCODERPARAM
GLOBAL CONST $TAGGDIPRECTF = "struct;float X;float Y;float Width;float Height;endstruct"
GLOBAL CONST $TAGGDIPSTARTUPINPUT = "uint Version;ptr Callback;bool NoThread;bool NoCodecs"
GLOBAL CONST $TAGGDIPSTARTUPOUTPUT = "ptr HookProc;ptr UnhookProc"
GLOBAL CONST $TAGGDIPIMAGECODECINFO = "byte CLSID[16];byte FormatID[16];ptr CodecName;ptr DllName;ptr FormatDesc;ptr FileExt;" & "ptr MimeType;dword Flags;dword Version;dword SigCount;dword SigSize;ptr SigPattern;ptr SigMask"
GLOBAL CONST $TAGGDIPPENCODERPARAMS = "uint Count;byte Params[1]"
GLOBAL CONST $TAGHDITEM = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
GLOBAL CONST $TAGNMHDDISPINFO = $TAGNMHDR & ";int Item;uint Mask;ptr Text;int TextMax;int Image;lparam lParam"
GLOBAL CONST $TAGNMHDFILTERBTNCLICK = $TAGNMHDR & ";int Item;" & $TAGRECT
GLOBAL CONST $TAGNMHEADER = $TAGNMHDR & ";int Item;int Button;ptr pItem"
GLOBAL CONST $TAGGETIPADDRESS = "byte Field4;byte Field3;byte Field2;byte Field1"
GLOBAL CONST $TAGNMIPADDRESS = $TAGNMHDR & ";int Field;int Value"
GLOBAL CONST $TAGLVFINDINFO = "struct;uint Flags;ptr Text;lparam Param;" & $TAGPOINT & ";uint Direction;endstruct"
GLOBAL CONST $TAGLVHITTESTINFO = $TAGPOINT & ";uint Flags;int Item;int SubItem;int iGroup"
GLOBAL CONST $TAGLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
GLOBAL CONST $TAGNMLISTVIEW = $TAGNMHDR & ";int Item;int SubItem;uint NewState;uint OldState;uint Changed;" & "struct;long ActionX;long ActionY;endstruct;lparam Param"
GLOBAL CONST $TAGNMLVCUSTOMDRAW = "struct;" & $TAGNMHDR & ";dword dwDrawStage;handle hdc;" & $TAGRECT & ";dword_ptr dwItemSpec;uint uItemState;lparam lItemlParam;endstruct" & ";dword clrText;dword clrTextBk;int iSubItem;dword dwItemType;dword clrFace;int iIconEffect;" & "int iIconPhase;int iPartID;int iStateID;struct;long TextLeft;long TextTop;long TextRight;long TextBottom;endstruct;uint uAlign"
GLOBAL CONST $TAGNMLVDISPINFO = $TAGNMHDR & ";" & $TAGLVITEM
GLOBAL CONST $TAGNMLVFINDITEM = $TAGNMHDR & ";int Start;" & $TAGLVFINDINFO
GLOBAL CONST $TAGNMLVGETINFOTIP = $TAGNMHDR & ";dword Flags;ptr Text;int TextMax;int Item;int SubItem;lparam lParam"
GLOBAL CONST $TAGNMITEMACTIVATE = $TAGNMHDR & ";int Index;int SubItem;uint NewState;uint OldState;uint Changed;" & $TAGPOINT & ";lparam lParam;uint KeyFlags"
GLOBAL CONST $TAGNMLVKEYDOWN = "align 1;" & $TAGNMHDR & ";word VKey;uint Flags"
GLOBAL CONST $TAGNMLVSCROLL = $TAGNMHDR & ";int DX;int DY"
GLOBAL CONST $TAGMCHITTESTINFO = "uint Size;" & $TAGPOINT & ";uint Hit;" & $TAGSYSTEMTIME & ";" & $TAGRECT & ";int iOffset;int iRow;int iCol"
GLOBAL CONST $TAGMCMONTHRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short Span"
GLOBAL CONST $TAGMCRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds;short MinSet;short MaxSet"
GLOBAL CONST $TAGMCSELRANGE = "word MinYear;word MinMonth;word MinDOW;word MinDay;word MinHour;word MinMinute;word MinSecond;" & "word MinMSeconds;word MaxYear;word MaxMonth;word MaxDOW;word MaxDay;word MaxHour;word MaxMinute;word MaxSecond;" & "word MaxMSeconds"
GLOBAL CONST $TAGNMDAYSTATE = $TAGNMHDR & ";" & $TAGSYSTEMTIME & ";int DayState;ptr pDayState"
GLOBAL CONST $TAGNMSELCHANGE = $TAGNMHDR & ";struct;word BegYear;word BegMonth;word BegDOW;word BegDay;word BegHour;word BegMinute;word BegSecond;word BegMSeconds;endstruct;" & "struct;word EndYear;word EndMonth;word EndDOW;word EndDay;word EndHour;word EndMinute;word EndSecond;word EndMSeconds;endstruct"
GLOBAL CONST $TAGNMOBJECTNOTIFY = $TAGNMHDR & ";int Item;ptr piid;ptr pObject;long Result;dword dwFlags"
GLOBAL CONST $TAGNMTCKEYDOWN = "align 1;" & $TAGNMHDR & ";word VKey;uint Flags"
GLOBAL CONST $TAGTVITEM = "struct;uint Mask;handle hItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;int SelectedImage;" & "int Children;lparam Param;endstruct"
GLOBAL CONST $TAGTVITEMEX = "struct;" & $TAGTVITEM & ";int Integral;uint uStateEx;hwnd hwnd;int iExpandedImage;int iReserved;endstruct"
GLOBAL CONST $TAGNMTREEVIEW = $TAGNMHDR & ";uint Action;" & "struct;uint OldMask;handle OldhItem;uint OldState;uint OldStateMask;" & "ptr OldText;int OldTextMax;int OldImage;int OldSelectedImage;int OldChildren;lparam OldParam;endstruct;" & "struct;uint NewMask;handle NewhItem;uint NewState;uint NewStateMask;" & "ptr NewText;int NewTextMax;int NewImage;int NewSelectedImage;int NewChildren;lparam NewParam;endstruct;" & "struct;long PointX;long PointY;endstruct"
GLOBAL CONST $TAGNMTVCUSTOMDRAW = "struct;" & $TAGNMHDR & ";dword DrawStage;handle HDC;" & $TAGRECT & ";dword_ptr ItemSpec;uint ItemState;lparam ItemParam;endstruct" & ";dword ClrText;dword ClrTextBk;int Level"
GLOBAL CONST $TAGNMTVDISPINFO = $TAGNMHDR & ";" & $TAGTVITEM
GLOBAL CONST $TAGNMTVGETINFOTIP = $TAGNMHDR & ";ptr Text;int TextMax;handle hItem;lparam lParam"
GLOBAL CONST $TAGNMTVITEMCHANGE = $TAGNMHDR & ";uint Changed;handle hItem;uint StateNew;uint StateOld;lparam lParam;"
GLOBAL CONST $TAGTVHITTESTINFO = $TAGPOINT & ";uint Flags;handle Item"
GLOBAL CONST $TAGNMTVKEYDOWN = "align 1;" & $TAGNMHDR & ";word VKey;uint Flags"
GLOBAL CONST $TAGNMMOUSE = $TAGNMHDR & ";dword_ptr ItemSpec;dword_ptr ItemData;" & $TAGPOINT & ";lparam HitInfo"
GLOBAL CONST $TAGTOKEN_PRIVILEGES = "dword Count;align 4;int64 LUID;dword Attributes"
GLOBAL CONST $TAGIMAGEINFO = "handle hBitmap;handle hMask;int Unused1;int Unused2;" & $TAGRECT
GLOBAL CONST $TAGMENUINFO = "dword Size;INT Mask;dword Style;uint YMax;handle hBack;dword ContextHelpID;ulong_ptr MenuData"
GLOBAL CONST $TAGMENUITEMINFO = "uint Size;uint Mask;uint Type;uint State;uint ID;handle SubMenu;handle BmpChecked;handle BmpUnchecked;" & "ulong_ptr ItemData;ptr TypeData;uint CCH;handle BmpItem"
GLOBAL CONST $TAGREBARBANDINFO = "uint cbSize;uint fMask;uint fStyle;dword clrFore;dword clrBack;ptr lpText;uint cch;" & "int iImage;hwnd hwndChild;uint cxMinChild;uint cyMinChild;uint cx;handle hbmBack;uint wID;uint cyChild;uint cyMaxChild;" & "uint cyIntegral;uint cxIdeal;lparam lParam;uint cxHeader" & ((@OSVERSION = "WIN_XP") ? "" : ";" & $TAGRECT & ";uint uChevronState")
GLOBAL CONST $TAGNMREBARAUTOBREAK = $TAGNMHDR & ";uint uBand;uint wID;lparam lParam;uint uMsg;uint fStyleCurrent;bool fAutoBreak"
GLOBAL CONST $TAGNMRBAUTOSIZE = $TAGNMHDR & ";bool fChanged;" & "struct;long TargetLeft;long TargetTop;long TargetRight;long TargetBottom;endstruct;" & "struct;long ActualLeft;long ActualTop;long ActualRight;long ActualBottom;endstruct"
GLOBAL CONST $TAGNMREBAR = $TAGNMHDR & ";dword dwMask;uint uBand;uint fStyle;uint wID;lparam lParam"
GLOBAL CONST $TAGNMREBARCHEVRON = $TAGNMHDR & ";uint uBand;uint wID;lparam lParam;" & $TAGRECT & ";lparam lParamNM"
GLOBAL CONST $TAGNMREBARCHILDSIZE = $TAGNMHDR & ";uint uBand;uint wID;" & "struct;long CLeft;long CTop;long CRight;long CBottom;endstruct;" & "struct;long BLeft;long BTop;long BRight;long BBottom;endstruct"
GLOBAL CONST $TAGCOLORSCHEME = "dword Size;dword BtnHighlight;dword BtnShadow"
GLOBAL CONST $TAGNMTOOLBAR = $TAGNMHDR & ";int iItem;" & "struct;int iBitmap;int idCommand;byte fsState;byte fsStyle;dword_ptr dwData;int_ptr iString;endstruct" & ";int cchText;ptr pszText;" & $TAGRECT
GLOBAL CONST $TAGNMTBHOTITEM = $TAGNMHDR & ";int idOld;int idNew;dword dwFlags"
GLOBAL CONST $TAGTBBUTTON = "int Bitmap;int Command;byte State;byte Style;dword_ptr Param;int_ptr String"
GLOBAL CONST $TAGTBBUTTONINFO = "uint Size;dword Mask;int Command;int Image;byte State;byte Style;word CX;dword_ptr Param;ptr Text;int TextMax"
GLOBAL CONST $TAGNETRESOURCE = "dword Scope;dword Type;dword DisplayType;dword Usage;ptr LocalName;ptr RemoteName;ptr Comment;ptr Provider"
GLOBAL CONST $TAGOVERLAPPED = "ulong_ptr Internal;ulong_ptr InternalHigh;struct;dword Offset;dword OffsetHigh;endstruct;handle hEvent"
GLOBAL CONST $TAGOPENFILENAME = "dword StructSize;hwnd hwndOwner;handle hInstance;ptr lpstrFilter;ptr lpstrCustomFilter;" & "dword nMaxCustFilter;dword nFilterIndex;ptr lpstrFile;dword nMaxFile;ptr lpstrFileTitle;dword nMaxFileTitle;" & "ptr lpstrInitialDir;ptr lpstrTitle;dword Flags;word nFileOffset;word nFileExtension;ptr lpstrDefExt;lparam lCustData;" & "ptr lpfnHook;ptr lpTemplateName;ptr pvReserved;dword dwReserved;dword FlagsEx"
GLOBAL CONST $TAGBITMAPINFOHEADER = "struct;dword biSize;long biWidth;long biHeight;word biPlanes;word biBitCount;" & "dword biCompression;dword biSizeImage;long biXPelsPerMeter;long biYPelsPerMeter;dword biClrUsed;dword biClrImportant;endstruct"
GLOBAL CONST $TAGBITMAPINFO = $TAGBITMAPINFOHEADER & ";dword biRGBQuad[1]"
GLOBAL CONST $TAGBLENDFUNCTION = "byte Op;byte Flags;byte Alpha;byte Format"
GLOBAL CONST $TAGGUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
GLOBAL CONST $TAGWINDOWPLACEMENT = "uint length;uint flags;uint showCmd;long ptMinPosition[2];long ptMaxPosition[2];long rcNormalPosition[4]"
GLOBAL CONST $TAGWINDOWPOS = "hwnd hWnd;hwnd InsertAfter;int X;int Y;int CX;int CY;uint Flags"
GLOBAL CONST $TAGSCROLLINFO = "uint cbSize;uint fMask;int nMin;int nMax;uint nPage;int nPos;int nTrackPos"
GLOBAL CONST $TAGSCROLLBARINFO = "dword cbSize;" & $TAGRECT & ";int dxyLineButton;int xyThumbTop;" & "int xyThumbBottom;int reserved;dword rgstate[6]"
GLOBAL CONST $TAGLOGFONT = "struct;long Height;long Width;long Escapement;long Orientation;long Weight;byte Italic;byte Underline;" & "byte Strikeout;byte CharSet;byte OutPrecision;byte ClipPrecision;byte Quality;byte PitchAndFamily;wchar FaceName[32];endstruct"
GLOBAL CONST $TAGKBDLLHOOKSTRUCT = "dword vkCode;dword scanCode;dword flags;dword time;ulong_ptr dwExtraInfo"
GLOBAL CONST $TAGPROCESS_INFORMATION = "handle hProcess;handle hThread;dword ProcessID;dword ThreadID"
GLOBAL CONST $TAGSTARTUPINFO = "dword Size;ptr Reserved1;ptr Desktop;ptr Title;dword X;dword Y;dword XSize;dword YSize;dword XCountChars;" & "dword YCountChars;dword FillAttribute;dword Flags;word ShowWindow;word Reserved2;ptr Reserved3;handle StdInput;" & "handle StdOutput;handle StdError"
GLOBAL CONST $TAGSECURITY_ATTRIBUTES = "dword Length;ptr Descriptor;bool InheritHandle"
GLOBAL CONST $TAGWIN32_FIND_DATA = "dword dwFileAttributes;dword ftCreationTime[2];dword ftLastAccessTime[2];dword ftLastWriteTime[2];dword nFileSizeHigh;dword nFileSizeLow;dword dwReserved0;dword dwReserved1;wchar cFileName[260];wchar cAlternateFileName[14]"
GLOBAL CONST $TAGTEXTMETRIC = "long tmHeight;long tmAscent;long tmDescent;long tmInternalLeading;long tmExternalLeading;" & "long tmAveCharWidth;long tmMaxCharWidth;long tmWeight;long tmOverhang;long tmDigitizedAspectX;long tmDigitizedAspectY;" & "wchar tmFirstChar;wchar tmLastChar;wchar tmDefaultChar;wchar tmBreakChar;byte tmItalic;byte tmUnderlined;byte tmStruckOut;" & "byte tmPitchAndFamily;byte tmCharSet"
GLOBAL CONST $TAGMEMMAP = "handle hProc;ulong_ptr Size;ptr Mem"
FUNC _MEMFREE(BYREF $TMEMMAP)
	LOCAL $PMEMORY = DLLSTRUCTGETDATA($TMEMMAP, "Mem")
	LOCAL $HPROCESS = DLLSTRUCTGETDATA($TMEMMAP, "hProc")
	LOCAL $BRESULT = _MEMVIRTUALFREEEX($HPROCESS, $PMEMORY, 0, $MEM_RELEASE)
	DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $BRESULT
ENDFUNC
FUNC _MEMGLOBALALLOC($IBYTES, $IFLAGS = 0)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "handle", "GlobalAlloc", "uint", $IFLAGS, "ulong_ptr", $IBYTES)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _MEMGLOBALFREE($HMEMORY)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "ptr", "GlobalFree", "handle", $HMEMORY)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _MEMGLOBALLOCK($HMEMORY)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "ptr", "GlobalLock", "handle", $HMEMORY)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _MEMGLOBALSIZE($HMEMORY)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "ulong_ptr", "GlobalSize", "handle", $HMEMORY)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _MEMGLOBALUNLOCK($HMEMORY)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "GlobalUnlock", "handle", $HMEMORY)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _MEMINIT($HWND, $ISIZE, BYREF $TMEMMAP)
	LOCAL $ARESULT = DLLCALL("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $HWND, "dword*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	LOCAL $IPROCESSID = $ARESULT[2]
	IF $IPROCESSID = 0 THEN RETURN SETERROR(1, 0, 0)
	LOCAL $IACCESS = BITOR($PROCESS_VM_OPERATION, $PROCESS_VM_READ, $PROCESS_VM_WRITE)
	LOCAL $HPROCESS = __MEM_OPENPROCESS($IACCESS, FALSE, $IPROCESSID, TRUE)
	LOCAL $IALLOC = BITOR($MEM_RESERVE, $MEM_COMMIT)
	LOCAL $PMEMORY = _MEMVIRTUALALLOCEX($HPROCESS, 0, $ISIZE, $IALLOC, $PAGE_READWRITE)
	IF $PMEMORY = 0 THEN RETURN SETERROR(2, 0, 0)
	$TMEMMAP = DLLSTRUCTCREATE($TAGMEMMAP)
	DLLSTRUCTSETDATA($TMEMMAP, "hProc", $HPROCESS)
	DLLSTRUCTSETDATA($TMEMMAP, "Size", $ISIZE)
	DLLSTRUCTSETDATA($TMEMMAP, "Mem", $PMEMORY)
	RETURN $PMEMORY
ENDFUNC
FUNC _MEMMOVEMEMORY($PSOURCE, $PDEST, $ILENGTH)
	DLLCALL("kernel32.dll", "none", "RtlMoveMemory", "struct*", $PDEST, "struct*", $PSOURCE, "ulong_ptr", $ILENGTH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED)
ENDFUNC
FUNC _MEMREAD(BYREF $TMEMMAP, $PSRCE, $PDEST, $ISIZE)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "ReadProcessMemory", "handle", DLLSTRUCTGETDATA($TMEMMAP, "hProc"), "ptr", $PSRCE, "struct*", $PDEST, "ulong_ptr", $ISIZE, "ulong_ptr*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _MEMWRITE(BYREF $TMEMMAP, $PSRCE, $PDEST = 0, $ISIZE = 0, $SSRCE = "struct*")
	IF $PDEST = 0 THEN $PDEST = DLLSTRUCTGETDATA($TMEMMAP, "Mem")
	IF $ISIZE = 0 THEN $ISIZE = DLLSTRUCTGETDATA($TMEMMAP, "Size")
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "WriteProcessMemory", "handle", DLLSTRUCTGETDATA($TMEMMAP, "hProc"), "ptr", $PDEST, $SSRCE, $PSRCE, "ulong_ptr", $ISIZE, "ulong_ptr*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _MEMVIRTUALALLOC($PADDRESS, $ISIZE, $IALLOCATION, $IPROTECT)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "ptr", "VirtualAlloc", "ptr", $PADDRESS, "ulong_ptr", $ISIZE, "dword", $IALLOCATION, "dword", $IPROTECT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _MEMVIRTUALALLOCEX($HPROCESS, $PADDRESS, $ISIZE, $IALLOCATION, $IPROTECT)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "ptr", "VirtualAllocEx", "handle", $HPROCESS, "ptr", $PADDRESS, "ulong_ptr", $ISIZE, "dword", $IALLOCATION, "dword", $IPROTECT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _MEMVIRTUALFREE($PADDRESS, $ISIZE, $IFREETYPE)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "VirtualFree", "ptr", $PADDRESS, "ulong_ptr", $ISIZE, "dword", $IFREETYPE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _MEMVIRTUALFREEEX($HPROCESS, $PADDRESS, $ISIZE, $IFREETYPE)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "VirtualFreeEx", "handle", $HPROCESS, "ptr", $PADDRESS, "ulong_ptr", $ISIZE, "dword", $IFREETYPE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC __MEM_OPENPROCESS($IACCESS, $BINHERIT, $IPID, $BDEBUGPRIV = FALSE)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", $IACCESS, "bool", $BINHERIT, "dword", $IPID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN $ARESULT[0]
	IF NOT $BDEBUGPRIV THEN RETURN SETERROR(100, 0, 0)
	LOCAL $HTOKEN = _SECURITY__OPENTHREADTOKENEX(BITOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	_SECURITY__SETPRIVILEGE($HTOKEN, "SeDebugPrivilege", TRUE)
	LOCAL $IERROR = @ERROR
	LOCAL $IEXTENDED = @EXTENDED
	LOCAL $IRET = 0
	IF NOT @ERROR THEN
		$ARESULT = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", $IACCESS, "bool", $BINHERIT, "dword", $IPID)
		$IERROR = @ERROR
		$IEXTENDED = @EXTENDED
		IF $ARESULT[0] THEN $IRET = $ARESULT[0]
		_SECURITY__SETPRIVILEGE($HTOKEN, "SeDebugPrivilege", FALSE)
		IF @ERROR THEN
			$IERROR = @ERROR + 20
			$IEXTENDED = @EXTENDED
		ENDIF
	ELSE
		$IERROR = @ERROR + 30
	ENDIF
	DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HTOKEN)
	RETURN SETERROR($IERROR, $IEXTENDED, $IRET)
ENDFUNC
GLOBAL CONST $OPT_COORDSRELATIVE = 0
GLOBAL CONST $OPT_COORDSABSOLUTE = 1
GLOBAL CONST $OPT_COORDSCLIENT = 2
GLOBAL CONST $OPT_ERRORSILENT = 0
GLOBAL CONST $OPT_ERRORFATAL = 1
GLOBAL CONST $OPT_CAPSNOSTORE = 0
GLOBAL CONST $OPT_CAPSSTORE = 1
GLOBAL CONST $OPT_MATCHSTART = 1
GLOBAL CONST $OPT_MATCHANY = 2
GLOBAL CONST $OPT_MATCHEXACT = 3
GLOBAL CONST $OPT_MATCHADVANCED = 4
GLOBAL CONST $CCS_TOP = 1
GLOBAL CONST $CCS_NOMOVEY = 2
GLOBAL CONST $CCS_BOTTOM = 3
GLOBAL CONST $CCS_NORESIZE = 4
GLOBAL CONST $CCS_NOPARENTALIGN = 8
GLOBAL CONST $CCS_NOHILITE = 16
GLOBAL CONST $CCS_ADJUSTABLE = 32
GLOBAL CONST $CCS_NODIVIDER = 64
GLOBAL CONST $CCS_VERT = 128
GLOBAL CONST $CCS_LEFT = 129
GLOBAL CONST $CCS_NOMOVEX = 130
GLOBAL CONST $CCS_RIGHT = 131
GLOBAL CONST $DT_DRIVETYPE = 1
GLOBAL CONST $DT_SSDSTATUS = 2
GLOBAL CONST $DT_BUSTYPE = 3
GLOBAL CONST $PROXY_IE = 0
GLOBAL CONST $PROXY_NONE = 1
GLOBAL CONST $PROXY_SPECIFIED = 2
GLOBAL CONST $OBJID_WINDOW = 0
GLOBAL CONST $OBJID_TITLEBAR = -2
GLOBAL CONST $OBJID_SIZEGRIP = -7
GLOBAL CONST $OBJID_CARET = -8
GLOBAL CONST $OBJID_CURSOR = -9
GLOBAL CONST $OBJID_ALERT = -10
GLOBAL CONST $OBJID_SOUND = -11
GLOBAL CONST $DLG_CENTERONTOP = 0
GLOBAL CONST $DLG_NOTITLE = 1
GLOBAL CONST $DLG_NOTONTOP = 2
GLOBAL CONST $DLG_TEXTLEFT = 4
GLOBAL CONST $DLG_TEXTRIGHT = 8
GLOBAL CONST $DLG_MOVEABLE = 16
GLOBAL CONST $DLG_TEXTVCENTER = 32
GLOBAL CONST $IDC_UNKNOWN = 0
GLOBAL CONST $IDC_APPSTARTING = 1
GLOBAL CONST $IDC_ARROW = 2
GLOBAL CONST $IDC_CROSS = 3
GLOBAL CONST $IDC_HAND = 32649
GLOBAL CONST $IDC_HELP = 4
GLOBAL CONST $IDC_IBEAM = 5
GLOBAL CONST $IDC_ICON = 6
GLOBAL CONST $IDC_NO = 7
GLOBAL CONST $IDC_SIZE = 8
GLOBAL CONST $IDC_SIZEALL = 9
GLOBAL CONST $IDC_SIZENESW = 10
GLOBAL CONST $IDC_SIZENS = 11
GLOBAL CONST $IDC_SIZENWSE = 12
GLOBAL CONST $IDC_SIZEWE = 13
GLOBAL CONST $IDC_UPARROW = 14
GLOBAL CONST $IDC_WAIT = 15
GLOBAL CONST $IDI_APPLICATION = 32512
GLOBAL CONST $IDI_ASTERISK = 32516
GLOBAL CONST $IDI_EXCLAMATION = 32515
GLOBAL CONST $IDI_HAND = 32513
GLOBAL CONST $IDI_QUESTION = 32514
GLOBAL CONST $IDI_WINLOGO = 32517
GLOBAL CONST $IDI_SHIELD = 32518
GLOBAL CONST $IDI_ERROR = $IDI_HAND
GLOBAL CONST $IDI_INFORMATION = $IDI_ASTERISK
GLOBAL CONST $IDI_WARNING = $IDI_EXCLAMATION
GLOBAL CONST $SD_LOGOFF = 0
GLOBAL CONST $SD_SHUTDOWN = 1
GLOBAL CONST $SD_REBOOT = 2
GLOBAL CONST $SD_FORCE = 4
GLOBAL CONST $SD_POWERDOWN = 8
GLOBAL CONST $SD_FORCEHUNG = 16
GLOBAL CONST $SD_STANDBY = 32
GLOBAL CONST $SD_HIBERNATE = 64
GLOBAL CONST $STDIN_CHILD = 1
GLOBAL CONST $STDOUT_CHILD = 2
GLOBAL CONST $STDERR_CHILD = 4
GLOBAL CONST $STDERR_MERGED = 8
GLOBAL CONST $STDIO_INHERIT_PARENT = 16
GLOBAL CONST $RUN_CREATE_NEW_CONSOLE = 65536
GLOBAL CONST $UBOUND_DIMENSIONS = 0
GLOBAL CONST $UBOUND_ROWS = 1
GLOBAL CONST $UBOUND_COLUMNS = 2
GLOBAL CONST $MOUSEEVENTF_ABSOLUTE = 32768
GLOBAL CONST $MOUSEEVENTF_MOVE = 1
GLOBAL CONST $MOUSEEVENTF_LEFTDOWN = 2
GLOBAL CONST $MOUSEEVENTF_LEFTUP = 4
GLOBAL CONST $MOUSEEVENTF_RIGHTDOWN = 8
GLOBAL CONST $MOUSEEVENTF_RIGHTUP = 16
GLOBAL CONST $MOUSEEVENTF_MIDDLEDOWN = 32
GLOBAL CONST $MOUSEEVENTF_MIDDLEUP = 64
GLOBAL CONST $MOUSEEVENTF_WHEEL = 2048
GLOBAL CONST $MOUSEEVENTF_XDOWN = 128
GLOBAL CONST $MOUSEEVENTF_XUP = 256
GLOBAL CONST $REG_NONE = 0
GLOBAL CONST $REG_SZ = 1
GLOBAL CONST $REG_EXPAND_SZ = 2
GLOBAL CONST $REG_BINARY = 3
GLOBAL CONST $REG_DWORD = 4
GLOBAL CONST $REG_DWORD_LITTLE_ENDIAN = 4
GLOBAL CONST $REG_DWORD_BIG_ENDIAN = 5
GLOBAL CONST $REG_LINK = 6
GLOBAL CONST $REG_MULTI_SZ = 7
GLOBAL CONST $REG_RESOURCE_LIST = 8
GLOBAL CONST $REG_FULL_RESOURCE_DESCRIPTOR = 9
GLOBAL CONST $REG_RESOURCE_REQUIREMENTS_LIST = 10
GLOBAL CONST $REG_QWORD = 11
GLOBAL CONST $REG_QWORD_LITTLE_ENDIAN = 11
GLOBAL CONST $HWND_BOTTOM = 1
GLOBAL CONST $HWND_NOTOPMOST = -2
GLOBAL CONST $HWND_TOP = 0
GLOBAL CONST $HWND_TOPMOST = -1
GLOBAL CONST $SWP_NOSIZE = 1
GLOBAL CONST $SWP_NOMOVE = 2
GLOBAL CONST $SWP_NOZORDER = 4
GLOBAL CONST $SWP_NOREDRAW = 8
GLOBAL CONST $SWP_NOACTIVATE = 16
GLOBAL CONST $SWP_FRAMECHANGED = 32
GLOBAL CONST $SWP_DRAWFRAME = 32
GLOBAL CONST $SWP_SHOWWINDOW = 64
GLOBAL CONST $SWP_HIDEWINDOW = 128
GLOBAL CONST $SWP_NOCOPYBITS = 256
GLOBAL CONST $SWP_NOOWNERZORDER = 512
GLOBAL CONST $SWP_NOREPOSITION = 512
GLOBAL CONST $SWP_NOSENDCHANGING = 1024
GLOBAL CONST $SWP_DEFERERASE = 8192
GLOBAL CONST $SWP_ASYNCWINDOWPOS = 16384
GLOBAL CONST $KEYWORD_DEFAULT = 1
GLOBAL CONST $KEYWORD_NULL = 2
GLOBAL CONST $DECLARED_LOCAL = -1
GLOBAL CONST $DECLARED_UNKNOWN = 0
GLOBAL CONST $DECLARED_GLOBAL = 1
GLOBAL CONST $ASSIGN_CREATE = 0
GLOBAL CONST $ASSIGN_FORCELOCAL = 1
GLOBAL CONST $ASSIGN_FORCEGLOBAL = 2
GLOBAL CONST $ASSIGN_EXISTFAIL = 4
GLOBAL CONST $BI_ENABLE = 0
GLOBAL CONST $BI_DISABLE = 1
GLOBAL CONST $BREAK_ENABLE = 1
GLOBAL CONST $BREAK_DISABLE = 0
GLOBAL CONST $CDTRAY_OPEN = "open"
GLOBAL CONST $CDTRAY_CLOSED = "closed"
GLOBAL CONST $SEND_DEFAULT = 0
GLOBAL CONST $SEND_RAW = 1
GLOBAL CONST $DIR_DEFAULT = 0
GLOBAL CONST $DIR_EXTENDED = 1
GLOBAL CONST $DIR_NORECURSE = 2
GLOBAL CONST $DIR_REMOVE = 1
GLOBAL CONST $DT_ALL = "ALL"
GLOBAL CONST $DT_CDROM = "CDROM"
GLOBAL CONST $DT_REMOVABLE = "REMOVABLE"
GLOBAL CONST $DT_FIXED = "FIXED"
GLOBAL CONST $DT_NETWORK = "NETWORK"
GLOBAL CONST $DT_RAMDISK = "RAMDISK"
GLOBAL CONST $DT_UNKNOWN = "UNKNOWN"
GLOBAL CONST $DT_UNDEFINED = 1
GLOBAL CONST $DT_FAT = "FAT"
GLOBAL CONST $DT_FAT32 = "FAT32"
GLOBAL CONST $DT_EXFAT = "exFAT"
GLOBAL CONST $DT_NTFS = "NTFS"
GLOBAL CONST $DT_NWFS = "NWFS"
GLOBAL CONST $DT_CDFS = "CDFS"
GLOBAL CONST $DT_UDF = "UDF"
GLOBAL CONST $DMA_DEFAULT = 0
GLOBAL CONST $DMA_PERSISTENT = 1
GLOBAL CONST $DMA_AUTHENTICATION = 8
GLOBAL CONST $DS_UNKNOWN = "UNKNOWN"
GLOBAL CONST $DS_READY = "READY"
GLOBAL CONST $DS_NOTREADY = "NOTREADY"
GLOBAL CONST $DS_INVALID = "INVALID"
GLOBAL CONST $MOUSE_CLICK_LEFT = "left"
GLOBAL CONST $MOUSE_CLICK_RIGHT = "right"
GLOBAL CONST $MOUSE_CLICK_MIDDLE = "middle"
GLOBAL CONST $MOUSE_CLICK_MAIN = "main"
GLOBAL CONST $MOUSE_CLICK_MENU = "menu"
GLOBAL CONST $MOUSE_CLICK_PRIMARY = "primary"
GLOBAL CONST $MOUSE_CLICK_SECONDARY = "secondary"
GLOBAL CONST $MOUSE_WHEEL_UP = "up"
GLOBAL CONST $MOUSE_WHEEL_DOWN = "down"
GLOBAL CONST $NUMBER_AUTO = 0
GLOBAL CONST $NUMBER_32BIT = 1
GLOBAL CONST $NUMBER_64BIT = 2
GLOBAL CONST $NUMBER_DOUBLE = 3
GLOBAL CONST $OBJ_NAME = 1
GLOBAL CONST $OBJ_STRING = 2
GLOBAL CONST $OBJ_PROGID = 3
GLOBAL CONST $OBJ_FILE = 4
GLOBAL CONST $OBJ_MODULE = 5
GLOBAL CONST $OBJ_CLSID = 6
GLOBAL CONST $OBJ_IID = 7
GLOBAL CONST $EXITCLOSE_NORMAL = 0
GLOBAL CONST $EXITCLOSE_BYEXIT = 1
GLOBAL CONST $EXITCLOSE_BYCLICK = 2
GLOBAL CONST $EXITCLOSE_BYLOGOFF = 3
GLOBAL CONST $EXITCLOSE_BYSHUTDOWN = 4
GLOBAL CONST $PROCESS_STATS_MEMORY = 0
GLOBAL CONST $PROCESS_STATS_IO = 1
GLOBAL CONST $PROCESS_LOW = 0
GLOBAL CONST $PROCESS_BELOWNORMAL = 1
GLOBAL CONST $PROCESS_NORMAL = 2
GLOBAL CONST $PROCESS_ABOVENORMAL = 3
GLOBAL CONST $PROCESS_HIGH = 4
GLOBAL CONST $PROCESS_REALTIME = 5
GLOBAL CONST $RUN_LOGON_NOPROFILE = 0
GLOBAL CONST $RUN_LOGON_PROFILE = 1
GLOBAL CONST $RUN_LOGON_NETWORK = 2
GLOBAL CONST $RUN_LOGON_INHERIT = 4
GLOBAL CONST $SOUND_NOWAIT = 0
GLOBAL CONST $SOUND_WAIT = 1
GLOBAL CONST $SHEX_OPEN = "open"
GLOBAL CONST $SHEX_EDIT = "edit"
GLOBAL CONST $SHEX_PRINT = "print"
GLOBAL CONST $SHEX_PROPERTIES = "properties"
GLOBAL CONST $TCP_DATA_DEFAULT = 0
GLOBAL CONST $TCP_DATA_BINARY = 1
GLOBAL CONST $UDP_OPEN_DEFAULT = 0
GLOBAL CONST $UDP_OPEN_BROADCAST = 1
GLOBAL CONST $UDP_DATA_DEFAULT = 0
GLOBAL CONST $UDP_DATA_BINARY = 1
GLOBAL CONST $UDP_DATA_ARRAY = 2
GLOBAL CONST $TIP_NOICON = 0
GLOBAL CONST $TIP_INFOICON = 1
GLOBAL CONST $TIP_WARNINGICON = 2
GLOBAL CONST $TIP_ERRORICON = 3
GLOBAL CONST $TIP_BALLOON = 1
GLOBAL CONST $TIP_CENTER = 2
GLOBAL CONST $TIP_FORCEVISIBLE = 4
GLOBAL CONST $WINDOWS_NOONTOP = 0
GLOBAL CONST $WINDOWS_ONTOP = 1
GLOBAL CONST $WIN_STATE_EXISTS = 1
GLOBAL CONST $WIN_STATE_VISIBLE = 2
GLOBAL CONST $WIN_STATE_ENABLED = 4
GLOBAL CONST $WIN_STATE_ACTIVE = 8
GLOBAL CONST $WIN_STATE_MINIMIZED = 16
GLOBAL CONST $WIN_STATE_MAXIMIZED = 32
GLOBAL CONST $FC_NOOVERWRITE = 0
GLOBAL CONST $FC_OVERWRITE = 1
GLOBAL CONST $FC_CREATEPATH = 8
GLOBAL CONST $FT_MODIFIED = 0
GLOBAL CONST $FT_CREATED = 1
GLOBAL CONST $FT_ACCESSED = 2
GLOBAL CONST $FT_ARRAY = 0
GLOBAL CONST $FT_STRING = 1
GLOBAL CONST $FSF_CREATEBUTTON = 1
GLOBAL CONST $FSF_NEWDIALOG = 2
GLOBAL CONST $FSF_EDITCONTROL = 4
GLOBAL CONST $FT_NONRECURSIVE = 0
GLOBAL CONST $FT_RECURSIVE = 1
GLOBAL CONST $FO_READ = 0
GLOBAL CONST $FO_APPEND = 1
GLOBAL CONST $FO_OVERWRITE = 2
GLOBAL CONST $FO_CREATEPATH = 8
GLOBAL CONST $FO_BINARY = 16
GLOBAL CONST $FO_UNICODE = 32
GLOBAL CONST $FO_UTF16_LE = 32
GLOBAL CONST $FO_UTF16_BE = 64
GLOBAL CONST $FO_UTF8 = 128
GLOBAL CONST $FO_UTF8_NOBOM = 256
GLOBAL CONST $FO_ANSI = 512
GLOBAL CONST $FO_UTF16_LE_NOBOM = 1024
GLOBAL CONST $FO_UTF16_BE_NOBOM = 2048
GLOBAL CONST $FO_UTF8_FULL = 16384
GLOBAL CONST $FO_FULLFILE_DETECT = 16384
GLOBAL CONST $EOF = -1
GLOBAL CONST $FD_FILEMUSTEXIST = 1
GLOBAL CONST $FD_PATHMUSTEXIST = 2
GLOBAL CONST $FD_MULTISELECT = 4
GLOBAL CONST $FD_PROMPTCREATENEW = 8
GLOBAL CONST $FD_PROMPTOVERWRITE = 16
GLOBAL CONST $CREATE_NEW = 1
GLOBAL CONST $CREATE_ALWAYS = 2
GLOBAL CONST $OPEN_EXISTING = 3
GLOBAL CONST $OPEN_ALWAYS = 4
GLOBAL CONST $TRUNCATE_EXISTING = 5
GLOBAL CONST $INVALID_SET_FILE_POINTER = -1
GLOBAL CONST $FILE_BEGIN = 0
GLOBAL CONST $FILE_CURRENT = 1
GLOBAL CONST $FILE_END = 2
GLOBAL CONST $FILE_ATTRIBUTE_READONLY = 1
GLOBAL CONST $FILE_ATTRIBUTE_HIDDEN = 2
GLOBAL CONST $FILE_ATTRIBUTE_SYSTEM = 4
GLOBAL CONST $FILE_ATTRIBUTE_DIRECTORY = 16
GLOBAL CONST $FILE_ATTRIBUTE_ARCHIVE = 32
GLOBAL CONST $FILE_ATTRIBUTE_DEVICE = 64
GLOBAL CONST $FILE_ATTRIBUTE_NORMAL = 128
GLOBAL CONST $FILE_ATTRIBUTE_TEMPORARY = 256
GLOBAL CONST $FILE_ATTRIBUTE_SPARSE_FILE = 512
GLOBAL CONST $FILE_ATTRIBUTE_REPARSE_POINT = 1024
GLOBAL CONST $FILE_ATTRIBUTE_COMPRESSED = 2048
GLOBAL CONST $FILE_ATTRIBUTE_OFFLINE = 4096
GLOBAL CONST $FILE_ATTRIBUTE_NOT_CONTENT_INDEXED = 8192
GLOBAL CONST $FILE_ATTRIBUTE_ENCRYPTED = 16384
GLOBAL CONST $FILE_SHARE_READ = 1
GLOBAL CONST $FILE_SHARE_WRITE = 2
GLOBAL CONST $FILE_SHARE_DELETE = 4
GLOBAL CONST $FILE_SHARE_READWRITE = BITOR($FILE_SHARE_READ, $FILE_SHARE_WRITE)
GLOBAL CONST $FILE_SHARE_ANY = BITOR($FILE_SHARE_READ, $FILE_SHARE_WRITE, $FILE_SHARE_DELETE)
GLOBAL CONST $GENERIC_ALL = 268435456
GLOBAL CONST $GENERIC_EXECUTE = 536870912
GLOBAL CONST $GENERIC_WRITE = 1073741824
GLOBAL CONST $GENERIC_READ = -2147483648
GLOBAL CONST $GENERIC_READWRITE = BITOR($GENERIC_READ, $GENERIC_WRITE)
GLOBAL CONST $FILE_ENCODING_UTF16LE = 32
GLOBAL CONST $FE_ENTIRE_UTF8 = 1
GLOBAL CONST $FE_PARTIALFIRST_UTF8 = 2
GLOBAL CONST $FN_FULLPATH = 0
GLOBAL CONST $FN_RELATIVEPATH = 1
GLOBAL CONST $FV_COMMENTS = "Comments"
GLOBAL CONST $FV_COMPANYNAME = "CompanyName"
GLOBAL CONST $FV_FILEDESCRIPTION = "FileDescription"
GLOBAL CONST $FV_FILEVERSION = "FileVersion"
GLOBAL CONST $FV_INTERNALNAME = "InternalName"
GLOBAL CONST $FV_LEGALCOPYRIGHT = "LegalCopyright"
GLOBAL CONST $FV_LEGALTRADEMARKS = "LegalTrademarks"
GLOBAL CONST $FV_ORIGINALFILENAME = "OriginalFilename"
GLOBAL CONST $FV_PRODUCTNAME = "ProductName"
GLOBAL CONST $FV_PRODUCTVERSION = "ProductVersion"
GLOBAL CONST $FV_PRIVATEBUILD = "PrivateBuild"
GLOBAL CONST $FV_SPECIALBUILD = "SpecialBuild"
GLOBAL CONST $FRTA_NOCOUNT = 0
GLOBAL CONST $FRTA_COUNT = 1
GLOBAL CONST $FRTA_INTARRAYS = 2
GLOBAL CONST $FRTA_ENTIRESPLIT = 4
GLOBAL CONST $FLTA_FILESFOLDERS = 0
GLOBAL CONST $FLTA_FILES = 1
GLOBAL CONST $FLTA_FOLDERS = 2
GLOBAL CONST $FLTAR_FILESFOLDERS = 0
GLOBAL CONST $FLTAR_FILES = 1
GLOBAL CONST $FLTAR_FOLDERS = 2
GLOBAL CONST $FLTAR_NOHIDDEN = 4
GLOBAL CONST $FLTAR_NOSYSTEM = 8
GLOBAL CONST $FLTAR_NOLINK = 16
GLOBAL CONST $FLTAR_NORECUR = 0
GLOBAL CONST $FLTAR_RECUR = 1
GLOBAL CONST $FLTAR_NOSORT = 0
GLOBAL CONST $FLTAR_SORT = 1
GLOBAL CONST $FLTAR_FASTSORT = 2
GLOBAL CONST $FLTAR_NOPATH = 0
GLOBAL CONST $FLTAR_RELPATH = 1
GLOBAL CONST $FLTAR_FULLPATH = 2
GLOBAL CONST $PATH_ORIGINAL = 0
GLOBAL CONST $PATH_DRIVE = 1
GLOBAL CONST $PATH_DIRECTORY = 2
GLOBAL CONST $PATH_FILENAME = 3
GLOBAL CONST $PATH_EXTENSION = 4
#Region Global Variables and Constants
	GLOBAL $__G_VENUM, $__G_VEXT = 0
	GLOBAL $__G_IRGBMODE = 1
	GLOBAL CONST $TAGOSVERSIONINFO = "struct;dword OSVersionInfoSize;dword MajorVersion;dword MinorVersion;dword BuildNumber;dword PlatformId;wchar CSDVersion[128];endstruct"
	GLOBAL CONST $IMAGE_BITMAP = 0
	GLOBAL CONST $IMAGE_ICON = 1
	GLOBAL CONST $IMAGE_CURSOR = 2
	GLOBAL CONST $IMAGE_ENHMETAFILE = 3
	GLOBAL CONST $LR_DEFAULTCOLOR = 0
	GLOBAL CONST $LR_MONOCHROME = 1
	GLOBAL CONST $LR_COLOR = 2
	GLOBAL CONST $LR_COPYRETURNORG = 4
	GLOBAL CONST $LR_COPYDELETEORG = 8
	GLOBAL CONST $LR_LOADFROMFILE = 16
	GLOBAL CONST $LR_LOADTRANSPARENT = 32
	GLOBAL CONST $LR_DEFAULTSIZE = 64
	GLOBAL CONST $LR_VGACOLOR = 128
	GLOBAL CONST $LR_LOADMAP3DCOLORS = 4096
	GLOBAL CONST $LR_CREATEDIBSECTION = 8192
	GLOBAL CONST $LR_COPYFROMRESOURCE = 16384
	GLOBAL CONST $LR_SHARED = 32768
	GLOBAL CONST $__TAGCURSORINFO = "dword Size;dword Flags;handle hCursor;" & "struct;long X;long Y;endstruct"
	GLOBAL CONST $__WINVER = __WINVER()
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_CREATEFILE($SFILENAME, $ICREATION, $IACCESS = 4, $ISHARE = 0, $IATTRIBUTES = 0, $TSECURITY = 0)
		LOCAL $IDA = 0, $ISM = 0, $ICD = 0, $IFA = 0
		IF BITAND($IACCESS, 1) <> 0 THEN $IDA = BITOR($IDA, $GENERIC_EXECUTE)
		IF BITAND($IACCESS, 2) <> 0 THEN $IDA = BITOR($IDA, $GENERIC_READ)
		IF BITAND($IACCESS, 4) <> 0 THEN $IDA = BITOR($IDA, $GENERIC_WRITE)
		IF BITAND($ISHARE, 1) <> 0 THEN $ISM = BITOR($ISM, $FILE_SHARE_DELETE)
		IF BITAND($ISHARE, 2) <> 0 THEN $ISM = BITOR($ISM, $FILE_SHARE_READ)
		IF BITAND($ISHARE, 4) <> 0 THEN $ISM = BITOR($ISM, $FILE_SHARE_WRITE)
		SWITCH $ICREATION
			CASE 0
				$ICD = $CREATE_NEW
			CASE 1
				$ICD = $CREATE_ALWAYS
			CASE 2
				$ICD = $OPEN_EXISTING
			CASE 3
				$ICD = $OPEN_ALWAYS
			CASE 4
				$ICD = $TRUNCATE_EXISTING
		ENDSWITCH
		IF BITAND($IATTRIBUTES, 1) <> 0 THEN $IFA = BITOR($IFA, $FILE_ATTRIBUTE_ARCHIVE)
		IF BITAND($IATTRIBUTES, 2) <> 0 THEN $IFA = BITOR($IFA, $FILE_ATTRIBUTE_HIDDEN)
		IF BITAND($IATTRIBUTES, 4) <> 0 THEN $IFA = BITOR($IFA, $FILE_ATTRIBUTE_READONLY)
		IF BITAND($IATTRIBUTES, 8) <> 0 THEN $IFA = BITOR($IFA, $FILE_ATTRIBUTE_SYSTEM)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "handle", "CreateFileW", "wstr", $SFILENAME, "dword", $IDA, "dword", $ISM, "struct*", $TSECURITY, "dword", $ICD, "dword", $IFA, "ptr", 0)
		IF @ERROR OR($ARESULT[0] = PTR(-1)) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_FREELIBRARY($HMODULE)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "FreeLibrary", "handle", $HMODULE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETCURSORINFO()
		LOCAL $TCURSOR = DLLSTRUCTCREATE($__TAGCURSORINFO)
		LOCAL $ICURSOR = DLLSTRUCTGETSIZE($TCURSOR)
		DLLSTRUCTSETDATA($TCURSOR, "Size", $ICURSOR)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetCursorInfo", "struct*", $TCURSOR)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ACURSOR[5]
		$ACURSOR[0] = TRUE
		$ACURSOR[1] = DLLSTRUCTGETDATA($TCURSOR, "Flags") <> 0
		$ACURSOR[2] = DLLSTRUCTGETDATA($TCURSOR, "hCursor")
		$ACURSOR[3] = DLLSTRUCTGETDATA($TCURSOR, "X")
		$ACURSOR[4] = DLLSTRUCTGETDATA($TCURSOR, "Y")
		RETURN $ACURSOR
	ENDFUNC
	FUNC _WINAPI_GETDLGCTRLID($HWND)
		LOCAL $ARESULT = DLLCALL("user32.dll", "int", "GetDlgCtrlID", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETMODULEHANDLE($SMODULENAME)
		LOCAL $SMODULENAMETYPE = "wstr"
		IF $SMODULENAME = "" THEN
			$SMODULENAME = 0
			$SMODULENAMETYPE = "ptr"
		ENDIF
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "handle", "GetModuleHandleW", $SMODULENAMETYPE, $SMODULENAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETSTRING($PSTRING, $BUNICODE = TRUE)
		LOCAL $ILENGTH = _WINAPI_STRLEN($PSTRING, $BUNICODE)
		IF @ERROR OR NOT $ILENGTH THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		LOCAL $TSTRING = DLLSTRUCTCREATE(($BUNICODE ? "wchar" : "char") & "[" & ($ILENGTH + 1) & "]", $PSTRING)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN SETEXTENDED($ILENGTH, DLLSTRUCTGETDATA($TSTRING, 1))
	ENDFUNC
	FUNC _WINAPI_ISWOW64PROCESS($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", ($__WINVER < 1536 ? 1024 : 4096), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, FALSE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "IsWow64Process", "handle", $HPROCESS[0], "bool*", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HPROCESS[0]) THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_LOADIMAGE($HINSTANCE, $SIMAGE, $ITYPE, $IXDESIRED, $IYDESIRED, $ILOAD)
		LOCAL $ARESULT, $SIMAGETYPE = "int"
		IF ISSTRING($SIMAGE) THEN $SIMAGETYPE = "wstr"
		$ARESULT = DLLCALL("user32.dll", "handle", "LoadImageW", "handle", $HINSTANCE, $SIMAGETYPE, $SIMAGE, "uint", $ITYPE, "int", $IXDESIRED, "int", $IYDESIRED, "uint", $ILOAD)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_LOADLIBRARY($SFILENAME)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "handle", "LoadLibraryW", "wstr", $SFILENAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_PATHISDIRECTORY($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathIsDirectoryW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_READFILE($HFILE, $PBUFFER, $ITOREAD, BYREF $IREAD, $TOVERLAPPED = 0)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "ReadFile", "handle", $HFILE, "struct*", $PBUFFER, "dword", $ITOREAD, "dword*", 0, "struct*", $TOVERLAPPED)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IREAD = $ARESULT[4]
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_STRLEN($PSTRING, $BUNICODE = TRUE)
		LOCAL $W = ""
		IF $BUNICODE THEN $W = "W"
		LOCAL $ARET = DLLCALL("kernel32.dll", "int", "lstrlen" & $W, "struct*", $PSTRING)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SWITCHCOLOR($ICOLOR)
		IF $ICOLOR = -1 THEN RETURN $ICOLOR
		RETURN BITOR(BITAND($ICOLOR, 65280), BITSHIFT(BITAND($ICOLOR, 255), -16), BITSHIFT(BITAND($ICOLOR, 16711680), 16))
	ENDFUNC
	FUNC _WINAPI_WRITEFILE($HFILE, $PBUFFER, $ITOWRITE, BYREF $IWRITTEN, $TOVERLAPPED = 0)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "WriteFile", "handle", $HFILE, "struct*", $PBUFFER, "dword", $ITOWRITE, "dword*", 0, "struct*", $TOVERLAPPED)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IWRITTEN = $ARESULT[4]
		RETURN $ARESULT[0]
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __CHECKERRORARRAYBOUNDS(CONST BYREF $ADATA, BYREF $ISTART, BYREF $IEND, $NDIM = 1, $IDIM = $UBOUND_DIMENSIONS)
		IF NOT ISARRAY($ADATA) THEN RETURN SETERROR(1, 0, 1)
		IF UBOUND($ADATA, $IDIM) <> $NDIM THEN RETURN SETERROR(2, 0, 1)
		IF $ISTART < 0 THEN $ISTART = 0
		LOCAL $IUBOUND = UBOUND($ADATA) - 1
		IF $IEND < 1 OR $IEND > $IUBOUND THEN $IEND = $IUBOUND
		IF $ISTART > $IEND THEN RETURN SETERROR(4, 0, 1)
		RETURN 0
	ENDFUNC
	FUNC __CHECKERRORCLOSEHANDLE($ARET, $HFILE, $BLASTERROR = FALSE, $ICURERR = @ERROR, $ICUREXT = @EXTENDED)
		IF NOT $ICURERR AND NOT $ARET[0] THEN $ICURERR = 10
		LOCAL $ALASTERROR = DLLCALL("kernel32.dll", "dword", "GetLastError")
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HFILE)
		IF $ICURERR THEN DLLCALL("kernel32.dll", "none", "SetLastError", "dword", $ALASTERROR[0])
		IF $BLASTERROR THEN $ICUREXT = $ALASTERROR[0]
		RETURN SETERROR($ICURERR, $ICUREXT, $ICURERR)
	ENDFUNC
	FUNC __DLL($SPATH, $BPIN = FALSE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetModuleHandleExW", "dword", ($BPIN ? 1 : 2), "wstr", $SPATH, "ptr*", 0)
		IF NOT $ARET[3] THEN
			LOCAL $ARESULT = DLLCALL("kernel32.dll", "handle", "LoadLibraryW", "wstr", $SPATH)
			IF NOT $ARESULT[0] THEN RETURN 0
		ENDIF
		RETURN 1
	ENDFUNC
	FUNC __ENUMWINDOWSPROC($HWND, $BVISIBLE)
		LOCAL $ARESULT
		IF $BVISIBLE THEN
			$ARESULT = DLLCALL("user32.dll", "bool", "IsWindowVisible", "hwnd", $HWND)
			IF NOT $ARESULT[0] THEN
				RETURN 1
			ENDIF
		ENDIF
		__INC($__G_VENUM)
		$__G_VENUM[$__G_VENUM[0][0]][0] = $HWND
		$ARESULT = DLLCALL("user32.dll", "int", "GetClassNameW", "hwnd", $HWND, "wstr", "", "int", 4096)
		$__G_VENUM[$__G_VENUM[0][0]][1] = $ARESULT[2]
		RETURN 1
	ENDFUNC
	FUNC __FATALEXIT($ICODE, $STEXT = "")
		IF $STEXT THEN MSGBOX($MB_SYSTEMMODAL, "AutoIt", $STEXT)
		DLLCALL("kernel32.dll", "none", "FatalExit", "int", $ICODE)
	ENDFUNC
	FUNC __INC(BYREF $ADATA, $IINCREMENT = 100)
		SELECT
			CASE UBOUND($ADATA, $UBOUND_COLUMNS)
				IF $IINCREMENT < 0 THEN
					REDIM $ADATA[$ADATA[0][0] + 1][UBOUND($ADATA, $UBOUND_COLUMNS)]
				ELSE
					$ADATA[0][0] += 1
					IF $ADATA[0][0] > UBOUND($ADATA) - 1 THEN
						REDIM $ADATA[$ADATA[0][0] + $IINCREMENT][UBOUND($ADATA, $UBOUND_COLUMNS)]
					ENDIF
				ENDIF
			CASE UBOUND($ADATA, $UBOUND_ROWS)
				IF $IINCREMENT < 0 THEN
					REDIM $ADATA[$ADATA[0] + 1]
				ELSE
					$ADATA[0] += 1
					IF $ADATA[0] > UBOUND($ADATA) - 1 THEN
						REDIM $ADATA[$ADATA[0] + $IINCREMENT]
					ENDIF
				ENDIF
			CASE ELSE
				RETURN 0
		ENDSELECT
		RETURN 1
	ENDFUNC
	FUNC __RGB($ICOLOR)
		IF $__G_IRGBMODE THEN
			$ICOLOR = _WINAPI_SWITCHCOLOR($ICOLOR)
		ENDIF
		RETURN $ICOLOR
	ENDFUNC
	FUNC __WINVER()
		LOCAL $TOSVI = DLLSTRUCTCREATE($TAGOSVERSIONINFO)
		DLLSTRUCTSETDATA($TOSVI, 1, DLLSTRUCTGETSIZE($TOSVI))
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetVersionExW", "struct*", $TOSVI)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN BITOR(BITSHIFT(DLLSTRUCTGETDATA($TOSVI, 2), -8), DLLSTRUCTGETDATA($TOSVI, 3))
	ENDFUNC
#EndRegion Internal Functions
#Region Global Variables and Constants
	GLOBAL CONST $DUPLICATE_CLOSE_SOURCE = 1
	GLOBAL CONST $DUPLICATE_SAME_ACCESS = 2
	GLOBAL CONST $OBJ_BITMAP = 7
	GLOBAL CONST $OBJ_BRUSH = 2
	GLOBAL CONST $OBJ_COLORSPACE = 14
	GLOBAL CONST $OBJ_DC = 3
	GLOBAL CONST $OBJ_ENHMETADC = 12
	GLOBAL CONST $OBJ_ENHMETAFILE = 13
	GLOBAL CONST $OBJ_EXTPEN = 11
	GLOBAL CONST $OBJ_FONT = 6
	GLOBAL CONST $OBJ_MEMDC = 10
	GLOBAL CONST $OBJ_METADC = 4
	GLOBAL CONST $OBJ_METAFILE = 9
	GLOBAL CONST $OBJ_PAL = 5
	GLOBAL CONST $OBJ_PEN = 1
	GLOBAL CONST $OBJ_REGION = 8
	GLOBAL CONST $NULL_BRUSH = 5
	GLOBAL CONST $NULL_PEN = 8
	GLOBAL CONST $BLACK_BRUSH = 4
	GLOBAL CONST $DKGRAY_BRUSH = 3
	GLOBAL CONST $DC_BRUSH = 18
	GLOBAL CONST $GRAY_BRUSH = 2
	GLOBAL CONST $HOLLOW_BRUSH = $NULL_BRUSH
	GLOBAL CONST $LTGRAY_BRUSH = 1
	GLOBAL CONST $WHITE_BRUSH = 0
	GLOBAL CONST $BLACK_PEN = 7
	GLOBAL CONST $DC_PEN = 19
	GLOBAL CONST $WHITE_PEN = 6
	GLOBAL CONST $ANSI_FIXED_FONT = 11
	GLOBAL CONST $ANSI_VAR_FONT = 12
	GLOBAL CONST $DEVICE_DEFAULT_FONT = 14
	GLOBAL CONST $DEFAULT_GUI_FONT = 17
	GLOBAL CONST $OEM_FIXED_FONT = 10
	GLOBAL CONST $SYSTEM_FONT = 13
	GLOBAL CONST $SYSTEM_FIXED_FONT = 16
	GLOBAL CONST $DEFAULT_PALETTE = 15
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_CLOSEHANDLE($HOBJECT)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HOBJECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_DELETEOBJECT($HOBJECT)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "bool", "DeleteObject", "handle", $HOBJECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_DUPLICATEHANDLE($HSOURCEPROCESSHANDLE, $HSOURCEHANDLE, $HTARGETPROCESSHANDLE, $IDESIREDACCESS, $IINHERITHANDLE, $IOPTIONS)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "DuplicateHandle", "handle", $HSOURCEPROCESSHANDLE, "handle", $HSOURCEHANDLE, "handle", $HTARGETPROCESSHANDLE, "handle*", 0, "dword", $IDESIREDACCESS, "bool", $IINHERITHANDLE, "dword", $IOPTIONS)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[4]
	ENDFUNC
	FUNC _WINAPI_GETCURRENTOBJECT($HDC, $ITYPE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "GetCurrentObject", "handle", $HDC, "uint", $ITYPE)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETCURRENTPROCESS()
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "handle", "GetCurrentProcess")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETOBJECT($HOBJECT, $ISIZE, $POBJECT)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "int", "GetObjectW", "handle", $HOBJECT, "int", $ISIZE, "struct*", $POBJECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETOBJECTINFOBYHANDLE($HOBJECT)
		LOCAL $TAGPUBLIC_OBJECT_BASIC_INFORMATION = "ulong Attributes;ulong GrantedAcess;ulong HandleCount;ulong PointerCount;ulong Reserved[10]"
		LOCAL $TPOBI = DLLSTRUCTCREATE($TAGPUBLIC_OBJECT_BASIC_INFORMATION)
		LOCAL $ARET = DLLCALL("ntdll.dll", "long", "ZwQueryObject", "handle", $HOBJECT, "uint", 0, "struct*", $TPOBI, "ulong", DLLSTRUCTGETSIZE($TPOBI), "ptr", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		LOCAL $ARESULT[4]
		FOR $I = 0 TO 3
			$ARESULT[$I] = DLLSTRUCTGETDATA($TPOBI, $I + 1)
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETOBJECTNAMEBYHANDLE($HOBJECT)
		LOCAL $TAGUNICODE_STRING = "struct;ushort Length;ushort MaximumLength;ptr Buffer;endstruct"
		LOCAL $TAGPUBLIC_OBJECT_TYPE_INFORMATION = "struct;" & $TAGUNICODE_STRING & ";ulong Reserved[22];endstruct"
		LOCAL $TPOTI = DLLSTRUCTCREATE($TAGPUBLIC_OBJECT_TYPE_INFORMATION & ";byte[32]")
		LOCAL $ARET = DLLCALL("ntdll.dll", "long", "ZwQueryObject", "handle", $HOBJECT, "uint", 2, "struct*", $TPOTI, "ulong", DLLSTRUCTGETSIZE($TPOTI), "ulong*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		LOCAL $PDATA = DLLSTRUCTGETDATA($TPOTI, 3)
		IF NOT $PDATA THEN RETURN SETERROR(11, 0, "")
		RETURN _WINAPI_GETSTRING($PDATA)
	ENDFUNC
	FUNC _WINAPI_GETOBJECTTYPE($HOBJECT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "dword", "GetObjectType", "handle", $HOBJECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETSTDHANDLE($ISTDHANDLE)
		IF $ISTDHANDLE < 0 OR $ISTDHANDLE > 2 THEN RETURN SETERROR(2, 0, -1)
		LOCAL CONST $AHANDLE[3] = [-10, -11, -12]
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "handle", "GetStdHandle", "dword", $AHANDLE[$ISTDHANDLE])
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETSTOCKOBJECT($IOBJECT)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "handle", "GetStockObject", "int", $IOBJECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SELECTOBJECT($HDC, $HGDIOBJ)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDC, "handle", $HGDIOBJ)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETHANDLEINFORMATION($HOBJECT, $IMASK, $IFLAGS)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "SetHandleInformation", "handle", $HOBJECT, "dword", $IMASK, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
#EndRegion Public Functions
GLOBAL CONST $LINGUISTIC_IGNORECASE = 16
GLOBAL CONST $LINGUISTIC_IGNOREDIACRITIC = 32
GLOBAL CONST $NORM_IGNORECASE = 1
GLOBAL CONST $NORM_IGNOREKANATYPE = 65536
GLOBAL CONST $NORM_IGNORENONSPACE = 2
GLOBAL CONST $NORM_IGNORESYMBOLS = 4
GLOBAL CONST $NORM_IGNOREWIDTH = 131072
GLOBAL CONST $NORM_LINGUISTIC_CASING = 134217728
GLOBAL CONST $SORT_DIGITSASNUMBERS = 8
GLOBAL CONST $SORT_STRINGSORT = 4096
GLOBAL CONST $CSTR_LESS_THAN = 1
GLOBAL CONST $CSTR_EQUAL = 2
GLOBAL CONST $CSTR_GREATER_THAN = 3
GLOBAL CONST $MUI_LANGUAGE_ID = 4
GLOBAL CONST $MUI_LANGUAGE_NAME = 8
GLOBAL CONST $DATE_AUTOLAYOUT = 64
GLOBAL CONST $DATE_LONGDATE = 2
GLOBAL CONST $DATE_LTRREADING = 16
GLOBAL CONST $DATE_SHORTDATE = 1
GLOBAL CONST $DATE_RTLREADING = 32
GLOBAL CONST $DATE_USE_ALT_CALENDAR = 4
GLOBAL CONST $DATE_YEARMONTH = 8
GLOBAL CONST $GEO_NATION = 1
GLOBAL CONST $GEO_LATITUDE = 2
GLOBAL CONST $GEO_LONGITUDE = 3
GLOBAL CONST $GEO_ISO2 = 4
GLOBAL CONST $GEO_ISO3 = 5
GLOBAL CONST $GEO_RFC1766 = 6
GLOBAL CONST $GEO_LCID = 7
GLOBAL CONST $GEO_FRIENDLYNAME = 8
GLOBAL CONST $GEO_OFFICIALNAME = 9
GLOBAL CONST $GEO_TIMEZONES = 10
GLOBAL CONST $GEO_OFFICIALLANGUAGES = 11
GLOBAL CONST $GEO_ISO_UN_NUMBER = 12
GLOBAL CONST $GEO_PARENT = 13
GLOBAL CONST $LOCALE_ILANGUAGE = 1
GLOBAL CONST $LOCALE_SLANGUAGE = 2
GLOBAL CONST $LOCALE_SENGLANGUAGE = 4097
GLOBAL CONST $LOCALE_SABBREVLANGNAME = 3
GLOBAL CONST $LOCALE_SNATIVELANGNAME = 4
GLOBAL CONST $LOCALE_ICOUNTRY = 5
GLOBAL CONST $LOCALE_SCOUNTRY = 6
GLOBAL CONST $LOCALE_SENGCOUNTRY = 4098
GLOBAL CONST $LOCALE_SABBREVCTRYNAME = 7
GLOBAL CONST $LOCALE_SNATIVECTRYNAME = 8
GLOBAL CONST $LOCALE_IDEFAULTLANGUAGE = 9
GLOBAL CONST $LOCALE_IDEFAULTCOUNTRY = 10
GLOBAL CONST $LOCALE_IDEFAULTCODEPAGE = 11
GLOBAL CONST $LOCALE_IDEFAULTANSICODEPAGE = 4100
GLOBAL CONST $LOCALE_IDEFAULTMACCODEPAGE = 4113
GLOBAL CONST $LOCALE_SLIST = 12
GLOBAL CONST $LOCALE_IMEASURE = 13
GLOBAL CONST $LOCALE_SDECIMAL = 14
GLOBAL CONST $LOCALE_STHOUSAND = 15
GLOBAL CONST $LOCALE_SGROUPING = 16
GLOBAL CONST $LOCALE_IDIGITS = 17
GLOBAL CONST $LOCALE_ILZERO = 18
GLOBAL CONST $LOCALE_INEGNUMBER = 4112
GLOBAL CONST $LOCALE_SNATIVEDIGITS = 19
GLOBAL CONST $LOCALE_SCURRENCY = 20
GLOBAL CONST $LOCALE_SINTLSYMBOL = 21
GLOBAL CONST $LOCALE_SMONDECIMALSEP = 22
GLOBAL CONST $LOCALE_SMONTHOUSANDSEP = 23
GLOBAL CONST $LOCALE_SMONGROUPING = 24
GLOBAL CONST $LOCALE_ICURRDIGITS = 25
GLOBAL CONST $LOCALE_IINTLCURRDIGITS = 26
GLOBAL CONST $LOCALE_ICURRENCY = 27
GLOBAL CONST $LOCALE_INEGCURR = 28
GLOBAL CONST $LOCALE_SDATE = 29
GLOBAL CONST $LOCALE_STIME = 30
GLOBAL CONST $LOCALE_SSHORTDATE = 31
GLOBAL CONST $LOCALE_SLONGDATE = 32
GLOBAL CONST $LOCALE_STIMEFORMAT = 4099
GLOBAL CONST $LOCALE_IDATE = 33
GLOBAL CONST $LOCALE_ILDATE = 34
GLOBAL CONST $LOCALE_ITIME = 35
GLOBAL CONST $LOCALE_ITIMEMARKPOSN = 4101
GLOBAL CONST $LOCALE_ICENTURY = 36
GLOBAL CONST $LOCALE_ITLZERO = 37
GLOBAL CONST $LOCALE_IDAYLZERO = 38
GLOBAL CONST $LOCALE_IMONLZERO = 39
GLOBAL CONST $LOCALE_S1159 = 40
GLOBAL CONST $LOCALE_S2359 = 41
GLOBAL CONST $LOCALE_ICALENDARTYPE = 4105
GLOBAL CONST $LOCALE_IOPTIONALCALENDAR = 4107
GLOBAL CONST $LOCALE_IFIRSTDAYOFWEEK = 4108
GLOBAL CONST $LOCALE_IFIRSTWEEKOFYEAR = 4109
GLOBAL CONST $LOCALE_SDAYNAME1 = 42
GLOBAL CONST $LOCALE_SDAYNAME2 = 43
GLOBAL CONST $LOCALE_SDAYNAME3 = 44
GLOBAL CONST $LOCALE_SDAYNAME4 = 45
GLOBAL CONST $LOCALE_SDAYNAME5 = 46
GLOBAL CONST $LOCALE_SDAYNAME6 = 47
GLOBAL CONST $LOCALE_SDAYNAME7 = 48
GLOBAL CONST $LOCALE_SABBREVDAYNAME1 = 49
GLOBAL CONST $LOCALE_SABBREVDAYNAME2 = 50
GLOBAL CONST $LOCALE_SABBREVDAYNAME3 = 51
GLOBAL CONST $LOCALE_SABBREVDAYNAME4 = 52
GLOBAL CONST $LOCALE_SABBREVDAYNAME5 = 53
GLOBAL CONST $LOCALE_SABBREVDAYNAME6 = 54
GLOBAL CONST $LOCALE_SABBREVDAYNAME7 = 55
GLOBAL CONST $LOCALE_SMONTHNAME1 = 56
GLOBAL CONST $LOCALE_SMONTHNAME2 = 57
GLOBAL CONST $LOCALE_SMONTHNAME3 = 58
GLOBAL CONST $LOCALE_SMONTHNAME4 = 59
GLOBAL CONST $LOCALE_SMONTHNAME5 = 60
GLOBAL CONST $LOCALE_SMONTHNAME6 = 61
GLOBAL CONST $LOCALE_SMONTHNAME7 = 62
GLOBAL CONST $LOCALE_SMONTHNAME8 = 63
GLOBAL CONST $LOCALE_SMONTHNAME9 = 64
GLOBAL CONST $LOCALE_SMONTHNAME10 = 65
GLOBAL CONST $LOCALE_SMONTHNAME11 = 66
GLOBAL CONST $LOCALE_SMONTHNAME12 = 67
GLOBAL CONST $LOCALE_SMONTHNAME13 = 4110
GLOBAL CONST $LOCALE_SABBREVMONTHNAME1 = 68
GLOBAL CONST $LOCALE_SABBREVMONTHNAME2 = 69
GLOBAL CONST $LOCALE_SABBREVMONTHNAME3 = 70
GLOBAL CONST $LOCALE_SABBREVMONTHNAME4 = 71
GLOBAL CONST $LOCALE_SABBREVMONTHNAME5 = 72
GLOBAL CONST $LOCALE_SABBREVMONTHNAME6 = 73
GLOBAL CONST $LOCALE_SABBREVMONTHNAME7 = 74
GLOBAL CONST $LOCALE_SABBREVMONTHNAME8 = 75
GLOBAL CONST $LOCALE_SABBREVMONTHNAME9 = 76
GLOBAL CONST $LOCALE_SABBREVMONTHNAME10 = 77
GLOBAL CONST $LOCALE_SABBREVMONTHNAME11 = 78
GLOBAL CONST $LOCALE_SABBREVMONTHNAME12 = 79
GLOBAL CONST $LOCALE_SABBREVMONTHNAME13 = 4111
GLOBAL CONST $LOCALE_SPOSITIVESIGN = 80
GLOBAL CONST $LOCALE_SNEGATIVESIGN = 81
GLOBAL CONST $LOCALE_IPOSSIGNPOSN = 82
GLOBAL CONST $LOCALE_INEGSIGNPOSN = 83
GLOBAL CONST $LOCALE_IPOSSYMPRECEDES = 84
GLOBAL CONST $LOCALE_IPOSSEPBYSPACE = 85
GLOBAL CONST $LOCALE_INEGSYMPRECEDES = 86
GLOBAL CONST $LOCALE_INEGSEPBYSPACE = 87
GLOBAL CONST $LOCALE_FONTSIGNATURE = 88
GLOBAL CONST $LOCALE_SISO639LANGNAME = 89
GLOBAL CONST $LOCALE_SISO3166CTRYNAME = 90
GLOBAL CONST $LOCALE_IDEFAULTEBCDICCODEPAGE = 4114
GLOBAL CONST $LOCALE_IPAPERSIZE = 4106
GLOBAL CONST $LOCALE_SENGCURRNAME = 4103
GLOBAL CONST $LOCALE_SNATIVECURRNAME = 4104
GLOBAL CONST $LOCALE_SYEARMONTH = 4102
GLOBAL CONST $LOCALE_SSORTNAME = 4115
GLOBAL CONST $LOCALE_IDIGITSUBSTITUTION = 4116
GLOBAL CONST $LOCALE_CUSTOM_DEFAULT = 3072
GLOBAL CONST $LOCALE_CUSTOM_UI_DEFAULT = 5120
GLOBAL CONST $LOCALE_CUSTOM_UNSPECIFIED = 4096
GLOBAL CONST $LOCALE_INVARIANT = 127
GLOBAL CONST $LOCALE_SYSTEM_DEFAULT = 2048
GLOBAL CONST $LOCALE_USER_DEFAULT = 1024
GLOBAL CONST $TIME_FORCE24HOURFORMAT = 8
GLOBAL CONST $TIME_NOMINUTESORSECONDS = 1
GLOBAL CONST $TIME_NOSECONDS = 2
GLOBAL CONST $TIME_NOTIMEMARKER = 4
GLOBAL CONST $LCID_INSTALLED = 1
GLOBAL CONST $LCID_SUPPORTED = 2
#Region Global Variables and Constants
	GLOBAL CONST $TAGNUMBERFMT = "uint NumDigits;uint LeadingZero;uint Grouping;ptr DecimalSep;ptr ThousandSep;uint NegativeOrder"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_COMPARESTRING($ILCID, $SSTRING1, $SSTRING2, $IFLAGS = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "int", "CompareStringW", "dword", $ILCID, "dword", $IFLAGS, "wstr", $SSTRING1, "int", -1, "wstr", $SSTRING2, "int", -1)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATENUMBERFORMATINFO($INUMDIGITS, $ILEADINGZERO, $IGROUPING, $SDECIMALSEP, $STHOUSANDSEP, $INEGATIVEORDER)
		LOCAL $TFMT = DLLSTRUCTCREATE($TAGNUMBERFMT & ";wchar[" & (STRINGLEN($SDECIMALSEP) + 1) & "];wchar[" & (STRINGLEN($STHOUSANDSEP) + 1) & "]")
		DLLSTRUCTSETDATA($TFMT, 1, $INUMDIGITS)
		DLLSTRUCTSETDATA($TFMT, 2, $ILEADINGZERO)
		DLLSTRUCTSETDATA($TFMT, 3, $IGROUPING)
		DLLSTRUCTSETDATA($TFMT, 4, DLLSTRUCTGETPTR($TFMT, 7))
		DLLSTRUCTSETDATA($TFMT, 5, DLLSTRUCTGETPTR($TFMT, 8))
		DLLSTRUCTSETDATA($TFMT, 6, $INEGATIVEORDER)
		DLLSTRUCTSETDATA($TFMT, 7, $SDECIMALSEP)
		DLLSTRUCTSETDATA($TFMT, 8, $STHOUSANDSEP)
		RETURN $TFMT
	ENDFUNC
	FUNC _WINAPI_ENUMSYSTEMGEOID()
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumGeoIDProc", "bool", "long")
		DIM $__G_VENUM[101] = [0]
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "EnumSystemGeoID", "dword", 16, "long", 0, "ptr", DLLCALLBACKGETPTR($HENUMPROC))
		IF @ERROR OR NOT $ARET[0] OR NOT $__G_VENUM[0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_ENUMSYSTEMLOCALES($IFLAG)
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumLocalesProc", "bool", "ptr")
		DIM $__G_VENUM[101] = [0]
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "EnumSystemLocalesW", "ptr", DLLCALLBACKGETPTR($HENUMPROC), "dword", $IFLAG)
		IF @ERROR OR NOT $ARET[0] OR NOT $__G_VENUM[0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_ENUMUILANGUAGES($IFLAG = 0)
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumUILanguagesProc", "bool", "ptr;long_ptr")
		LOCAL $IID = 1
		IF $__WINVER >= 1536 THEN
			IF BITAND($IFLAG, 8) THEN
				$IID = 0
			ENDIF
		ELSE
			$IFLAG = 0
		ENDIF
		DIM $__G_VENUM[101] = [0]
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "EnumUILanguagesW", "ptr", DLLCALLBACKGETPTR($HENUMPROC), "dword", $IFLAG, "long_ptr", $IID)
		IF @ERROR OR NOT $ARET[0] OR NOT $__G_VENUM[0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_GETDATEFORMAT($ILCID = 0, $TSYSTEMTIME = 0, $IFLAGS = 0, $SFORMAT = "")
		IF NOT $ILCID THEN $ILCID = 1024
		LOCAL $STYPEOFFORMAT = "wstr"
		IF NOT STRINGSTRIPWS($SFORMAT, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFFORMAT = "ptr"
			$SFORMAT = 0
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "int", "GetDateFormatW", "dword", $ILCID, "dword", $IFLAGS, "struct*", $TSYSTEMTIME, $STYPEOFFORMAT, $SFORMAT, "wstr", "", "int", 2048)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[5]
	ENDFUNC
	FUNC _WINAPI_GETDURATIONFORMAT($ILCID, $IDURATION, $SFORMAT = "")
		IF NOT $ILCID THEN $ILCID = 1024
		LOCAL $PST, $IVAL
		IF ISDLLSTRUCT($IDURATION) THEN
			$PST = DLLSTRUCTGETPTR($IDURATION)
			$IVAL = 0
		ELSE
			$PST = 0
			$IVAL = $IDURATION
		ENDIF
		LOCAL $STYPEOFFORMAT = "wstr"
		IF NOT STRINGSTRIPWS($SFORMAT, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFFORMAT = "ptr"
			$SFORMAT = 0
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "int", "GetDurationFormat", "dword", $ILCID, "dword", 0, "ptr", $PST, "uint64", $IVAL, $STYPEOFFORMAT, $SFORMAT, "wstr", "", "int", 2048)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[6]
	ENDFUNC
	FUNC _WINAPI_GETGEOINFO($IGEOID, $ITYPE, $ILANGUAGE = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "int", "GetGeoInfoW", "long", $IGEOID, "dword", $ITYPE, "wstr", "", "int", 4096, "word", $ILANGUAGE)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_GETLOCALEINFO($ILCID, $ITYPE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "int", "GetLocaleInfoW", "dword", $ILCID, "dword", $ITYPE, "wstr", "", "int", 2048)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_GETNUMBERFORMAT($ILCID, $SNUMBER, $TNUMBERFMT = 0)
		IF NOT $ILCID THEN $ILCID = 1024
		LOCAL $ARET = DLLCALL("kernel32.dll", "int", "GetNumberFormatW", "dword", $ILCID, "dword", 0, "wstr", $SNUMBER, "struct*", $TNUMBERFMT, "wstr", "", "int", 2048)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[5]
	ENDFUNC
	FUNC _WINAPI_GETSYSTEMDEFAULTLANGID()
		LOCAL $ARET = DLLCALL("kernel32.dll", "word", "GetSystemDefaultLangID")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETSYSTEMDEFAULTLCID()
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "GetSystemDefaultLCID")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETSYSTEMDEFAULTUILANGUAGE()
		LOCAL $ARET = DLLCALL("kernel32.dll", "word", "GetSystemDefaultUILanguage")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETTHREADLOCALE()
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "GetThreadLocale")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETTHREADUILANGUAGE()
		LOCAL $ARET = DLLCALL("kernel32.dll", "word", "GetThreadUILanguage")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETTIMEFORMAT($ILCID = 0, $TSYSTEMTIME = 0, $IFLAGS = 0, $SFORMAT = "")
		IF NOT $ILCID THEN $ILCID = 1024
		LOCAL $STYPEOFFORMAT = "wstr"
		IF NOT STRINGSTRIPWS($SFORMAT, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFFORMAT = "ptr"
			$SFORMAT = 0
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "int", "GetTimeFormatW", "dword", $ILCID, "dword", $IFLAGS, "struct*", $TSYSTEMTIME, $STYPEOFFORMAT, $SFORMAT, "wstr", "", "int", 2048)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARET[5]
	ENDFUNC
	FUNC _WINAPI_GETUSERDEFAULTLANGID()
		LOCAL $ARET = DLLCALL("kernel32.dll", "word", "GetUserDefaultLangID")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETUSERDEFAULTLCID()
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "GetUserDefaultLCID")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETUSERDEFAULTUILANGUAGE()
		LOCAL $ARET = DLLCALL("kernel32.dll", "word", "GetUserDefaultUILanguage")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETUSERGEOID()
		LOCAL $ARET = DLLCALL("kernel32.dll", "long", "GetUserGeoID", "uint", 16)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ISVALIDLOCALE($ILCID, $IFLAG = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "IsValidLocale", "dword", $ILCID, "dword", $IFLAG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETLOCALEINFO($ILCID, $ITYPE, $SDATA)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "SetLocaleInfoW", "dword", $ILCID, "dword", $ITYPE, "wstr", $SDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETTHREADLOCALE($ILCID)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "SetThreadLocale", "dword", $ILCID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETTHREADUILANGUAGE($ILANGUAGE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "word", "SetThreadUILanguage", "word", $ILANGUAGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN($ARET[0] = $ARET[1])
	ENDFUNC
	FUNC _WINAPI_SETUSERGEOID($IGEOID)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "SetUserGeoID", "long", $IGEOID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __ENUMGEOIDPROC($IID)
		__INC($__G_VENUM)
		$__G_VENUM[$__G_VENUM[0]] = $IID
		RETURN 1
	ENDFUNC
	FUNC __ENUMLOCALESPROC($PLOCALE)
		__INC($__G_VENUM)
		$__G_VENUM[$__G_VENUM[0]] = DEC(DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & (_WINAPI_STRLEN($PLOCALE) + 1) & "]", $PLOCALE), 1))
		RETURN 1
	ENDFUNC
	FUNC __ENUMUILANGUAGESPROC($PLANGUAGE, $IID)
		__INC($__G_VENUM)
		$__G_VENUM[$__G_VENUM[0]] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & (_WINAPI_STRLEN($PLANGUAGE) + 1) & "]", $PLANGUAGE), 1)
		IF $IID THEN
			$__G_VENUM[$__G_VENUM[0]] = DEC($__G_VENUM[$__G_VENUM[0]])
		ENDIF
		RETURN 1
	ENDFUNC
#EndRegion Internal Functions
FUNC _DATEADD($STYPE, $INUMBER, $SDATE)
	LOCAL $ASTIMEPART[4]
	LOCAL $ASDATEPART[4]
	LOCAL $IJULIANDATE
	$STYPE = STRINGLEFT($STYPE, 1)
	IF STRINGINSTR("D,M,Y,w,h,n,s", $STYPE) = 0 OR $STYPE = "" THEN
		RETURN SETERROR(1, 0, 0)
	ENDIF
	IF NOT STRINGISINT($INUMBER) THEN
		RETURN SETERROR(2, 0, 0)
	ENDIF
	IF NOT _DATEISVALID($SDATE) THEN
		RETURN SETERROR(3, 0, 0)
	ENDIF
	_DATETIMESPLIT($SDATE, $ASDATEPART, $ASTIMEPART)
	IF $STYPE = "d" OR $STYPE = "w" THEN
		IF $STYPE = "w" THEN $INUMBER = $INUMBER * 7
		$IJULIANDATE = _DATETODAYVALUE($ASDATEPART[1], $ASDATEPART[2], $ASDATEPART[3]) + $INUMBER
		_DAYVALUETODATE($IJULIANDATE, $ASDATEPART[1], $ASDATEPART[2], $ASDATEPART[3])
	ENDIF
	IF $STYPE = "m" THEN
		$ASDATEPART[2] = $ASDATEPART[2] + $INUMBER
		WHILE $ASDATEPART[2] > 12
			$ASDATEPART[2] = $ASDATEPART[2] - 12
			$ASDATEPART[1] = $ASDATEPART[1] + 1
		WEND
		WHILE $ASDATEPART[2] < 1
			$ASDATEPART[2] = $ASDATEPART[2] + 12
			$ASDATEPART[1] = $ASDATEPART[1] - 1
		WEND
	ENDIF
	IF $STYPE = "y" THEN
		$ASDATEPART[1] = $ASDATEPART[1] + $INUMBER
	ENDIF
	IF $STYPE = "h" OR $STYPE = "n" OR $STYPE = "s" THEN
		LOCAL $ITIMEVAL = _TIMETOTICKS($ASTIMEPART[1], $ASTIMEPART[2], $ASTIMEPART[3]) / 1000
		IF $STYPE = "h" THEN $ITIMEVAL = $ITIMEVAL + $INUMBER * 3600
		IF $STYPE = "n" THEN $ITIMEVAL = $ITIMEVAL + $INUMBER * 60
		IF $STYPE = "s" THEN $ITIMEVAL = $ITIMEVAL + $INUMBER
		LOCAL $IDAY2ADD = INT($ITIMEVAL / (24 * 60 * 60))
		$ITIMEVAL = $ITIMEVAL - $IDAY2ADD * 24 * 60 * 60
		IF $ITIMEVAL < 0 THEN
			$IDAY2ADD = $IDAY2ADD - 1
			$ITIMEVAL = $ITIMEVAL + 24 * 60 * 60
		ENDIF
		$IJULIANDATE = _DATETODAYVALUE($ASDATEPART[1], $ASDATEPART[2], $ASDATEPART[3]) + $IDAY2ADD
		_DAYVALUETODATE($IJULIANDATE, $ASDATEPART[1], $ASDATEPART[2], $ASDATEPART[3])
		_TICKSTOTIME($ITIMEVAL * 1000, $ASTIMEPART[1], $ASTIMEPART[2], $ASTIMEPART[3])
	ENDIF
	LOCAL $INUMDAYS = _DAYSINMONTH($ASDATEPART[1])
	IF $INUMDAYS[$ASDATEPART[2]] < $ASDATEPART[3] THEN $ASDATEPART[3] = $INUMDAYS[$ASDATEPART[2]]
	$SDATE = $ASDATEPART[1] & "/" & STRINGRIGHT("0" & $ASDATEPART[2], 2) & "/" & STRINGRIGHT("0" & $ASDATEPART[3], 2)
	IF $ASTIMEPART[0] > 0 THEN
		IF $ASTIMEPART[0] > 2 THEN
			$SDATE = $SDATE & " " & STRINGRIGHT("0" & $ASTIMEPART[1], 2) & ":" & STRINGRIGHT("0" & $ASTIMEPART[2], 2) & ":" & STRINGRIGHT("0" & $ASTIMEPART[3], 2)
		ELSE
			$SDATE = $SDATE & " " & STRINGRIGHT("0" & $ASTIMEPART[1], 2) & ":" & STRINGRIGHT("0" & $ASTIMEPART[2], 2)
		ENDIF
	ENDIF
	RETURN $SDATE
ENDFUNC
FUNC _DATEDAYOFWEEK($IDAYNUM, $IFORMAT = DEFAULT)
	LOCAL CONST $MONDAY_IS_NO1 = 128
	IF $IFORMAT = DEFAULT THEN $IFORMAT = 0
	$IDAYNUM = INT($IDAYNUM)
	IF $IDAYNUM < 1 OR $IDAYNUM > 7 THEN RETURN SETERROR(1, 0, "")
	LOCAL $TSYSTEMTIME = DLLSTRUCTCREATE($TAGSYSTEMTIME)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "Year", BITAND($IFORMAT, $MONDAY_IS_NO1) ? 2007 : 2006)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "Month", 1)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "Day", $IDAYNUM)
	RETURN _WINAPI_GETDATEFORMAT(BITAND($IFORMAT, $DMW_LOCALE_LONGNAME) ? $LOCALE_USER_DEFAULT : $LOCALE_INVARIANT, $TSYSTEMTIME, 0, BITAND($IFORMAT, $DMW_SHORTNAME) ? "ddd" : "dddd")
ENDFUNC
FUNC _DATEDAYSINMONTH($IYEAR, $IMONTHNUM)
	$IMONTHNUM = INT($IMONTHNUM)
	$IYEAR = INT($IYEAR)
	RETURN __DATEISMONTH($IMONTHNUM) AND __DATEISYEAR($IYEAR) ? _DAYSINMONTH($IYEAR)[$IMONTHNUM] : SETERROR(1, 0, 0)
ENDFUNC
FUNC _DATEDIFF($STYPE, $SSTARTDATE, $SENDDATE)
	$STYPE = STRINGLEFT($STYPE, 1)
	IF STRINGINSTR("d,m,y,w,h,n,s", $STYPE) = 0 OR $STYPE = "" THEN
		RETURN SETERROR(1, 0, 0)
	ENDIF
	IF NOT _DATEISVALID($SSTARTDATE) THEN
		RETURN SETERROR(2, 0, 0)
	ENDIF
	IF NOT _DATEISVALID($SENDDATE) THEN
		RETURN SETERROR(3, 0, 0)
	ENDIF
	LOCAL $ASSTARTDATEPART[4], $ASSTARTTIMEPART[4], $ASENDDATEPART[4], $ASENDTIMEPART[4]
	_DATETIMESPLIT($SSTARTDATE, $ASSTARTDATEPART, $ASSTARTTIMEPART)
	_DATETIMESPLIT($SENDDATE, $ASENDDATEPART, $ASENDTIMEPART)
	LOCAL $ADAYSDIFF = _DATETODAYVALUE($ASENDDATEPART[1], $ASENDDATEPART[2], $ASENDDATEPART[3]) - _DATETODAYVALUE($ASSTARTDATEPART[1], $ASSTARTDATEPART[2], $ASSTARTDATEPART[3])
	LOCAL $ITIMEDIFF, $IYEARDIFF, $ISTARTTIMEINSECS, $IENDTIMEINSECS
	IF $ASSTARTTIMEPART[0] > 1 AND $ASENDTIMEPART[0] > 1 THEN
		$ISTARTTIMEINSECS = $ASSTARTTIMEPART[1] * 3600 + $ASSTARTTIMEPART[2] * 60 + $ASSTARTTIMEPART[3]
		$IENDTIMEINSECS = $ASENDTIMEPART[1] * 3600 + $ASENDTIMEPART[2] * 60 + $ASENDTIMEPART[3]
		$ITIMEDIFF = $IENDTIMEINSECS - $ISTARTTIMEINSECS
		IF $ITIMEDIFF < 0 THEN
			$ADAYSDIFF = $ADAYSDIFF - 1
			$ITIMEDIFF = $ITIMEDIFF + 24 * 60 * 60
		ENDIF
	ELSE
		$ITIMEDIFF = 0
	ENDIF
	SELECT
		CASE $STYPE = "d"
			RETURN $ADAYSDIFF
		CASE $STYPE = "m"
			$IYEARDIFF = $ASENDDATEPART[1] - $ASSTARTDATEPART[1]
			LOCAL $IMONTHDIFF = $ASENDDATEPART[2] - $ASSTARTDATEPART[2] + $IYEARDIFF * 12
			IF $ASENDDATEPART[3] < $ASSTARTDATEPART[3] THEN $IMONTHDIFF = $IMONTHDIFF - 1
			$ISTARTTIMEINSECS = $ASSTARTTIMEPART[1] * 3600 + $ASSTARTTIMEPART[2] * 60 + $ASSTARTTIMEPART[3]
			$IENDTIMEINSECS = $ASENDTIMEPART[1] * 3600 + $ASENDTIMEPART[2] * 60 + $ASENDTIMEPART[3]
			$ITIMEDIFF = $IENDTIMEINSECS - $ISTARTTIMEINSECS
			IF $ASENDDATEPART[3] = $ASSTARTDATEPART[3] AND $ITIMEDIFF < 0 THEN $IMONTHDIFF = $IMONTHDIFF - 1
			RETURN $IMONTHDIFF
		CASE $STYPE = "y"
			$IYEARDIFF = $ASENDDATEPART[1] - $ASSTARTDATEPART[1]
			IF $ASENDDATEPART[2] < $ASSTARTDATEPART[2] THEN $IYEARDIFF = $IYEARDIFF - 1
			IF $ASENDDATEPART[2] = $ASSTARTDATEPART[2] AND $ASENDDATEPART[3] < $ASSTARTDATEPART[3] THEN $IYEARDIFF = $IYEARDIFF - 1
			$ISTARTTIMEINSECS = $ASSTARTTIMEPART[1] * 3600 + $ASSTARTTIMEPART[2] * 60 + $ASSTARTTIMEPART[3]
			$IENDTIMEINSECS = $ASENDTIMEPART[1] * 3600 + $ASENDTIMEPART[2] * 60 + $ASENDTIMEPART[3]
			$ITIMEDIFF = $IENDTIMEINSECS - $ISTARTTIMEINSECS
			IF $ASENDDATEPART[2] = $ASSTARTDATEPART[2] AND $ASENDDATEPART[3] = $ASSTARTDATEPART[3] AND $ITIMEDIFF < 0 THEN $IYEARDIFF = $IYEARDIFF - 1
			RETURN $IYEARDIFF
		CASE $STYPE = "w"
			RETURN INT($ADAYSDIFF / 7)
		CASE $STYPE = "h"
			RETURN $ADAYSDIFF * 24 + INT($ITIMEDIFF / 3600)
		CASE $STYPE = "n"
			RETURN $ADAYSDIFF * 24 * 60 + INT($ITIMEDIFF / 60)
		CASE $STYPE = "s"
			RETURN $ADAYSDIFF * 24 * 60 * 60 + $ITIMEDIFF
	ENDSELECT
ENDFUNC
FUNC _DATEISLEAPYEAR($IYEAR)
	IF STRINGISINT($IYEAR) THEN
		SELECT
			CASE MOD($IYEAR, 4) = 0 AND MOD($IYEAR, 100) <> 0
				RETURN 1
			CASE MOD($IYEAR, 400) = 0
				RETURN 1
			CASE ELSE
				RETURN 0
		ENDSELECT
	ENDIF
	RETURN SETERROR(1, 0, 0)
ENDFUNC
FUNC __DATEISMONTH($INUMBER)
	$INUMBER = INT($INUMBER)
	RETURN $INUMBER >= 1 AND $INUMBER <= 12
ENDFUNC
FUNC _DATEISVALID($SDATE)
	LOCAL $ASDATEPART[4], $ASTIMEPART[4]
	_DATETIMESPLIT($SDATE, $ASDATEPART, $ASTIMEPART)
	IF NOT STRINGISINT($ASDATEPART[1]) THEN RETURN 0
	IF NOT STRINGISINT($ASDATEPART[2]) THEN RETURN 0
	IF NOT STRINGISINT($ASDATEPART[3]) THEN RETURN 0
	$ASDATEPART[1] = INT($ASDATEPART[1])
	$ASDATEPART[2] = INT($ASDATEPART[2])
	$ASDATEPART[3] = INT($ASDATEPART[3])
	LOCAL $INUMDAYS = _DAYSINMONTH($ASDATEPART[1])
	IF $ASDATEPART[1] < 1000 OR $ASDATEPART[1] > 2999 THEN RETURN 0
	IF $ASDATEPART[2] < 1 OR $ASDATEPART[2] > 12 THEN RETURN 0
	IF $ASDATEPART[3] < 1 OR $ASDATEPART[3] > $INUMDAYS[$ASDATEPART[2]] THEN RETURN 0
	IF $ASTIMEPART[0] < 1 THEN RETURN 1
	IF $ASTIMEPART[0] < 2 THEN RETURN 0
	IF $ASTIMEPART[0] = 2 THEN $ASTIMEPART[3] = "00"
	IF NOT STRINGISINT($ASTIMEPART[1]) THEN RETURN 0
	IF NOT STRINGISINT($ASTIMEPART[2]) THEN RETURN 0
	IF NOT STRINGISINT($ASTIMEPART[3]) THEN RETURN 0
	$ASTIMEPART[1] = INT($ASTIMEPART[1])
	$ASTIMEPART[2] = INT($ASTIMEPART[2])
	$ASTIMEPART[3] = INT($ASTIMEPART[3])
	IF $ASTIMEPART[1] < 0 OR $ASTIMEPART[1] > 23 THEN RETURN 0
	IF $ASTIMEPART[2] < 0 OR $ASTIMEPART[2] > 59 THEN RETURN 0
	IF $ASTIMEPART[3] < 0 OR $ASTIMEPART[3] > 59 THEN RETURN 0
	RETURN 1
ENDFUNC
FUNC __DATEISYEAR($INUMBER)
	RETURN STRINGLEN($INUMBER) = 4
ENDFUNC
FUNC _DATELASTWEEKDAYNUM($IWEEKDAYNUM)
	SELECT
		CASE NOT STRINGISINT($IWEEKDAYNUM)
			RETURN SETERROR(1, 0, 0)
		CASE $IWEEKDAYNUM < 1 OR $IWEEKDAYNUM > 7
			RETURN SETERROR(2, 0, 0)
		CASE ELSE
			LOCAL $ILASTWEEKDAYNUM
			IF $IWEEKDAYNUM = 1 THEN
				$ILASTWEEKDAYNUM = 7
			ELSE
				$ILASTWEEKDAYNUM = $IWEEKDAYNUM - 1
			ENDIF
			RETURN $ILASTWEEKDAYNUM
	ENDSELECT
ENDFUNC
FUNC _DATELASTMONTHNUM($IMONTHNUM)
	SELECT
		CASE NOT STRINGISINT($IMONTHNUM)
			RETURN SETERROR(1, 0, 0)
		CASE NOT __DATEISMONTH($IMONTHNUM)
			RETURN SETERROR(2, 0, 0)
		CASE ELSE
			LOCAL $ILASTMONTHNUM
			IF $IMONTHNUM = 1 THEN
				$ILASTMONTHNUM = 12
			ELSE
				$ILASTMONTHNUM = $IMONTHNUM - 1
			ENDIF
			$ILASTMONTHNUM = STRINGFORMAT("%02d", $ILASTMONTHNUM)
			RETURN $ILASTMONTHNUM
	ENDSELECT
ENDFUNC
FUNC _DATELASTMONTHYEAR($IMONTHNUM, $IYEAR)
	SELECT
		CASE NOT STRINGISINT($IMONTHNUM) OR NOT STRINGISINT($IYEAR)
			RETURN SETERROR(1, 0, 0)
		CASE NOT __DATEISMONTH($IMONTHNUM)
			RETURN SETERROR(2, 0, 0)
		CASE ELSE
			LOCAL $ILASTYEAR
			IF $IMONTHNUM = 1 THEN
				$ILASTYEAR = $IYEAR - 1
			ELSE
				$ILASTYEAR = $IYEAR
			ENDIF
			$ILASTYEAR = STRINGFORMAT("%04d", $ILASTYEAR)
			RETURN $ILASTYEAR
	ENDSELECT
ENDFUNC
FUNC _DATENEXTWEEKDAYNUM($IWEEKDAYNUM)
	SELECT
		CASE NOT STRINGISINT($IWEEKDAYNUM)
			RETURN SETERROR(1, 0, 0)
		CASE $IWEEKDAYNUM < 1 OR $IWEEKDAYNUM > 7
			RETURN SETERROR(2, 0, 0)
		CASE ELSE
			LOCAL $INEXTWEEKDAYNUM
			IF $IWEEKDAYNUM = 7 THEN
				$INEXTWEEKDAYNUM = 1
			ELSE
				$INEXTWEEKDAYNUM = $IWEEKDAYNUM + 1
			ENDIF
			RETURN $INEXTWEEKDAYNUM
	ENDSELECT
ENDFUNC
FUNC _DATENEXTMONTHNUM($IMONTHNUM)
	SELECT
		CASE NOT STRINGISINT($IMONTHNUM)
			RETURN SETERROR(1, 0, 0)
		CASE NOT __DATEISMONTH($IMONTHNUM)
			RETURN SETERROR(2, 0, 0)
		CASE ELSE
			LOCAL $INEXTMONTHNUM
			IF $IMONTHNUM = 12 THEN
				$INEXTMONTHNUM = 1
			ELSE
				$INEXTMONTHNUM = $IMONTHNUM + 1
			ENDIF
			$INEXTMONTHNUM = STRINGFORMAT("%02d", $INEXTMONTHNUM)
			RETURN $INEXTMONTHNUM
	ENDSELECT
ENDFUNC
FUNC _DATENEXTMONTHYEAR($IMONTHNUM, $IYEAR)
	SELECT
		CASE NOT STRINGISINT($IMONTHNUM) OR NOT STRINGISINT($IYEAR)
			RETURN SETERROR(1, 0, 0)
		CASE NOT __DATEISMONTH($IMONTHNUM)
			RETURN SETERROR(2, 0, 0)
		CASE ELSE
			LOCAL $INEXTYEAR
			IF $IMONTHNUM = 12 THEN
				$INEXTYEAR = $IYEAR + 1
			ELSE
				$INEXTYEAR = $IYEAR
			ENDIF
			$INEXTYEAR = STRINGFORMAT("%04d", $INEXTYEAR)
			RETURN $INEXTYEAR
	ENDSELECT
ENDFUNC
FUNC _DATETIMEFORMAT($SDATE, $STYPE)
	LOCAL $ASDATEPART[4], $ASTIMEPART[4]
	LOCAL $STEMPDATE = "", $STEMPTIME = ""
	LOCAL $SAM, $SPM, $STEMPSTRING = ""
	IF NOT _DATEISVALID($SDATE) THEN
		RETURN SETERROR(1, 0, "")
	ENDIF
	IF $STYPE < 0 OR $STYPE > 5 OR NOT ISINT($STYPE) THEN
		RETURN SETERROR(2, 0, "")
	ENDIF
	_DATETIMESPLIT($SDATE, $ASDATEPART, $ASTIMEPART)
	SWITCH $STYPE
		CASE 0
			$STEMPSTRING = _WINAPI_GETLOCALEINFO($LOCALE_USER_DEFAULT, $LOCALE_SSHORTDATE)
			IF NOT @ERROR AND NOT($STEMPSTRING = "") THEN
				$STEMPDATE = $STEMPSTRING
			ELSE
				$STEMPDATE = "M/d/yyyy"
			ENDIF
			IF $ASTIMEPART[0] > 1 THEN
				$STEMPSTRING = _WINAPI_GETLOCALEINFO($LOCALE_USER_DEFAULT, $LOCALE_STIMEFORMAT)
				IF NOT @ERROR AND NOT($STEMPSTRING = "") THEN
					$STEMPTIME = $STEMPSTRING
				ELSE
					$STEMPTIME = "h:mm:ss tt"
				ENDIF
			ENDIF
		CASE 1
			$STEMPSTRING = _WINAPI_GETLOCALEINFO($LOCALE_USER_DEFAULT, $LOCALE_SLONGDATE)
			IF NOT @ERROR AND NOT($STEMPSTRING = "") THEN
				$STEMPDATE = $STEMPSTRING
			ELSE
				$STEMPDATE = "dddd, MMMM dd, yyyy"
			ENDIF
		CASE 2
			$STEMPSTRING = _WINAPI_GETLOCALEINFO($LOCALE_USER_DEFAULT, $LOCALE_SSHORTDATE)
			IF NOT @ERROR AND NOT($STEMPSTRING = "") THEN
				$STEMPDATE = $STEMPSTRING
			ELSE
				$STEMPDATE = "M/d/yyyy"
			ENDIF
		CASE 3
			IF $ASTIMEPART[0] > 1 THEN
				$STEMPSTRING = _WINAPI_GETLOCALEINFO($LOCALE_USER_DEFAULT, $LOCALE_STIMEFORMAT)
				IF NOT @ERROR AND NOT($STEMPSTRING = "") THEN
					$STEMPTIME = $STEMPSTRING
				ELSE
					$STEMPTIME = "h:mm:ss tt"
				ENDIF
			ENDIF
		CASE 4
			IF $ASTIMEPART[0] > 1 THEN
				$STEMPTIME = "hh:mm"
			ENDIF
		CASE 5
			IF $ASTIMEPART[0] > 1 THEN
				$STEMPTIME = "hh:mm:ss"
			ENDIF
	ENDSWITCH
	IF $STEMPDATE <> "" THEN
		$STEMPSTRING = _WINAPI_GETLOCALEINFO($LOCALE_USER_DEFAULT, $LOCALE_SDATE)
		IF NOT @ERROR AND NOT($STEMPSTRING = "") THEN
			$STEMPDATE = STRINGREPLACE($STEMPDATE, "/", $STEMPSTRING)
		ENDIF
		LOCAL $IWDAY = _DATETODAYOFWEEK($ASDATEPART[1], $ASDATEPART[2], $ASDATEPART[3])
		$ASDATEPART[3] = STRINGRIGHT("0" & $ASDATEPART[3], 2)
		$ASDATEPART[2] = STRINGRIGHT("0" & $ASDATEPART[2], 2)
		$STEMPDATE = STRINGREPLACE($STEMPDATE, "d", "@")
		$STEMPDATE = STRINGREPLACE($STEMPDATE, "m", "#")
		$STEMPDATE = STRINGREPLACE($STEMPDATE, "y", "&")
		$STEMPDATE = STRINGREPLACE($STEMPDATE, "@@@@", _DATEDAYOFWEEK($IWDAY, 0))
		$STEMPDATE = STRINGREPLACE($STEMPDATE, "@@@", _DATEDAYOFWEEK($IWDAY, 1))
		$STEMPDATE = STRINGREPLACE($STEMPDATE, "@@", $ASDATEPART[3])
		$STEMPDATE = STRINGREPLACE($STEMPDATE, "@", STRINGREPLACE(STRINGLEFT($ASDATEPART[3], 1), "0", "") & STRINGRIGHT($ASDATEPART[3], 1))
		$STEMPDATE = STRINGREPLACE($STEMPDATE, "####", _DATETOMONTH($ASDATEPART[2], 0))
		$STEMPDATE = STRINGREPLACE($STEMPDATE, "###", _DATETOMONTH($ASDATEPART[2], 1))
		$STEMPDATE = STRINGREPLACE($STEMPDATE, "##", $ASDATEPART[2])
		$STEMPDATE = STRINGREPLACE($STEMPDATE, "#", STRINGREPLACE(STRINGLEFT($ASDATEPART[2], 1), "0", "") & STRINGRIGHT($ASDATEPART[2], 1))
		$STEMPDATE = STRINGREPLACE($STEMPDATE, "&&&&", $ASDATEPART[1])
		$STEMPDATE = STRINGREPLACE($STEMPDATE, "&&", STRINGRIGHT($ASDATEPART[1], 2))
	ENDIF
	IF $STEMPTIME <> "" THEN
		$STEMPSTRING = _WINAPI_GETLOCALEINFO($LOCALE_USER_DEFAULT, $LOCALE_S1159)
		IF NOT @ERROR AND NOT($STEMPSTRING = "") THEN
			$SAM = $STEMPSTRING
		ELSE
			$SAM = "AM"
		ENDIF
		$STEMPSTRING = _WINAPI_GETLOCALEINFO($LOCALE_USER_DEFAULT, $LOCALE_S2359)
		IF NOT @ERROR AND NOT($STEMPSTRING = "") THEN
			$SPM = $STEMPSTRING
		ELSE
			$SPM = "PM"
		ENDIF
		$STEMPSTRING = _WINAPI_GETLOCALEINFO($LOCALE_USER_DEFAULT, $LOCALE_STIME)
		IF NOT @ERROR AND NOT($STEMPSTRING = "") THEN
			$STEMPTIME = STRINGREPLACE($STEMPTIME, ":", $STEMPSTRING)
		ENDIF
		IF STRINGINSTR($STEMPTIME, "tt") THEN
			IF $ASTIMEPART[1] < 12 THEN
				$STEMPTIME = STRINGREPLACE($STEMPTIME, "tt", $SAM)
				IF $ASTIMEPART[1] = 0 THEN $ASTIMEPART[1] = 12
			ELSE
				$STEMPTIME = STRINGREPLACE($STEMPTIME, "tt", $SPM)
				IF $ASTIMEPART[1] > 12 THEN $ASTIMEPART[1] = $ASTIMEPART[1] - 12
			ENDIF
		ENDIF
		$ASTIMEPART[1] = STRINGRIGHT("0" & $ASTIMEPART[1], 2)
		$ASTIMEPART[2] = STRINGRIGHT("0" & $ASTIMEPART[2], 2)
		$ASTIMEPART[3] = STRINGRIGHT("0" & $ASTIMEPART[3], 2)
		$STEMPTIME = STRINGREPLACE($STEMPTIME, "hh", STRINGFORMAT("%02d", $ASTIMEPART[1]))
		$STEMPTIME = STRINGREPLACE($STEMPTIME, "h", STRINGREPLACE(STRINGLEFT($ASTIMEPART[1], 1), "0", "") & STRINGRIGHT($ASTIMEPART[1], 1))
		$STEMPTIME = STRINGREPLACE($STEMPTIME, "mm", STRINGFORMAT("%02d", $ASTIMEPART[2]))
		$STEMPTIME = STRINGREPLACE($STEMPTIME, "ss", STRINGFORMAT("%02d", $ASTIMEPART[3]))
		$STEMPDATE = STRINGSTRIPWS($STEMPDATE & " " & $STEMPTIME, $STR_STRIPLEADING + $STR_STRIPTRAILING)
	ENDIF
	RETURN $STEMPDATE
ENDFUNC
FUNC _DATETIMESPLIT($SDATE, BYREF $ADATEPART, BYREF $ITIMEPART)
	LOCAL $SDATETIME = STRINGSPLIT($SDATE, " T")
	IF $SDATETIME[0] > 0 THEN $ADATEPART = STRINGSPLIT($SDATETIME[1], "/-.")
	IF $SDATETIME[0] > 1 THEN
		$ITIMEPART = STRINGSPLIT($SDATETIME[2], ":")
		IF UBOUND($ITIMEPART) < 4 THEN REDIM $ITIMEPART[4]
	ELSE
		DIM $ITIMEPART[4]
	ENDIF
	IF UBOUND($ADATEPART) < 4 THEN REDIM $ADATEPART[4]
	FOR $X = 1 TO 3
		IF STRINGISINT($ADATEPART[$X]) THEN
			$ADATEPART[$X] = INT($ADATEPART[$X])
		ELSE
			$ADATEPART[$X] = -1
		ENDIF
		IF STRINGISINT($ITIMEPART[$X]) THEN
			$ITIMEPART[$X] = INT($ITIMEPART[$X])
		ELSE
			$ITIMEPART[$X] = 0
		ENDIF
	NEXT
	RETURN 1
ENDFUNC
FUNC _DATETODAYOFWEEK($IYEAR, $IMONTH, $IDAY)
	IF NOT _DATEISVALID($IYEAR & "/" & $IMONTH & "/" & $IDAY) THEN
		RETURN SETERROR(1, 0, "")
	ENDIF
	LOCAL $I_FACTORA = INT((14 - $IMONTH) / 12)
	LOCAL $I_FACTORY = $IYEAR - $I_FACTORA
	LOCAL $I_FACTORM = $IMONTH + (12 * $I_FACTORA) - 2
	LOCAL $I_FACTORD = MOD($IDAY + $I_FACTORY + INT($I_FACTORY / 4) - INT($I_FACTORY / 100) + INT($I_FACTORY / 400) + INT((31 * $I_FACTORM) / 12), 7)
	RETURN $I_FACTORD + 1
ENDFUNC
FUNC _DATETODAYOFWEEKISO($IYEAR, $IMONTH, $IDAY)
	LOCAL $IDOW = _DATETODAYOFWEEK($IYEAR, $IMONTH, $IDAY)
	IF @ERROR THEN
		RETURN SETERROR(1, 0, "")
	ENDIF
	IF $IDOW >= 2 THEN RETURN $IDOW - 1
	RETURN 7
ENDFUNC
FUNC _DATETODAYVALUE($IYEAR, $IMONTH, $IDAY)
	IF NOT _DATEISVALID(STRINGFORMAT("%04d/%02d/%02d", $IYEAR, $IMONTH, $IDAY)) THEN
		RETURN SETERROR(1, 0, "")
	ENDIF
	IF $IMONTH < 3 THEN
		$IMONTH = $IMONTH + 12
		$IYEAR = $IYEAR - 1
	ENDIF
	LOCAL $I_FACTORA = INT($IYEAR / 100)
	LOCAL $I_FACTORB = INT($I_FACTORA / 4)
	LOCAL $I_FACTORC = 2 - $I_FACTORA + $I_FACTORB
	LOCAL $I_FACTORE = INT(1461 * ($IYEAR + 4716) / 4)
	LOCAL $I_FACTORF = INT(153 * ($IMONTH + 1) / 5)
	LOCAL $IJULIANDATE = $I_FACTORC + $IDAY + $I_FACTORE + $I_FACTORF - 1524.5
	RETURN $IJULIANDATE
ENDFUNC
FUNC _DATETOMONTH($IMONNUM, $IFORMAT = DEFAULT)
	IF $IFORMAT = DEFAULT THEN $IFORMAT = 0
	$IMONNUM = INT($IMONNUM)
	IF NOT __DATEISMONTH($IMONNUM) THEN RETURN SETERROR(1, 0, "")
	LOCAL $TSYSTEMTIME = DLLSTRUCTCREATE($TAGSYSTEMTIME)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "Year", @YEAR)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "Month", $IMONNUM)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "Day", 1)
	RETURN _WINAPI_GETDATEFORMAT(BITAND($IFORMAT, $DMW_LOCALE_LONGNAME) ? $LOCALE_USER_DEFAULT : $LOCALE_INVARIANT, $TSYSTEMTIME, 0, BITAND($IFORMAT, $DMW_SHORTNAME) ? "MMM" : "MMMM")
ENDFUNC
FUNC _DAYVALUETODATE($IJULIANDATE, BYREF $IYEAR, BYREF $IMONTH, BYREF $IDAY)
	IF $IJULIANDATE < 0 OR NOT ISNUMBER($IJULIANDATE) THEN
		RETURN SETERROR(1, 0, 0)
	ENDIF
	LOCAL $I_FACTORZ = INT($IJULIANDATE + 0.5)
	LOCAL $I_FACTORW = INT(($I_FACTORZ - 1867216.25) / 36524.25)
	LOCAL $I_FACTORX = INT($I_FACTORW / 4)
	LOCAL $I_FACTORA = $I_FACTORZ + 1 + $I_FACTORW - $I_FACTORX
	LOCAL $I_FACTORB = $I_FACTORA + 1524
	LOCAL $I_FACTORC = INT(($I_FACTORB - 122.1) / 365.25)
	LOCAL $I_FACTORD = INT(365.25 * $I_FACTORC)
	LOCAL $I_FACTORE = INT(($I_FACTORB - $I_FACTORD) / 30.6001)
	LOCAL $I_FACTORF = INT(30.6001 * $I_FACTORE)
	$IDAY = $I_FACTORB - $I_FACTORD - $I_FACTORF
	IF $I_FACTORE - 1 < 13 THEN
		$IMONTH = $I_FACTORE - 1
	ELSE
		$IMONTH = $I_FACTORE - 13
	ENDIF
	IF $IMONTH < 3 THEN
		$IYEAR = $I_FACTORC - 4715
	ELSE
		$IYEAR = $I_FACTORC - 4716
	ENDIF
	$IYEAR = STRINGFORMAT("%04d", $IYEAR)
	$IMONTH = STRINGFORMAT("%02d", $IMONTH)
	$IDAY = STRINGFORMAT("%02d", $IDAY)
	RETURN $IYEAR & "/" & $IMONTH & "/" & $IDAY
ENDFUNC
FUNC _DATE_JULIANDAYNO($IYEAR, $IMONTH, $IDAY)
	LOCAL $SFULLDATE = STRINGFORMAT("%04d/%02d/%02d", $IYEAR, $IMONTH, $IDAY)
	IF NOT _DATEISVALID($SFULLDATE) THEN
		RETURN SETERROR(1, 0, "")
	ENDIF
	LOCAL $IJDAY = 0
	LOCAL $AIDAYSINMONTH = _DAYSINMONTH($IYEAR)
	FOR $ICNTR = 1 TO $IMONTH - 1
		$IJDAY = $IJDAY + $AIDAYSINMONTH[$ICNTR]
	NEXT
	$IJDAY = ($IYEAR * 1000) + ($IJDAY + $IDAY)
	RETURN $IJDAY
ENDFUNC
FUNC _JULIANTODATE($IJDAY, $SSEP = "/")
	LOCAL $IYEAR = INT($IJDAY / 1000)
	LOCAL $IDAYS = MOD($IJDAY, 1000)
	LOCAL $IMAXDAYS = 365
	IF _DATEISLEAPYEAR($IYEAR) THEN $IMAXDAYS = 366
	IF $IDAYS > $IMAXDAYS THEN
		RETURN SETERROR(1, 0, "")
	ENDIF
	LOCAL $AIDAYSINMONTH = _DAYSINMONTH($IYEAR)
	LOCAL $IMONTH = 1
	WHILE $IDAYS > $AIDAYSINMONTH[$IMONTH]
		$IDAYS = $IDAYS - $AIDAYSINMONTH[$IMONTH]
		$IMONTH = $IMONTH + 1
	WEND
	RETURN STRINGFORMAT("%04d%s%02d%s%02d", $IYEAR, $SSEP, $IMONTH, $SSEP, $IDAYS)
ENDFUNC
FUNC _NOW()
	RETURN _DATETIMEFORMAT(@YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC, 0)
ENDFUNC
FUNC _NOWCALC()
	RETURN @YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC
ENDFUNC
FUNC _NOWCALCDATE()
	RETURN @YEAR & "/" & @MON & "/" & @MDAY
ENDFUNC
FUNC _NOWDATE()
	RETURN _DATETIMEFORMAT(@YEAR & "/" & @MON & "/" & @MDAY, 0)
ENDFUNC
FUNC _NOWTIME($STYPE = 3)
	IF $STYPE < 3 OR $STYPE > 5 THEN $STYPE = 3
	RETURN _DATETIMEFORMAT(@YEAR & "/" & @MON & "/" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC, $STYPE)
ENDFUNC
FUNC _SETDATE($IDAY, $IMONTH = 0, $IYEAR = 0)
	IF $IYEAR = 0 THEN $IYEAR = @YEAR
	IF $IMONTH = 0 THEN $IMONTH = @MON
	IF NOT _DATEISVALID($IYEAR & "/" & $IMONTH & "/" & $IDAY) THEN RETURN 1
	LOCAL $TSYSTEMTIME = DLLSTRUCTCREATE($TAGSYSTEMTIME)
	DLLCALL("kernel32.dll", "none", "GetLocalTime", "struct*", $TSYSTEMTIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "Day", $IDAY)
	IF $IMONTH > 0 THEN DLLSTRUCTSETDATA($TSYSTEMTIME, "Month", $IMONTH)
	IF $IYEAR > 0 THEN DLLSTRUCTSETDATA($TSYSTEMTIME, "Year", $IYEAR)
	LOCAL $IRETURN = _DATE_TIME_SETLOCALTIME($TSYSTEMTIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN INT($IRETURN)
ENDFUNC
FUNC _SETTIME($IHOUR, $IMINUTE, $ISECOND = 0, $IMSECONDS = 0)
	IF $IHOUR < 0 OR $IHOUR > 23 THEN RETURN 1
	IF $IMINUTE < 0 OR $IMINUTE > 59 THEN RETURN 1
	IF $ISECOND < 0 OR $ISECOND > 59 THEN RETURN 1
	IF $IMSECONDS < 0 OR $IMSECONDS > 999 THEN RETURN 1
	LOCAL $TSYSTEMTIME = DLLSTRUCTCREATE($TAGSYSTEMTIME)
	DLLCALL("kernel32.dll", "none", "GetLocalTime", "struct*", $TSYSTEMTIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "Hour", $IHOUR)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "Minute", $IMINUTE)
	IF $ISECOND > 0 THEN DLLSTRUCTSETDATA($TSYSTEMTIME, "Second", $ISECOND)
	IF $IMSECONDS > 0 THEN DLLSTRUCTSETDATA($TSYSTEMTIME, "MSeconds", $IMSECONDS)
	LOCAL $IRETURN = _DATE_TIME_SETLOCALTIME($TSYSTEMTIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN INT($IRETURN)
ENDFUNC
FUNC _TICKSTOTIME($ITICKS, BYREF $IHOURS, BYREF $IMINS, BYREF $ISECS)
	IF NUMBER($ITICKS) > 0 THEN
		$ITICKS = INT($ITICKS / 1000)
		$IHOURS = INT($ITICKS / 3600)
		$ITICKS = MOD($ITICKS, 3600)
		$IMINS = INT($ITICKS / 60)
		$ISECS = MOD($ITICKS, 60)
		RETURN 1
	ELSEIF NUMBER($ITICKS) = 0 THEN
		$IHOURS = 0
		$ITICKS = 0
		$IMINS = 0
		$ISECS = 0
		RETURN 1
	ELSE
		RETURN SETERROR(1, 0, 0)
	ENDIF
ENDFUNC
FUNC _TIMETOTICKS($IHOURS = @HOUR, $IMINS = @MIN, $ISECS = @SEC)
	IF STRINGISINT($IHOURS) AND STRINGISINT($IMINS) AND STRINGISINT($ISECS) THEN
		LOCAL $ITICKS = 1000 * ((3600 * $IHOURS) + (60 * $IMINS) + $ISECS)
		RETURN $ITICKS
	ELSE
		RETURN SETERROR(1, 0, 0)
	ENDIF
ENDFUNC
FUNC _WEEKNUMBERISO($IYEAR = @YEAR, $IMONTH = @MON, $IDAY = @MDAY)
	IF $IDAY > 31 OR $IDAY < 1 THEN
		RETURN SETERROR(1, 0, -1)
	ELSEIF NOT __DATEISMONTH($IMONTH) THEN
		RETURN SETERROR(2, 0, -1)
	ELSEIF $IYEAR < 1 OR $IYEAR > 2999 THEN
		RETURN SETERROR(3, 0, -1)
	ENDIF
	LOCAL $IDOW = _DATETODAYOFWEEKISO($IYEAR, $IMONTH, $IDAY) - 1
	LOCAL $IDOW0101 = _DATETODAYOFWEEKISO($IYEAR, 1, 1) - 1
	IF($IMONTH = 1 AND 3 < $IDOW0101 AND $IDOW0101 < 7 - ($IDAY - 1)) THEN
		$IDOW = $IDOW0101 - 1
		$IDOW0101 = _DATETODAYOFWEEKISO($IYEAR - 1, 1, 1) - 1
		$IMONTH = 12
		$IDAY = 31
		$IYEAR = $IYEAR - 1
	ELSEIF($IMONTH = 12 AND 30 - ($IDAY - 1) < _DATETODAYOFWEEKISO($IYEAR + 1, 1, 1) - 1 AND _DATETODAYOFWEEKISO($IYEAR + 1, 1, 1) - 1 < 4) THEN
		RETURN 1
	ENDIF
	RETURN INT((_DATETODAYOFWEEKISO($IYEAR, 1, 1) - 1 < 4) + 4 * ($IMONTH - 1) + (2 * ($IMONTH - 1) + ($IDAY - 1) + $IDOW0101 - $IDOW + 6) * 36 / 256)
ENDFUNC
FUNC _WEEKNUMBER($IYEAR = @YEAR, $IMONTH = @MON, $IDAY = @MDAY, $IWEEKSTART = 1)
	IF $IDAY > 31 OR $IDAY < 1 THEN
		RETURN SETERROR(1, 0, -1)
	ELSEIF NOT __DATEISMONTH($IMONTH) THEN
		RETURN SETERROR(3, 0, -1)
	ELSEIF $IYEAR < 1 OR $IYEAR > 2999 THEN
		RETURN SETERROR(4, 0, -1)
	ELSEIF $IWEEKSTART < 1 OR $IWEEKSTART > 2 THEN
		RETURN SETERROR(2, 0, -1)
	ENDIF
	LOCAL $ISTARTWEEK1, $IENDWEEK1
	LOCAL $IDOW0101 = _DATETODAYOFWEEKISO($IYEAR, 1, 1)
	LOCAL $IDATE = $IYEAR & "/" & $IMONTH & "/" & $IDAY
	IF $IWEEKSTART = 1 THEN
		IF $IDOW0101 = 6 THEN
			$ISTARTWEEK1 = 0
		ELSE
			$ISTARTWEEK1 = -1 * $IDOW0101 - 1
		ENDIF
		$IENDWEEK1 = $ISTARTWEEK1 + 6
	ELSE
		$ISTARTWEEK1 = $IDOW0101 * -1
		$IENDWEEK1 = $ISTARTWEEK1 + 6
	ENDIF
	LOCAL $ISTARTWEEK1NY
	LOCAL $IENDWEEK1DATE = _DATEADD("d", $IENDWEEK1, $IYEAR & "/01/01")
	LOCAL $IDOW0101NY = _DATETODAYOFWEEKISO($IYEAR + 1, 1, 1)
	IF $IWEEKSTART = 1 THEN
		IF $IDOW0101NY = 6 THEN
			$ISTARTWEEK1NY = 0
		ELSE
			$ISTARTWEEK1NY = -1 * $IDOW0101NY - 1
		ENDIF
	ELSE
		$ISTARTWEEK1NY = $IDOW0101NY * -1
	ENDIF
	LOCAL $ISTARTWEEK1DATENY = _DATEADD("d", $ISTARTWEEK1NY, $IYEAR + 1 & "/01/01")
	LOCAL $ICURRDATEDIFF = _DATEDIFF("d", $IENDWEEK1DATE, $IDATE) - 1
	LOCAL $ICURRDATEDIFFNY = _DATEDIFF("d", $ISTARTWEEK1DATENY, $IDATE)
	IF $ICURRDATEDIFF >= 0 AND $ICURRDATEDIFFNY < 0 THEN RETURN 2 + INT($ICURRDATEDIFF / 7)
	IF $ICURRDATEDIFF < 0 OR $ICURRDATEDIFFNY >= 0 THEN RETURN 1
ENDFUNC
FUNC _DAYSINMONTH($IYEAR)
	LOCAL $ADAYS = [12, 31, (_DATEISLEAPYEAR($IYEAR) ? 29 : 28), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
	RETURN $ADAYS
ENDFUNC
FUNC __DATE_TIME_CLONESYSTEMTIME($PSYSTEMTIME)
	LOCAL $TSYSTEMTIME1 = DLLSTRUCTCREATE($TAGSYSTEMTIME, $PSYSTEMTIME)
	LOCAL $TSYSTEMTIME2 = DLLSTRUCTCREATE($TAGSYSTEMTIME)
	DLLSTRUCTSETDATA($TSYSTEMTIME2, "Month", DLLSTRUCTGETDATA($TSYSTEMTIME1, "Month"))
	DLLSTRUCTSETDATA($TSYSTEMTIME2, "Day", DLLSTRUCTGETDATA($TSYSTEMTIME1, "Day"))
	DLLSTRUCTSETDATA($TSYSTEMTIME2, "Year", DLLSTRUCTGETDATA($TSYSTEMTIME1, "Year"))
	DLLSTRUCTSETDATA($TSYSTEMTIME2, "Hour", DLLSTRUCTGETDATA($TSYSTEMTIME1, "Hour"))
	DLLSTRUCTSETDATA($TSYSTEMTIME2, "Minute", DLLSTRUCTGETDATA($TSYSTEMTIME1, "Minute"))
	DLLSTRUCTSETDATA($TSYSTEMTIME2, "Second", DLLSTRUCTGETDATA($TSYSTEMTIME1, "Second"))
	DLLSTRUCTSETDATA($TSYSTEMTIME2, "MSeconds", DLLSTRUCTGETDATA($TSYSTEMTIME1, "MSeconds"))
	DLLSTRUCTSETDATA($TSYSTEMTIME2, "DOW", DLLSTRUCTGETDATA($TSYSTEMTIME1, "DOW"))
	RETURN $TSYSTEMTIME2
ENDFUNC
FUNC _DATE_TIME_COMPAREFILETIME($TFILETIME1, $TFILETIME2)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "long", "CompareFileTime", "struct*", $TFILETIME1, "struct*", $TFILETIME2)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _DATE_TIME_DOSDATETIMETOFILETIME($IFATDATE, $IFATTIME)
	LOCAL $TTIME = DLLSTRUCTCREATE($TAGFILETIME)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "DosDateTimeToFileTime", "word", $IFATDATE, "word", $IFATTIME, "struct*", $TTIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN SETEXTENDED($ARESULT[0], $TTIME)
ENDFUNC
FUNC _DATE_TIME_DOSDATETOARRAY($IDOSDATE)
	LOCAL $ADATE[3]
	$ADATE[0] = BITAND($IDOSDATE, 31)
	$ADATE[1] = BITAND(BITSHIFT($IDOSDATE, 5), 15)
	$ADATE[2] = BITAND(BITSHIFT($IDOSDATE, 9), 63) + 1980
	RETURN $ADATE
ENDFUNC
FUNC _DATE_TIME_DOSDATETIMETOARRAY($IDOSDATE, $IDOSTIME)
	LOCAL $ADATE[6]
	$ADATE[0] = BITAND($IDOSDATE, 31)
	$ADATE[1] = BITAND(BITSHIFT($IDOSDATE, 5), 15)
	$ADATE[2] = BITAND(BITSHIFT($IDOSDATE, 9), 63) + 1980
	$ADATE[5] = BITAND($IDOSTIME, 31) * 2
	$ADATE[4] = BITAND(BITSHIFT($IDOSTIME, 5), 63)
	$ADATE[3] = BITAND(BITSHIFT($IDOSTIME, 11), 31)
	RETURN $ADATE
ENDFUNC
FUNC _DATE_TIME_DOSDATETIMETOSTR($IDOSDATE, $IDOSTIME)
	LOCAL $ADATE = _DATE_TIME_DOSDATETIMETOARRAY($IDOSDATE, $IDOSTIME)
	RETURN STRINGFORMAT("%02d/%02d/%04d %02d:%02d:%02d", $ADATE[0], $ADATE[1], $ADATE[2], $ADATE[3], $ADATE[4], $ADATE[5])
ENDFUNC
FUNC _DATE_TIME_DOSDATETOSTR($IDOSDATE)
	LOCAL $ADATE = _DATE_TIME_DOSDATETOARRAY($IDOSDATE)
	RETURN STRINGFORMAT("%02d/%02d/%04d", $ADATE[0], $ADATE[1], $ADATE[2])
ENDFUNC
FUNC _DATE_TIME_DOSTIMETOARRAY($IDOSTIME)
	LOCAL $ATIME[3]
	$ATIME[2] = BITAND($IDOSTIME, 31) * 2
	$ATIME[1] = BITAND(BITSHIFT($IDOSTIME, 5), 63)
	$ATIME[0] = BITAND(BITSHIFT($IDOSTIME, 11), 31)
	RETURN $ATIME
ENDFUNC
FUNC _DATE_TIME_DOSTIMETOSTR($IDOSTIME)
	LOCAL $ATIME = _DATE_TIME_DOSTIMETOARRAY($IDOSTIME)
	RETURN STRINGFORMAT("%02d:%02d:%02d", $ATIME[0], $ATIME[1], $ATIME[2])
ENDFUNC
FUNC _DATE_TIME_ENCODEFILETIME($IMONTH, $IDAY, $IYEAR, $IHOUR = 0, $IMINUTE = 0, $ISECOND = 0, $IMSECONDS = 0)
	LOCAL $TSYSTEMTIME = _DATE_TIME_ENCODESYSTEMTIME($IMONTH, $IDAY, $IYEAR, $IHOUR, $IMINUTE, $ISECOND, $IMSECONDS)
	RETURN _DATE_TIME_SYSTEMTIMETOFILETIME($TSYSTEMTIME)
ENDFUNC
FUNC _DATE_TIME_ENCODESYSTEMTIME($IMONTH, $IDAY, $IYEAR, $IHOUR = 0, $IMINUTE = 0, $ISECOND = 0, $IMSECONDS = 0)
	LOCAL $TSYSTEMTIME = DLLSTRUCTCREATE($TAGSYSTEMTIME)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "Month", $IMONTH)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "Day", $IDAY)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "Year", $IYEAR)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "Hour", $IHOUR)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "Minute", $IMINUTE)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "Second", $ISECOND)
	DLLSTRUCTSETDATA($TSYSTEMTIME, "MSeconds", $IMSECONDS)
	RETURN $TSYSTEMTIME
ENDFUNC
FUNC _DATE_TIME_FILETIMETOARRAY(BYREF $TFILETIME)
	IF((DLLSTRUCTGETDATA($TFILETIME, 1) + DLLSTRUCTGETDATA($TFILETIME, 2)) = 0) THEN RETURN SETERROR(10, 0, 0)
	LOCAL $TSYSTEMTIME = _DATE_TIME_FILETIMETOSYSTEMTIME($TFILETIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN _DATE_TIME_SYSTEMTIMETOARRAY($TSYSTEMTIME)
ENDFUNC
FUNC _DATE_TIME_FILETIMETOSTR(BYREF $TFILETIME, $IFMT = 0)
	LOCAL $ADATE = _DATE_TIME_FILETIMETOARRAY($TFILETIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
	IF $IFMT THEN
		RETURN STRINGFORMAT("%04d/%02d/%02d %02d:%02d:%02d", $ADATE[2], $ADATE[0], $ADATE[1], $ADATE[3], $ADATE[4], $ADATE[5])
	ELSE
		RETURN STRINGFORMAT("%02d/%02d/%04d %02d:%02d:%02d", $ADATE[0], $ADATE[1], $ADATE[2], $ADATE[3], $ADATE[4], $ADATE[5])
	ENDIF
ENDFUNC
FUNC _DATE_TIME_FILETIMETODOSDATETIME($TFILETIME)
	LOCAL $ADATE[2]
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "FileTimeToDosDateTime", "struct*", $TFILETIME, "word*", 0, "word*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, $ADATE)
	$ADATE[0] = $ARESULT[2]
	$ADATE[1] = $ARESULT[3]
	RETURN SETEXTENDED($ARESULT[0], $ADATE)
ENDFUNC
FUNC _DATE_TIME_FILETIMETOLOCALFILETIME($TFILETIME)
	LOCAL $TLOCAL = DLLSTRUCTCREATE($TAGFILETIME)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "FileTimeToLocalFileTime", "struct*", $TFILETIME, "struct*", $TLOCAL)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN SETEXTENDED($ARESULT[0], $TLOCAL)
ENDFUNC
FUNC _DATE_TIME_FILETIMETOSYSTEMTIME($TFILETIME)
	LOCAL $TSYSTTIME = DLLSTRUCTCREATE($TAGSYSTEMTIME)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "FileTimeToSystemTime", "struct*", $TFILETIME, "struct*", $TSYSTTIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN SETEXTENDED($ARESULT[0], $TSYSTTIME)
ENDFUNC
FUNC _DATE_TIME_GETFILETIME($HFILE)
	LOCAL $ADATE[3]
	$ADATE[0] = DLLSTRUCTCREATE($TAGFILETIME)
	$ADATE[1] = DLLSTRUCTCREATE($TAGFILETIME)
	$ADATE[2] = DLLSTRUCTCREATE($TAGFILETIME)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "GetFileTime", "handle", $HFILE, "struct*", $ADATE[0], "struct*", $ADATE[1], "struct*", $ADATE[2])
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN SETEXTENDED($ARESULT[0], $ADATE)
ENDFUNC
FUNC _DATE_TIME_GETLOCALTIME()
	LOCAL $TSYSTTIME = DLLSTRUCTCREATE($TAGSYSTEMTIME)
	DLLCALL("kernel32.dll", "none", "GetLocalTime", "struct*", $TSYSTTIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $TSYSTTIME
ENDFUNC
FUNC _DATE_TIME_GETSYSTEMTIME()
	LOCAL $TSYSTTIME = DLLSTRUCTCREATE($TAGSYSTEMTIME)
	DLLCALL("kernel32.dll", "none", "GetSystemTime", "struct*", $TSYSTTIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $TSYSTTIME
ENDFUNC
FUNC _DATE_TIME_GETSYSTEMTIMEADJUSTMENT()
	LOCAL $AINFO[3]
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "GetSystemTimeAdjustment", "dword*", 0, "dword*", 0, "bool*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	$AINFO[0] = $ARESULT[1]
	$AINFO[1] = $ARESULT[2]
	$AINFO[2] = $ARESULT[3] <> 0
	RETURN SETEXTENDED($ARESULT[0], $AINFO)
ENDFUNC
FUNC _DATE_TIME_GETSYSTEMTIMEASFILETIME()
	LOCAL $TFILETIME = DLLSTRUCTCREATE($TAGFILETIME)
	DLLCALL("kernel32.dll", "none", "GetSystemTimeAsFileTime", "struct*", $TFILETIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $TFILETIME
ENDFUNC
FUNC _DATE_TIME_GETSYSTEMTIMES()
	LOCAL $AINFO[3]
	$AINFO[0] = DLLSTRUCTCREATE($TAGFILETIME)
	$AINFO[1] = DLLSTRUCTCREATE($TAGFILETIME)
	$AINFO[2] = DLLSTRUCTCREATE($TAGFILETIME)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "GetSystemTimes", "struct*", $AINFO[0], "struct*", $AINFO[1], "struct*", $AINFO[2])
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN SETEXTENDED($ARESULT[0], $AINFO)
ENDFUNC
FUNC _DATE_TIME_GETTICKCOUNT()
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "dword", "GetTickCount")
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _DATE_TIME_GETTIMEZONEINFORMATION()
	LOCAL $TTIMEZONE = DLLSTRUCTCREATE($TAGTIME_ZONE_INFORMATION)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "dword", "GetTimeZoneInformation", "struct*", $TTIMEZONE)
	IF @ERROR OR $ARESULT[0] = -1 THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	LOCAL $AINFO[8]
	$AINFO[0] = $ARESULT[0]
	$AINFO[1] = DLLSTRUCTGETDATA($TTIMEZONE, "Bias")
	$AINFO[2] = DLLSTRUCTGETDATA($TTIMEZONE, "StdName")
	$AINFO[3] = __DATE_TIME_CLONESYSTEMTIME(DLLSTRUCTGETPTR($TTIMEZONE, "StdDate"))
	$AINFO[4] = DLLSTRUCTGETDATA($TTIMEZONE, "StdBias")
	$AINFO[5] = DLLSTRUCTGETDATA($TTIMEZONE, "DayName")
	$AINFO[6] = __DATE_TIME_CLONESYSTEMTIME(DLLSTRUCTGETPTR($TTIMEZONE, "DayDate"))
	$AINFO[7] = DLLSTRUCTGETDATA($TTIMEZONE, "DayBias")
	RETURN $AINFO
ENDFUNC
FUNC _DATE_TIME_LOCALFILETIMETOFILETIME($TLOCALTIME)
	LOCAL $TFILETIME = DLLSTRUCTCREATE($TAGFILETIME)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "LocalFileTimeToFileTime", "struct*", $TLOCALTIME, "struct*", $TFILETIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN SETEXTENDED($ARESULT[0], $TFILETIME)
ENDFUNC
FUNC _DATE_TIME_SETFILETIME($HFILE, $TCREATETIME, $TLASTACCESS, $TLASTWRITE)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "SetFileTime", "handle", $HFILE, "struct*", $TCREATETIME, "struct*", $TLASTACCESS, "struct*", $TLASTWRITE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _DATE_TIME_SETLOCALTIME($TSYSTEMTIME)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "SetLocalTime", "struct*", $TSYSTEMTIME)
	IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
	$ARESULT = DLLCALL("kernel32.dll", "bool", "SetLocalTime", "struct*", $TSYSTEMTIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _DATE_TIME_SETSYSTEMTIME($TSYSTEMTIME)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "SetSystemTime", "struct*", $TSYSTEMTIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _DATE_TIME_SETSYSTEMTIMEADJUSTMENT($IADJUSTMENT, $BDISABLED)
	LOCAL $HTOKEN = _SECURITY__OPENTHREADTOKENEX(BITOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
	_SECURITY__SETPRIVILEGE($HTOKEN, "SeSystemtimePrivilege", TRUE)
	LOCAL $IERROR = @ERROR
	LOCAL $ILASTERROR = @EXTENDED
	LOCAL $BRET = FALSE
	IF NOT @ERROR THEN
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "SetSystemTimeAdjustment", "dword", $IADJUSTMENT, "bool", $BDISABLED)
		IF @ERROR THEN
			$IERROR = @ERROR
			$ILASTERROR = @EXTENDED
		ELSEIF $ARESULT[0] THEN
			$BRET = TRUE
		ELSE
			$IERROR = 20
			$ILASTERROR = _WINAPI_GETLASTERROR()
		ENDIF
		_SECURITY__SETPRIVILEGE($HTOKEN, "SeSystemtimePrivilege", FALSE)
		IF NOT $IERROR AND @ERROR THEN $IERROR = 22
	ENDIF
	_WINAPI_CLOSEHANDLE($HTOKEN)
	RETURN SETERROR($IERROR, $ILASTERROR, $BRET)
ENDFUNC
FUNC _DATE_TIME_SETTIMEZONEINFORMATION($IBIAS, $SSTDNAME, $TSTDDATE, $ISTDBIAS, $SDAYNAME, $TDAYDATE, $IDAYBIAS)
	LOCAL $TZONEINFO = DLLSTRUCTCREATE($TAGTIME_ZONE_INFORMATION)
	DLLSTRUCTSETDATA($TZONEINFO, "Bias", $IBIAS)
	DLLSTRUCTSETDATA($TZONEINFO, "StdName", $SSTDNAME)
	_MEMMOVEMEMORY($TSTDDATE, DLLSTRUCTGETPTR($TZONEINFO, "StdDate"), DLLSTRUCTGETSIZE($TSTDDATE))
	DLLSTRUCTSETDATA($TZONEINFO, "StdBias", $ISTDBIAS)
	DLLSTRUCTSETDATA($TZONEINFO, "DayName", $SDAYNAME)
	_MEMMOVEMEMORY($TDAYDATE, DLLSTRUCTGETPTR($TZONEINFO, "DayDate"), DLLSTRUCTGETSIZE($TDAYDATE))
	DLLSTRUCTSETDATA($TZONEINFO, "DayBias", $IDAYBIAS)
	LOCAL $HTOKEN = _SECURITY__OPENTHREADTOKENEX(BITOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
	_SECURITY__SETPRIVILEGE($HTOKEN, "SeTimeZonePrivilege", TRUE)
	LOCAL $IERROR = @ERROR
	LOCAL $ILASTERROR = @EXTENDED
	LOCAL $BRET = FALSE
	IF NOT @ERROR THEN
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "SetTimeZoneInformation", "struct*", $TZONEINFO)
		IF @ERROR THEN
			$IERROR = @ERROR
			$ILASTERROR = @EXTENDED
		ELSEIF $ARESULT[0] THEN
			$ILASTERROR = 0
			$BRET = TRUE
		ELSE
			$IERROR = 20
			$ILASTERROR = _WINAPI_GETLASTERROR()
		ENDIF
		_SECURITY__SETPRIVILEGE($HTOKEN, "SeTimeZonePrivilege", FALSE)
		IF NOT $IERROR AND @ERROR THEN $IERROR = 22
	ENDIF
	_WINAPI_CLOSEHANDLE($HTOKEN)
	RETURN SETERROR($IERROR, $ILASTERROR, $BRET)
ENDFUNC
FUNC _DATE_TIME_SYSTEMTIMETOARRAY(BYREF $TSYSTEMTIME)
	LOCAL $AINFO[8]
	$AINFO[0] = DLLSTRUCTGETDATA($TSYSTEMTIME, "Month")
	$AINFO[1] = DLLSTRUCTGETDATA($TSYSTEMTIME, "Day")
	$AINFO[2] = DLLSTRUCTGETDATA($TSYSTEMTIME, "Year")
	$AINFO[3] = DLLSTRUCTGETDATA($TSYSTEMTIME, "Hour")
	$AINFO[4] = DLLSTRUCTGETDATA($TSYSTEMTIME, "Minute")
	$AINFO[5] = DLLSTRUCTGETDATA($TSYSTEMTIME, "Second")
	$AINFO[6] = DLLSTRUCTGETDATA($TSYSTEMTIME, "MSeconds")
	$AINFO[7] = DLLSTRUCTGETDATA($TSYSTEMTIME, "DOW")
	RETURN $AINFO
ENDFUNC
FUNC _DATE_TIME_SYSTEMTIMETODATESTR(BYREF $TSYSTEMTIME, $IFMT = 0)
	LOCAL $AINFO = _DATE_TIME_SYSTEMTIMETOARRAY($TSYSTEMTIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
	IF $IFMT THEN
		RETURN STRINGFORMAT("%04d/%02d/%02d", $AINFO[2], $AINFO[0], $AINFO[1])
	ELSE
		RETURN STRINGFORMAT("%02d/%02d/%04d", $AINFO[0], $AINFO[1], $AINFO[2])
	ENDIF
ENDFUNC
FUNC _DATE_TIME_SYSTEMTIMETODATETIMESTR(BYREF $TSYSTEMTIME, $IFMT = 0)
	LOCAL $AINFO = _DATE_TIME_SYSTEMTIMETOARRAY($TSYSTEMTIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
	IF $IFMT THEN
		RETURN STRINGFORMAT("%04d/%02d/%02d %02d:%02d:%02d", $AINFO[2], $AINFO[0], $AINFO[1], $AINFO[3], $AINFO[4], $AINFO[5])
	ELSE
		RETURN STRINGFORMAT("%02d/%02d/%04d %02d:%02d:%02d", $AINFO[0], $AINFO[1], $AINFO[2], $AINFO[3], $AINFO[4], $AINFO[5])
	ENDIF
ENDFUNC
FUNC _DATE_TIME_SYSTEMTIMETOFILETIME($TSYSTEMTIME)
	LOCAL $TFILETIME = DLLSTRUCTCREATE($TAGFILETIME)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "SystemTimeToFileTime", "struct*", $TSYSTEMTIME, "struct*", $TFILETIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN SETEXTENDED($ARESULT[0], $TFILETIME)
ENDFUNC
FUNC _DATE_TIME_SYSTEMTIMETOTIMESTR(BYREF $TSYSTEMTIME)
	LOCAL $AINFO = _DATE_TIME_SYSTEMTIMETOARRAY($TSYSTEMTIME)
	RETURN STRINGFORMAT("%02d:%02d:%02d", $AINFO[3], $AINFO[4], $AINFO[5])
ENDFUNC
FUNC _DATE_TIME_SYSTEMTIMETOTZSPECIFICLOCALTIME($TUTC, $TTIMEZONE = 0)
	LOCAL $TLOCALTIME = DLLSTRUCTCREATE($TAGSYSTEMTIME)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "SystemTimeToTzSpecificLocalTime", "struct*", $TTIMEZONE, "struct*", $TUTC, "struct*", $TLOCALTIME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN SETEXTENDED($ARESULT[0], $TLOCALTIME)
ENDFUNC
FUNC _DATE_TIME_TZSPECIFICLOCALTIMETOSYSTEMTIME($TLOCALTIME, $TTIMEZONE = 0)
	LOCAL $TUTC = DLLSTRUCTCREATE($TAGSYSTEMTIME)
	LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "TzSpecificLocalTimeToSystemTime", "struct*", $TTIMEZONE, "struct*", $TLOCALTIME, "struct*", $TUTC)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN SETEXTENDED($ARESULT[0], $TUTC)
ENDFUNC
GLOBAL CONST $INET_LOCALCACHE = 0
GLOBAL CONST $INET_FORCERELOAD = 1
GLOBAL CONST $INET_IGNORESSL = 2
GLOBAL CONST $INET_ASCIITRANSFER = 4
GLOBAL CONST $INET_BINARYTRANSFER = 8
GLOBAL CONST $INET_FORCEBYPASS = 16
GLOBAL CONST $INET_DOWNLOADWAIT = 0
GLOBAL CONST $INET_DOWNLOADBACKGROUND = 1
GLOBAL CONST $INET_DOWNLOADREAD = 0
GLOBAL CONST $INET_DOWNLOADSIZE = 1
GLOBAL CONST $INET_DOWNLOADCOMPLETE = 2
GLOBAL CONST $INET_DOWNLOADSUCCESS = 3
GLOBAL CONST $INET_DOWNLOADERROR = 4
GLOBAL CONST $INET_DOWNLOADEXTENDED = 5
FUNC _GETIP()
	LOCAL CONST $GETIP_TIMER = 300000
	LOCAL STATIC $HTIMER = 0
	LOCAL STATIC $SLASTIP = 0
	IF TIMERDIFF($HTIMER) < $GETIP_TIMER AND NOT $SLASTIP THEN
		RETURN SETEXTENDED(1, $SLASTIP)
	ENDIF
	LOCAL $AGETIPURL = ["https://api.ipify.org", "http://checkip.dyndns.org", "http://www.myexternalip.com/raw", "http://bot.whatismyipaddress.com"], $ARETURN = 0, $SRETURN = ""
	FOR $I = 0 TO UBOUND($AGETIPURL) - 1
		$SRETURN = INETREAD($AGETIPURL[$I])
		IF @ERROR OR $SRETURN == "" THEN CONTINUELOOP
		$ARETURN = STRINGREGEXP(BINARYTOSTRING($SRETURN), "((?:\d{1,3}\.){3}\d{1,3})", $STR_REGEXPARRAYGLOBALMATCH)
		IF NOT @ERROR THEN
			$SRETURN = $ARETURN[0]
			EXITLOOP
		ENDIF
		$SRETURN = ""
	NEXT
	$HTIMER = TIMERINIT()
	$SLASTIP = $SRETURN
	IF $SRETURN == "" THEN RETURN SETERROR(1, 0, -1)
	RETURN $SRETURN
ENDFUNC
FUNC _INETEXPLORERCAPABLE($SIESTRING)
	IF STRINGLEN($SIESTRING) <= 0 THEN RETURN SETERROR(1, 0, "")
	LOCAL $S_IERETURN
	LOCAL $N_IECHAR
	FOR $I_IECOUNT = 1 TO STRINGLEN($SIESTRING)
		$N_IECHAR = "0x" & HEX(ASC(STRINGMID($SIESTRING, $I_IECOUNT, 1)), 2)
		IF $N_IECHAR < 33 OR $N_IECHAR = 37 OR $N_IECHAR = 47 OR $N_IECHAR > 127 THEN
			$S_IERETURN = $S_IERETURN & "%" & STRINGRIGHT($N_IECHAR, 2)
		ELSE
			$S_IERETURN = $S_IERETURN & CHR($N_IECHAR)
		ENDIF
	NEXT
	RETURN $S_IERETURN
ENDFUNC
FUNC _INETGETSOURCE($SURL, $BSTRING = TRUE)
	LOCAL $SSTRING = INETREAD($SURL, $INET_FORCERELOAD)
	LOCAL $IERROR = @ERROR, $IEXTENDED = @EXTENDED
	IF $BSTRING = DEFAULT OR $BSTRING THEN $SSTRING = BINARYTOSTRING($SSTRING)
	RETURN SETERROR($IERROR, $IEXTENDED, $SSTRING)
ENDFUNC
FUNC _INETMAIL($SMAILTO, $SMAILSUBJECT, $SMAILBODY)
	LOCAL $IPREV = OPT("ExpandEnvStrings", 1)
	LOCAL $SVAR, $SDFLT = REGREAD("HKCU\Software\Clients\Mail", "")
	IF $SDFLT = "Windows Live Mail" THEN
		$SVAR = REGREAD("HKCR\WLMail.Url.Mailto\Shell\open\command", "")
	ELSE
		$SVAR = REGREAD("HKCR\mailto\shell\open\command", "")
	ENDIF
	LOCAL $IRET = RUN(STRINGREPLACE($SVAR, "%1", _INETEXPLORERCAPABLE("mailto:" & $SMAILTO & "?subject=" & $SMAILSUBJECT & "&body=" & $SMAILBODY)))
	LOCAL $IERROR = @ERROR, $IEXTENDED = @EXTENDED
	OPT("ExpandEnvStrings", $IPREV)
	RETURN SETERROR($IERROR, $IEXTENDED, $IRET)
ENDFUNC
FUNC _INETSMTPMAIL($SSMTPSERVER, $SFROMNAME, $SFROMADDRESS, $STOADDRESS, $SSUBJECT = "", $ABODY = "", $SEHLO = "", $SFIRST = "", $BTRACE = 0)
	IF $SSMTPSERVER = "" OR $SFROMADDRESS = "" OR $STOADDRESS = "" OR $SFROMNAME = "" OR STRINGLEN($SFROMNAME) > 256 THEN RETURN SETERROR(1, 0, 0)
	IF $SEHLO = "" THEN $SEHLO = @COMPUTERNAME
	IF TCPSTARTUP() = 0 THEN RETURN SETERROR(2, 0, 0)
	LOCAL $S_IPADDRESS, $I_COUNT
	IF STRINGREGEXP($SSMTPSERVER, "^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$") THEN
		$S_IPADDRESS = $SSMTPSERVER
	ELSE
		$S_IPADDRESS = TCPNAMETOIP($SSMTPSERVER)
	ENDIF
	IF $S_IPADDRESS = "" THEN
		TCPSHUTDOWN()
		RETURN SETERROR(3, 0, 0)
	ENDIF
	LOCAL $VSOCKET = TCPCONNECT($S_IPADDRESS, 25)
	IF $VSOCKET = -1 THEN
		TCPSHUTDOWN()
		RETURN SETERROR(4, 0, 0)
	ENDIF
	LOCAL $ASEND[6], $AREPLYCODE[6]
	$ASEND[0] = "HELO " & $SEHLO & @CRLF
	IF STRINGLEFT($SEHLO, 5) = "EHLO " THEN $ASEND[0] = $SEHLO & @CRLF
	$AREPLYCODE[0] = "250"
	$ASEND[1] = "MAIL FROM: <" & $SFROMADDRESS & ">" & @CRLF
	$AREPLYCODE[1] = "250"
	$ASEND[2] = "RCPT TO: <" & $STOADDRESS & ">" & @CRLF
	$AREPLYCODE[2] = "250"
	$ASEND[3] = "DATA" & @CRLF
	$AREPLYCODE[3] = "354"
	LOCAL $ARESULT = _DATE_TIME_GETTIMEZONEINFORMATION()
	LOCAL $IBIAS = -$ARESULT[1] / 60
	LOCAL $IBIASH = INT($IBIAS)
	LOCAL $IBIASM = 0
	IF $IBIASH <> $IBIAS THEN $IBIASM = ABS($IBIAS - $IBIASH) * 60
	$IBIAS = STRINGFORMAT(" (%+.2d%.2d)", $IBIASH, $IBIASM)
	$ASEND[4] = "From:" & $SFROMNAME & "<" & $SFROMADDRESS & ">" & @CRLF & "To:" & "<" & $STOADDRESS & ">" & @CRLF & "Subject:" & $SSUBJECT & @CRLF & "Mime-Version: 1.0" & @CRLF & "Date: " & _DATEDAYOFWEEK(@WDAY, 1) & ", " & @MDAY & " " & _DATETOMONTH(@MON, 1) & " " & @YEAR & " " & @HOUR & ":" & @MIN & ":" & @SEC & $IBIAS & @CRLF & "Content-Type: text/plain; charset=US-ASCII" & @CRLF & @CRLF
	$AREPLYCODE[4] = ""
	$ASEND[5] = @CRLF & "." & @CRLF
	$AREPLYCODE[5] = "250"
	IF __SMTPSEND($VSOCKET, $ASEND[0], $AREPLYCODE[0], $BTRACE, "220", $SFIRST) THEN RETURN SETERROR(50, 0, 0)
	FOR $I_COUNT = 1 TO UBOUND($ASEND) - 2
		IF __SMTPSEND($VSOCKET, $ASEND[$I_COUNT], $AREPLYCODE[$I_COUNT], $BTRACE) THEN RETURN SETERROR(50 + $I_COUNT, 0, 0)
	NEXT
	FOR $I_COUNT = 0 TO UBOUND($ABODY) - 1
		IF STRINGLEFT($ABODY[$I_COUNT], 1) = "." THEN $ABODY[$I_COUNT] = "." & $ABODY[$I_COUNT]
		IF __SMTPSEND($VSOCKET, $ABODY[$I_COUNT] & @CRLF, "", $BTRACE) THEN RETURN SETERROR(500 + $I_COUNT, 0, 0)
	NEXT
	$I_COUNT = UBOUND($ASEND) - 1
	IF __SMTPSEND($VSOCKET, $ASEND[$I_COUNT], $AREPLYCODE[$I_COUNT], $BTRACE) THEN RETURN SETERROR(5000, 0, 0)
	TCPCLOSESOCKET($VSOCKET)
	TCPSHUTDOWN()
	RETURN 1
ENDFUNC
FUNC __SMTPTRACE($SSTR, $ITIMEOUT = 0)
	LOCAL $SW_TITLE = "SMTP trace"
	LOCAL $SSMTPTRACE = CONTROLGETTEXT($SW_TITLE, "", "Static1")
	$SSTR = STRINGLEFT(STRINGREPLACE($SSTR, @CRLF, ""), 70)
	$SSMTPTRACE &= @HOUR & ":" & @MIN & ":" & @SEC & " " & $SSTR & @LF
	IF WINEXISTS($SW_TITLE) THEN
		CONTROLSETTEXT($SW_TITLE, "", "Static1", $SSMTPTRACE)
	ELSE
		SPLASHTEXTON($SW_TITLE, $SSMTPTRACE, 400, 500, 500, 100, 4 + 16, "", 8)
	ENDIF
	IF $ITIMEOUT THEN SLEEP($ITIMEOUT * 1000)
ENDFUNC
FUNC __SMTPSEND($VSOCKET, $SSEND, $SREPLYCODE, $BTRACE, $SINTREPLY = "", $SFIRST = "")
	LOCAL $SRECEIVE, $I, $HTIMER
	IF $BTRACE THEN __SMTPTRACE($SSEND)
	IF $SINTREPLY <> "" THEN
		IF $SFIRST <> -1 THEN
			IF TCPSEND($VSOCKET, $SFIRST) = 0 THEN
				TCPCLOSESOCKET($VSOCKET)
				TCPSHUTDOWN()
				RETURN 1
			ENDIF
		ENDIF
		$SRECEIVE = ""
		$HTIMER = TIMERINIT()
		WHILE STRINGLEFT($SRECEIVE, STRINGLEN($SINTREPLY)) <> $SINTREPLY AND TIMERDIFF($HTIMER) < 45000
			$SRECEIVE = TCPRECV($VSOCKET, 1000)
			IF $BTRACE AND $SRECEIVE <> "" THEN __SMTPTRACE("intermediate->" & $SRECEIVE)
		WEND
	ENDIF
	IF TCPSEND($VSOCKET, $SSEND) = 0 THEN
		TCPCLOSESOCKET($VSOCKET)
		TCPSHUTDOWN()
		RETURN 1
	ENDIF
	$HTIMER = TIMERINIT()
	$SRECEIVE = ""
	WHILE $SRECEIVE = "" AND TIMERDIFF($HTIMER) < 45000
		$I += 1
		$SRECEIVE = TCPRECV($VSOCKET, 1000)
		IF $SREPLYCODE = "" THEN EXITLOOP
	WEND
	IF $SREPLYCODE <> "" THEN
		IF $BTRACE THEN __SMTPTRACE($I & " <- " & $SRECEIVE)
		IF STRINGLEFT($SRECEIVE, STRINGLEN($SREPLYCODE)) <> $SREPLYCODE THEN
			TCPCLOSESOCKET($VSOCKET)
			TCPSHUTDOWN()
			IF $BTRACE THEN __SMTPTRACE("<-> " & $SREPLYCODE, 5)
			RETURN 2
		ENDIF
	ENDIF
	RETURN 0
ENDFUNC
FUNC _TCPIPTONAME($SIP, $IOPTION = DEFAULT, $HDLL = DEFAULT)
	LOCAL $IINADDR_NONE = -1, $IAF_INET = 2, $SSEPARATOR = @CR
	IF $IOPTION = DEFAULT THEN $IOPTION = 0
	IF $HDLL = DEFAULT THEN $HDLL = "ws2_32.dll"
	LOCAL $AVDLLCALL = DLLCALL($HDLL, "ulong", "inet_addr", "STR", $SIP)
	IF @ERROR THEN RETURN SETERROR(1, 0, "")
	LOCAL $VBINIP = $AVDLLCALL[0]
	IF $VBINIP = $IINADDR_NONE THEN RETURN SETERROR(2, 0, "")
	$AVDLLCALL = DLLCALL($HDLL, "ptr", "gethostbyaddr", "ptr*", $VBINIP, "int", 4, "int", $IAF_INET)
	IF @ERROR THEN RETURN SETERROR(3, 0, "")
	LOCAL $PVHOSTENT = $AVDLLCALL[0]
	IF $PVHOSTENT = 0 THEN
		$AVDLLCALL = DLLCALL($HDLL, "int", "WSAGetLastError")
		IF @ERROR THEN RETURN SETERROR(5, 0, "")
		RETURN SETERROR(4, $AVDLLCALL[0], "")
	ENDIF
	LOCAL $THOSTENT = DLLSTRUCTCREATE("ptr;ptr;short;short;ptr", $PVHOSTENT)
	LOCAL $SHOSTNAMES = __TCPIPTONAME_SZSTRINGREAD(DLLSTRUCTGETDATA($THOSTENT, 1))
	IF @ERROR THEN RETURN SETERROR(6, 0, $SHOSTNAMES)
	IF $IOPTION = 1 THEN
		LOCAL $TALIASES
		$SHOSTNAMES &= $SSEPARATOR
		FOR $I = 0 TO 63
			$TALIASES = DLLSTRUCTCREATE("ptr", DLLSTRUCTGETDATA($THOSTENT, 2) + ($I * 4))
			IF DLLSTRUCTGETDATA($TALIASES, 1) = 0 THEN EXITLOOP
			$SHOSTNAMES &= __TCPIPTONAME_SZSTRINGREAD(DLLSTRUCTGETDATA($TALIASES, 1))
			IF @ERROR THEN
				SETERROR(7)
				EXITLOOP
			ENDIF
		NEXT
		RETURN STRINGSPLIT(STRINGSTRIPWS($SHOSTNAMES, $STR_STRIPTRAILING), @CR)
	ELSE
		RETURN $SHOSTNAMES
	ENDIF
ENDFUNC
FUNC __TCPIPTONAME_SZSTRINGREAD($PSTR, $ILEN = -1)
	LOCAL $TSTRING
	IF $PSTR < 1 THEN RETURN ""
	IF $ILEN < 0 THEN $ILEN = _WINAPI_STRLEN($PSTR, FALSE)
	$TSTRING = DLLSTRUCTCREATE("char[" & $ILEN & "]", $PSTR)
	IF @ERROR THEN RETURN SETERROR(2, 0, "")
	RETURN SETEXTENDED($ILEN, DLLSTRUCTGETDATA($TSTRING, 1))
ENDFUNC
GLOBAL CONST $GDIP_DASHCAPFLAT = 0
GLOBAL CONST $GDIP_DASHCAPROUND = 2
GLOBAL CONST $GDIP_DASHCAPTRIANGLE = 3
GLOBAL CONST $GDIP_DASHSTYLESOLID = 0
GLOBAL CONST $GDIP_DASHSTYLEDASH = 1
GLOBAL CONST $GDIP_DASHSTYLEDOT = 2
GLOBAL CONST $GDIP_DASHSTYLEDASHDOT = 3
GLOBAL CONST $GDIP_DASHSTYLEDASHDOTDOT = 4
GLOBAL CONST $GDIP_DASHSTYLECUSTOM = 5
GLOBAL CONST $GDIP_EPGCHROMINANCETABLE = "{F2E455DC-09B3-4316-8260-676ADA32481C}"
GLOBAL CONST $GDIP_EPGCOLORDEPTH = "{66087055-AD66-4C7C-9A18-38A2310B8337}"
GLOBAL CONST $GDIP_EPGCOMPRESSION = "{E09D739D-CCD4-44EE-8EBA-3FBF8BE4FC58}"
GLOBAL CONST $GDIP_EPGLUMINANCETABLE = "{EDB33BCE-0266-4A77-B904-27216099E717}"
GLOBAL CONST $GDIP_EPGQUALITY = "{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}"
GLOBAL CONST $GDIP_EPGRENDERMETHOD = "{6D42C53A-229A-4825-8BB7-5C99E2B9A8B8}"
GLOBAL CONST $GDIP_EPGSAVEFLAG = "{292266FC-AC40-47BF-8CFC-A85B89A655DE}"
GLOBAL CONST $GDIP_EPGSCANMETHOD = "{3A4E2661-3109-4E56-8536-42C156E7DCFA}"
GLOBAL CONST $GDIP_EPGTRANSFORMATION = "{8D0EB2D1-A58E-4EA8-AA14-108074B7B6F9}"
GLOBAL CONST $GDIP_EPGVERSION = "{24D18C76-814A-41A4-BF53-1C219CCCF797}"
GLOBAL CONST $GDIP_EPTBYTE = 1
GLOBAL CONST $GDIP_EPTASCII = 2
GLOBAL CONST $GDIP_EPTSHORT = 3
GLOBAL CONST $GDIP_EPTLONG = 4
GLOBAL CONST $GDIP_EPTRATIONAL = 5
GLOBAL CONST $GDIP_EPTLONGRANGE = 6
GLOBAL CONST $GDIP_EPTUNDEFINED = 7
GLOBAL CONST $GDIP_EPTRATIONALRANGE = 8
GLOBAL CONST $GDIP_ERROK = 0
GLOBAL CONST $GDIP_ERRGENERICERROR = 1
GLOBAL CONST $GDIP_ERRINVALIDPARAMETER = 2
GLOBAL CONST $GDIP_ERROUTOFMEMORY = 3
GLOBAL CONST $GDIP_ERROBJECTBUSY = 4
GLOBAL CONST $GDIP_ERRINSUFFICIENTBUFFER = 5
GLOBAL CONST $GDIP_ERRNOTIMPLEMENTED = 6
GLOBAL CONST $GDIP_ERRWIN32ERROR = 7
GLOBAL CONST $GDIP_ERRWRONGSTATE = 8
GLOBAL CONST $GDIP_ERRABORTED = 9
GLOBAL CONST $GDIP_ERRFILENOTFOUND = 10
GLOBAL CONST $GDIP_ERRVALUEOVERFLOW = 11
GLOBAL CONST $GDIP_ERRACCESSDENIED = 12
GLOBAL CONST $GDIP_ERRUNKNOWNIMAGEFORMAT = 13
GLOBAL CONST $GDIP_ERRFONTFAMILYNOTFOUND = 14
GLOBAL CONST $GDIP_ERRFONTSTYLENOTFOUND = 15
GLOBAL CONST $GDIP_ERRNOTTRUETYPEFONT = 16
GLOBAL CONST $GDIP_ERRUNSUPPORTEDGDIVERSION = 17
GLOBAL CONST $GDIP_ERRGDIPLUSNOTINITIALIZED = 18
GLOBAL CONST $GDIP_ERRPROPERTYNOTFOUND = 19
GLOBAL CONST $GDIP_ERRPROPERTYNOTSUPPORTED = 20
GLOBAL CONST $GDIP_EVTCOMPRESSIONLZW = 2
GLOBAL CONST $GDIP_EVTCOMPRESSIONCCITT3 = 3
GLOBAL CONST $GDIP_EVTCOMPRESSIONCCITT4 = 4
GLOBAL CONST $GDIP_EVTCOMPRESSIONRLE = 5
GLOBAL CONST $GDIP_EVTCOMPRESSIONNONE = 6
GLOBAL CONST $GDIP_EVTTRANSFORMROTATE90 = 13
GLOBAL CONST $GDIP_EVTTRANSFORMROTATE180 = 14
GLOBAL CONST $GDIP_EVTTRANSFORMROTATE270 = 15
GLOBAL CONST $GDIP_EVTTRANSFORMFLIPHORIZONTAL = 16
GLOBAL CONST $GDIP_EVTTRANSFORMFLIPVERTICAL = 17
GLOBAL CONST $GDIP_EVTMULTIFRAME = 18
GLOBAL CONST $GDIP_EVTLASTFRAME = 19
GLOBAL CONST $GDIP_EVTFLUSH = 20
GLOBAL CONST $GDIP_EVTFRAMEDIMENSIONPAGE = 23
GLOBAL CONST $GDIP_ICFENCODER = 1
GLOBAL CONST $GDIP_ICFDECODER = 2
GLOBAL CONST $GDIP_ICFSUPPORTBITMAP = 4
GLOBAL CONST $GDIP_ICFSUPPORTVECTOR = 8
GLOBAL CONST $GDIP_ICFSEEKABLEENCODE = 16
GLOBAL CONST $GDIP_ICFBLOCKINGDECODE = 32
GLOBAL CONST $GDIP_ICFBUILTIN = 65536
GLOBAL CONST $GDIP_ICFSYSTEM = 131072
GLOBAL CONST $GDIP_ICFUSER = 262144
GLOBAL CONST $GDIP_ILMREAD = 1
GLOBAL CONST $GDIP_ILMWRITE = 2
GLOBAL CONST $GDIP_ILMUSERINPUTBUF = 4
GLOBAL CONST $GDIP_LINECAPFLAT = 0
GLOBAL CONST $GDIP_LINECAPSQUARE = 1
GLOBAL CONST $GDIP_LINECAPROUND = 2
GLOBAL CONST $GDIP_LINECAPTRIANGLE = 3
GLOBAL CONST $GDIP_LINECAPNOANCHOR = 16
GLOBAL CONST $GDIP_LINECAPSQUAREANCHOR = 17
GLOBAL CONST $GDIP_LINECAPROUNDANCHOR = 18
GLOBAL CONST $GDIP_LINECAPDIAMONDANCHOR = 19
GLOBAL CONST $GDIP_LINECAPARROWANCHOR = 20
GLOBAL CONST $GDIP_LINECAPCUSTOM = 255
GLOBAL CONST $GDIP_PXF01INDEXED = 196865
GLOBAL CONST $GDIP_PXF04INDEXED = 197634
GLOBAL CONST $GDIP_PXF08INDEXED = 198659
GLOBAL CONST $GDIP_PXF16GRAYSCALE = 1052676
GLOBAL CONST $GDIP_PXF16RGB555 = 135173
GLOBAL CONST $GDIP_PXF16RGB565 = 135174
GLOBAL CONST $GDIP_PXF16ARGB1555 = 397319
GLOBAL CONST $GDIP_PXF24RGB = 137224
GLOBAL CONST $GDIP_PXF32RGB = 139273
GLOBAL CONST $GDIP_PXF32ARGB = 2498570
GLOBAL CONST $GDIP_PXF32PARGB = 925707
GLOBAL CONST $GDIP_PXF48RGB = 1060876
GLOBAL CONST $GDIP_PXF64ARGB = 3424269
GLOBAL CONST $GDIP_PXF64PARGB = 1720334
GLOBAL CONST $GDIP_IMAGEFORMAT_UNDEFINED = "{B96B3CA9-0728-11D3-9D7B-0000F81EF32E}"
GLOBAL CONST $GDIP_IMAGEFORMAT_MEMORYBMP = "{B96B3CAA-0728-11D3-9D7B-0000F81EF32E}"
GLOBAL CONST $GDIP_IMAGEFORMAT_BMP = "{B96B3CAB-0728-11D3-9D7B-0000F81EF32E}"
GLOBAL CONST $GDIP_IMAGEFORMAT_EMF = "{B96B3CAC-0728-11D3-9D7B-0000F81EF32E}"
GLOBAL CONST $GDIP_IMAGEFORMAT_WMF = "{B96B3CAD-0728-11D3-9D7B-0000F81EF32E}"
GLOBAL CONST $GDIP_IMAGEFORMAT_JPEG = "{B96B3CAE-0728-11D3-9D7B-0000F81EF32E}"
GLOBAL CONST $GDIP_IMAGEFORMAT_PNG = "{B96B3CAF-0728-11D3-9D7B-0000F81EF32E}"
GLOBAL CONST $GDIP_IMAGEFORMAT_GIF = "{B96B3CB0-0728-11D3-9D7B-0000F81EF32E}"
GLOBAL CONST $GDIP_IMAGEFORMAT_TIFF = "{B96B3CB1-0728-11D3-9D7B-0000F81EF32E}"
GLOBAL CONST $GDIP_IMAGEFORMAT_EXIF = "{B96B3CB2-0728-11D3-9D7B-0000F81EF32E}"
GLOBAL CONST $GDIP_IMAGEFORMAT_ICON = "{B96B3CB5-0728-11D3-9D7B-0000F81EF32E}"
GLOBAL CONST $GDIP_IMAGETYPE_UNKNOWN = 0
GLOBAL CONST $GDIP_IMAGETYPE_BITMAP = 1
GLOBAL CONST $GDIP_IMAGETYPE_METAFILE = 2
GLOBAL CONST $GDIP_IMAGEFLAGS_NONE = 0
GLOBAL CONST $GDIP_IMAGEFLAGS_SCALABLE = 1
GLOBAL CONST $GDIP_IMAGEFLAGS_HASALPHA = 2
GLOBAL CONST $GDIP_IMAGEFLAGS_HASTRANSLUCENT = 4
GLOBAL CONST $GDIP_IMAGEFLAGS_PARTIALLYSCALABLE = 8
GLOBAL CONST $GDIP_IMAGEFLAGS_COLORSPACE_RGB = 16
GLOBAL CONST $GDIP_IMAGEFLAGS_COLORSPACE_CMYK = 32
GLOBAL CONST $GDIP_IMAGEFLAGS_COLORSPACE_GRAY = 64
GLOBAL CONST $GDIP_IMAGEFLAGS_COLORSPACE_YCBCR = 128
GLOBAL CONST $GDIP_IMAGEFLAGS_COLORSPACE_YCCK = 256
GLOBAL CONST $GDIP_IMAGEFLAGS_HASREALDPI = 4096
GLOBAL CONST $GDIP_IMAGEFLAGS_HASREALPIXELSIZE = 8192
GLOBAL CONST $GDIP_IMAGEFLAGS_READONLY = 65536
GLOBAL CONST $GDIP_IMAGEFLAGS_CACHING = 131072
GLOBAL CONST $GDIP_SMOOTHINGMODE_INVALID = -1
GLOBAL CONST $GDIP_SMOOTHINGMODE_DEFAULT = 0
GLOBAL CONST $GDIP_SMOOTHINGMODE_HIGHSPEED = 1
GLOBAL CONST $GDIP_SMOOTHINGMODE_HIGHQUALITY = 2
GLOBAL CONST $GDIP_SMOOTHINGMODE_NONE = 3
GLOBAL CONST $GDIP_SMOOTHINGMODE_ANTIALIAS8X4 = 4
GLOBAL CONST $GDIP_SMOOTHINGMODE_ANTIALIAS = $GDIP_SMOOTHINGMODE_ANTIALIAS8X4
GLOBAL CONST $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 = 5
GLOBAL CONST $GDIP_RLUM = 0.3086
GLOBAL CONST $GDIP_GLUM = 0.6094
GLOBAL CONST $GDIP_BLUM = 0.082
GLOBAL CONST $GDIP_INTERPOLATIONMODE_INVALID = -1
GLOBAL CONST $GDIP_INTERPOLATIONMODE_DEFAULT = 0
GLOBAL CONST $GDIP_INTERPOLATIONMODE_LOWQUALITY = 1
GLOBAL CONST $GDIP_INTERPOLATIONMODE_HIGHQUALITY = 2
GLOBAL CONST $GDIP_INTERPOLATIONMODE_BILINEAR = 3
GLOBAL CONST $GDIP_INTERPOLATIONMODE_BICUBIC = 4
GLOBAL CONST $GDIP_INTERPOLATIONMODE_NEARESTNEIGHBOR = 5
GLOBAL CONST $GDIP_INTERPOLATIONMODE_HIGHQUALITYBILINEAR = 6
GLOBAL CONST $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC = 7
GLOBAL CONST $GDIP_TEXTRENDERINGHINT_SYSTEMDEFAULT = 0
GLOBAL CONST $GDIP_TEXTRENDERINGHINT_SINGLEBITPERPIXELGRIDFIT = 1
GLOBAL CONST $GDIP_TEXTRENDERINGHINT_SINGLEBITPERPIXEL = 2
GLOBAL CONST $GDIP_TEXTRENDERINGHINT_ANTIALIASGRIDFIT = 3
GLOBAL CONST $GDIP_TEXTRENDERINGHINT_ANTIALIAS = 4
GLOBAL CONST $GDIP_TEXTRENDERINGHINT_CLEARTYPEGRIDFIT = 5
GLOBAL CONST $GDIP_PIXELOFFSETMODE_INVALID = -1
GLOBAL CONST $GDIP_PIXELOFFSETMODE_DEFAULT = 0
GLOBAL CONST $GDIP_PIXELOFFSETMODE_HIGHSPEED = 1
GLOBAL CONST $GDIP_PIXELOFFSETMODE_HIGHQUALITY = 2
GLOBAL CONST $GDIP_PIXELOFFSETMODE_NONE = 3
GLOBAL CONST $GDIP_PIXELOFFSETMODE_HALF = 4
GLOBAL CONST $GDIP_PENSETLINEJOIN_MITER = 0
GLOBAL CONST $GDIP_PENSETLINEJOIN_BEVEL = 1
GLOBAL CONST $GDIP_PENSETLINEJOIN_ROUND = 2
GLOBAL CONST $GDIP_PENSETLINEJOIN_MITERCLIPPED = 3
GLOBAL CONST $GDIP_FILLMODEALTERNATE = 0
GLOBAL CONST $GDIP_FILLMODEWINDING = 1
GLOBAL CONST $GDIP_QUALITYMODEINVALID = -1
GLOBAL CONST $GDIP_QUALITYMODEDEFAULT = 0
GLOBAL CONST $GDIP_QUALITYMODELOW = 1
GLOBAL CONST $GDIP_QUALITYMODEHIGH = 2
GLOBAL CONST $GDIP_COMPOSITINGMODESOURCEOVER = 0
GLOBAL CONST $GDIP_COMPOSITINGMODESOURCECOPY = 1
GLOBAL CONST $GDIP_COMPOSITINGQUALITYINVALID = $GDIP_QUALITYMODEINVALID
GLOBAL CONST $GDIP_COMPOSITINGQUALITYDEFAULT = $GDIP_QUALITYMODEDEFAULT
GLOBAL CONST $GDIP_COMPOSITINGQUALITYHIGHSPEED = $GDIP_QUALITYMODELOW
GLOBAL CONST $GDIP_COMPOSITINGQUALITYHIGHQUALITY = $GDIP_QUALITYMODEHIGH
GLOBAL CONST $GDIP_COMPOSITINGQUALITYGAMMACORRECTED = 3
GLOBAL CONST $GDIP_COMPOSITINGQUALITYASSUMELINEAR = 4
GLOBAL CONST $GDIP_HATCHSTYLE_HORIZONTAL = 0
GLOBAL CONST $GDIP_HATCHSTYLE_VERTICAL = 1
GLOBAL CONST $GDIP_HATCHSTYLE_FORWARDDIAGONAL = 2
GLOBAL CONST $GDIP_HATCHSTYLE_BACKWARDDIAGONAL = 3
GLOBAL CONST $GDIP_HATCHSTYLE_CROSS = 4
GLOBAL CONST $GDIP_HATCHSTYLE_DIAGONALCROSS = 5
GLOBAL CONST $GDIP_HATCHSTYLE_05PERCENT = 6
GLOBAL CONST $GDIP_HATCHSTYLE_10PERCENT = 7
GLOBAL CONST $GDIP_HATCHSTYLE_20PERCENT = 8
GLOBAL CONST $GDIP_HATCHSTYLE_25PERCENT = 9
GLOBAL CONST $GDIP_HATCHSTYLE_30PERCENT = 10
GLOBAL CONST $GDIP_HATCHSTYLE_40PERCENT = 11
GLOBAL CONST $GDIP_HATCHSTYLE_50PERCENT = 12
GLOBAL CONST $GDIP_HATCHSTYLE_60PERCENT = 13
GLOBAL CONST $GDIP_HATCHSTYLE_70PERCENT = 14
GLOBAL CONST $GDIP_HATCHSTYLE_75PERCENT = 15
GLOBAL CONST $GDIP_HATCHSTYLE_80PERCENT = 16
GLOBAL CONST $GDIP_HATCHSTYLE_90PERCENT = 17
GLOBAL CONST $GDIP_HATCHSTYLE_LIGHTDOWNWARDDIAGONAL = 18
GLOBAL CONST $GDIP_HATCHSTYLE_LIGHTUPWARDDIAGONAL = 19
GLOBAL CONST $GDIP_HATCHSTYLE_DARKDOWNWARDDIAGONAL = 20
GLOBAL CONST $GDIP_HATCHSTYLE_DARKUPWARDDIAGONAL = 21
GLOBAL CONST $GDIP_HATCHSTYLE_WIDEDOWNWARDDIAGONAL = 22
GLOBAL CONST $GDIP_HATCHSTYLE_WIDEUPWARDDIAGONAL = 23
GLOBAL CONST $GDIP_HATCHSTYLE_LIGHTVERTICAL = 24
GLOBAL CONST $GDIP_HATCHSTYLE_LIGHTHORIZONTAL = 25
GLOBAL CONST $GDIP_HATCHSTYLE_NARROWVERTICAL = 26
GLOBAL CONST $GDIP_HATCHSTYLE_NARROWHORIZONTAL = 27
GLOBAL CONST $GDIP_HATCHSTYLE_DARKVERTICAL = 28
GLOBAL CONST $GDIP_HATCHSTYLE_DARKHORIZONTAL = 29
GLOBAL CONST $GDIP_HATCHSTYLE_DASHEDDOWNWARDDIAGONAL = 30
GLOBAL CONST $GDIP_HATCHSTYLE_DASHEDUPWARDDIAGONAL = 31
GLOBAL CONST $GDIP_HATCHSTYLE_DASHEDHORIZONTAL = 32
GLOBAL CONST $GDIP_HATCHSTYLE_DASHEDVERTICAL = 33
GLOBAL CONST $GDIP_HATCHSTYLE_SMALLCONFETTI = 34
GLOBAL CONST $GDIP_HATCHSTYLE_LARGECONFETTI = 35
GLOBAL CONST $GDIP_HATCHSTYLE_ZIGZAG = 36
GLOBAL CONST $GDIP_HATCHSTYLE_WAVE = 37
GLOBAL CONST $GDIP_HATCHSTYLE_DIAGONALBRICK = 38
GLOBAL CONST $GDIP_HATCHSTYLE_HORIZONTALBRICK = 39
GLOBAL CONST $GDIP_HATCHSTYLE_WEAVE = 40
GLOBAL CONST $GDIP_HATCHSTYLE_PLAID = 41
GLOBAL CONST $GDIP_HATCHSTYLE_DIVOT = 42
GLOBAL CONST $GDIP_HATCHSTYLE_DOTTEDGRID = 43
GLOBAL CONST $GDIP_HATCHSTYLE_DOTTEDDIAMOND = 44
GLOBAL CONST $GDIP_HATCHSTYLE_SHINGLE = 45
GLOBAL CONST $GDIP_HATCHSTYLE_TRELLIS = 46
GLOBAL CONST $GDIP_HATCHSTYLE_SPHERE = 47
GLOBAL CONST $GDIP_HATCHSTYLE_SMALLGRID = 48
GLOBAL CONST $GDIP_HATCHSTYLE_SMALLCHECKERBOARD = 49
GLOBAL CONST $GDIP_HATCHSTYLE_LARGECHECKERBOARD = 50
GLOBAL CONST $GDIP_HATCHSTYLE_OUTLINEDDIAMOND = 51
GLOBAL CONST $GDIP_HATCHSTYLE_SOLIDDIAMOND = 52
GLOBAL CONST $GDIP_HATCHSTYLE_TOTAL = 53
GLOBAL CONST $GDIP_HATCHSTYLE_LARGEGRID = $GDIP_HATCHSTYLE_CROSS
GLOBAL CONST $GDIP_HATCHSTYLE_MIN = $GDIP_HATCHSTYLE_HORIZONTAL
GLOBAL CONST $GDIP_HATCHSTYLE_MAX = $GDIP_HATCHSTYLE_TOTAL - 1
GLOBAL CONST $GDIP_BLUREFFECTGUID = "{633C80A4-1843-482b-9EF2-BE2834C5FDD4}"
GLOBAL CONST $GDIP_SHARPENEFFECTGUID = "{63CBF3EE-C526-402c-8F71-62C540BF5142}"
GLOBAL CONST $GDIP_COLORMATRIXEFFECTGUID = "{718F2615-7933-40e3-A511-5F68FE14DD74}"
GLOBAL CONST $GDIP_COLORLUTEFFECTGUID = "{A7CE72A9-0F7F-40d7-B3CC-D0C02D5C3212}"
GLOBAL CONST $GDIP_BRIGHTNESSCONTRASTEFFECTGUID = "{D3A1DBE1-8EC4-4c17-9F4C-EA97AD1C343D}"
GLOBAL CONST $GDIP_HUESATURATIONLIGHTNESSEFFECTGUID = "{8B2DD6C3-EB07-4d87-A5F0-7108E26A9C5F}"
GLOBAL CONST $GDIP_LEVELSEFFECTGUID = "{99C354EC-2A31-4f3a-8C34-17A803B33A25}"
GLOBAL CONST $GDIP_TINTEFFECTGUID = "{1077AF00-2848-4441-9489-44AD4C2D7A2C}"
GLOBAL CONST $GDIP_COLORBALANCEEFFECTGUID = "{537E597D-251E-48da-9664-29CA496B70F8}"
GLOBAL CONST $GDIP_REDEYECORRECTIONEFFECTGUID = "{74D29D05-69A4-4266-9549-3CC52836B632}"
GLOBAL CONST $GDIP_COLORCURVEEFFECTGUID = "{DD6A0022-58E4-4a67-9D9B-D48EB881A53D}"
GLOBAL CONST $GDIP_ADJUSTEXPOSURE = 0
GLOBAL CONST $GDIP_ADJUSTDENSITY = 1
GLOBAL CONST $GDIP_ADJUSTCONTRAST = 2
GLOBAL CONST $GDIP_ADJUSTHIGHLIGHT = 3
GLOBAL CONST $GDIP_ADJUSTSHADOW = 4
GLOBAL CONST $GDIP_ADJUSTMIDTONE = 5
GLOBAL CONST $GDIP_ADJUSTWHITESATURATION = 6
GLOBAL CONST $GDIP_ADJUSTBLACKSATURATION = 7
GLOBAL CONST $GDIP_CURVECHANNELALL = 0
GLOBAL CONST $GDIP_CURVECHANNELRED = 1
GLOBAL CONST $GDIP_CURVECHANNELGREEN = 2
GLOBAL CONST $GDIP_CURVECHANNELBLUE = 3
GLOBAL CONST $GDIP_PALETTETYPECUSTOM = 0
GLOBAL CONST $GDIP_PALETTETYPEOPTIMAL = 1
GLOBAL CONST $GDIP_PALETTETYPEFIXEDBW = 2
GLOBAL CONST $GDIP_PALETTETYPEFIXEDHALFTONE8 = 3
GLOBAL CONST $GDIP_PALETTETYPEFIXEDHALFTONE27 = 4
GLOBAL CONST $GDIP_PALETTETYPEFIXEDHALFTONE64 = 5
GLOBAL CONST $GDIP_PALETTETYPEFIXEDHALFTONE125 = 6
GLOBAL CONST $GDIP_PALETTETYPEFIXEDHALFTONE216 = 7
GLOBAL CONST $GDIP_PALETTETYPEFIXEDHALFTONE252 = 8
GLOBAL CONST $GDIP_PALETTETYPEFIXEDHALFTONE256 = 9
GLOBAL CONST $GDIP_PALETTEFLAGSHASALPHA = 1
GLOBAL CONST $GDIP_PALETTEFLAGSGRAYSCALE = 2
GLOBAL CONST $GDIP_PALETTEFLAGSHALFTONE = 4
GLOBAL CONST $GDIP_DITHERTYPENONE = 0
GLOBAL CONST $GDIP_DITHERTYPESOLID = 1
GLOBAL CONST $GDIP_DITHERTYPEORDERED4X4 = 2
GLOBAL CONST $GDIP_DITHERTYPEORDERED8X8 = 3
GLOBAL CONST $GDIP_DITHERTYPEORDERED16X16 = 4
GLOBAL CONST $GDIP_DITHERTYPEORDERED91X91 = 5
GLOBAL CONST $GDIP_DITHERTYPESPIRAL4X4 = 6
GLOBAL CONST $GDIP_DITHERTYPESPIRAL8X8 = 7
GLOBAL CONST $GDIP_DITHERTYPEDUALSPIRAL4X4 = 8
GLOBAL CONST $GDIP_DITHERTYPEDUALSPIRAL8X8 = 9
GLOBAL CONST $GDIP_DITHERTYPEERRORDIFFUSION = 10
GLOBAL CONST $GDIP_DITHERTYPEMAX = 10
GLOBAL CONST $GDIP_HISTOGRAMFORMATARGB = 0
GLOBAL CONST $GDIP_HISTOGRAMFORMATPARGB = 1
GLOBAL CONST $GDIP_HISTOGRAMFORMATRGB = 2
GLOBAL CONST $GDIP_HISTOGRAMFORMATGRAY = 3
GLOBAL CONST $GDIP_HISTOGRAMFORMATB = 4
GLOBAL CONST $GDIP_HISTOGRAMFORMATG = 5
GLOBAL CONST $GDIP_HISTOGRAMFORMATR = 6
GLOBAL CONST $GDIP_HISTOGRAMFORMATA = 7
GLOBAL CONST $GDIP_TEXTRENDERINGHINTSYSTEMDEFAULT = 0
GLOBAL CONST $GDIP_TEXTRENDERINGHINTSINGLEBITPERPIXELGRIDFIT = 1
GLOBAL CONST $GDIP_TEXTRENDERINGHINTSINGLEBITPERPIXEL = 2
GLOBAL CONST $GDIP_TEXTRENDERINGHINTANTIALIASGRIDFIT = 3
GLOBAL CONST $GDIP_TEXTRENDERINGHINTANTIALIAS = 4
GLOBAL CONST $GDIP_TEXTRENDERINGHINTCLEARTYPEGRIDFIT = 5
GLOBAL CONST $GDIP_ROTATENONEFLIPNONE = 0
GLOBAL CONST $GDIP_ROTATE90FLIPNONE = 1
GLOBAL CONST $GDIP_ROTATE180FLIPNONE = 2
GLOBAL CONST $GDIP_ROTATE270FLIPNONE = 3
GLOBAL CONST $GDIP_ROTATENONEFLIPX = 4
GLOBAL CONST $GDIP_ROTATE90FLIPX = 5
GLOBAL CONST $GDIP_ROTATE180FLIPX = 6
GLOBAL CONST $GDIP_ROTATE270FLIPX = 7
GLOBAL CONST $GDIP_ROTATENONEFLIPY = $GDIP_ROTATE180FLIPX
GLOBAL CONST $GDIP_ROTATE90FLIPY = $GDIP_ROTATE270FLIPX
GLOBAL CONST $GDIP_ROTATE180FLIPY = $GDIP_ROTATENONEFLIPX
GLOBAL CONST $GDIP_ROTATE270FLIPY = $GDIP_ROTATE90FLIPX
GLOBAL CONST $GDIP_ROTATENONEFLIPXY = $GDIP_ROTATE180FLIPNONE
GLOBAL CONST $GDIP_ROTATE90FLIPXY = $GDIP_ROTATE270FLIPNONE
GLOBAL CONST $GDIP_ROTATE270FLIPXY = $GDIP_ROTATE90FLIPNONE
GLOBAL CONST $GDIP_FRAMEDIMENSION_TIME = "{6AEDBD6D-3FB5-418A-83A6-7F45229DC872}"
GLOBAL CONST $GDIP_FRAMEDIMENSION_RESOLUTION = "{84236F7B-3BD3-428F-8DAB-4EA1439CA315}"
GLOBAL CONST $GDIP_FRAMEDIMENSION_PAGE = "{7462DC86-6180-4C7E-8E3F-EE7333A7A483}"
GLOBAL CONST $GDIP_COLORADJUSTTYPE_DEFAULT = 0
GLOBAL CONST $GDIP_COLORADJUSTTYPE_BITMAP = 1
GLOBAL CONST $GDIP_COLORADJUSTTYPE_BRUSH = 2
GLOBAL CONST $GDIP_COLORADJUSTTYPE_PEN = 3
GLOBAL CONST $GDIP_COLORADJUSTTYPE_TEXT = 4
GLOBAL CONST $GDIP_COLORADJUSTTYPE_COUNT = 5
GLOBAL CONST $GDIP_COLORADJUSTTYPE_ANY = 6
GLOBAL CONST $COINIT_APARTMENTTHREADED = 2
GLOBAL CONST $COINIT_DISABLE_OLE1DDE = 4
GLOBAL CONST $COINIT_MULTITHREADED = 0
GLOBAL CONST $COINIT_SPEED_OVER_MEMORY = 8
#Region Global Variables and Constants
	GLOBAL CONST $__TAGWINAPICOM_GUID = "struct;ulong Data1;ushort Data2;ushort Data3;byte Data4[8];endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_CLSIDFROMPROGID($SPROGID)
		LOCAL $TGUID = DLLSTRUCTCREATE($__TAGWINAPICOM_GUID)
		LOCAL $ARETURN = DLLCALL("ole32.dll", "long", "CLSIDFromProgID", "wstr", $SPROGID, "struct*", $TGUID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARETURN[0] THEN RETURN SETERROR(10, $ARETURN[0], "")
		$ARETURN = DLLCALL("ole32.dll", "int", "StringFromGUID2", "struct*", $TGUID, "wstr", "", "int", 39)
		IF @ERROR OR NOT $ARETURN[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		RETURN $ARETURN[2]
	ENDFUNC
	FUNC _WINAPI_COINITIALIZE($IFLAGS = 0)
		LOCAL $ARETURN = DLLCALL("ole32.dll", "long", "CoInitializeEx", "ptr", 0, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARETURN[0] THEN RETURN SETERROR(10, $ARETURN[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_COTASKMEMALLOC($ISIZE)
		LOCAL $ARETURN = DLLCALL("ole32.dll", "ptr", "CoTaskMemAlloc", "uint_ptr", $ISIZE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARETURN[0]
	ENDFUNC
	FUNC _WINAPI_COTASKMEMFREE($PMEMORY)
		DLLCALL("ole32.dll", "none", "CoTaskMemFree", "ptr", $PMEMORY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_COTASKMEMREALLOC($PMEMORY, $ISIZE)
		LOCAL $ARETURN = DLLCALL("ole32.dll", "ptr", "CoTaskMemRealloc", "ptr", $PMEMORY, "ulong_ptr", $ISIZE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARETURN[0]
	ENDFUNC
	FUNC _WINAPI_COUNINITIALIZE()
		DLLCALL("ole32.dll", "none", "CoUninitialize")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_CREATEGUID()
		LOCAL $TGUID = DLLSTRUCTCREATE($__TAGWINAPICOM_GUID)
		LOCAL $ARETURN = DLLCALL("ole32.dll", "long", "CoCreateGuid", "struct*", $TGUID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARETURN[0] THEN RETURN SETERROR(10, $ARETURN[0], "")
		$ARETURN = DLLCALL("ole32.dll", "int", "StringFromGUID2", "struct*", $TGUID, "wstr", "", "int", 65536)
		IF @ERROR OR NOT $ARETURN[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		RETURN $ARETURN[2]
	ENDFUNC
	FUNC _WINAPI_CREATESTREAMONHGLOBAL($HGLOBAL = 0, $BDELETEONRELEASE = TRUE)
		LOCAL $ARETURN = DLLCALL("ole32.dll", "long", "CreateStreamOnHGlobal", "handle", $HGLOBAL, "bool", $BDELETEONRELEASE, "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARETURN[0] THEN RETURN SETERROR(10, $ARETURN[0], 0)
		RETURN $ARETURN[3]
	ENDFUNC
	FUNC _WINAPI_GETHGLOBALFROMSTREAM($PSTREAM)
		LOCAL $ARETURN = DLLCALL("ole32.dll", "uint", "GetHGlobalFromStream", "ptr", $PSTREAM, "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARETURN[0] THEN RETURN SETERROR(10, $ARETURN[0], 0)
		RETURN $ARETURN[2]
	ENDFUNC
	FUNC _WINAPI_PROGIDFROMCLSID($SCLSID)
		LOCAL $TGUID = DLLSTRUCTCREATE($__TAGWINAPICOM_GUID)
		LOCAL $ARETURN = DLLCALL("ole32.dll", "uint", "CLSIDFromString", "wstr", $SCLSID, "struct*", $TGUID)
		IF @ERROR OR $ARETURN[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		$ARETURN = DLLCALL("ole32.dll", "uint", "ProgIDFromCLSID", "struct*", $TGUID, "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARETURN[0] THEN RETURN SETERROR(10, $ARETURN[0], "")
		LOCAL $SID = _WINAPI_GETSTRING($ARETURN[2])
		_WINAPI_COTASKMEMFREE($ARETURN[2])
		RETURN $SID
	ENDFUNC
	FUNC _WINAPI_RELEASESTREAM($PSTREAM)
		LOCAL $ARETURN = DLLCALL("oleaut32.dll", "long", "DispCallFunc", "ptr", $PSTREAM, "ulong_ptr", 8 * (1 + @AUTOITX64), "uint", 4, "ushort", 23, "uint", 0, "ptr", 0, "ptr", 0, "str", "")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARETURN[0] THEN RETURN SETERROR(10, $ARETURN[0], 0)
		RETURN 1
	ENDFUNC
#EndRegion Public Functions
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_CHARTOOEM($SSTR)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "CharToOemW", "wstr", $SSTR, "wstr", "")
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_CLIENTTOSCREEN($HWND, BYREF $TPOINT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "ClientToScreen", "hwnd", $HWND, "struct*", $TPOINT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_DWORDTOFLOAT($IVALUE)
		LOCAL $TDWORD = DLLSTRUCTCREATE("dword")
		LOCAL $TFLOAT = DLLSTRUCTCREATE("float", DLLSTRUCTGETPTR($TDWORD))
		DLLSTRUCTSETDATA($TDWORD, 1, $IVALUE)
		RETURN DLLSTRUCTGETDATA($TFLOAT, 1)
	ENDFUNC
	FUNC _WINAPI_DWORDTOINT($IVALUE)
		LOCAL $TDATA = DLLSTRUCTCREATE("int")
		DLLSTRUCTSETDATA($TDATA, 1, $IVALUE)
		RETURN DLLSTRUCTGETDATA($TDATA, 1)
	ENDFUNC
	FUNC _WINAPI_FLOATTODWORD($IVALUE)
		LOCAL $TFLOAT = DLLSTRUCTCREATE("float")
		LOCAL $TDWORD = DLLSTRUCTCREATE("dword", DLLSTRUCTGETPTR($TFLOAT))
		DLLSTRUCTSETDATA($TFLOAT, 1, $IVALUE)
		RETURN DLLSTRUCTGETDATA($TDWORD, 1)
	ENDFUNC
	FUNC _WINAPI_FLOATTOINT($NFLOAT)
		LOCAL $TFLOAT = DLLSTRUCTCREATE("float")
		LOCAL $TINT = DLLSTRUCTCREATE("int", DLLSTRUCTGETPTR($TFLOAT))
		DLLSTRUCTSETDATA($TFLOAT, 1, $NFLOAT)
		RETURN DLLSTRUCTGETDATA($TINT, 1)
	ENDFUNC
	FUNC _WINAPI_GETXYFROMPOINT(BYREF $TPOINT, BYREF $IX, BYREF $IY)
		$IX = DLLSTRUCTGETDATA($TPOINT, "X")
		$IY = DLLSTRUCTGETDATA($TPOINT, "Y")
	ENDFUNC
	FUNC _WINAPI_GUIDFROMSTRING($SGUID)
		LOCAL $TGUID = DLLSTRUCTCREATE($TAGGUID)
		_WINAPI_GUIDFROMSTRINGEX($SGUID, $TGUID)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TGUID
	ENDFUNC
	FUNC _WINAPI_GUIDFROMSTRINGEX($SGUID, $TGUID)
		LOCAL $ARESULT = DLLCALL("ole32.dll", "long", "CLSIDFromString", "wstr", $SGUID, "struct*", $TGUID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_HASHDATA($PMEMORY, $ISIZE, $ILENGTH = 32)
		IF($ILENGTH <= 0) OR($ILENGTH > 256) THEN RETURN SETERROR(11, 0, 0)
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[" & $ILENGTH & "]")
		LOCAL $ARET = DLLCALL("shlwapi.dll", "uint", "HashData", "struct*", $PMEMORY, "dword", $ISIZE, "struct*", $TDATA, "dword", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN DLLSTRUCTGETDATA($TDATA, 1)
	ENDFUNC
	FUNC _WINAPI_HASHSTRING($SSTRING, $BCASESENSITIVE = TRUE, $ILENGTH = 32)
		LOCAL $ILENGTHS = STRINGLEN($SSTRING)
		IF NOT $ILENGTHS OR($ILENGTH > 256) THEN RETURN SETERROR(12, 0, 0)
		LOCAL $TSTRING = DLLSTRUCTCREATE("wchar[" & ($ILENGTHS + 1) & "]")
		IF NOT $BCASESENSITIVE THEN
			$SSTRING = STRINGLOWER($SSTRING)
		ENDIF
		DLLSTRUCTSETDATA($TSTRING, 1, $SSTRING)
		LOCAL $SHASH = _WINAPI_HASHDATA($TSTRING, 2 * $ILENGTHS, $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $SHASH
	ENDFUNC
	FUNC _WINAPI_HIBYTE($IVALUE)
		RETURN BITAND(BITSHIFT($IVALUE, 8), 255)
	ENDFUNC
	FUNC _WINAPI_HIDWORD($IVALUE)
		LOCAL $TINT64 = DLLSTRUCTCREATE("int64")
		LOCAL $TQWORD = DLLSTRUCTCREATE("dword;dword", DLLSTRUCTGETPTR($TINT64))
		DLLSTRUCTSETDATA($TINT64, 1, $IVALUE)
		RETURN DLLSTRUCTGETDATA($TQWORD, 2)
	ENDFUNC
	FUNC _WINAPI_HIWORD($ILONG)
		RETURN BITSHIFT($ILONG, 16)
	ENDFUNC
	FUNC _WINAPI_INTTODWORD($IVALUE)
		LOCAL $TDATA = DLLSTRUCTCREATE("dword")
		DLLSTRUCTSETDATA($TDATA, 1, $IVALUE)
		RETURN DLLSTRUCTGETDATA($TDATA, 1)
	ENDFUNC
	FUNC _WINAPI_INTTOFLOAT($IINT)
		LOCAL $TINT = DLLSTRUCTCREATE("int")
		LOCAL $TFLOAT = DLLSTRUCTCREATE("float", DLLSTRUCTGETPTR($TINT))
		DLLSTRUCTSETDATA($TINT, 1, $IINT)
		RETURN DLLSTRUCTGETDATA($TFLOAT, 1)
	ENDFUNC
	FUNC _WINAPI_LOBYTE($IVALUE)
		RETURN BITAND($IVALUE, 255)
	ENDFUNC
	FUNC _WINAPI_LODWORD($IVALUE)
		LOCAL $TINT64 = DLLSTRUCTCREATE("int64")
		LOCAL $TQWORD = DLLSTRUCTCREATE("dword;dword", DLLSTRUCTGETPTR($TINT64))
		DLLSTRUCTSETDATA($TINT64, 1, $IVALUE)
		RETURN DLLSTRUCTGETDATA($TQWORD, 1)
	ENDFUNC
	FUNC _WINAPI_LOWORD($ILONG)
		RETURN BITAND($ILONG, 65535)
	ENDFUNC
	FUNC _WINAPI_LONGMID($IVALUE, $ISTART, $ICOUNT)
		RETURN BITAND(BITSHIFT($IVALUE, $ISTART), BITOR(BITSHIFT(BITSHIFT(2147483647, 32 - ($ICOUNT + 1)), 1), BITSHIFT(1, -($ICOUNT - 1))))
	ENDFUNC
	FUNC _WINAPI_MAKELANGID($ILNGIDPRIMARY, $ILNGIDSUB)
		RETURN BITOR(BITSHIFT($ILNGIDSUB, -10), $ILNGIDPRIMARY)
	ENDFUNC
	FUNC _WINAPI_MAKELCID($ILNGID, $ISORTID)
		RETURN BITOR(BITSHIFT($ISORTID, -16), $ILNGID)
	ENDFUNC
	FUNC _WINAPI_MAKELONG($ILO, $IHI)
		RETURN BITOR(BITSHIFT($IHI, -16), BITAND($ILO, 65535))
	ENDFUNC
	FUNC _WINAPI_MAKEQWORD($ILODWORD, $IHIDWORD)
		LOCAL $TINT64 = DLLSTRUCTCREATE("uint64")
		LOCAL $TDWORDS = DLLSTRUCTCREATE("dword;dword", DLLSTRUCTGETPTR($TINT64))
		DLLSTRUCTSETDATA($TDWORDS, 1, $ILODWORD)
		DLLSTRUCTSETDATA($TDWORDS, 2, $IHIDWORD)
		RETURN DLLSTRUCTGETDATA($TINT64, 1)
	ENDFUNC
	FUNC _WINAPI_MAKEWORD($ILO, $IHI)
		LOCAL $TWORD = DLLSTRUCTCREATE("ushort")
		LOCAL $TBYTE = DLLSTRUCTCREATE("byte;byte", DLLSTRUCTGETPTR($TWORD))
		DLLSTRUCTSETDATA($TBYTE, 1, $IHI)
		DLLSTRUCTSETDATA($TBYTE, 2, $ILO)
		RETURN DLLSTRUCTGETDATA($TWORD, 1)
	ENDFUNC
	FUNC _WINAPI_MULTIBYTETOWIDECHAR($VTEXT, $ICODEPAGE = 0, $IFLAGS = 0, $BRETSTRING = FALSE)
		LOCAL $STEXTTYPE = "str"
		IF NOT ISSTRING($VTEXT) THEN $STEXTTYPE = "struct*"
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "int", "MultiByteToWideChar", "uint", $ICODEPAGE, "dword", $IFLAGS, $STEXTTYPE, $VTEXT, "int", -1, "ptr", 0, "int", 0)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $IOUT = $ARESULT[0]
		LOCAL $TOUT = DLLSTRUCTCREATE("wchar[" & $IOUT & "]")
		$ARESULT = DLLCALL("kernel32.dll", "int", "MultiByteToWideChar", "uint", $ICODEPAGE, "dword", $IFLAGS, $STEXTTYPE, $VTEXT, "int", -1, "struct*", $TOUT, "int", $IOUT)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		IF $BRETSTRING THEN RETURN DLLSTRUCTGETDATA($TOUT, 1)
		RETURN $TOUT
	ENDFUNC
	FUNC _WINAPI_MULTIBYTETOWIDECHAREX($STEXT, $PTEXT, $ICODEPAGE = 0, $IFLAGS = 0)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "int", "MultiByteToWideChar", "uint", $ICODEPAGE, "dword", $IFLAGS, "STR", $STEXT, "int", -1, "struct*", $PTEXT, "int", (STRINGLEN($STEXT) + 1) * 2)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_OEMTOCHAR($SSTR)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "OemToChar", "str", $SSTR, "str", "")
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_POINTFROMRECT(BYREF $TRECT, $BCENTER = TRUE)
		LOCAL $IX1 = DLLSTRUCTGETDATA($TRECT, "Left")
		LOCAL $IY1 = DLLSTRUCTGETDATA($TRECT, "Top")
		LOCAL $IX2 = DLLSTRUCTGETDATA($TRECT, "Right")
		LOCAL $IY2 = DLLSTRUCTGETDATA($TRECT, "Bottom")
		IF $BCENTER THEN
			$IX1 = $IX1 + (($IX2 - $IX1) / 2)
			$IY1 = $IY1 + (($IY2 - $IY1) / 2)
		ENDIF
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		DLLSTRUCTSETDATA($TPOINT, "X", $IX1)
		DLLSTRUCTSETDATA($TPOINT, "Y", $IY1)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_PRIMARYLANGID($ILNGID)
		RETURN BITAND($ILNGID, 1023)
	ENDFUNC
	FUNC _WINAPI_SCREENTOCLIENT($HWND, BYREF $TPOINT)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "ScreenToClient", "hwnd", $HWND, "struct*", $TPOINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SHORTTOWORD($IVALUE)
		RETURN BITAND($IVALUE, 65535)
	ENDFUNC
	FUNC _WINAPI_STRFORMATBYTESIZE($ISIZE)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "ptr", "StrFormatByteSizeW", "int64", $ISIZE, "wstr", "", "uint", 1024)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_STRFORMATBYTESIZEEX($ISIZE)
		LOCAL $ASYMBOL = DLLCALL("kernel32.dll", "int", "GetLocaleInfoW", "dword", 1024, "dword", 15, "wstr", "", "int", 2048)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		LOCAL $SSIZE = _WINAPI_STRFORMATBYTESIZE(0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN STRINGREPLACE($SSIZE, "0", STRINGREGEXPREPLACE(NUMBER($ISIZE), "(?<=\d)(?=(\d{3})+\z)", $ASYMBOL[3]))
	ENDFUNC
	FUNC _WINAPI_STRFORMATKBSIZE($ISIZE)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "ptr", "StrFormatKBSizeW", "int64", $ISIZE, "wstr", "", "uint", 1024)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_STRFROMTIMEINTERVAL($ITIME, $IDIGITS = 7)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "int", "StrFromTimeIntervalW", "wstr", "", "uint", 1024, "dword", $ITIME, "int", $IDIGITS)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN STRINGSTRIPWS($ARET[1], $STR_STRIPLEADING + $STR_STRIPTRAILING)
	ENDFUNC
	FUNC _WINAPI_STRINGFROMGUID($TGUID)
		LOCAL $ARESULT = DLLCALL("ole32.dll", "int", "StringFromGUID2", "struct*", $TGUID, "wstr", "", "int", 40)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN SETEXTENDED($ARESULT[0], $ARESULT[2])
	ENDFUNC
	FUNC _WINAPI_SUBLANGID($ILNGID)
		RETURN BITSHIFT($ILNGID, 10)
	ENDFUNC
	FUNC _WINAPI_SWAPDWORD($IVALUE)
		LOCAL $TSTRUCT1 = DLLSTRUCTCREATE("dword;dword")
		LOCAL $TSTRUCT2 = DLLSTRUCTCREATE("byte[4];byte[4]", DLLSTRUCTGETPTR($TSTRUCT1))
		DLLSTRUCTSETDATA($TSTRUCT1, 1, $IVALUE)
		FOR $I = 1 TO 4
			DLLSTRUCTSETDATA($TSTRUCT2, 2, DLLSTRUCTGETDATA($TSTRUCT2, 1, 5 - $I), $I)
		NEXT
		RETURN DLLSTRUCTGETDATA($TSTRUCT1, 2)
	ENDFUNC
	FUNC _WINAPI_SWAPQWORD($IVALUE)
		LOCAL $TSTRUCT1 = DLLSTRUCTCREATE("int64;int64")
		LOCAL $TSTRUCT2 = DLLSTRUCTCREATE("byte[8];byte[8]", DLLSTRUCTGETPTR($TSTRUCT1))
		DLLSTRUCTSETDATA($TSTRUCT1, 1, $IVALUE)
		FOR $I = 1 TO 8
			DLLSTRUCTSETDATA($TSTRUCT2, 2, DLLSTRUCTGETDATA($TSTRUCT2, 1, 9 - $I), $I)
		NEXT
		RETURN DLLSTRUCTGETDATA($TSTRUCT1, 2)
	ENDFUNC
	FUNC _WINAPI_SWAPWORD($IVALUE)
		LOCAL $TSTRUCT1 = DLLSTRUCTCREATE("word;word")
		LOCAL $TSTRUCT2 = DLLSTRUCTCREATE("byte[2];byte[2]", DLLSTRUCTGETPTR($TSTRUCT1))
		DLLSTRUCTSETDATA($TSTRUCT1, 1, $IVALUE)
		FOR $I = 1 TO 2
			DLLSTRUCTSETDATA($TSTRUCT2, 2, DLLSTRUCTGETDATA($TSTRUCT2, 1, 3 - $I), $I)
		NEXT
		RETURN DLLSTRUCTGETDATA($TSTRUCT1, 2)
	ENDFUNC
	FUNC _WINAPI_WIDECHARTOMULTIBYTE($VUNICODE, $ICODEPAGE = 0, $BRETNOSTRUCT = TRUE, $BRETBINARY = FALSE)
		LOCAL $SUNICODETYPE = "wstr"
		IF NOT ISSTRING($VUNICODE) THEN $SUNICODETYPE = "struct*"
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "int", "WideCharToMultiByte", "uint", $ICODEPAGE, "dword", 0, $SUNICODETYPE, $VUNICODE, "int", -1, "ptr", 0, "int", 0, "ptr", 0, "ptr", 0)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		LOCAL $TMULTIBYTE = DLLSTRUCTCREATE((($BRETBINARY) ? ("byte") : ("char")) & "[" & $ARESULT[0] & "]")
		$ARESULT = DLLCALL("kernel32.dll", "int", "WideCharToMultiByte", "uint", $ICODEPAGE, "dword", 0, $SUNICODETYPE, $VUNICODE, "int", -1, "struct*", $TMULTIBYTE, "int", $ARESULT[0], "ptr", 0, "ptr", 0)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		IF $BRETNOSTRUCT THEN RETURN DLLSTRUCTGETDATA($TMULTIBYTE, 1)
		RETURN $TMULTIBYTE
	ENDFUNC
	FUNC _WINAPI_WORDTOSHORT($IVALUE)
		IF BITAND($IVALUE, 32768) THEN
			RETURN BITOR($IVALUE, -32768)
		ENDIF
		RETURN BITAND($IVALUE, 32767)
	ENDFUNC
#EndRegion Public Functions
GLOBAL CONST $FR_PRIVATE = 16
GLOBAL CONST $FR_NOT_ENUM = 32
GLOBAL CONST $COMPRESSION_BITMAP_PNG = 0
GLOBAL CONST $COMPRESSION_BITMAP_JPEG = 1
GLOBAL CONST $BS_DIBPATTERN = 5
GLOBAL CONST $BS_DIBPATTERN8X8 = 8
GLOBAL CONST $BS_DIBPATTERNPT = 6
GLOBAL CONST $BS_HATCHED = 2
GLOBAL CONST $BS_HOLLOW = 1
GLOBAL CONST $BS_NULL = 1
GLOBAL CONST $BS_PATTERN = 3
GLOBAL CONST $BS_PATTERN8X8 = 7
GLOBAL CONST $BS_SOLID = 0
GLOBAL CONST $HS_BDIAGONAL = 3
GLOBAL CONST $HS_CROSS = 4
GLOBAL CONST $HS_DIAGCROSS = 5
GLOBAL CONST $HS_FDIAGONAL = 2
GLOBAL CONST $HS_HORIZONTAL = 0
GLOBAL CONST $HS_VERTICAL = 1
GLOBAL CONST $DIB_PAL_COLORS = 1
GLOBAL CONST $DIB_RGB_COLORS = 0
GLOBAL CONST $CA_NEGATIVE = 1
GLOBAL CONST $CA_LOG_FILTER = 2
GLOBAL CONST $ILLUMINANT_DEVICE_DEFAULT = 0
GLOBAL CONST $ILLUMINANT_A = 1
GLOBAL CONST $ILLUMINANT_B = 2
GLOBAL CONST $ILLUMINANT_C = 3
GLOBAL CONST $ILLUMINANT_D50 = 4
GLOBAL CONST $ILLUMINANT_D55 = 5
GLOBAL CONST $ILLUMINANT_D65 = 6
GLOBAL CONST $ILLUMINANT_D75 = 7
GLOBAL CONST $ILLUMINANT_F2 = 8
GLOBAL CONST $ILLUMINANT_TUNGSTEN = $ILLUMINANT_A
GLOBAL CONST $ILLUMINANT_DAYLIGHT = $ILLUMINANT_C
GLOBAL CONST $ILLUMINANT_FLUORESCENT = $ILLUMINANT_F2
GLOBAL CONST $ILLUMINANT_NTSC = $ILLUMINANT_C
GLOBAL CONST $BI_RGB = 0
GLOBAL CONST $BI_RLE8 = 1
GLOBAL CONST $BI_RLE4 = 2
GLOBAL CONST $BI_BITFIELDS = 3
GLOBAL CONST $BI_JPEG = 4
GLOBAL CONST $BI_PNG = 5
GLOBAL CONST $ALTERNATE = 1
GLOBAL CONST $WINDING = 2
GLOBAL CONST $DWMWA_NCRENDERING_ENABLED = 1
GLOBAL CONST $DWMWA_NCRENDERING_POLICY = 2
GLOBAL CONST $DWMWA_TRANSITIONS_FORCEDISABLED = 3
GLOBAL CONST $DWMWA_ALLOW_NCPAINT = 4
GLOBAL CONST $DWMWA_CAPTION_BUTTON_BOUNDS = 5
GLOBAL CONST $DWMWA_NONCLIENT_RTL_LAYOUT = 6
GLOBAL CONST $DWMWA_FORCE_ICONIC_REPRESENTATION = 7
GLOBAL CONST $DWMWA_FLIP3D_POLICY = 8
GLOBAL CONST $DWMWA_EXTENDED_FRAME_BOUNDS = 9
GLOBAL CONST $DWMWA_HAS_ICONIC_BITMAP = 10
GLOBAL CONST $DWMWA_DISALLOW_PEEK = 11
GLOBAL CONST $DWMWA_EXCLUDED_FROM_PEEK = 12
GLOBAL CONST $DWMNCRP_USEWINDOWSTYLE = 0
GLOBAL CONST $DWMNCRP_DISABLED = 1
GLOBAL CONST $DWMNCRP_ENABLED = 2
GLOBAL CONST $DWMFLIP3D_DEFAULT = 0
GLOBAL CONST $DWMFLIP3D_EXCLUDEBELOW = 1
GLOBAL CONST $DWMFLIP3D_EXCLUDEABOVE = 2
GLOBAL CONST $DM_BITSPERPEL = 262144
GLOBAL CONST $DM_COLLATE = 32768
GLOBAL CONST $DM_COLOR = 2048
GLOBAL CONST $DM_COPIES = 256
GLOBAL CONST $DM_DEFAULTSOURCE = 512
GLOBAL CONST $DM_DISPLAYFIXEDOUTPUT = 536870912
GLOBAL CONST $DM_DISPLAYFLAGS = 2097152
GLOBAL CONST $DM_DISPLAYFREQUENCY = 4194304
GLOBAL CONST $DM_DISPLAYORIENTATION = 128
GLOBAL CONST $DM_DITHERTYPE = 67108864
GLOBAL CONST $DM_DUPLEX = 4096
GLOBAL CONST $DM_FORMNAME = 65536
GLOBAL CONST $DM_ICMINTENT = 16777216
GLOBAL CONST $DM_ICMMETHOD = 8388608
GLOBAL CONST $DM_LOGPIXELS = 131072
GLOBAL CONST $DM_MEDIATYPE = 33554432
GLOBAL CONST $DM_NUP = 64
GLOBAL CONST $DM_ORIENTATION = 1
GLOBAL CONST $DM_PANNINGHEIGHT = 268435456
GLOBAL CONST $DM_PANNINGWIDTH = 134217728
GLOBAL CONST $DM_PAPERLENGTH = 4
GLOBAL CONST $DM_PAPERSIZE = 2
GLOBAL CONST $DM_PAPERWIDTH = 8
GLOBAL CONST $DM_PELSHEIGHT = 1048576
GLOBAL CONST $DM_PELSWIDTH = 524288
GLOBAL CONST $DM_POSITION = 32
GLOBAL CONST $DM_PRINTQUALITY = 1024
GLOBAL CONST $DM_SCALE = 16
GLOBAL CONST $DM_TTOPTION = 16384
GLOBAL CONST $DM_YRESOLUTION = 8192
GLOBAL CONST $DMPAPER_LETTER = 1
GLOBAL CONST $DMPAPER_LETTERSMALL = 2
GLOBAL CONST $DMPAPER_TABLOID = 3
GLOBAL CONST $DMPAPER_LEDGER = 4
GLOBAL CONST $DMPAPER_LEGAL = 5
GLOBAL CONST $DMPAPER_STATEMENT = 6
GLOBAL CONST $DMPAPER_EXECUTIVE = 7
GLOBAL CONST $DMPAPER_A3 = 8
GLOBAL CONST $DMPAPER_A4 = 9
GLOBAL CONST $DMPAPER_A4SMALL = 10
GLOBAL CONST $DMPAPER_A5 = 11
GLOBAL CONST $DMPAPER_B4 = 12
GLOBAL CONST $DMPAPER_B5 = 13
GLOBAL CONST $DMPAPER_FOLIO = 14
GLOBAL CONST $DMPAPER_QUARTO = 15
GLOBAL CONST $DMPAPER_10X14 = 16
GLOBAL CONST $DMPAPER_11X17 = 17
GLOBAL CONST $DMPAPER_NOTE = 18
GLOBAL CONST $DMPAPER_ENV_9 = 19
GLOBAL CONST $DMPAPER_ENV_10 = 20
GLOBAL CONST $DMPAPER_ENV_11 = 21
GLOBAL CONST $DMPAPER_ENV_12 = 22
GLOBAL CONST $DMPAPER_ENV_14 = 23
GLOBAL CONST $DMPAPER_CSHEET = 24
GLOBAL CONST $DMPAPER_DSHEET = 25
GLOBAL CONST $DMPAPER_ESHEET = 26
GLOBAL CONST $DMPAPER_ENV_DL = 27
GLOBAL CONST $DMPAPER_ENV_C5 = 28
GLOBAL CONST $DMPAPER_ENV_C3 = 29
GLOBAL CONST $DMPAPER_ENV_C4 = 30
GLOBAL CONST $DMPAPER_ENV_C6 = 31
GLOBAL CONST $DMPAPER_ENV_C65 = 32
GLOBAL CONST $DMPAPER_ENV_B4 = 33
GLOBAL CONST $DMPAPER_ENV_B5 = 34
GLOBAL CONST $DMPAPER_ENV_B6 = 35
GLOBAL CONST $DMPAPER_ENV_ITALY = 36
GLOBAL CONST $DMPAPER_ENV_MONARCH = 37
GLOBAL CONST $DMPAPER_ENV_PERSONAL = 38
GLOBAL CONST $DMPAPER_FANFOLD_US = 39
GLOBAL CONST $DMPAPER_FANFOLD_STD_GERMAN = 40
GLOBAL CONST $DMPAPER_FANFOLD_LGL_GERMAN = 41
GLOBAL CONST $DMPAPER_ISO_B4 = 42
GLOBAL CONST $DMPAPER_JAPANESE_POSTCARD = 43
GLOBAL CONST $DMPAPER_9X11 = 44
GLOBAL CONST $DMPAPER_10X11 = 45
GLOBAL CONST $DMPAPER_15X11 = 46
GLOBAL CONST $DMPAPER_ENV_INVITE = 47
GLOBAL CONST $DMPAPER_RESERVED_48 = 48
GLOBAL CONST $DMPAPER_RESERVED_49 = 49
GLOBAL CONST $DMPAPER_LETTER_EXTRA = 50
GLOBAL CONST $DMPAPER_LEGAL_EXTRA = 51
GLOBAL CONST $DMPAPER_TABLOID_EXTRA = 52
GLOBAL CONST $DMPAPER_A4_EXTRA = 53
GLOBAL CONST $DMPAPER_LETTER_TRANSVERSE = 54
GLOBAL CONST $DMPAPER_A4_TRANSVERSE = 55
GLOBAL CONST $DMPAPER_LETTER_EXTRA_TRANSVERSE = 56
GLOBAL CONST $DMPAPER_A_PLUS = 57
GLOBAL CONST $DMPAPER_B_PLUS = 58
GLOBAL CONST $DMPAPER_LETTER_PLUS = 59
GLOBAL CONST $DMPAPER_A4_PLUS = 60
GLOBAL CONST $DMPAPER_A5_TRANSVERSE = 61
GLOBAL CONST $DMPAPER_B5_TRANSVERSE = 62
GLOBAL CONST $DMPAPER_A3_EXTRA = 63
GLOBAL CONST $DMPAPER_A5_EXTRA = 64
GLOBAL CONST $DMPAPER_B5_EXTRA = 65
GLOBAL CONST $DMPAPER_A2 = 66
GLOBAL CONST $DMPAPER_A3_TRANSVERSE = 67
GLOBAL CONST $DMPAPER_A3_EXTRA_TRANSVERSE = 68
GLOBAL CONST $DMPAPER_DBL_JAPANESE_POSTCARD = 69
GLOBAL CONST $DMPAPER_A6 = 70
GLOBAL CONST $DMPAPER_JENV_KAKU2 = 71
GLOBAL CONST $DMPAPER_JENV_KAKU3 = 72
GLOBAL CONST $DMPAPER_JENV_CHOU3 = 73
GLOBAL CONST $DMPAPER_JENV_CHOU4 = 74
GLOBAL CONST $DMPAPER_LETTER_ROTATED = 75
GLOBAL CONST $DMPAPER_A3_ROTATED = 76
GLOBAL CONST $DMPAPER_A4_ROTATED = 77
GLOBAL CONST $DMPAPER_A5_ROTATED = 78
GLOBAL CONST $DMPAPER_B4_JIS_ROTATED = 79
GLOBAL CONST $DMPAPER_B5_JIS_ROTATED = 80
GLOBAL CONST $DMPAPER_JAPANESE_POSTCARD_ROTATED = 81
GLOBAL CONST $DMPAPER_DBL_JAPANESE_POSTCARD_ROTATED = 82
GLOBAL CONST $DMPAPER_A6_ROTATED = 83
GLOBAL CONST $DMPAPER_JENV_KAKU2_ROTATED = 84
GLOBAL CONST $DMPAPER_JENV_KAKU3_ROTATED = 85
GLOBAL CONST $DMPAPER_JENV_CHOU3_ROTATED = 86
GLOBAL CONST $DMPAPER_JENV_CHOU4_ROTATED = 87
GLOBAL CONST $DMPAPER_B6_JIS = 88
GLOBAL CONST $DMPAPER_B6_JIS_ROTATED = 89
GLOBAL CONST $DMPAPER_12X11 = 90
GLOBAL CONST $DMPAPER_JENV_YOU4 = 91
GLOBAL CONST $DMPAPER_JENV_YOU4_ROTATED = 92
GLOBAL CONST $DMPAPER_P16K = 93
GLOBAL CONST $DMPAPER_P32K = 94
GLOBAL CONST $DMPAPER_P32KBIG = 95
GLOBAL CONST $DMPAPER_PENV_1 = 96
GLOBAL CONST $DMPAPER_PENV_2 = 97
GLOBAL CONST $DMPAPER_PENV_3 = 98
GLOBAL CONST $DMPAPER_PENV_4 = 99
GLOBAL CONST $DMPAPER_PENV_5 = 100
GLOBAL CONST $DMPAPER_PENV_6 = 101
GLOBAL CONST $DMPAPER_PENV_7 = 102
GLOBAL CONST $DMPAPER_PENV_8 = 103
GLOBAL CONST $DMPAPER_PENV_9 = 104
GLOBAL CONST $DMPAPER_PENV_10 = 105
GLOBAL CONST $DMPAPER_P16K_ROTATED = 106
GLOBAL CONST $DMPAPER_P32K_ROTATED = 107
GLOBAL CONST $DMPAPER_P32KBIG_ROTATED = 108
GLOBAL CONST $DMPAPER_PENV_1_ROTATED = 109
GLOBAL CONST $DMPAPER_PENV_2_ROTATED = 110
GLOBAL CONST $DMPAPER_PENV_3_ROTATED = 111
GLOBAL CONST $DMPAPER_PENV_4_ROTATED = 112
GLOBAL CONST $DMPAPER_PENV_5_ROTATED = 113
GLOBAL CONST $DMPAPER_PENV_6_ROTATED = 114
GLOBAL CONST $DMPAPER_PENV_7_ROTATED = 115
GLOBAL CONST $DMPAPER_PENV_8_ROTATED = 116
GLOBAL CONST $DMPAPER_PENV_9_ROTATED = 117
GLOBAL CONST $DMPAPER_PENV_10_ROTATED = 118
GLOBAL CONST $DMPAPER_USER = 256
GLOBAL CONST $DMBIN_UPPER = 1
GLOBAL CONST $DMBIN_LOWER = 2
GLOBAL CONST $DMBIN_MIDDLE = 3
GLOBAL CONST $DMBIN_MANUAL = 4
GLOBAL CONST $DMBIN_ENVELOPE = 5
GLOBAL CONST $DMBIN_ENVMANUAL = 6
GLOBAL CONST $DMBIN_AUTO = 7
GLOBAL CONST $DMBIN_TRACTOR = 8
GLOBAL CONST $DMBIN_SMALLFMT = 9
GLOBAL CONST $DMBIN_LARGEFMT = 10
GLOBAL CONST $DMBIN_LARGECAPACITY = 11
GLOBAL CONST $DMBIN_CASSETTE = 14
GLOBAL CONST $DMBIN_FORMSOURCE = 15
GLOBAL CONST $DMBIN_USER = 256
GLOBAL CONST $DMRES_DRAFT = -1
GLOBAL CONST $DMRES_LOW = -2
GLOBAL CONST $DMRES_MEDIUM = -3
GLOBAL CONST $DMRES_HIGH = -4
GLOBAL CONST $DMDO_DEFAULT = 0
GLOBAL CONST $DMDO_90 = 1
GLOBAL CONST $DMDO_180 = 2
GLOBAL CONST $DMDO_270 = 3
GLOBAL CONST $DMDFO_DEFAULT = 0
GLOBAL CONST $DMDFO_STRETCH = 1
GLOBAL CONST $DMDFO_CENTER = 2
GLOBAL CONST $DMCOLOR_MONOCHROME = 1
GLOBAL CONST $DMCOLOR_COLOR = 2
GLOBAL CONST $DMDUP_SIMPLEX = 1
GLOBAL CONST $DMDUP_VERTICAL = 2
GLOBAL CONST $DMDUP_HORIZONTAL = 3
GLOBAL CONST $DMTT_BITMAP = 1
GLOBAL CONST $DMTT_DOWNLOAD = 2
GLOBAL CONST $DMTT_SUBDEV = 3
GLOBAL CONST $DMTT_DOWNLOAD_OUTLINE = 4
GLOBAL CONST $DMCOLLATE_FALSE = 0
GLOBAL CONST $DMCOLLATE_TRUE = 1
GLOBAL CONST $DM_GRAYSCALE = 1
GLOBAL CONST $DM_INTERLACED = 2
GLOBAL CONST $DMNUP_SYSTEM = 1
GLOBAL CONST $DMNUP_ONEUP = 2
GLOBAL CONST $DMICMMETHOD_NONE = 1
GLOBAL CONST $DMICMMETHOD_SYSTEM = 2
GLOBAL CONST $DMICMMETHOD_DRIVER = 3
GLOBAL CONST $DMICMMETHOD_DEVICE = 4
GLOBAL CONST $DMICMMETHOD_USER = 256
GLOBAL CONST $DMICM_SATURATE = 1
GLOBAL CONST $DMICM_CONTRAST = 2
GLOBAL CONST $DMICM_COLORIMETRIC = 3
GLOBAL CONST $DMICM_ABS_COLORIMETRIC = 4
GLOBAL CONST $DMICM_USER = 256
GLOBAL CONST $DMMEDIA_STANDARD = 1
GLOBAL CONST $DMMEDIA_TRANSPARENCY = 2
GLOBAL CONST $DMMEDIA_GLOSSY = 3
GLOBAL CONST $DMMEDIA_USER = 256
GLOBAL CONST $DMDITHER_NONE = 1
GLOBAL CONST $DMDITHER_COARSE = 2
GLOBAL CONST $DMDITHER_FINE = 3
GLOBAL CONST $DMDITHER_LINEART = 4
GLOBAL CONST $DMDITHER_ERRORDIFFUSION = 5
GLOBAL CONST $DMDITHER_RESERVED6 = 6
GLOBAL CONST $DMDITHER_RESERVED7 = 7
GLOBAL CONST $DMDITHER_RESERVED8 = 8
GLOBAL CONST $DMDITHER_RESERVED9 = 9
GLOBAL CONST $DMDITHER_GRAYSCALE = 10
GLOBAL CONST $DMDITHER_USER = 256
GLOBAL CONST $ENUM_CURRENT_SETTINGS = -1
GLOBAL CONST $ENUM_REGISTRY_SETTINGS = -2
GLOBAL CONST $DEVICE_FONTTYPE = 2
GLOBAL CONST $RASTER_FONTTYPE = 1
GLOBAL CONST $TRUETYPE_FONTTYPE = 4
GLOBAL CONST $NTM_BOLD = 32
GLOBAL CONST $NTM_DSIG = 2097152
GLOBAL CONST $NTM_ITALIC = 1
GLOBAL CONST $NTM_MULTIPLEMASTER = 524288
GLOBAL CONST $NTM_NONNEGATIVE_AC = 65536
GLOBAL CONST $NTM_PS_OPENTYPE = 131072
GLOBAL CONST $NTM_REGULAR = 64
GLOBAL CONST $NTM_TT_OPENTYPE = 262144
GLOBAL CONST $NTM_TYPE1 = 1048576
GLOBAL CONST $FLOODFILLBORDER = 0
GLOBAL CONST $FLOODFILLSURFACE = 1
GLOBAL CONST $AD_COUNTERCLOCKWISE = 1
GLOBAL CONST $AD_CLOCKWISE = 2
GLOBAL CONST $DCB_ACCUMULATE = 2
GLOBAL CONST $DCB_DISABLE = 8
GLOBAL CONST $DCB_ENABLE = 4
GLOBAL CONST $DCB_RESET = 1
GLOBAL CONST $DCB_SET = BITOR($DCB_RESET, $DCB_ACCUMULATE)
GLOBAL CONST $DCX_WINDOW = 1
GLOBAL CONST $DCX_CACHE = 2
GLOBAL CONST $DCX_PARENTCLIP = 32
GLOBAL CONST $DCX_CLIPSIBLINGS = 16
GLOBAL CONST $DCX_CLIPCHILDREN = 8
GLOBAL CONST $DCX_NORESETATTRS = 4
GLOBAL CONST $DCX_LOCKWINDOWUPDATE = 1024
GLOBAL CONST $DCX_EXCLUDERGN = 64
GLOBAL CONST $DCX_INTERSECTRGN = 128
GLOBAL CONST $DCX_INTERSECTUPDATE = 512
GLOBAL CONST $DCX_VALIDATE = 2097152
GLOBAL CONST $GGO_BEZIER = 3
GLOBAL CONST $GGO_BITMAP = 1
GLOBAL CONST $GGO_GLYPH_INDEX = 128
GLOBAL CONST $GGO_GRAY2_BITMAP = 4
GLOBAL CONST $GGO_GRAY4_BITMAP = 5
GLOBAL CONST $GGO_GRAY8_BITMAP = 6
GLOBAL CONST $GGO_METRICS = 0
GLOBAL CONST $GGO_NATIVE = 2
GLOBAL CONST $GGO_UNHINTED = 256
GLOBAL CONST $GM_COMPATIBLE = 1
GLOBAL CONST $GM_ADVANCED = 2
GLOBAL CONST $MM_ANISOTROPIC = 8
GLOBAL CONST $MM_HIENGLISH = 5
GLOBAL CONST $MM_HIMETRIC = 3
GLOBAL CONST $MM_ISOTROPIC = 7
GLOBAL CONST $MM_LOENGLISH = 4
GLOBAL CONST $MM_LOMETRIC = 2
GLOBAL CONST $MM_TEXT = 1
GLOBAL CONST $MM_TWIPS = 6
GLOBAL CONST $R2_BLACK = 1
GLOBAL CONST $R2_COPYPEN = 13
GLOBAL CONST $R2_LAST = 16
GLOBAL CONST $R2_MASKNOTPEN = 3
GLOBAL CONST $R2_MASKPEN = 9
GLOBAL CONST $R2_MASKPENNOT = 5
GLOBAL CONST $R2_MERGENOTPEN = 12
GLOBAL CONST $R2_MERGEPEN = 15
GLOBAL CONST $R2_MERGEPENNOT = 14
GLOBAL CONST $R2_NOP = 11
GLOBAL CONST $R2_NOT = 6
GLOBAL CONST $R2_NOTCOPYPEN = 4
GLOBAL CONST $R2_NOTMASKPEN = 8
GLOBAL CONST $R2_NOTMERGEPEN = 2
GLOBAL CONST $R2_NOTXORPEN = 10
GLOBAL CONST $R2_WHITE = 16
GLOBAL CONST $R2_XORPEN = 7
GLOBAL CONST $BLACKONWHITE = 1
GLOBAL CONST $COLORONCOLOR = 3
GLOBAL CONST $HALFTONE = 4
GLOBAL CONST $WHITEONBLACK = 2
GLOBAL CONST $STRETCH_ANDSCANS = $BLACKONWHITE
GLOBAL CONST $STRETCH_DELETESCANS = $COLORONCOLOR
GLOBAL CONST $STRETCH_HALFTONE = $HALFTONE
GLOBAL CONST $STRETCH_ORSCANS = $WHITEONBLACK
GLOBAL CONST $TA_BASELINE = 24
GLOBAL CONST $TA_BOTTOM = 8
GLOBAL CONST $TA_TOP = 0
GLOBAL CONST $TA_CENTER = 6
GLOBAL CONST $TA_LEFT = 0
GLOBAL CONST $TA_RIGHT = 2
GLOBAL CONST $TA_NOUPDATECP = 0
GLOBAL CONST $TA_RTLREADING = 256
GLOBAL CONST $TA_UPDATECP = 1
GLOBAL CONST $VTA_BASELINE = $TA_BASELINE
GLOBAL CONST $VTA_BOTTOM = $TA_RIGHT
GLOBAL CONST $VTA_TOP = $TA_LEFT
GLOBAL CONST $VTA_CENTER = $TA_CENTER
GLOBAL CONST $VTA_LEFT = $TA_BOTTOM
GLOBAL CONST $VTA_RIGHT = $TA_TOP
GLOBAL CONST $UDF_BGR = 1
GLOBAL CONST $UDF_RGB = 0
GLOBAL CONST $MWT_IDENTITY = 1
GLOBAL CONST $MWT_LEFTMULTIPLY = 2
GLOBAL CONST $MWT_RIGHTMULTIPLY = 3
GLOBAL CONST $MWT_SET = 4
GLOBAL CONST $MONITOR_DEFAULTTONEAREST = 2
GLOBAL CONST $MONITOR_DEFAULTTONULL = 0
GLOBAL CONST $MONITOR_DEFAULTTOPRIMARY = 1
GLOBAL CONST $PT_BEZIERTO = 4
GLOBAL CONST $PT_LINETO = 2
GLOBAL CONST $PT_MOVETO = 6
GLOBAL CONST $PT_CLOSEFIGURE = 1
#Region Global Variables and Constants
	GLOBAL $__G_HHEAP = 0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_CREATEBUFFER($ILENGTH, $PBUFFER = 0, $BABORT = TRUE)
		$PBUFFER = __HEAPREALLOC($PBUFFER, $ILENGTH, 0, $BABORT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $PBUFFER
	ENDFUNC
	FUNC _WINAPI_CREATEBUFFERFROMSTRUCT($TSTRUCT, $PBUFFER = 0, $BABORT = TRUE)
		IF NOT ISDLLSTRUCT($TSTRUCT) THEN RETURN SETERROR(1, 0, 0)
		$PBUFFER = __HEAPREALLOC($PBUFFER, DLLSTRUCTGETSIZE($TSTRUCT), 0, $BABORT)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 100, @EXTENDED, 0)
		_WINAPI_MOVEMEMORY($PBUFFER, $TSTRUCT, DLLSTRUCTGETSIZE($TSTRUCT))
		RETURN $PBUFFER
	ENDFUNC
	FUNC _WINAPI_CREATESTRING($SSTRING, $PSTRING = 0, $ILENGTH = -1, $BUNICODE = TRUE, $BABORT = TRUE)
		$ILENGTH = NUMBER($ILENGTH)
		IF $ILENGTH >= 0 THEN
			$SSTRING = STRINGLEFT($SSTRING, $ILENGTH)
		ELSE
			$ILENGTH = STRINGLEN($SSTRING)
		ENDIF
		LOCAL $ISIZE = $ILENGTH + 1
		IF $BUNICODE THEN
			$ISIZE *= 2
		ENDIF
		$PSTRING = __HEAPREALLOC($PSTRING, $ISIZE, 0, $BABORT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		DLLSTRUCTSETDATA(DLLSTRUCTCREATE(($BUNICODE ? "wchar" : "char") & "[" & ($ILENGTH + 1) & "]", $PSTRING), 1, $SSTRING)
		RETURN SETEXTENDED($ILENGTH, $PSTRING)
	ENDFUNC
	FUNC _WINAPI_EQUALMEMORY($PSOURCE1, $PSOURCE2, $ILENGTH)
		IF _WINAPI_ISBADREADPTR($PSOURCE1, $ILENGTH) THEN RETURN SETERROR(11, @EXTENDED, 0)
		IF _WINAPI_ISBADREADPTR($PSOURCE2, $ILENGTH) THEN RETURN SETERROR(12, @EXTENDED, 0)
		LOCAL $ARET = DLLCALL("ntdll.dll", "ulong_ptr", "RtlCompareMemory", "struct*", $PSOURCE1, "struct*", $PSOURCE2, "ulong_ptr", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN NUMBER($ARET[0] = $ILENGTH)
	ENDFUNC
	FUNC _WINAPI_FILLMEMORY($PMEMORY, $ILENGTH, $IVALUE = 0)
		IF _WINAPI_ISBADWRITEPTR($PMEMORY, $ILENGTH) THEN RETURN SETERROR(11, @EXTENDED, 0)
		DLLCALL("ntdll.dll", "none", "RtlFillMemory", "struct*", $PMEMORY, "ulong_ptr", $ILENGTH, "byte", $IVALUE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_FREEMEMORY($PMEMORY)
		IF NOT __HEAPFREE($PMEMORY, 1) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_GETMEMORYSIZE($PMEMORY)
		LOCAL $IRESULT = __HEAPSIZE($PMEMORY, 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $IRESULT
	ENDFUNC
	FUNC _WINAPI_GLOBALMEMORYSTATUS()
		LOCAL CONST $TAGMEMORYSTATUSEX = "dword Length;dword MemoryLoad;" & "uint64 TotalPhys;uint64 AvailPhys;uint64 TotalPageFile;uint64 AvailPageFile;" & "uint64 TotalVirtual;uint64 AvailVirtual;uint64 AvailExtendedVirtual"
		LOCAL $TMEM = DLLSTRUCTCREATE($TAGMEMORYSTATUSEX)
		DLLSTRUCTSETDATA($TMEM, 1, DLLSTRUCTGETSIZE($TMEM))
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GlobalMemoryStatusEx", "struct*", $TMEM)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $AMEM[7]
		$AMEM[0] = DLLSTRUCTGETDATA($TMEM, 2)
		$AMEM[1] = DLLSTRUCTGETDATA($TMEM, 3)
		$AMEM[2] = DLLSTRUCTGETDATA($TMEM, 4)
		$AMEM[3] = DLLSTRUCTGETDATA($TMEM, 5)
		$AMEM[4] = DLLSTRUCTGETDATA($TMEM, 6)
		$AMEM[5] = DLLSTRUCTGETDATA($TMEM, 7)
		$AMEM[6] = DLLSTRUCTGETDATA($TMEM, 8)
		RETURN $AMEM
	ENDFUNC
	FUNC _WINAPI_ISBADCODEPTR($PADDRESS)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "IsBadCodePtr", "struct*", $PADDRESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ISBADREADPTR($PADDRESS, $ILENGTH)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "IsBadReadPtr", "struct*", $PADDRESS, "uint_ptr", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ISBADSTRINGPTR($PADDRESS, $ILENGTH)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "IsBadStringPtr", "struct*", $PADDRESS, "uint_ptr", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ISBADWRITEPTR($PADDRESS, $ILENGTH)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "IsBadWritePtr", "struct*", $PADDRESS, "uint_ptr", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ISMEMORY($PMEMORY)
		LOCAL $BRESULT = __HEAPVALIDATE($PMEMORY)
		RETURN SETERROR(@ERROR, @EXTENDED, $BRESULT)
	ENDFUNC
	FUNC _WINAPI_LOCALFREE($HMEMORY)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "handle", "LocalFree", "handle", $HMEMORY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_MOVEMEMORY($PDESTINATION, $PSOURCE, $ILENGTH)
		IF _WINAPI_ISBADREADPTR($PSOURCE, $ILENGTH) THEN RETURN SETERROR(10, @EXTENDED, 0)
		IF _WINAPI_ISBADWRITEPTR($PDESTINATION, $ILENGTH) THEN RETURN SETERROR(11, @EXTENDED, 0)
		DLLCALL("ntdll.dll", "none", "RtlMoveMemory", "struct*", $PDESTINATION, "struct*", $PSOURCE, "ulong_ptr", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_READPROCESSMEMORY($HPROCESS, $PBASEADDRESS, $PBUFFER, $ISIZE, BYREF $IREAD)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "ReadProcessMemory", "handle", $HPROCESS, "ptr", $PBASEADDRESS, "struct*", $PBUFFER, "ulong_ptr", $ISIZE, "ulong_ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IREAD = $ARESULT[5]
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_WRITEPROCESSMEMORY($HPROCESS, $PBASEADDRESS, $PBUFFER, $ISIZE, BYREF $IWRITTEN, $SBUFFER = "ptr")
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "WriteProcessMemory", "handle", $HPROCESS, "ptr", $PBASEADDRESS, $SBUFFER, $PBUFFER, "ulong_ptr", $ISIZE, "ulong_ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IWRITTEN = $ARESULT[5]
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_ZEROMEMORY($PMEMORY, $ILENGTH)
		IF _WINAPI_ISBADWRITEPTR($PMEMORY, $ILENGTH) THEN RETURN SETERROR(11, @EXTENDED, 0)
		DLLCALL("ntdll.dll", "none", "RtlZeroMemory", "struct*", $PMEMORY, "ulong_ptr", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __HEAPALLOC($ISIZE, $BABORT = FALSE)
		LOCAL $ARET
		IF NOT $__G_HHEAP THEN
			$ARET = DLLCALL("kernel32.dll", "handle", "HeapCreate", "dword", 0, "ulong_ptr", 0, "ulong_ptr", 0)
			IF @ERROR OR NOT $ARET[0] THEN __FATALEXIT(1, "Error allocating memory.")
			$__G_HHEAP = $ARET[0]
		ENDIF
		$ARET = DLLCALL("kernel32.dll", "ptr", "HeapAlloc", "handle", $__G_HHEAP, "dword", 8, "ulong_ptr", $ISIZE)
		IF @ERROR OR NOT $ARET[0] THEN
			IF $BABORT THEN __FATALEXIT(1, "Error allocating memory.")
			RETURN SETERROR(@ERROR + 30, @EXTENDED, 0)
		ENDIF
		RETURN $ARET[0]
	ENDFUNC
	FUNC __HEAPFREE(BYREF $PMEMORY, $BCHECK = FALSE, $ICURERR = @ERROR, $ICUREXT = @EXTENDED)
		IF $BCHECK AND(NOT __HEAPVALIDATE($PMEMORY)) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "int", "HeapFree", "handle", $__G_HHEAP, "dword", 0, "ptr", $PMEMORY)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 40, @EXTENDED, 0)
		$PMEMORY = 0
		RETURN SETERROR($ICURERR, $ICUREXT, 1)
	ENDFUNC
	FUNC __HEAPREALLOC($PMEMORY, $ISIZE, $BAMOUNT = FALSE, $BABORT = FALSE)
		LOCAL $ARET, $PRET
		IF __HEAPVALIDATE($PMEMORY) THEN
			IF $BAMOUNT AND(__HEAPSIZE($PMEMORY) >= $ISIZE) THEN RETURN SETEXTENDED(1, PTR($PMEMORY))
			$ARET = DLLCALL("kernel32.dll", "ptr", "HeapReAlloc", "handle", $__G_HHEAP, "dword", 8, "ptr", $PMEMORY, "ulong_ptr", $ISIZE)
			IF @ERROR OR NOT $ARET[0] THEN
				IF $BABORT THEN __FATALEXIT(1, "Error allocating memory.")
				RETURN SETERROR(@ERROR + 20, @EXTENDED, PTR($PMEMORY))
			ENDIF
			$PRET = $ARET[0]
		ELSE
			$PRET = __HEAPALLOC($ISIZE, $BABORT)
			IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		ENDIF
		RETURN $PRET
	ENDFUNC
	FUNC __HEAPSIZE($PMEMORY, $BCHECK = FALSE)
		IF $BCHECK AND(NOT __HEAPVALIDATE($PMEMORY)) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "ulong_ptr", "HeapSize", "handle", $__G_HHEAP, "dword", 0, "ptr", $PMEMORY)
		IF @ERROR OR($ARET[0] = PTR(-1)) THEN RETURN SETERROR(@ERROR + 50, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC __HEAPVALIDATE($PMEMORY)
		IF(NOT $__G_HHEAP) OR(NOT PTR($PMEMORY)) THEN RETURN SETERROR(9, 0, FALSE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "int", "HeapValidate", "handle", $__G_HHEAP, "dword", 0, "ptr", $PMEMORY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
#EndRegion Internal Functions
GLOBAL CONST $SND_APPLICATION = 128
GLOBAL CONST $SND_ALIAS = 65536
GLOBAL CONST $SND_ALIAS_ID = 1114112
GLOBAL CONST $SND_ASYNC = 1
GLOBAL CONST $SND_FILENAME = 131072
GLOBAL CONST $SND_LOOP = 8
GLOBAL CONST $SND_MEMORY = 4
GLOBAL CONST $SND_NODEFAULT = 2
GLOBAL CONST $SND_NOSTOP = 16
GLOBAL CONST $SND_NOWAIT = 8192
GLOBAL CONST $SND_PURGE = 64
GLOBAL CONST $SND_RESOURCE = 262148
GLOBAL CONST $SND_SENTRY = 524288
GLOBAL CONST $SND_SYNC = 0
GLOBAL CONST $SND_SYSTEM = 2097152
GLOBAL CONST $SND_SYSTEM_NOSTOP = 2097168
GLOBAL CONST $SND_ALIAS_SYSTEMASTERISK = "SystemAsterisk"
GLOBAL CONST $SND_ALIAS_SYSTEMDEFAULT = "SystemDefault"
GLOBAL CONST $SND_ALIAS_SYSTEMEXCLAMATION = "SystemExclamation"
GLOBAL CONST $SND_ALIAS_SYSTEMEXIT = "SystemExit"
GLOBAL CONST $SND_ALIAS_SYSTEMHAND = "SystemHand"
GLOBAL CONST $SND_ALIAS_SYSTEMQUESTION = "SystemQuestion"
GLOBAL CONST $SND_ALIAS_SYSTEMSTART = "SystemStart"
GLOBAL CONST $SND_ALIAS_SYSTEMWELCOME = "SystemWelcome"
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_ARRAYTOSTRUCT(CONST BYREF $ADATA, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($ADATA, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TAGSTRUCT = ""
		FOR $I = $ISTART TO $IEND
			$TAGSTRUCT &= "wchar[" & (STRINGLEN($ADATA[$I]) + 1) & "];"
		NEXT
		LOCAL $TDATA = DLLSTRUCTCREATE($TAGSTRUCT & "wchar[1]")
		LOCAL $ICOUNT = 1
		FOR $I = $ISTART TO $IEND
			DLLSTRUCTSETDATA($TDATA, $ICOUNT, $ADATA[$I])
			$ICOUNT += 1
		NEXT
		DLLSTRUCTSETDATA($TDATA, $ICOUNT, CHRW(0))
		RETURN $TDATA
	ENDFUNC
	FUNC _WINAPI_CREATEMARGINS($ILEFTWIDTH, $IRIGHTWIDTH, $ITOPHEIGHT, $IBOTTOMHEIGHT)
		LOCAL $TMARGINS = DLLSTRUCTCREATE($TAGMARGINS)
		DLLSTRUCTSETDATA($TMARGINS, 1, $ILEFTWIDTH)
		DLLSTRUCTSETDATA($TMARGINS, 2, $IRIGHTWIDTH)
		DLLSTRUCTSETDATA($TMARGINS, 3, $ITOPHEIGHT)
		DLLSTRUCTSETDATA($TMARGINS, 4, $IBOTTOMHEIGHT)
		RETURN $TMARGINS
	ENDFUNC
	FUNC _WINAPI_CREATEPOINT($IX, $IY)
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		DLLSTRUCTSETDATA($TPOINT, 1, $IX)
		DLLSTRUCTSETDATA($TPOINT, 2, $IY)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_CREATERECT($ILEFT, $ITOP, $IRIGHT, $IBOTTOM)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		DLLSTRUCTSETDATA($TRECT, 1, $ILEFT)
		DLLSTRUCTSETDATA($TRECT, 2, $ITOP)
		DLLSTRUCTSETDATA($TRECT, 3, $IRIGHT)
		DLLSTRUCTSETDATA($TRECT, 4, $IBOTTOM)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_CREATERECTEX($IX, $IY, $IWIDTH, $IHEIGHT)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		DLLSTRUCTSETDATA($TRECT, 1, $IX)
		DLLSTRUCTSETDATA($TRECT, 2, $IY)
		DLLSTRUCTSETDATA($TRECT, 3, $IX + $IWIDTH)
		DLLSTRUCTSETDATA($TRECT, 4, $IY + $IHEIGHT)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_CREATESIZE($IWIDTH, $IHEIGHT)
		LOCAL $TSIZE = DLLSTRUCTCREATE($TAGSIZE)
		DLLSTRUCTSETDATA($TSIZE, 1, $IWIDTH)
		DLLSTRUCTSETDATA($TSIZE, 2, $IHEIGHT)
		RETURN $TSIZE
	ENDFUNC
	FUNC _WINAPI_COPYSTRUCT($TSTRUCT, $SSTRUCT = "")
		LOCAL $ISIZE = DLLSTRUCTGETSIZE($TSTRUCT)
		IF NOT $ISIZE THEN RETURN SETERROR(1, 0, 0)
		LOCAL $TRESULT
		IF NOT STRINGSTRIPWS($SSTRUCT, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES) THEN
			$TRESULT = DLLSTRUCTCREATE("byte[" & $ISIZE & "]")
		ELSE
			$TRESULT = DLLSTRUCTCREATE($SSTRUCT)
		ENDIF
		IF DLLSTRUCTGETSIZE($TRESULT) < $ISIZE THEN RETURN SETERROR(2, 0, 0)
		_WINAPI_MOVEMEMORY($TRESULT, $TSTRUCT, $ISIZE)
		RETURN $TRESULT
	ENDFUNC
	FUNC _WINAPI_GETEXTENDED()
		RETURN $__G_VEXT
	ENDFUNC
	FUNC _WINAPI_GETMOUSEPOS($BTOCLIENT = FALSE, $HWND = 0)
		LOCAL $IMODE = OPT("MouseCoordMode", 1)
		LOCAL $APOS = MOUSEGETPOS()
		OPT("MouseCoordMode", $IMODE)
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		DLLSTRUCTSETDATA($TPOINT, "X", $APOS[0])
		DLLSTRUCTSETDATA($TPOINT, "Y", $APOS[1])
		IF $BTOCLIENT AND NOT _WINAPI_SCREENTOCLIENT($HWND, $TPOINT) THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_GETMOUSEPOSX($BTOCLIENT = FALSE, $HWND = 0)
		LOCAL $TPOINT = _WINAPI_GETMOUSEPOS($BTOCLIENT, $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TPOINT, "X")
	ENDFUNC
	FUNC _WINAPI_GETMOUSEPOSY($BTOCLIENT = FALSE, $HWND = 0)
		LOCAL $TPOINT = _WINAPI_GETMOUSEPOS($BTOCLIENT, $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TPOINT, "Y")
	ENDFUNC
	FUNC _WINAPI_MULDIV($INUMBER, $INUMERATOR, $IDENOMINATOR)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "int", "MulDiv", "int", $INUMBER, "int", $INUMERATOR, "int", $IDENOMINATOR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_PLAYSOUND($SSOUND, $IFLAGS = $SND_SYSTEM_NOSTOP, $HINSTANCE = 0)
		LOCAL $STYPEOFSOUND = "ptr"
		IF $SSOUND THEN
			IF ISSTRING($SSOUND) THEN
				$STYPEOFSOUND = "wstr"
			ENDIF
		ELSE
			$SSOUND = 0
			$IFLAGS = 0
		ENDIF
		LOCAL $ARET = DLLCALL("winmm.dll", "bool", "PlaySoundW", $STYPEOFSOUND, $SSOUND, "handle", $HINSTANCE, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_STRINGLENA(CONST BYREF $TSTRING)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "int", "lstrlenA", "struct*", $TSTRING)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_STRINGLENW(CONST BYREF $TSTRING)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "int", "lstrlenW", "struct*", $TSTRING)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_STRUCTTOARRAY(BYREF $TSTRUCT, $IITEMS = 0)
		LOCAL $ISIZE = 2 * FLOOR(DLLSTRUCTGETSIZE($TSTRUCT) / 2)
		LOCAL $PSTRUCT = DLLSTRUCTGETPTR($TSTRUCT)
		IF NOT $ISIZE OR NOT $PSTRUCT THEN RETURN SETERROR(1, 0, 0)
		LOCAL $TDATA, $ILENGTH, $IOFFSET = 0
		LOCAL $ARESULT[101] = [0]
		WHILE 1
			$ILENGTH = _WINAPI_STRLEN($PSTRUCT + $IOFFSET)
			IF NOT $ILENGTH THEN
				EXITLOOP
			ENDIF
			IF 2 * (1 + $ILENGTH) + $IOFFSET > $ISIZE THEN RETURN SETERROR(3, 0, 0)
			$TDATA = DLLSTRUCTCREATE("wchar[" & (1 + $ILENGTH) & "]", $PSTRUCT + $IOFFSET)
			IF @ERROR THEN RETURN SETERROR(@ERROR + 10, 0, 0)
			__INC($ARESULT)
			$ARESULT[$ARESULT[0]] = DLLSTRUCTGETDATA($TDATA, 1)
			IF $ARESULT[0] = $IITEMS THEN
				EXITLOOP
			ENDIF
			$IOFFSET += 2 * (1 + $ILENGTH)
			IF $IOFFSET >= $ISIZE THEN RETURN SETERROR(3, 0, 0)
		WEND
		IF NOT $ARESULT[0] THEN RETURN SETERROR(2, 0, 0)
		__INC($ARESULT, -1)
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_UNIONSTRUCT($TSTRUCT1, $TSTRUCT2, $SSTRUCT = "")
		LOCAL $ASIZE[2] = [DLLSTRUCTGETSIZE($TSTRUCT1), DLLSTRUCTGETSIZE($TSTRUCT2)]
		IF NOT $ASIZE[0] OR NOT $ASIZE[1] THEN RETURN SETERROR(1, 0, 0)
		LOCAL $TRESULT
		IF NOT STRINGSTRIPWS($SSTRUCT, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES) THEN
			$TRESULT = DLLSTRUCTCREATE("byte[" & ($ASIZE[0] + $ASIZE[1]) & "]")
		ELSE
			$TRESULT = DLLSTRUCTCREATE($SSTRUCT)
		ENDIF
		IF DLLSTRUCTGETSIZE($TRESULT) < ($ASIZE[0] + $ASIZE[1]) THEN RETURN SETERROR(2, 0, 0)
		_WINAPI_MOVEMEMORY($TRESULT, $TSTRUCT1, $ASIZE[0])
		_WINAPI_MOVEMEMORY(DLLSTRUCTGETPTR($TRESULT) + $ASIZE[0], $TSTRUCT2, $ASIZE[1])
		RETURN $TRESULT
	ENDFUNC
#EndRegion Public Functions
#Region Global Variables and Constants
	GLOBAL CONST $TAGBITMAP = "struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct"
	GLOBAL CONST $TAGBITMAPV5HEADER = "struct;dword bV5Size;long bV5Width;long bV5Height;ushort bV5Planes;ushort bV5BitCount;dword bV5Compression;dword bV5SizeImage;long bV5XPelsPerMeter;long bV5YPelsPerMeter;dword bV5ClrUsed;dword bV5ClrImportant;dword bV5RedMask;dword bV5GreenMask;dword bV5BlueMask;dword bV5AlphaMask;dword bV5CSType;int bV5Endpoints[9];dword bV5GammaRed;dword bV5GammaGreen;dword bV5GammaBlue;dword bV5Intent;dword bV5ProfileData;dword bV5ProfileSize;dword bV5Reserved;endstruct"
	GLOBAL CONST $TAGDIBSECTION = $TAGBITMAP & ";" & $TAGBITMAPINFOHEADER & ";dword dsBitfields[3];ptr dshSection;dword dsOffset"
	GLOBAL CONST $TMPF_FIXED_PITCH = 1
	GLOBAL CONST $TMPF_VECTOR = 2
	GLOBAL CONST $TMPF_TRUETYPE = 4
	GLOBAL CONST $TMPF_DEVICE = 8
	GLOBAL CONST $__WINAPICONSTANT_FW_NORMAL = 400
	GLOBAL CONST $__WINAPICONSTANT_DEFAULT_CHARSET = 1
	GLOBAL CONST $__WINAPICONSTANT_OUT_DEFAULT_PRECIS = 0
	GLOBAL CONST $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS = 0
	GLOBAL CONST $__WINAPICONSTANT_DEFAULT_QUALITY = 0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_BITBLT($HDESTDC, $IXDEST, $IYDEST, $IWIDTH, $IHEIGHT, $HSRCDC, $IXSRC, $IYSRC, $IROP)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "bool", "BitBlt", "handle", $HDESTDC, "int", $IXDEST, "int", $IYDEST, "int", $IWIDTH, "int", $IHEIGHT, "handle", $HSRCDC, "int", $IXSRC, "int", $IYSRC, "dword", $IROP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_COMBINERGN($HRGNDEST, $HRGNSRC1, $HRGNSRC2, $ICOMBINEMODE)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "int", "CombineRgn", "handle", $HRGNDEST, "handle", $HRGNSRC1, "handle", $HRGNSRC2, "int", $ICOMBINEMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_COPYBITMAP($HBITMAP)
		$HBITMAP = _WINAPI_COPYIMAGE($HBITMAP, 0, 0, 0, 8192)
		RETURN SETERROR(@ERROR, @EXTENDED, $HBITMAP)
	ENDFUNC
	FUNC _WINAPI_COPYIMAGE($HIMAGE, $ITYPE = 0, $IXDESIREDPIXELS = 0, $IYDESIREDPIXELS = 0, $IFLAGS = 0)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "CopyImage", "handle", $HIMAGE, "uint", $ITYPE, "int", $IXDESIREDPIXELS, "int", $IYDESIREDPIXELS, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEANDBITMAP($HBITMAP)
		LOCAL $IERROR = 0, $HDIB = 0
		$HBITMAP = _WINAPI_COPYBITMAP($HBITMAP)
		IF NOT $HBITMAP THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		DO
			LOCAL $ATDIB[2]
			$ATDIB[0] = DLLSTRUCTCREATE($TAGDIBSECTION)
			IF(NOT _WINAPI_GETOBJECT($HBITMAP, DLLSTRUCTGETSIZE($ATDIB[0]), $ATDIB[0])) OR(DLLSTRUCTGETDATA($ATDIB[0], "bmBitsPixel") <> 32) OR(DLLSTRUCTGETDATA($ATDIB[0], "biCompression")) THEN
				$IERROR = 10
				EXITLOOP
			ENDIF
			$ATDIB[1] = DLLSTRUCTCREATE($TAGBITMAP)
			$HDIB = _WINAPI_CREATEDIB(DLLSTRUCTGETDATA($ATDIB[0], "bmWidth"), DLLSTRUCTGETDATA($ATDIB[0], "bmHeight"), 1)
			IF NOT _WINAPI_GETOBJECT($HDIB, DLLSTRUCTGETSIZE($ATDIB[1]), $ATDIB[1]) THEN
				$IERROR = 11
				EXITLOOP
			ENDIF
			LOCAL $ARET = DLLCALL("user32.dll", "lresult", "CallWindowProc", "ptr", __ANDPROC(), "ptr", 0, "uint", 0, "wparam", DLLSTRUCTGETPTR($ATDIB[0]), "lparam", DLLSTRUCTGETPTR($ATDIB[1]))
			IF @ERROR THEN
				$IERROR = @ERROR
				EXITLOOP
			ENDIF
			IF NOT $ARET[0] THEN
				$IERROR = 12
				EXITLOOP
			ENDIF
			$IERROR = 0
		UNTIL 1
		_WINAPI_DELETEOBJECT($HBITMAP)
		IF $IERROR THEN
			IF $HDIB THEN
				_WINAPI_DELETEOBJECT($HDIB)
			ENDIF
			$HDIB = 0
		ENDIF
		RETURN SETERROR($IERROR, 0, $HDIB)
	ENDFUNC
	FUNC _WINAPI_CREATEBITMAP($IWIDTH, $IHEIGHT, $IPLANES = 1, $IBITSPERPEL = 1, $PBITS = 0)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "handle", "CreateBitmap", "int", $IWIDTH, "int", $IHEIGHT, "uint", $IPLANES, "uint", $IBITSPERPEL, "struct*", $PBITS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_CREATECOMPATIBLEBITMAP($HDC, $IWIDTH, $IHEIGHT)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $HDC, "int", $IWIDTH, "int", $IHEIGHT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_CREATEDIB($IWIDTH, $IHEIGHT, $IBITSPERPEL = 32, $TCOLORTABLE = 0, $ICOLORCOUNT = 0)
		LOCAL $ARGBQ[2], $ICOLORS, $TAGRGBQ
		SWITCH $IBITSPERPEL
			CASE 1
				$ICOLORS = 2
			CASE 4
				$ICOLORS = 16
			CASE 8
				$ICOLORS = 256
			CASE ELSE
				$ICOLORS = 0
		ENDSWITCH
		IF $ICOLORS THEN
			IF NOT ISDLLSTRUCT($TCOLORTABLE) THEN
				SWITCH $IBITSPERPEL
					CASE 1
						$ARGBQ[0] = 0
						$ARGBQ[1] = 16777215
						$TCOLORTABLE = _WINAPI_CREATEDIBCOLORTABLE($ARGBQ)
					CASE ELSE
				ENDSWITCH
			ELSE
				IF $ICOLORS > $ICOLORCOUNT THEN
					$ICOLORS = $ICOLORCOUNT
				ENDIF
				IF(NOT $ICOLORS) OR((4 * $ICOLORS) > DLLSTRUCTGETSIZE($TCOLORTABLE)) THEN
					RETURN SETERROR(20, 0, 0)
				ENDIF
			ENDIF
			$TAGRGBQ = ";dword aRGBQuad[" & $ICOLORS & "]"
		ELSE
			$TAGRGBQ = ""
		ENDIF
		LOCAL $TBITMAPINFO = DLLSTRUCTCREATE($TAGBITMAPINFOHEADER & $TAGRGBQ)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biSize", 40)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biWidth", $IWIDTH)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biHeight", $IHEIGHT)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biPlanes", 1)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biBitCount", $IBITSPERPEL)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biCompression", 0)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biSizeImage", 0)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biXPelsPerMeter", 0)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biYPelsPerMeter", 0)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biClrUsed", $ICOLORS)
		DLLSTRUCTSETDATA($TBITMAPINFO, "biClrImportant", 0)
		IF $ICOLORS THEN
			IF ISDLLSTRUCT($TCOLORTABLE) THEN
				_WINAPI_MOVEMEMORY(DLLSTRUCTGETPTR($TBITMAPINFO, "aRGBQuad"), $TCOLORTABLE, 4 * $ICOLORS)
			ELSE
				_WINAPI_ZEROMEMORY(DLLSTRUCTGETPTR($TBITMAPINFO, "aRGBQuad"), 4 * $ICOLORS)
			ENDIF
		ENDIF
		LOCAL $HBITMAP = _WINAPI_CREATEDIBSECTION(0, $TBITMAPINFO, 0, $__G_VEXT)
		IF NOT $HBITMAP THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $HBITMAP
	ENDFUNC
	FUNC _WINAPI_CREATEDIBSECTION($HDC, $TBITMAPINFO, $IUSAGE, BYREF $PBITS, $HSECTION = 0, $IOFFSET = 0)
		$PBITS = 0
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "CreateDIBSection", "handle", $HDC, "struct*", $TBITMAPINFO, "uint", $IUSAGE, "ptr*", 0, "handle", $HSECTION, "dword", $IOFFSET)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		$PBITS = $ARET[4]
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEDIBCOLORTABLE(CONST BYREF $ACOLORTABLE, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($ACOLORTABLE, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TCOLORTABLE = DLLSTRUCTCREATE("dword[" & ($IEND - $ISTART + 1) & "]")
		LOCAL $ICOUNT = 1
		FOR $I = $ISTART TO $IEND
			DLLSTRUCTSETDATA($TCOLORTABLE, 1, _WINAPI_SWITCHCOLOR(__RGB($ACOLORTABLE[$I])), $ICOUNT)
			$ICOUNT += 1
		NEXT
		RETURN $TCOLORTABLE
	ENDFUNC
	FUNC _WINAPI_CREATEFONT($IHEIGHT, $IWIDTH, $IESCAPE = 0, $IORIENTN = 0, $IWEIGHT = $__WINAPICONSTANT_FW_NORMAL, $BITALIC = FALSE, $BUNDERLINE = FALSE, $BSTRIKEOUT = FALSE, $ICHARSET = $__WINAPICONSTANT_DEFAULT_CHARSET, $IOUTPUTPREC = $__WINAPICONSTANT_OUT_DEFAULT_PRECIS, $ICLIPPREC = $__WINAPICONSTANT_CLIP_DEFAULT_PRECIS, $IQUALITY = $__WINAPICONSTANT_DEFAULT_QUALITY, $IPITCH = 0, $SFACE = "Arial")
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "handle", "CreateFontW", "int", $IHEIGHT, "int", $IWIDTH, "int", $IESCAPE, "int", $IORIENTN, "int", $IWEIGHT, "dword", $BITALIC, "dword", $BUNDERLINE, "dword", $BSTRIKEOUT, "dword", $ICHARSET, "dword", $IOUTPUTPREC, "dword", $ICLIPPREC, "dword", $IQUALITY, "dword", $IPITCH, "wstr", $SFACE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_CREATEFONTINDIRECT($TLOGFONT)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "handle", "CreateFontIndirectW", "struct*", $TLOGFONT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_CREATERECTRGN($ILEFTRECT, $ITOPRECT, $IRIGHTRECT, $IBOTTOMRECT)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "handle", "CreateRectRgn", "int", $ILEFTRECT, "int", $ITOPRECT, "int", $IRIGHTRECT, "int", $IBOTTOMRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_CREATEROUNDRECTRGN($ILEFTRECT, $ITOPRECT, $IRIGHTRECT, $IBOTTOMRECT, $IWIDTHELLIPSE, $IHEIGHTELLIPSE)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "handle", "CreateRoundRectRgn", "int", $ILEFTRECT, "int", $ITOPRECT, "int", $IRIGHTRECT, "int", $IBOTTOMRECT, "int", $IWIDTHELLIPSE, "int", $IHEIGHTELLIPSE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_CREATESOLIDBRUSH($ICOLOR)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "handle", "CreateSolidBrush", "INT", $ICOLOR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETBITMAPDIMENSION($HBITMAP)
		LOCAL $TOBJ = DLLSTRUCTCREATE($TAGBITMAP)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetObject", "handle", $HBITMAP, "int", DLLSTRUCTGETSIZE($TOBJ), "struct*", $TOBJ)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN _WINAPI_CREATESIZE(DLLSTRUCTGETDATA($TOBJ, "bmWidth"), DLLSTRUCTGETDATA($TOBJ, "bmHeight"))
	ENDFUNC
	FUNC _WINAPI_GETSYSCOLORBRUSH($IINDEX)
		LOCAL $ARESULT = DLLCALL("user32.dll", "handle", "GetSysColorBrush", "int", $IINDEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETTEXTEXTENTPOINT32($HDC, $STEXT)
		LOCAL $TSIZE = DLLSTRUCTCREATE($TAGSIZE)
		LOCAL $ISIZE = STRINGLEN($STEXT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $HDC, "wstr", $STEXT, "int", $ISIZE, "struct*", $TSIZE)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TSIZE
	ENDFUNC
	FUNC _WINAPI_GETTEXTMETRICS($HDC)
		LOCAL $TTEXTMETRIC = DLLSTRUCTCREATE($TAGTEXTMETRIC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "GetTextMetricsW", "handle", $HDC, "struct*", $TTEXTMETRIC)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TTEXTMETRIC
	ENDFUNC
	FUNC _WINAPI_GETWINDOWRGN($HWND, $HRGN)
		LOCAL $ARESULT = DLLCALL("user32.dll", "int", "GetWindowRgn", "hwnd", $HWND, "handle", $HRGN)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_ISALPHABITMAP($HBITMAP)
		$HBITMAP = _WINAPI_COPYBITMAP($HBITMAP)
		IF NOT $HBITMAP THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ARET, $IERROR = 0
		DO
			LOCAL $TDIB = DLLSTRUCTCREATE($TAGDIBSECTION)
			IF(NOT _WINAPI_GETOBJECT($HBITMAP, DLLSTRUCTGETSIZE($TDIB), $TDIB)) OR(DLLSTRUCTGETDATA($TDIB, "bmBitsPixel") <> 32) OR(DLLSTRUCTGETDATA($TDIB, "biCompression")) THEN
				$IERROR = 1
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("user32.dll", "int", "CallWindowProc", "ptr", __ALPHAPROC(), "ptr", 0, "uint", 0, "struct*", $TDIB, "ptr", 0)
			IF @ERROR OR($ARET[0] = -1) THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
		UNTIL 1
		_WINAPI_DELETEOBJECT($HBITMAP)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PTINRECT(BYREF $TRECT, BYREF $TPOINT)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "PtInRect", "struct*", $TRECT, "struct", $TPOINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_REDRAWWINDOW($HWND, $TRECT = 0, $HREGION = 0, $IFLAGS = 5)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "RedrawWindow", "hwnd", $HWND, "struct*", $TRECT, "handle", $HREGION, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETWINDOWRGN($HWND, $HRGN, $BREDRAW = TRUE)
		LOCAL $ARESULT = DLLCALL("user32.dll", "int", "SetWindowRgn", "hwnd", $HWND, "handle", $HRGN, "bool", $BREDRAW)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
#EndRegion Public Functions
#Region Embedded DLL Functions
	FUNC __ALPHAPROC()
		STATIC $PPROC = 0
		IF NOT $PPROC THEN
			IF @AUTOITX64 THEN
				$PPROC = __INIT(BINARY("0x48894C240848895424104C894424184C894C24205541574831C050504883EC28" & "48837C24600074054831C0EB0748C7C0010000004821C0751F488B6C24604883" & "7D180074054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB" & "034831C04821C0740C48C7C0FFFFFFFF4863C0EB6F48C744242800000000488B" & "6C24604C637D04488B6C2460486345084C0FAFF849C1E7024983C7FC4C3B7C24" & "287C36488B6C24604C8B7D184C037C24284983C7034C897C2430488B6C243080" & "7D0000740C48C7C0010000004863C0EB1348834424280471A54831C04863C0EB" & "034831C04883C438415F5DC3"))
			ELSE
				$PPROC = __INIT(BINARY("0x555331C05050837C241C00740431C0EB05B80100000021C075198B6C241C837D" & "1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021C07407" & "B8FFFFFFFFEB4FC70424000000008B6C241C8B5D048B6C241C0FAF5D08C1E302" & "83C3FC3B1C247C288B6C241C8B5D14031C2483C303895C24048B6C2404807D00" & "007407B801000000EB0C8304240471BE31C0EB0231C083C4085B5DC21000"))
			ENDIF
		ENDIF
		RETURN $PPROC
	ENDFUNC
	FUNC __ANDPROC()
		STATIC $PPROC = 0
		IF NOT $PPROC THEN
			IF @AUTOITX64 THEN
				$PPROC = __INIT(BINARY("0x48894C240848895424104C894424184C894C2420554157415648C7C009000000" & "4883EC0848C704240000000048FFC875EF4883EC284883BC24A0000000007405" & "4831C0EB0748C7C0010000004821C00F85840000004883BC24A8000000007405" & "4831C0EB0748C7C0010000004821C07555488BAC24A000000048837D18007405" & "4831C0EB0748C7C0010000004821C07522488BAC24A800000048837D18007405" & "4831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C048" & "21C07502EB0948C7C001000000EB034831C04821C07502EB0948C7C001000000" & "EB034831C04821C0740B4831C04863C0E9D701000048C74424280000000048C7" & "44243000000000488BAC24A00000004C637D0849FFCF4C3B7C24300F8C9C0100" & "0048C74424380000000048C74424400000000048C744244800000000488BAC24" & "A00000004C637D0449FFCF4C3B7C24480F8CDB000000488BAC24A00000004C8B" & "7D184C037C24284983C7034C897C2450488B6C2450807D000074264C8B7C2440" & "4C8B74243849F7DE4983C61F4C89F148C7C00100000048D3E04909C74C897C24" & "4048FF4424384C8B7C24384983FF1F7E6F4C8B7C244049F7D74C897C244048C7" & "442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D184C037C" & "24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C2458588845" & "0048FF4424604883442458F871B948C74424380000000048C744244000000000" & "48834424280448FF4424480F810BFFFFFF48837C24380074794C8B7C244049F7" & "D74C8B74243849F7DE4983C6204C89F148C7C0FFFFFFFF48D3E04921C74C897C" & "244048C7442458180000004831C0483B4424587F3D488BAC24A80000004C8B7D" & "184C037C24604C897C24504C8B7C2440488B4C245849D3FF4C89F850488B6C24" & "585888450048FF4424604883442458F871B948FF4424300F814AFEFFFF48C7C0" & "010000004863C0EB034831C04883C470415E415F5DC3"))
			ELSE
				$PPROC = __INIT(BINARY("0x555357BA0800000083EC04C70424000000004A75F3837C243800740431C0EB05" & "B80100000021C07562837C243C00740431C0EB05B80100000021C0753F8B6C24" & "38837D1400740431C0EB05B80100000021C075198B6C243C837D1400740431C0" & "EB05B80100000021C07502EB07B801000000EB0231C021C07502EB07B8010000" & "00EB0231C021C07502EB07B801000000EB0231C021C0740731C0E969010000C7" & "042400000000C7442404000000008B6C24388B5D084B3B5C24040F8C3F010000" & "C744240800000000C744240C00000000C7442410000000008B6C24388B5D044B" & "3B5C24100F8CA90000008B6C24388B5D14031C2483C303895C24148B6C241480" & "7D0000741C8B5C240C8B7C2408F7DF83C71F89F9B801000000D3E009C3895C24" & "0CFF4424088B5C240883FB1F7E578B5C240CF7D3895C240CC744241818000000" & "31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3" & "FB538B6C241858884500FF44241C83442418F871CBC744240800000000C74424" & "0C0000000083042404FF4424100F8145FFFFFF837C240800745B8B5C240CF7D3" & "8B7C2408F7DF83C72089F9B8FFFFFFFFD3E021C3895C240CC744241818000000" & "31C03B4424187F2D8B6C243C8B5D14035C241C895C24148B5C240C8B4C2418D3" & "FB538B6C241858884500FF44241C83442418F871CBFF4424040F81AFFEFFFFB8" & "01000000EB0231C083C4205F5B5DC21000"))
			ENDIF
		ENDIF
		RETURN $PPROC
	ENDFUNC
	FUNC __XORPROC()
		STATIC $PPROC = 0
		IF NOT $PPROC THEN
			IF @AUTOITX64 THEN
				$PPROC = __INIT(BINARY("0x48894C240848895424104C894424184C894C24205541574831C050504883EC28" & "48837C24600074054831C0EB0748C7C0010000004821C0751B48837C24680074" & "054831C0EB0748C7C0010000004821C07502EB0948C7C001000000EB034831C0" & "4821C074084831C04863C0EB7748C7442428000000004C637C24584983C7FC4C" & "3B7C24287C4F4C8B7C24604C037C24284C897C2430488B6C2430807D00007405" & "4831C0EB0748C7C0010000004821C0741C4C8B7C24684C037C24284983C7034C" & "897C2430488B6C2430C64500FF48834424280471A148C7C0010000004863C0EB" & "034831C04883C438415F5DC3"))
			ELSE
				$PPROC = __INIT(BINARY("0x555331C05050837C241C00740431C0EB05B80100000021C07516837C24200074" & "0431C0EB05B80100000021C07502EB07B801000000EB0231C021C0740431C0EB" & "5AC70424000000008B5C241883C3FC3B1C247C3E8B5C241C031C24895C24048B" & "6C2404807D0000740431C0EB05B80100000021C074168B5C2420031C2483C303" & "895C24048B6C2404C64500FF8304240471B6B801000000EB0231C083C4085B5D" & "C21000"))
			ENDIF
		ENDIF
		RETURN $PPROC
	ENDFUNC
#EndRegion Embedded DLL Functions
#Region Internal Functions
	FUNC __INIT($DDATA)
		LOCAL $ILENGTH = BINARYLEN($DDATA)
		LOCAL $ARET = DLLCALL("kernel32.dll", "ptr", "VirtualAlloc", "ptr", 0, "ulong_ptr", $ILENGTH, "dword", 4096, "dword", 64)
		IF @ERROR OR NOT $ARET[0] THEN __FATALEXIT(1, "Error allocating memory.")
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[" & $ILENGTH & "]", $ARET[0])
		DLLSTRUCTSETDATA($TDATA, 1, $DDATA)
		RETURN $ARET[0]
	ENDFUNC
#EndRegion Internal Functions
#Region Global Variables and Constants
	GLOBAL CONST $DI_MASK = 1
	GLOBAL CONST $DI_IMAGE = 2
	GLOBAL CONST $DI_NORMAL = 3
	GLOBAL CONST $DI_COMPAT = 4
	GLOBAL CONST $DI_DEFAULTSIZE = 8
	GLOBAL CONST $DI_NOMIRROR = 16
	GLOBAL CONST $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP = 1
	GLOBAL CONST $DISPLAY_DEVICE_MULTI_DRIVER = 2
	GLOBAL CONST $DISPLAY_DEVICE_PRIMARY_DEVICE = 4
	GLOBAL CONST $DISPLAY_DEVICE_MIRRORING_DRIVER = 8
	GLOBAL CONST $DISPLAY_DEVICE_VGA_COMPATIBLE = 16
	GLOBAL CONST $DISPLAY_DEVICE_REMOVABLE = 32
	GLOBAL CONST $DISPLAY_DEVICE_DISCONNECT = 33554432
	GLOBAL CONST $DISPLAY_DEVICE_REMOTE = 67108864
	GLOBAL CONST $DISPLAY_DEVICE_MODESPRUNED = 134217728
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_CREATECOMPATIBLEDC($HDC)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_DELETEDC($HDC)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "bool", "DeleteDC", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_DRAWEDGE($HDC, $TRECT, $IEDGETYPE, $IFLAGS)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "DrawEdge", "handle", $HDC, "struct*", $TRECT, "uint", $IEDGETYPE, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_DRAWFRAMECONTROL($HDC, $TRECT, $ITYPE, $ISTATE)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "DrawFrameControl", "handle", $HDC, "struct*", $TRECT, "uint", $ITYPE, "uint", $ISTATE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_DRAWICON($HDC, $IX, $IY, $HICON)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "DrawIcon", "handle", $HDC, "int", $IX, "int", $IY, "handle", $HICON)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_DRAWICONEX($HDC, $IX, $IY, $HICON, $IWIDTH = 0, $IHEIGHT = 0, $ISTEP = 0, $HBRUSH = 0, $IFLAGS = 3)
		LOCAL $IOPTIONS
		SWITCH $IFLAGS
			CASE 1
				$IOPTIONS = $DI_MASK
			CASE 2
				$IOPTIONS = $DI_IMAGE
			CASE 3
				$IOPTIONS = $DI_NORMAL
			CASE 4
				$IOPTIONS = $DI_COMPAT
			CASE 5
				$IOPTIONS = $DI_DEFAULTSIZE
			CASE ELSE
				$IOPTIONS = $DI_NOMIRROR
		ENDSWITCH
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "DrawIconEx", "handle", $HDC, "int", $IX, "int", $IY, "handle", $HICON, "int", $IWIDTH, "int", $IHEIGHT, "uint", $ISTEP, "handle", $HBRUSH, "uint", $IOPTIONS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_DRAWTEXT($HDC, $STEXT, BYREF $TRECT, $IFLAGS)
		LOCAL $ARESULT = DLLCALL("user32.dll", "int", "DrawTextW", "handle", $HDC, "wstr", $STEXT, "int", -1, "struct*", $TRECT, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_ENUMDISPLAYDEVICES($SDEVICE, $IDEVNUM)
		LOCAL $TNAME = 0, $IFLAGS = 0, $ADEVICE[5]
		IF $SDEVICE <> "" THEN
			$TNAME = DLLSTRUCTCREATE("wchar Text[" & STRINGLEN($SDEVICE) + 1 & "]")
			DLLSTRUCTSETDATA($TNAME, "Text", $SDEVICE)
		ENDIF
		LOCAL CONST $TAGDISPLAY_DEVICE = "dword Size;wchar Name[32];wchar String[128];dword Flags;wchar ID[128];wchar Key[128]"
		LOCAL $TDEVICE = DLLSTRUCTCREATE($TAGDISPLAY_DEVICE)
		LOCAL $IDEVICE = DLLSTRUCTGETSIZE($TDEVICE)
		DLLSTRUCTSETDATA($TDEVICE, "Size", $IDEVICE)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "EnumDisplayDevicesW", "struct*", $TNAME, "dword", $IDEVNUM, "struct*", $TDEVICE, "dword", 1)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $IN = DLLSTRUCTGETDATA($TDEVICE, "Flags")
		IF BITAND($IN, $DISPLAY_DEVICE_ATTACHED_TO_DESKTOP) <> 0 THEN $IFLAGS = BITOR($IFLAGS, 1)
		IF BITAND($IN, $DISPLAY_DEVICE_PRIMARY_DEVICE) <> 0 THEN $IFLAGS = BITOR($IFLAGS, 2)
		IF BITAND($IN, $DISPLAY_DEVICE_MIRRORING_DRIVER) <> 0 THEN $IFLAGS = BITOR($IFLAGS, 4)
		IF BITAND($IN, $DISPLAY_DEVICE_VGA_COMPATIBLE) <> 0 THEN $IFLAGS = BITOR($IFLAGS, 8)
		IF BITAND($IN, $DISPLAY_DEVICE_REMOVABLE) <> 0 THEN $IFLAGS = BITOR($IFLAGS, 16)
		IF BITAND($IN, $DISPLAY_DEVICE_MODESPRUNED) <> 0 THEN $IFLAGS = BITOR($IFLAGS, 32)
		$ADEVICE[0] = TRUE
		$ADEVICE[1] = DLLSTRUCTGETDATA($TDEVICE, "Name")
		$ADEVICE[2] = DLLSTRUCTGETDATA($TDEVICE, "String")
		$ADEVICE[3] = $IFLAGS
		$ADEVICE[4] = DLLSTRUCTGETDATA($TDEVICE, "ID")
		RETURN $ADEVICE
	ENDFUNC
	FUNC _WINAPI_FILLRECT($HDC, $TRECT, $HBRUSH)
		LOCAL $ARESULT
		IF ISPTR($HBRUSH) THEN
			$ARESULT = DLLCALL("user32.dll", "int", "FillRect", "handle", $HDC, "struct*", $TRECT, "handle", $HBRUSH)
		ELSE
			$ARESULT = DLLCALL("user32.dll", "int", "FillRect", "handle", $HDC, "struct*", $TRECT, "dword_ptr", $HBRUSH)
		ENDIF
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_FRAMERECT($HDC, $TRECT, $HBRUSH)
		LOCAL $ARESULT = DLLCALL("user32.dll", "int", "FrameRect", "handle", $HDC, "struct*", $TRECT, "handle", $HBRUSH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETBKMODE($HDC)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "int", "GetBkMode", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETDC($HWND)
		LOCAL $ARESULT = DLLCALL("user32.dll", "handle", "GetDC", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETDCEX($HWND, $HRGN, $IFLAGS)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "GetDCEx", "hwnd", $HWND, "handle", $HRGN, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETDEVICECAPS($HDC, $IINDEX)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "int", "GetDeviceCaps", "handle", $HDC, "int", $IINDEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETTEXTCOLOR($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "dword", "GetTextColor", "handle", $HDC)
		IF @ERROR OR($ARET[0] = 4294967295) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN __RGB($ARET[0])
	ENDFUNC
	FUNC _WINAPI_GETWINDOWDC($HWND)
		LOCAL $ARESULT = DLLCALL("user32.dll", "handle", "GetWindowDC", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_PRINTWINDOW($HWND, $HDC, $BCLIENT = FALSE)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "PrintWindow", "hwnd", $HWND, "handle", $HDC, "uint", $BCLIENT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_RELEASEDC($HWND, $HDC)
		LOCAL $ARESULT = DLLCALL("user32.dll", "int", "ReleaseDC", "hwnd", $HWND, "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_RESTOREDC($HDC, $IID)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "RestoreDC", "handle", $HDC, "int", $IID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SAVEDC($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "SaveDC", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETBKCOLOR($HDC, $ICOLOR)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "INT", "SetBkColor", "handle", $HDC, "INT", $ICOLOR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETBKMODE($HDC, $IBKMODE)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "int", "SetBkMode", "handle", $HDC, "int", $IBKMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETTEXTCOLOR($HDC, $ICOLOR)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "INT", "SetTextColor", "handle", $HDC, "INT", $ICOLOR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_TWIPSPERPIXELX()
		LOCAL $HDC, $ITWIPSPERPIXELX
		$HDC = _WINAPI_GETDC(0)
		LOCAL CONST $__WINAPICONSTANT_LOGPIXELSX = 88
		$ITWIPSPERPIXELX = 1440 / _WINAPI_GETDEVICECAPS($HDC, $__WINAPICONSTANT_LOGPIXELSX)
		_WINAPI_RELEASEDC(0, $HDC)
		RETURN $ITWIPSPERPIXELX
	ENDFUNC
	FUNC _WINAPI_TWIPSPERPIXELY()
		LOCAL $HDC, $ITWIPSPERPIXELY
		$HDC = _WINAPI_GETDC(0)
		LOCAL CONST $__WINAPICONSTANT_LOGPIXELSY = 90
		$ITWIPSPERPIXELY = 1440 / _WINAPI_GETDEVICECAPS($HDC, $__WINAPICONSTANT_LOGPIXELSY)
		_WINAPI_RELEASEDC(0, $HDC)
		RETURN $ITWIPSPERPIXELY
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
#EndRegion Internal Functions
#Region Global Variables and Constants
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	GLOBAL CONST $TAGICONINFO = "bool Icon;dword XHotSpot;dword YHotSpot;handle hMask;handle hColor"
	FUNC _WINAPI_ADDICONTRANSPARENCY($HICON, $IPERCENT = 50, $BDELETE = FALSE)
		LOCAL $TBITMAP, $HDIB = 0, $HRESULT = 0
		LOCAL $AHBITMAP[2]
		LOCAL $TICONINFO = DLLSTRUCTCREATE($TAGICONINFO)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetIconInfo", "handle", $HICON, "struct*", $TICONINFO)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		FOR $I = 0 TO 1
			$AHBITMAP[$I] = DLLSTRUCTGETDATA($TICONINFO, $I + 4)
		NEXT
		LOCAL $IERROR = 0
		DO
			$HDIB = _WINAPI_COPYBITMAP($AHBITMAP[1])
			IF NOT $HDIB THEN
				$IERROR = 20
				EXITLOOP
			ENDIF
			$TBITMAP = DLLSTRUCTCREATE($TAGBITMAP)
			IF(NOT _WINAPI_GETOBJECT($HDIB, DLLSTRUCTGETSIZE($TBITMAP), $TBITMAP)) OR(DLLSTRUCTGETDATA($TBITMAP, "bmBitsPixel") <> 32) THEN
				$IERROR = 21
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("user32.dll", "lresult", "CallWindowProc", "PTR", __TRANSPARENCYPROC(), "hwnd", 0, "uint", $IPERCENT, "wparam", DLLSTRUCTGETPTR($TBITMAP), "lparam", 0)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			IF $ARET[0] = -1 THEN
				$HRESULT = _WINAPI_CREATEEMPTYICON(DLLSTRUCTGETDATA($TBITMAP, "bmWidth"), DLLSTRUCTGETDATA($TBITMAP, "bmHeight"))
			ELSE
				$HRESULT = _WINAPI_CREATEICONINDIRECT($HDIB, $AHBITMAP[0])
			ENDIF
			IF NOT $HRESULT THEN $IERROR = 22
		UNTIL 1
		IF $HDIB THEN
			_WINAPI_DELETEOBJECT($HDIB)
		ENDIF
		FOR $I = 0 TO 1
			IF $AHBITMAP[$I] THEN
				_WINAPI_DELETEOBJECT($AHBITMAP[$I])
			ENDIF
		NEXT
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		IF $BDELETE THEN
			_WINAPI_DESTROYICON($HICON)
		ENDIF
		RETURN $HRESULT
	ENDFUNC
	FUNC _WINAPI_COPYICON($HICON)
		LOCAL $ARESULT = DLLCALL("user32.dll", "handle", "CopyIcon", "handle", $HICON)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_CREATE32BITHICON($HICON, $BDELETE = FALSE)
		LOCAL $AHBITMAP[2], $HRESULT = 0
		LOCAL $ADIB[2][2] = [[0, 0], [0, 0]]
		LOCAL $TICONINFO = DLLSTRUCTCREATE($TAGICONINFO)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetIconInfo", "handle", $HICON, "struct*", $TICONINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF NOT $ARET[0] THEN RETURN SETERROR(10, 0, 0)
		FOR $I = 0 TO 1
			$AHBITMAP[$I] = DLLSTRUCTGETDATA($TICONINFO, $I + 4)
		NEXT
		IF _WINAPI_ISALPHABITMAP($AHBITMAP[1]) THEN
			$ADIB[0][0] = _WINAPI_CREATEANDBITMAP($AHBITMAP[1])
			IF NOT @ERROR THEN
				$HRESULT = _WINAPI_CREATEICONINDIRECT($AHBITMAP[1], $ADIB[0][0])
			ENDIF
		ELSE
			LOCAL $TSIZE = _WINAPI_GETBITMAPDIMENSION($AHBITMAP[1])
			LOCAL $ASIZE[2]
			FOR $I = 0 TO 1
				$ASIZE[$I] = DLLSTRUCTGETDATA($TSIZE, $I + 1)
			NEXT
			LOCAL $HSRCDC = _WINAPI_CREATECOMPATIBLEDC(0)
			LOCAL $HDSTDC = _WINAPI_CREATECOMPATIBLEDC(0)
			LOCAL $HSRCSV, $HDSTSV
			FOR $I = 0 TO 1
				$ADIB[$I][0] = _WINAPI_CREATEDIB($ASIZE[0], $ASIZE[1])
				$ADIB[$I][1] = $__G_VEXT
				$HSRCSV = _WINAPI_SELECTOBJECT($HSRCDC, $AHBITMAP[$I])
				$HDSTSV = _WINAPI_SELECTOBJECT($HDSTDC, $ADIB[$I][0])
				_WINAPI_BITBLT($HDSTDC, 0, 0, $ASIZE[0], $ASIZE[1], $HSRCDC, 0, 0, 12583114)
				_WINAPI_SELECTOBJECT($HSRCDC, $HSRCSV)
				_WINAPI_SELECTOBJECT($HDSTDC, $HDSTSV)
			NEXT
			_WINAPI_DELETEDC($HSRCDC)
			_WINAPI_DELETEDC($HDSTDC)
			$ARET = DLLCALL("user32.dll", "lresult", "CallWindowProc", "ptr", __XORPROC(), "ptr", 0, "uint", $ASIZE[0] * $ASIZE[1] * 4, "wparam", $ADIB[0][1], "lparam", $ADIB[1][1])
			IF NOT @ERROR AND $ARET[0] THEN
				$HRESULT = _WINAPI_CREATEICONINDIRECT($ADIB[1][0], $AHBITMAP[0])
			ENDIF
		ENDIF
		FOR $I = 0 TO 1
			_WINAPI_DELETEOBJECT($AHBITMAP[$I])
			IF $ADIB[$I][0] THEN
				_WINAPI_DELETEOBJECT($ADIB[$I][0])
			ENDIF
		NEXT
		IF NOT $HRESULT THEN RETURN SETERROR(11, 0, 0)
		IF $BDELETE THEN
			_WINAPI_DESTROYICON($HICON)
		ENDIF
		RETURN $HRESULT
	ENDFUNC
	FUNC _WINAPI_CREATEEMPTYICON($IWIDTH, $IHEIGHT, $IBITSPERPEL = 32)
		LOCAL $HXOR = _WINAPI_CREATEDIB($IWIDTH, $IHEIGHT, $IBITSPERPEL)
		LOCAL $HAND = _WINAPI_CREATEDIB($IWIDTH, $IHEIGHT, 1)
		LOCAL $HDC = _WINAPI_CREATECOMPATIBLEDC(0)
		LOCAL $HSV = _WINAPI_SELECTOBJECT($HDC, $HAND)
		LOCAL $HBRUSH = _WINAPI_CREATESOLIDBRUSH(16777215)
		LOCAL $TRECT = _WINAPI_CREATERECT(0, 0, $IWIDTH, $IHEIGHT)
		_WINAPI_FILLRECT($HDC, $TRECT, $HBRUSH)
		_WINAPI_DELETEOBJECT($HBRUSH)
		_WINAPI_SELECTOBJECT($HDC, $HSV)
		_WINAPI_DELETEDC($HDC)
		LOCAL $HICON = _WINAPI_CREATEICONINDIRECT($HXOR, $HAND)
		LOCAL $IERROR = @ERROR
		IF $HXOR THEN
			_WINAPI_DELETEOBJECT($HXOR)
		ENDIF
		IF $HAND THEN
			_WINAPI_DELETEOBJECT($HAND)
		ENDIF
		IF NOT $HICON THEN RETURN SETERROR($IERROR + 10, 0, 0)
		RETURN $HICON
	ENDFUNC
	FUNC _WINAPI_CREATEICON($HINSTANCE, $IWIDTH, $IHEIGHT, $IPLANES, $IBITSPIXEL, $PANDBITS, $PXORBITS)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "CreateIcon", "handle", $HINSTANCE, "int", $IWIDTH, "int", $IHEIGHT, "byte", $IPLANES, "byte", $IBITSPIXEL, "struct*", $PANDBITS, "struct*", $PXORBITS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEICONFROMRESOURCEEX($PDATA, $ISIZE, $BICON = TRUE, $IXDESIREDPIXELS = 0, $IYDESIREDPIXELS = 0, $IFLAGS = 0)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "CreateIconFromResourceEx", "ptr", $PDATA, "dword", $ISIZE, "bool", $BICON, "dword", 196608, "int", $IXDESIREDPIXELS, "int", $IYDESIREDPIXELS, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEICONINDIRECT($HBITMAP, $HMASK, $IXHOTSPOT = 0, $IYHOTSPOT = 0, $BICON = TRUE)
		LOCAL $TICONINFO = DLLSTRUCTCREATE($TAGICONINFO)
		DLLSTRUCTSETDATA($TICONINFO, 1, $BICON)
		DLLSTRUCTSETDATA($TICONINFO, 2, $IXHOTSPOT)
		DLLSTRUCTSETDATA($TICONINFO, 3, $IYHOTSPOT)
		DLLSTRUCTSETDATA($TICONINFO, 4, $HMASK)
		DLLSTRUCTSETDATA($TICONINFO, 5, $HBITMAP)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "CreateIconIndirect", "struct*", $TICONINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DESTROYICON($HICON)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "DestroyIcon", "handle", $HICON)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_EXTRACTICON($SICON, $IINDEX, $BSMALL = FALSE)
		LOCAL $PLARGE, $PSMALL, $TPTR = DLLSTRUCTCREATE("ptr")
		IF $BSMALL THEN
			$PLARGE = 0
			$PSMALL = DLLSTRUCTGETPTR($TPTR)
		ELSE
			$PLARGE = DLLSTRUCTGETPTR($TPTR)
			$PSMALL = 0
		ENDIF
		DLLCALL("shell32.dll", "uint", "ExtractIconExW", "wstr", $SICON, "int", $IINDEX, "ptr", $PLARGE, "ptr", $PSMALL, "uint", 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TPTR, 1)
	ENDFUNC
	FUNC _WINAPI_EXTRACTICONEX($SFILEPATH, $IINDEX, $PALARGE, $PASMALL, $IICONS)
		LOCAL $ARESULT = DLLCALL("shell32.dll", "uint", "ExtractIconExW", "wstr", $SFILEPATH, "int", $IINDEX, "struct*", $PALARGE, "struct*", $PASMALL, "uint", $IICONS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_FILEICONINIT($BRESTORE = TRUE)
		LOCAL $ARET = DLLCALL("shell32.dll", "int", 660, "int", $BRESTORE)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_GETICONDIMENSION($HICON)
		LOCAL $TICONINFO = DLLSTRUCTCREATE($TAGICONINFO)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetIconInfo", "handle", $HICON, "struct*", $TICONINFO)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TSIZE = _WINAPI_GETBITMAPDIMENSION(DLLSTRUCTGETDATA($TICONINFO, 5))
		FOR $I = 4 TO 5
			_WINAPI_DELETEOBJECT(DLLSTRUCTGETDATA($TICONINFO, $I))
		NEXT
		IF NOT ISDLLSTRUCT($TSIZE) THEN RETURN SETERROR(20, 0, 0)
		RETURN $TSIZE
	ENDFUNC
	FUNC _WINAPI_GETICONINFO($HICON)
		LOCAL $TINFO = DLLSTRUCTCREATE($TAGICONINFO)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetIconInfo", "handle", $HICON, "struct*", $TINFO)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $AICON[6]
		$AICON[0] = TRUE
		$AICON[1] = DLLSTRUCTGETDATA($TINFO, "Icon") <> 0
		$AICON[2] = DLLSTRUCTGETDATA($TINFO, "XHotSpot")
		$AICON[3] = DLLSTRUCTGETDATA($TINFO, "YHotSpot")
		$AICON[4] = DLLSTRUCTGETDATA($TINFO, "hMask")
		$AICON[5] = DLLSTRUCTGETDATA($TINFO, "hColor")
		RETURN $AICON
	ENDFUNC
	FUNC _WINAPI_GETICONINFOEX($HICON)
		LOCAL $TIIEX = DLLSTRUCTCREATE("dword;int;dword;dword;ptr;ptr;ushort;wchar[260];wchar[260]")
		DLLSTRUCTSETDATA($TIIEX, 1, DLLSTRUCTGETSIZE($TIIEX))
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetIconInfoExW", "handle", $HICON, "struct*", $TIIEX)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARESULT[8]
		FOR $I = 0 TO 7
			$ARESULT[$I] = DLLSTRUCTGETDATA($TIIEX, $I + 2)
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_LOADICON($HINSTANCE, $SNAME)
		LOCAL $STYPEOFNAME = "int"
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "LoadIconW", "handle", $HINSTANCE, $STYPEOFNAME, $SNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_LOADICONMETRIC($HINSTANCE, $SNAME, $IMETRIC)
		LOCAL $STYPEOFNAME = "int"
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		LOCAL $ARET = DLLCALL("comctl32.dll", "long", "LoadIconMetric", "handle", $HINSTANCE, $STYPEOFNAME, $SNAME, "int", $IMETRIC, "handle*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[4]
	ENDFUNC
	FUNC _WINAPI_LOADICONWITHSCALEDOWN($HINSTANCE, $SNAME, $IWIDTH, $IHEIGHT)
		LOCAL $STYPEOFNAME = "int"
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		LOCAL $ARET = DLLCALL("comctl32.dll", "long", "LoadIconWithScaleDown", "handle", $HINSTANCE, $STYPEOFNAME, $SNAME, "int", $IWIDTH, "int", $IHEIGHT, "handle*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[5]
	ENDFUNC
	FUNC _WINAPI_LOADSHELL32ICON($IICONID)
		LOCAL $TICONS = DLLSTRUCTCREATE("ptr Data")
		LOCAL $IICONS = _WINAPI_EXTRACTICONEX("shell32.dll", $IICONID, 0, $TICONS, 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $IICONS <= 0 THEN RETURN SETERROR(10, 0, 0)
		RETURN DLLSTRUCTGETDATA($TICONS, "Data")
	ENDFUNC
	FUNC _WINAPI_LOOKUPICONIDFROMDIRECTORYEX($PDATA, $BICON = TRUE, $IXDESIREDPIXELS = 0, $IYDESIREDPIXELS = 0, $IFLAGS = 0)
		LOCAL $ARET = DLLCALL("user32.dll", "int", "LookupIconIdFromDirectoryEx", "ptr", $PDATA, "bool", $BICON, "int", $IXDESIREDPIXELS, "int", $IYDESIREDPIXELS, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_MIRRORICON($HICON, $BDELETE = FALSE)
		IF NOT $BDELETE THEN
			$HICON = _WINAPI_COPYICON($HICON)
		ENDIF
		LOCAL $ARET = DLLCALL("comctl32.dll", "int", 414, "ptr", 0, "ptr*", $HICON)
		IF @ERROR OR NOT $ARET[0] THEN
			LOCAL $IERROR = @ERROR + 10
			IF $HICON AND NOT $BDELETE THEN
				_WINAPI_DESTROYICON($HICON)
			ENDIF
			RETURN SETERROR($IERROR, 0, 0)
		ENDIF
		RETURN $ARET[2]
	ENDFUNC
#EndRegion Public Functions
#Region Embedded DLL Functions
	FUNC __TRANSPARENCYPROC()
		STATIC $PPROC = 0
		IF NOT $PPROC THEN
			IF @AUTOITX64 THEN
				$PPROC = __INIT(BINARY("0x48894C240848895424104C894424184C894C24205541574831C0505050505050" & "4883EC284883BC24800000000074054831C0EB0748C7C0010000004821C07522" & "488BAC248000000048837D180074054831C0EB0748C7C0010000004821C07502" & "EB0948C7C001000000EB034831C04821C0740B4831C04863C0E93C0100004C63" & "7C24784983FF647E0F48C7C0010000004863C0E9220100004C637C24784D21FF" & "7D08C74424780000000048C74424280100000048C74424300000000048C74424" & "3800000000488BAC24800000004C637D04488BAC2480000000486345084C0FAF" & "F849C1E7024983C7FC4C3B7C24380F8C88000000488BAC24800000004C8B7D18" & "4C037C24384983C7034C897C2440488B6C2440480FB64500505888442448807C" & "244800744B4C0FB67C244848634424784C0FAFF84C89F848C7C1640000004899" & "48F7F94989C74C89F850488B6C244858884500488B6C2440807D0000740948C7" & "4424280000000048C7442430010000004883442438040F8149FFFFFF48837C24" & "3000741148837C242800740948C7C001000000EB034831C04821C0740E48C7C0" & "FFFFFFFF4863C0EB11EB0C48C7C0010000004863C0EB034831C04883C458415F" & "5DC3"))
			ELSE
				$PPROC = __INIT(BINARY("0x555331C05050505050837C242800740431C0EB05B80100000021C075198B6C24" & "28837D1400740431C0EB05B80100000021C07502EB07B801000000EB0231C021" & "C0740731C0E9E50000008B5C242483FB647E0AB801000000E9D20000008B5C24" & "2421DB7D08C744242400000000C7042401000000C744240400000000C7442408" & "000000008B6C24288B5D048B6C24280FAF5D08C1E30283C3FC3B5C24087C648B" & "6C24288B5D14035C240883C303895C240C8B6C240C0FB6450088442410807C24" & "100074380FB65C24100FAF5C242489D8B96400000099F7F989C3538B6C241058" & "8845008B6C240C807D00007407C7042400000000C74424040100000083442408" & "047181837C240400740D833C24007407B801000000EB0231C021C07409B8FFFF" & "FFFFEB0BEB07B801000000EB0231C083C4145B5DC21000"))
			ENDIF
		ENDIF
		RETURN $PPROC
	ENDFUNC
#EndRegion Embedded DLL Functions
#Region Global Variables and Constants
	GLOBAL CONST $TAGBITMAPV4HEADER = "struct;dword bV4Size;long bV4Width;long bV4Height;ushort bV4Planes;ushort bV4BitCount;dword bV4Compression;dword bV4SizeImage;long bV4XPelsPerMeter;long bV4YPelsPerMeter;dword bV4ClrUsed;dword bV4ClrImportant;dword bV4RedMask;dword bV4GreenMask;dword bV4BlueMask;dword bV4AlphaMask;dword bV4CSType;int bV4Endpoints[9];dword bV4GammaRed;dword bV4GammaGreen;dword bV4GammaBlue;endstruct"
	GLOBAL CONST $TAGCOLORADJUSTMENT = "ushort Size;ushort Flags;ushort IlluminantIndex;ushort RedGamma;ushort GreenGamma;ushort BlueGamma;ushort ReferenceBlack;ushort ReferenceWhite;short Contrast;short Brightness;short Colorfulness;short RedGreenTint"
	GLOBAL CONST $TAGDEVMODE = "wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;short Orientation;short PaperSize;short PaperLength;short PaperWidth;short Scale;short Copies;short DefaultSource;short PrintQuality;short Color;short Duplex;short YResolution;short TTOption;short Collate;wchar FormName[32];ushort Unused1;dword Unused2[3];dword Nup;dword Unused3;dword ICMMethod;dword ICMIntent;dword MediaType;dword DitherType;dword Reserved1;dword Reserved2;dword PanningWidth;dword PanningHeight"
	GLOBAL CONST $TAGDEVMODE_DISPLAY = "wchar DeviceName[32];ushort SpecVersion;ushort DriverVersion;ushort Size;ushort DriverExtra;dword Fields;" & $TAGPOINT & ";dword DisplayOrientation;dword DisplayFixedOutput;short Unused1[5];wchar Unused2[32];ushort LogPixels;dword BitsPerPel;dword PelsWidth;dword PelsHeight;dword DisplayFlags;dword DisplayFrequency"
	GLOBAL CONST $TAGDWM_COLORIZATION_PARAMETERS = "dword Color;dword AfterGlow;uint ColorBalance;uint AfterGlowBalance;uint BlurBalance;uint GlassReflectionIntensity; uint OpaqueBlend"
	GLOBAL CONST $TAGENHMETAHEADER = "struct;dword Type;dword Size;long rcBounds[4];long rcFrame[4];dword Signature;dword Version;dword Bytes;dword Records;ushort Handles;ushort Reserved;dword Description;dword OffDescription;dword PalEntries;long Device[2];long Millimeters[2];dword PixelFormat;dword OffPixelFormat;dword OpenGL;long Micrometers[2];endstruct"
	GLOBAL CONST $TAGEXTLOGPEN = "dword PenStyle;dword Width;uint BrushStyle;dword Color;ulong_ptr Hatch;dword NumEntries"
	GLOBAL CONST $TAGFONTSIGNATURE = "dword fsUsb[4];dword fsCsb[2]"
	GLOBAL CONST $TAGGLYPHMETRICS = "uint BlackBoxX;uint BlackBoxY;" & $TAGPOINT & ";short CellIncX;short CellIncY"
	GLOBAL CONST $TAGLOGBRUSH = "uint Style;dword Color;ulong_ptr Hatch"
	GLOBAL CONST $TAGLOGPEN = "uint Style;dword Width;dword Color"
	GLOBAL CONST $TAGMAT2 = "short eM11[2];short eM12[2];short eM21[2];short eM22[2]"
	GLOBAL CONST $TAGNEWTEXTMETRIC = $TAGTEXTMETRIC & ";dword ntmFlags;uint ntmSizeEM;uint ntmCellHeight;uint ntmAvgWidth"
	GLOBAL CONST $TAGNEWTEXTMETRICEX = $TAGNEWTEXTMETRIC & ";" & $TAGFONTSIGNATURE
	GLOBAL CONST $TAGPANOSE = "struct;byte bFamilyType;byte bSerifStyle;byte bWeight;byte bProportion;byte bContrast;byte bStrokeVariation;byte bArmStyle;byte bLetterform;byte bMidline;byte bXHeight;endstruct"
	GLOBAL CONST $TAGOUTLINETEXTMETRIC = "struct;uint otmSize;" & $TAGTEXTMETRIC & ";byte otmFiller;" & $TAGPANOSE & ";byte bugFiller[3];uint otmSelection;uint otmType;int otmCharSlopeRise;int otmCharSlopeRun;int otmItalicAngle;uint otmEMSquare;int otmAscent;int otmDescent;uint otmLineGap;uint otmCapEmHeight;uint otmXHeight;long otmFontBox[4];int otmMacAscent;int otmMacDescent;uint otmMacLineGap;uint otmMinimumPPEM;long otmSubscriptSize[2];long otmSubscriptOffset[2];long otmSuperscriptSize[2];long otmSuperscriptOffse[2];uint otmStrikeoutSize;int otmStrikeoutPosition;int otmUnderscoreSize;int otmUnderscorePosition;uint_ptr otmFamilyName;uint_ptr otmFaceName;uint_ptr otmStyleName;uint_ptr otmFullName;endstruct"
	GLOBAL CONST $TAGPAINTSTRUCT = "hwnd hDC;int fErase;dword rPaint[4];int fRestore;int fIncUpdate;byte rgbReserved[32]"
	GLOBAL CONST $TAGRGNDATAHEADER = "struct;dword Size;dword Type;dword Count;dword RgnSize;" & $TAGRECT & ";endstruct"
	GLOBAL CONST $TAGXFORM = "float eM11;float eM12;float eM21;float eM22;float eDx;float eDy"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_ABORTPATH($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "AbortPath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ADDFONTMEMRESOURCEEX($PDATA, $ISIZE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "AddFontMemResourceEx", "ptr", $PDATA, "dword", $ISIZE, "ptr", 0, "dword*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN SETEXTENDED($ARET[4], $ARET[0])
	ENDFUNC
	FUNC _WINAPI_ADDFONTRESOURCEEX($SFONT, $IFLAG = 0, $BNOTIFY = FALSE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "AddFontResourceExW", "wstr", $SFONT, "dword", $IFLAG, "ptr", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $BNOTIFY THEN
			LOCAL CONST $WM_FONTCHANGE = 29
			LOCAL CONST $HWND_BROADCAST = 65535
			DLLCALL("user32.dll", "lresult", "SendMessage", "hwnd", $HWND_BROADCAST, "uint", $WM_FONTCHANGE, "wparam", 0, "lparam", 0)
		ENDIF
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ADDICONOVERLAY($HICON, $HOVERLAY)
		LOCAL $ARET, $HRESULT = 0, $IERROR = 0
		LOCAL $AHDEV[2] = [0, 0]
		LOCAL $TSIZE = _WINAPI_GETICONDIMENSION($HICON)
		LOCAL $HIL = DLLCALL("comctl32.dll", "handle", "ImageList_Create", "int", DLLSTRUCTGETDATA($TSIZE, 1), "int", DLLSTRUCTGETDATA($TSIZE, 2), "uint", 33, "int", 2, "int", 2)
		IF @ERROR OR NOT $HIL[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		DO
			$AHDEV[0] = _WINAPI_CREATE32BITHICON($HICON)
			IF @ERROR THEN
				$IERROR = @ERROR + 100
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $HIL[0], "int", -1, "handle", $AHDEV[0])
			IF @ERROR OR($ARET[0] = -1) THEN
				$IERROR = @ERROR + 200
				EXITLOOP
			ENDIF
			$AHDEV[1] = _WINAPI_CREATE32BITHICON($HOVERLAY)
			IF @ERROR THEN
				$IERROR = @ERROR + 300
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("comctl32.dll", "int", "ImageList_ReplaceIcon", "handle", $HIL[0], "int", -1, "handle", $AHDEV[1])
			IF @ERROR OR($ARET[0] = -1) THEN
				$IERROR = @ERROR + 400
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("comctl32.dll", "bool", "ImageList_SetOverlayImage", "handle", $HIL[0], "int", 1, "int", 1)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 500
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("comctl32.dll", "handle", "ImageList_GetIcon", "handle", $HIL[0], "int", 0, "uint", 256)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 600
				EXITLOOP
			ENDIF
			$HRESULT = $ARET[0]
		UNTIL 1
		DLLCALL("comctl32.dll", "bool", "ImageList_Destroy", "handle", $HIL[0])
		FOR $I = 0 TO 1
			IF $AHDEV[$I] THEN
				_WINAPI_DESTROYICON($AHDEV[$I])
			ENDIF
		NEXT
		IF NOT $HRESULT THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $HRESULT
	ENDFUNC
	FUNC _WINAPI_ADJUSTBITMAP($HBITMAP, $IWIDTH, $IHEIGHT, $IMODE = 3, $TADJUSTMENT = 0)
		LOCAL $TOBJ = DLLSTRUCTCREATE($TAGBITMAP)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetObject", "handle", $HBITMAP, "int", DLLSTRUCTGETSIZE($TOBJ), "struct*", $TOBJ)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $IWIDTH = -1 THEN
			$IWIDTH = DLLSTRUCTGETDATA($TOBJ, "bmWidth")
		ENDIF
		IF $IHEIGHT = -1 THEN
			$IHEIGHT = DLLSTRUCTGETDATA($TOBJ, "bmHeight")
		ENDIF
		$ARET = DLLCALL("user32.dll", "handle", "GetDC", "hwnd", 0)
		LOCAL $HDC = $ARET[0]
		$ARET = DLLCALL("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $HDC)
		LOCAL $HDESTDC = $ARET[0]
		$ARET = DLLCALL("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $HDC, "int", $IWIDTH, "int", $IHEIGHT)
		LOCAL $HBMP = $ARET[0]
		$ARET = DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDESTDC, "handle", $HBMP)
		LOCAL $HDESTSV = $ARET[0]
		$ARET = DLLCALL("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $HDC)
		LOCAL $HSRCDC = $ARET[0]
		$ARET = DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HSRCDC, "handle", $HBITMAP)
		LOCAL $HSRCSV = $ARET[0]
		IF _WINAPI_SETSTRETCHBLTMODE($HDESTDC, $IMODE) THEN
			SWITCH $IMODE
				CASE 4
					IF ISDLLSTRUCT($TADJUSTMENT) THEN
						IF NOT _WINAPI_SETCOLORADJUSTMENT($HDESTDC, $TADJUSTMENT) THEN
						ENDIF
					ENDIF
				CASE ELSE
			ENDSWITCH
		ENDIF
		$ARET = _WINAPI_STRETCHBLT($HDESTDC, 0, 0, $IWIDTH, $IHEIGHT, $HSRCDC, 0, 0, DLLSTRUCTGETDATA($TOBJ, "bmWidth"), DLLSTRUCTGETDATA($TOBJ, "bmHeight"), 13369376)
		DLLCALL("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $HDC)
		DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDESTDC, "handle", $HDESTSV)
		DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HSRCDC, "handle", $HSRCSV)
		DLLCALL("gdi32.dll", "bool", "DeleteDC", "handle", $HDESTDC)
		DLLCALL("gdi32.dll", "bool", "DeleteDC", "handle", $HSRCDC)
		IF NOT $ARET THEN RETURN SETERROR(10, 0, 0)
		RETURN $HBMP
	ENDFUNC
	FUNC _WINAPI_ALPHABLEND($HDESTDC, $IXDEST, $IYDEST, $IWIDTHDEST, $IHEIGHTDEST, $HSRCDC, $IXSRC, $IYSRC, $IWIDTHSRC, $IHEIGHTSRC, $IALPHA, $BALPHA = FALSE)
		LOCAL $IBLEND = BITOR(BITSHIFT(NOT($BALPHA = FALSE), -24), BITSHIFT(BITAND($IALPHA, 255), -16))
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "GdiAlphaBlend", "handle", $HDESTDC, "int", $IXDEST, "int", $IYDEST, "int", $IWIDTHDEST, "int", $IHEIGHTDEST, "handle", $HSRCDC, "int", $IXSRC, "int", $IYSRC, "int", $IWIDTHSRC, "int", $IHEIGHTSRC, "dword", $IBLEND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ANGLEARC($HDC, $IX, $IY, $IRADIUS, $NSTARTANGLE, $NSWEEPANGLE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "AngleArc", "handle", $HDC, "int", $IX, "int", $IY, "dword", $IRADIUS, "float", $NSTARTANGLE, "float", $NSWEEPANGLE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ARC($HDC, $TRECT, $IXSTARTARC, $IYSTARTARC, $IXENDARC, $IYENDARC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "Arc", "handle", $HDC, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4), "int", $IXSTARTARC, "int", $IYSTARTARC, "int", $IXENDARC, "int", $IYENDARC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ARCTO($HDC, $TRECT, $IXRADIAL1, $IYRADIAL1, $IXRADIAL2, $IYRADIAL2)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "ArcTo", "handle", $HDC, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4), "int", $IXRADIAL1, "int", $IYRADIAL1, "int", $IXRADIAL2, "int", $IYRADIAL2)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_BEGINPAINT($HWND, BYREF $TPAINTSTRUCT)
		$TPAINTSTRUCT = DLLSTRUCTCREATE($TAGPAINTSTRUCT)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "BeginPaint", "hwnd", $HWND, "struct*", $TPAINTSTRUCT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_BEGINPATH($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "BeginPath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CLOSEENHMETAFILE($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "CloseEnhMetaFile", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CLOSEFIGURE($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "CloseFigure", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_COLORADJUSTLUMA($IRGB, $IPERCENT, $BSCALE = TRUE)
		IF $IRGB = -1 THEN RETURN SETERROR(10, 0, -1)
		IF $BSCALE THEN
			$IPERCENT = FLOOR($IPERCENT * 10)
		ENDIF
		LOCAL $ARET = DLLCALL("shlwapi.dll", "dword", "ColorAdjustLuma", "dword", __RGB($IRGB), "int", $IPERCENT, "bool", $BSCALE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN __RGB($ARET[0])
	ENDFUNC
	FUNC _WINAPI_COLORHLSTORGB($IHUE, $ILUMINANCE, $ISATURATION)
		IF NOT $ISATURATION THEN $IHUE = 160
		LOCAL $ARET = DLLCALL("shlwapi.dll", "dword", "ColorHLSToRGB", "word", $IHUE, "word", $ILUMINANCE, "word", $ISATURATION)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN __RGB($ARET[0])
	ENDFUNC
	FUNC _WINAPI_COLORRGBTOHLS($IRGB, BYREF $IHUE, BYREF $ILUMINANCE, BYREF $ISATURATION)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "none", "ColorRGBToHLS", "dword", __RGB($IRGB), "word*", 0, "word*", 0, "word*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		$IHUE = $ARET[2]
		$ILUMINANCE = $ARET[3]
		$ISATURATION = $ARET[4]
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_COMBINETRANSFORM($TXFORM1, $TXFORM2)
		LOCAL $TXFORM = DLLSTRUCTCREATE($TAGXFORM)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "CombineTransform", "struct*", $TXFORM, "struct*", $TXFORM1, "struct*", $TXFORM2)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TXFORM
	ENDFUNC
	FUNC _WINAPI_COMPRESSBITMAPBITS($HBITMAP, BYREF $PBUFFER, $ICOMPRESSION = 0, $IQUALITY = 100)
		IF NOT __DLL("gdiplus.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $ASIZE[2], $ICOUNT, $IFORMAT, $ILENGTH, $SMIME, $ARET, $HDC, $HSV, $HMEM, $TBITS, $TDATA, $PDATA, $IERROR = 1
		LOCAL $HSOURCE = 0, $HIMAGE = 0, $HTOKEN = 0, $PSTREAM = 0, $TPARAM = 0
		LOCAL $TDIB = DLLSTRUCTCREATE($TAGDIBSECTION)
		DO
			SWITCH $ICOMPRESSION
				CASE 0
					$SMIME = "image/png"
				CASE 1
					$SMIME = "image/jpeg"
				CASE ELSE
					$IERROR = 10
					EXITLOOP
			ENDSWITCH
			WHILE $HBITMAP
				IF NOT _WINAPI_GETOBJECT($HBITMAP, DLLSTRUCTGETSIZE($TDIB), $TDIB) THEN
					$IERROR = 11
					EXITLOOP 2
				ENDIF
				IF(DLLSTRUCTGETDATA($TDIB, "bmBitsPixel") = 32) AND(NOT DLLSTRUCTGETDATA($TDIB, "biCompression")) THEN
					$IERROR = 12
					EXITLOOP
				ENDIF
				IF $HSOURCE THEN
					$IERROR = 13
					EXITLOOP 2
				ENDIF
				$HSOURCE = _WINAPI_CREATEDIB(DLLSTRUCTGETDATA($TDIB, "bmWidth"), DLLSTRUCTGETDATA($TDIB, "bmHeight"))
				IF NOT $HSOURCE THEN
					$IERROR = @ERROR + 100
					EXITLOOP 2
				ENDIF
				$HDC = _WINAPI_CREATECOMPATIBLEDC(0)
				$HSV = _WINAPI_SELECTOBJECT($HDC, $HSOURCE)
				IF _WINAPI_DRAWBITMAP($HDC, 0, 0, $HBITMAP) THEN
					$HBITMAP = $HSOURCE
				ELSE
					$IERROR = @ERROR + 200
					$HBITMAP = 0
				ENDIF
				_WINAPI_SELECTOBJECT($HDC, $HSV)
				_WINAPI_DELETEDC($HDC)
			WEND
			IF NOT $HBITMAP THEN
				EXITLOOP
			ENDIF
			FOR $I = 0 TO 1
				$ASIZE[$I] = DLLSTRUCTGETDATA($TDIB, $I + 2)
			NEXT
			$TBITS = DLLSTRUCTCREATE("byte[" & ($ASIZE[0] * $ASIZE[1] * 4) & "]")
			IF NOT _WINAPI_GETBITMAPBITS($HBITMAP, DLLSTRUCTGETSIZE($TBITS), $TBITS) THEN
				$IERROR = @ERROR + 300
				EXITLOOP
			ENDIF
			$TDATA = DLLSTRUCTCREATE($TAGGDIPSTARTUPINPUT)
			DLLSTRUCTSETDATA($TDATA, "Version", 1)
			$ARET = DLLCALL("gdiplus.dll", "int", "GdiplusStartup", "ulong_ptr*", 0, "struct*", $TDATA, "ptr", 0)
			IF @ERROR OR $ARET[0] THEN
				$IERROR = @ERROR + 400
				EXITLOOP
			ENDIF
			IF _WINAPI_ISALPHABITMAP($HBITMAP) THEN
				$IFORMAT = 2498570
			ELSE
				$IFORMAT = 139273
			ENDIF
			$HTOKEN = $ARET[1]
			$ARET = DLLCALL("gdiplus.dll", "int", "GdipCreateBitmapFromScan0", "int", $ASIZE[0], "int", $ASIZE[1], "uint", $ASIZE[0] * 4, "int", $IFORMAT, "struct*", $TBITS, "ptr*", 0)
			IF @ERROR OR $ARET[0] THEN
				$IERROR = @ERROR + 500
				EXITLOOP
			ENDIF
			$HIMAGE = $ARET[6]
			$ARET = DLLCALL("gdiplus.dll", "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
			IF @ERROR OR $ARET[0] THEN
				$IERROR = @ERROR + 600
				EXITLOOP
			ENDIF
			$ICOUNT = $ARET[1]
			$TDATA = DLLSTRUCTCREATE("byte[" & $ARET[2] & "]")
			IF @ERROR THEN
				$IERROR = @ERROR + 700
				EXITLOOP
			ENDIF
			$PDATA = DLLSTRUCTGETPTR($TDATA)
			$ARET = DLLCALL("gdiplus.dll", "int", "GdipGetImageEncoders", "uint", $ICOUNT, "uint", $ARET[2], "struct*", $TDATA)
			IF @ERROR OR $ARET[0] THEN
				$IERROR = @ERROR + 800
				EXITLOOP
			ENDIF
			LOCAL $TCODEC, $PENCODER = 0
			FOR $I = 1 TO $ICOUNT
				$TCODEC = DLLSTRUCTCREATE($TAGGDIPIMAGECODECINFO, $PDATA)
				IF NOT STRINGINSTR(_WINAPI_WIDECHARTOMULTIBYTE(DLLSTRUCTGETDATA($TCODEC, "MimeType")), $SMIME) THEN
					$PDATA += DLLSTRUCTGETSIZE($TAGGDIPIMAGECODECINFO)
				ELSE
					$PENCODER = $PDATA
					$IERROR = 0
					EXITLOOP
				ENDIF
			NEXT
			IF NOT $PENCODER THEN
				$IERROR = 15
				EXITLOOP
			ENDIF
			SWITCH $ICOMPRESSION
				CASE 0
				CASE 1
					LOCAL CONST $TAGENCODERPARAMETER = "byte[16] GUID;ulong NumberOfValues;dword Type;ptr pValue"
					$TPARAM = DLLSTRUCTCREATE("dword Count;" & $TAGENCODERPARAMETER & ";ulong Quality")
					DLLSTRUCTSETDATA($TPARAM, "Count", 1)
					DLLSTRUCTSETDATA($TPARAM, "NumberOfValues", 1)
					DLLSTRUCTSETDATA($TPARAM, "Type", 4)
					DLLSTRUCTSETDATA($TPARAM, "pValue", DLLSTRUCTGETPTR($TPARAM, "Quality"))
					DLLSTRUCTSETDATA($TPARAM, "Quality", $IQUALITY)
					$ARET = DLLCALL("ole32.dll", "long", "CLSIDFromString", "wstr", "{1D5BE4B5-FA4A-452D-9CDD-5DB35105E7EB}", "ptr", DLLSTRUCTGETPTR($TPARAM, 2))
					IF @ERROR OR $ARET[0] THEN
						$TPARAM = 0
					ENDIF
			ENDSWITCH
			$PSTREAM = _WINAPI_CREATESTREAMONHGLOBAL()
			$ARET = DLLCALL("gdiplus.dll", "int", "GdipSaveImageToStream", "handle", $HIMAGE, "ptr", $PSTREAM, "ptr", $PENCODER, "struct*", $TPARAM)
			IF @ERROR OR $ARET[0] THEN
				$IERROR = @ERROR + 900
				EXITLOOP
			ENDIF
			$HMEM = _WINAPI_GETHGLOBALFROMSTREAM($PSTREAM)
			$ARET = DLLCALL("kernel32.dll", "ulong_ptr", "GlobalSize", "handle", $HMEM)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 1000
				EXITLOOP
			ENDIF
			$ILENGTH = $ARET[0]
			$ARET = DLLCALL("kernel32.dll", "ptr", "GlobalLock", "handle", $HMEM)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 1100
				EXITLOOP
			ENDIF
			$PBUFFER = __HEAPREALLOC($PBUFFER, $ILENGTH, 1)
			IF NOT @ERROR THEN
				_WINAPI_MOVEMEMORY($PBUFFER, $ARET[0], $ILENGTH)
			ELSE
				$IERROR = @ERROR + 1300
			ENDIF
		UNTIL 1
		IF $PSTREAM THEN
			_WINAPI_RELEASESTREAM($PSTREAM)
		ENDIF
		IF $HIMAGE THEN
			DLLCALL("gdiplus.dll", "int", "GdipDisposeImage", "handle", $HIMAGE)
		ENDIF
		IF $HTOKEN THEN
			DLLCALL("gdiplus.dll", "none", "GdiplusShutdown", "ulong_ptr", $HTOKEN)
		ENDIF
		IF $HSOURCE THEN
			_WINAPI_DELETEOBJECT($HSOURCE)
		ENDIF
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ILENGTH
	ENDFUNC
	FUNC _WINAPI_COPYENHMETAFILE($HEMF, $SFILEPATH = "")
		LOCAL $STYPEOFFILE = "wstr"
		IF NOT STRINGSTRIPWS($SFILEPATH, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFFILE = "ptr"
			$SFILEPATH = 0
		ENDIF
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "CopyEnhMetaFileW", "handle", $HEMF, $STYPEOFFILE, $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_COPYRECT($TRECT)
		LOCAL $TDATA = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "CopyRect", "struct*", $TDATA, "struct*", $TRECT)
		IF @ERROR OR NOT $ARET[0] THEN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TDATA
	ENDFUNC
	FUNC _WINAPI_CREATE32BITHBITMAP($HICON, $BDIB = FALSE, $BDELETE = FALSE)
		LOCAL $HBITMAP = 0
		LOCAL $ADIB[2] = [0, 0]
		LOCAL $HTEMP = _WINAPI_CREATE32BITHICON($HICON)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $IERROR = 0
		DO
			LOCAL $TICONINFO = DLLSTRUCTCREATE($TAGICONINFO)
			LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetIconInfo", "handle", $HTEMP, "struct*", $TICONINFO)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
			FOR $I = 0 TO 1
				$ADIB[$I] = DLLSTRUCTGETDATA($TICONINFO, $I + 4)
			NEXT
			LOCAL $TBITMAP = DLLSTRUCTCREATE($TAGBITMAP)
			IF NOT _WINAPI_GETOBJECT($ADIB[0], DLLSTRUCTGETSIZE($TBITMAP), $TBITMAP) THEN
				$IERROR = @ERROR + 20
				EXITLOOP
			ENDIF
			IF $BDIB THEN
				$HBITMAP = _WINAPI_CREATEDIB(DLLSTRUCTGETDATA($TBITMAP, "bmWidth"), DLLSTRUCTGETDATA($TBITMAP, "bmHeight"))
				LOCAL $HDC = _WINAPI_CREATECOMPATIBLEDC(0)
				LOCAL $HSV = _WINAPI_SELECTOBJECT($HDC, $HBITMAP)
				_WINAPI_DRAWICONEX($HDC, 0, 0, $HTEMP)
				_WINAPI_SELECTOBJECT($HDC, $HSV)
				_WINAPI_DELETEDC($HDC)
			ELSE
				$HBITMAP = $ADIB[1]
				$ADIB[1] = 0
			ENDIF
		UNTIL 1
		FOR $I = 0 TO 1
			IF $ADIB[$I] THEN
				_WINAPI_DELETEOBJECT($ADIB[$I])
			ENDIF
		NEXT
		_WINAPI_DESTROYICON($HTEMP)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		IF NOT $HBITMAP THEN RETURN SETERROR(12, 0, 0)
		IF $BDELETE THEN
			_WINAPI_DESTROYICON($HICON)
		ENDIF
		RETURN $HBITMAP
	ENDFUNC
	FUNC _WINAPI_CREATEBITMAPINDIRECT(BYREF $TBITMAP)
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "CreateBitmapIndirect", "struct*", $TBITMAP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEBRUSHINDIRECT($ISTYLE, $IRGB, $IHATCH = 0)
		LOCAL $TLOGBRUSH = DLLSTRUCTCREATE($TAGLOGBRUSH)
		DLLSTRUCTSETDATA($TLOGBRUSH, 1, $ISTYLE)
		DLLSTRUCTSETDATA($TLOGBRUSH, 2, __RGB($IRGB))
		DLLSTRUCTSETDATA($TLOGBRUSH, 3, $IHATCH)
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "CreateBrushIndirect", "struct*", $TLOGBRUSH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATECOLORADJUSTMENT($IFLAGS = 0, $IILLUMINANT = 0, $IGAMMAR = 10000, $IGAMMAG = 10000, $IGAMMAB = 10000, $IBLACK = 0, $IWHITE = 10000, $ICONTRAST = 0, $IBRIGHTNESS = 0, $ICOLORFULNESS = 0, $ITINT = 0)
		LOCAL $TCA = DLLSTRUCTCREATE($TAGCOLORADJUSTMENT)
		DLLSTRUCTSETDATA($TCA, 1, DLLSTRUCTGETSIZE($TCA))
		DLLSTRUCTSETDATA($TCA, 2, $IFLAGS)
		DLLSTRUCTSETDATA($TCA, 3, $IILLUMINANT)
		DLLSTRUCTSETDATA($TCA, 4, $IGAMMAR)
		DLLSTRUCTSETDATA($TCA, 5, $IGAMMAG)
		DLLSTRUCTSETDATA($TCA, 6, $IGAMMAB)
		DLLSTRUCTSETDATA($TCA, 7, $IBLACK)
		DLLSTRUCTSETDATA($TCA, 8, $IWHITE)
		DLLSTRUCTSETDATA($TCA, 9, $ICONTRAST)
		DLLSTRUCTSETDATA($TCA, 10, $IBRIGHTNESS)
		DLLSTRUCTSETDATA($TCA, 11, $ICOLORFULNESS)
		DLLSTRUCTSETDATA($TCA, 12, $ITINT)
		RETURN $TCA
	ENDFUNC
	FUNC _WINAPI_CREATECOMPATIBLEBITMAPEX($HDC, $IWIDTH, $IHEIGHT, $IRGB)
		LOCAL $HBRUSH = _WINAPI_CREATEBRUSHINDIRECT(0, $IRGB)
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $HDC)
		LOCAL $HDESTDC = $ARET[0]
		$ARET = DLLCALL("gdi32.dll", "handle", "CreateCompatibleBitmap", "handle", $HDC, "int", $IWIDTH, "int", $IHEIGHT)
		LOCAL $HBMP = $ARET[0]
		$ARET = DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDESTDC, "handle", $HBMP)
		LOCAL $HDESTSV = $ARET[0]
		LOCAL $TRECT = _WINAPI_CREATERECTEX(0, 0, $IWIDTH, $IHEIGHT)
		LOCAL $IERROR = 0
		$ARET = DLLCALL("user32.dll", "int", "FillRect", "handle", $HDESTDC, "struct*", $TRECT, "handle", $HBRUSH)
		IF @ERROR OR NOT $ARET[0] THEN
			$IERROR = @ERROR + 10
			_WINAPI_DELETEOBJECT($HBMP)
		ENDIF
		_WINAPI_DELETEOBJECT($HBRUSH)
		DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDESTDC, "handle", $HDESTSV)
		DLLCALL("gdi32.dll", "bool", "DeleteDC", "handle", $HDESTDC)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $HBMP
	ENDFUNC
	FUNC _WINAPI_CREATEDIBITMAP($HDC, BYREF $TBITMAPINFO, $IUSAGE, $PBITS = 0)
		LOCAL $IINIT = 0
		IF $PBITS THEN
			$IINIT = 4
		ENDIF
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "CreateDIBitmap", "handle", $HDC, "struct*", $TBITMAPINFO, "dword", $IINIT, "struct*", $PBITS, "struct*", $TBITMAPINFO, "uint", $IUSAGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEELLIPTICRGN($TRECT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "CreateEllipticRgnIndirect", "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEENHMETAFILE($HDC = 0, $TRECT = 0, $BPIXELS = FALSE, $SFILEPATH = "", $SDESCRIPTION = "")
		LOCAL $STYPEOFFILE = "wstr"
		IF NOT STRINGSTRIPWS($SFILEPATH, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFFILE = "ptr"
			$SFILEPATH = 0
		ENDIF
		LOCAL $TDATA = 0, $ADATA = STRINGSPLIT($SDESCRIPTION, "|", $STR_NOCOUNT)
		IF UBOUND($ADATA) < 2 THEN
			REDIM $ADATA[2]
			$ADATA[1] = ""
		ENDIF
		FOR $I = 0 TO 1
			$ADATA[$I] = STRINGSTRIPWS($ADATA[$I], $STR_STRIPLEADING + $STR_STRIPTRAILING)
		NEXT
		IF($ADATA[0]) OR($ADATA[1]) THEN
			$TDATA = _WINAPI_ARRAYTOSTRUCT($ADATA)
		ENDIF
		LOCAL $IXP, $IYP, $IXM, $IYM, $HREF = 0
		IF $BPIXELS AND(ISDLLSTRUCT($TRECT)) THEN
			IF NOT $HDC THEN
				$HREF = _WINAPI_GETDC(0)
			ENDIF
			$IXP = _WINAPI_GETDEVICECAPS($HREF, 8)
			$IYP = _WINAPI_GETDEVICECAPS($HREF, 10)
			$IXM = _WINAPI_GETDEVICECAPS($HREF, 4)
			$IYM = _WINAPI_GETDEVICECAPS($HREF, 6)
			IF $HREF THEN
				_WINAPI_RELEASEDC(0, $HREF)
			ENDIF
			FOR $I = 1 TO 3 STEP 2
				DLLSTRUCTSETDATA($TRECT, $I, ROUND(DLLSTRUCTGETDATA($TRECT, $I) * $IXM / $IXP * 100))
			NEXT
			FOR $I = 2 TO 4 STEP 2
				DLLSTRUCTSETDATA($TRECT, $I, ROUND(DLLSTRUCTGETDATA($TRECT, $I) * $IYM / $IYP * 100))
			NEXT
		ENDIF
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "CreateEnhMetaFileW", "handle", $HDC, $STYPEOFFILE, $SFILEPATH, "struct*", $TRECT, "struct*", $TDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEFONTEX($IHEIGHT, $IWIDTH = 0, $IESCAPEMENT = 0, $IORIENTATION = 0, $IWEIGHT = 400, $BITALIC = FALSE, $BUNDERLINE = FALSE, $BSTRIKEOUT = FALSE, $ICHARSET = 1, $IOUTPRECISION = 0, $ICLIPPRECISION = 0, $IQUALITY = 0, $IPITCHANDFAMILY = 0, $SFACENAME = "", $ISTYLE = 0)
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "CreateFontW", "int", $IHEIGHT, "int", $IWIDTH, "int", $IESCAPEMENT, "int", $IORIENTATION, "int", $IWEIGHT, "dword", $BITALIC, "dword", $BUNDERLINE, "dword", $BSTRIKEOUT, "dword", $ICHARSET, "dword", $IOUTPRECISION, "dword", $ICLIPPRECISION, "dword", $IQUALITY, "dword", $IPITCHANDFAMILY, "wstr", _WINAPI_GETFONTNAME($SFACENAME, $ISTYLE, $ICHARSET))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATENULLRGN()
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "CreateRectRgn", "int", 0, "int", 0, "int", 0, "int", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEPEN($IPENSTYLE, $IWIDTH, $ICOLOR)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "handle", "CreatePen", "int", $IPENSTYLE, "int", $IWIDTH, "INT", $ICOLOR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_CREATEPOLYGONRGN(CONST BYREF $APOINT, $ISTART = 0, $IEND = -1, $IMODE = 1)
		IF __CHECKERRORARRAYBOUNDS($APOINT, $ISTART, $IEND, 2, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TAGSTRUCT = ""
		FOR $I = $ISTART TO $IEND
			$TAGSTRUCT &= "int[2];"
		NEXT
		LOCAL $TDATA = DLLSTRUCTCREATE($TAGSTRUCT)
		LOCAL $ICOUNT = 1
		FOR $I = $ISTART TO $IEND
			FOR $J = 0 TO 1
				DLLSTRUCTSETDATA($TDATA, $ICOUNT, $APOINT[$I][$J], $J + 1)
			NEXT
			$ICOUNT += 1
		NEXT
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "CreatePolygonRgn", "struct*", $TDATA, "int", $ICOUNT - 1, "int", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATERECTRGNINDIRECT($TRECT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "CreateRectRgnIndirect", "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATESOLIDBITMAP($HWND, $ICOLOR, $IWIDTH, $IHEIGHT, $BRGB = 1)
		LOCAL $HDC = _WINAPI_GETDC($HWND)
		LOCAL $HDESTDC = _WINAPI_CREATECOMPATIBLEDC($HDC)
		LOCAL $HBITMAP = _WINAPI_CREATECOMPATIBLEBITMAP($HDC, $IWIDTH, $IHEIGHT)
		LOCAL $HOLD = _WINAPI_SELECTOBJECT($HDESTDC, $HBITMAP)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		DLLSTRUCTSETDATA($TRECT, 1, 0)
		DLLSTRUCTSETDATA($TRECT, 2, 0)
		DLLSTRUCTSETDATA($TRECT, 3, $IWIDTH)
		DLLSTRUCTSETDATA($TRECT, 4, $IHEIGHT)
		IF $BRGB THEN
			$ICOLOR = BITOR(BITAND($ICOLOR, 65280), BITSHIFT(BITAND($ICOLOR, 255), -16), BITSHIFT(BITAND($ICOLOR, 16711680), 16))
		ENDIF
		LOCAL $HBRUSH = _WINAPI_CREATESOLIDBRUSH($ICOLOR)
		IF NOT _WINAPI_FILLRECT($HDESTDC, $TRECT, $HBRUSH) THEN
			_WINAPI_DELETEOBJECT($HBITMAP)
			$HBITMAP = 0
		ENDIF
		_WINAPI_DELETEOBJECT($HBRUSH)
		_WINAPI_RELEASEDC($HWND, $HDC)
		_WINAPI_SELECTOBJECT($HDESTDC, $HOLD)
		_WINAPI_DELETEDC($HDESTDC)
		IF NOT $HBITMAP THEN RETURN SETERROR(1, 0, 0)
		RETURN $HBITMAP
	ENDFUNC
	FUNC _WINAPI_CREATETRANSFORM($NM11 = 1, $NM12 = 0, $NM21 = 0, $NM22 = 1, $NDX = 0, $NDY = 0)
		LOCAL $TXFORM = DLLSTRUCTCREATE($TAGXFORM)
		DLLSTRUCTSETDATA($TXFORM, 1, $NM11)
		DLLSTRUCTSETDATA($TXFORM, 2, $NM12)
		DLLSTRUCTSETDATA($TXFORM, 3, $NM21)
		DLLSTRUCTSETDATA($TXFORM, 4, $NM22)
		DLLSTRUCTSETDATA($TXFORM, 5, $NDX)
		DLLSTRUCTSETDATA($TXFORM, 6, $NDY)
		RETURN $TXFORM
	ENDFUNC
	FUNC _WINAPI_DELETEENHMETAFILE($HEMF)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "DeleteEnhMetaFile", "handle", $HEMF)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DPTOLP($HDC, BYREF $TPOINT, $ICOUNT = 1)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "DPtoLP", "handle", $HDC, "struct*", $TPOINT, "int", $ICOUNT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DRAWANIMATEDRECTS($HWND, $TRECTFROM, $TRECTTO)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "DrawAnimatedRects", "hwnd", $HWND, "int", 3, "struct*", $TRECTFROM, "struct*", $TRECTTO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DRAWBITMAP($HDC, $IX, $IY, $HBITMAP, $IROP = 13369376)
		LOCAL $TOBJ = DLLSTRUCTCREATE($TAGBITMAP)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetObject", "handle", $HBITMAP, "int", DLLSTRUCTGETSIZE($TOBJ), "struct*", $TOBJ)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		$ARET = DLLCALL("user32.dll", "handle", "GetDC", "hwnd", 0)
		LOCAL $_HDC = $ARET[0]
		$ARET = DLLCALL("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $_HDC)
		LOCAL $HSRCDC = $ARET[0]
		$ARET = DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HSRCDC, "handle", $HBITMAP)
		LOCAL $HSRCSV = $ARET[0]
		LOCAL $IERROR = 0
		$ARET = DLLCALL("gdi32.dll", "int", "BitBlt", "hwnd", $HDC, "int", $IX, "int", $IY, "int", DLLSTRUCTGETDATA($TOBJ, "bmWidth"), "int", DLLSTRUCTGETDATA($TOBJ, "bmHeight"), "hwnd", $HSRCDC, "int", 0, "int", 0, "int", $IROP)
		IF @ERROR OR NOT $ARET[0] THEN
			$IERROR = @ERROR + 1
		ENDIF
		DLLCALL("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $_HDC)
		DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HSRCDC, "handle", $HSRCSV)
		DLLCALL("gdi32.dll", "bool", "DeleteDC", "handle", $HSRCDC)
		IF $IERROR THEN RETURN SETERROR(10, 0, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DRAWFOCUSRECT($HDC, $TRECT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "DrawFocusRect", "handle", $HDC, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DRAWLINE($HDC, $IX1, $IY1, $IX2, $IY2)
		_WINAPI_MOVETO($HDC, $IX1, $IY1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		_WINAPI_LINETO($HDC, $IX2, $IY2)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
		RETURN TRUE
	ENDFUNC
	FUNC _WINAPI_DRAWSHADOWTEXT($HDC, $STEXT, $IRGBTEXT, $IRGBSHADOW, $IXOFFSET = 0, $IYOFFSET = 0, $TRECT = 0, $IFLAGS = 0)
		LOCAL $ARET
		IF NOT ISDLLSTRUCT($TRECT) THEN
			$TRECT = DLLSTRUCTCREATE($TAGRECT)
			$ARET = DLLCALL("user32.dll", "bool", "GetClientRect", "hwnd", _WINAPI_WINDOWFROMDC($HDC), "struct*", $TRECT)
			IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			IF NOT $ARET[0] THEN RETURN SETERROR(10, 0, 0)
		ENDIF
		$ARET = DLLCALL("comctl32.dll", "int", "DrawShadowText", "handle", $HDC, "wstr", $STEXT, "uint", -1, "struct*", $TRECT, "dword", $IFLAGS, "int", __RGB($IRGBTEXT), "int", __RGB($IRGBSHADOW), "int", $IXOFFSET, "int", $IYOFFSET)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DWMDEFWINDOWPROC($HWND, $IMSG, $WPARAM, $LPARAM)
		LOCAL $ARET = DLLCALL("dwmapi.dll", "bool", "DwmDefWindowProc", "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM, "lresult*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ARET[5]
	ENDFUNC
	FUNC _WINAPI_DWMENABLEBLURBEHINDWINDOW($HWND, $BENABLE = TRUE, $BTRANSITION = FALSE, $HRGN = 0)
		LOCAL $TBLURBEHIND = DLLSTRUCTCREATE("dword;bool;handle;bool")
		LOCAL $IFLAGS = 0
		IF $HRGN THEN
			$IFLAGS += 2
			DLLSTRUCTSETDATA($TBLURBEHIND, 3, $HRGN)
		ENDIF
		DLLSTRUCTSETDATA($TBLURBEHIND, 1, BITOR($IFLAGS, 5))
		DLLSTRUCTSETDATA($TBLURBEHIND, 2, $BENABLE)
		DLLSTRUCTSETDATA($TBLURBEHIND, 4, $BTRANSITION)
		LOCAL $ARET = DLLCALL("dwmapi.dll", "long", "DwmEnableBlurBehindWindow", "hwnd", $HWND, "struct*", $TBLURBEHIND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMENABLECOMPOSITION($BENABLE)
		IF $BENABLE THEN $BENABLE = 1
		LOCAL $ARET = DLLCALL("dwmapi.dll", "long", "DwmEnableComposition", "uint", $BENABLE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMEXTENDFRAMEINTOCLIENTAREA($HWND, $TMARGINS = 0)
		IF NOT ISDLLSTRUCT($TMARGINS) THEN
			$TMARGINS = _WINAPI_CREATEMARGINS(-1, -1, -1, -1)
		ENDIF
		LOCAL $ARET = DLLCALL("dwmapi.dll", "long", "DwmExtendFrameIntoClientArea", "hwnd", $HWND, "struct*", $TMARGINS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMGETCOLORIZATIONCOLOR()
		LOCAL $ARET = DLLCALL("dwmapi.dll", "long", "DwmGetColorizationColor", "dword*", 0, "bool*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN SETEXTENDED($ARET[2], $ARET[1])
	ENDFUNC
	FUNC _WINAPI_DWMGETCOLORIZATIONPARAMETERS()
		LOCAL $TDWMCP = DLLSTRUCTCREATE($TAGDWM_COLORIZATION_PARAMETERS)
		LOCAL $ARET = DLLCALL("dwmapi.dll", "uint", 127, "struct*", $TDWMCP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TDWMCP
	ENDFUNC
	FUNC _WINAPI_DWMGETWINDOWATTRIBUTE($HWND, $IATTRIBUTE)
		LOCAL $TAGSTRUCT
		SWITCH $IATTRIBUTE
			CASE 5, 9
				$TAGSTRUCT = $TAGRECT
			CASE 1
				$TAGSTRUCT = "uint"
			CASE ELSE
				RETURN SETERROR(11, 0, 0)
		ENDSWITCH
		LOCAL $TDATA = DLLSTRUCTCREATE($TAGSTRUCT)
		LOCAL $ARET = DLLCALL("dwmapi.dll", "long", "DwmGetWindowAttribute", "hwnd", $HWND, "dword", $IATTRIBUTE, "struct*", $TDATA, "dword", DLLSTRUCTGETSIZE($TDATA))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		SWITCH $IATTRIBUTE
			CASE 1
				RETURN DLLSTRUCTGETDATA($TDATA, 1)
			CASE ELSE
				RETURN $TDATA
		ENDSWITCH
	ENDFUNC
	FUNC _WINAPI_DWMINVALIDATEICONICBITMAPS($HWND)
		LOCAL $ARET = DLLCALL("dwmapi.dll", "long", "DwmInvalidateIconicBitmaps", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMISCOMPOSITIONENABLED()
		LOCAL $ARET = DLLCALL("dwmapi.dll", "long", "DwmIsCompositionEnabled", "bool*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_DWMQUERYTHUMBNAILSOURCESIZE($HTHUMBNAIL)
		LOCAL $TSIZE = DLLSTRUCTCREATE($TAGSIZE)
		LOCAL $ARET = DLLCALL("dwmapi.dll", "long", "DwmQueryThumbnailSourceSize", "handle", $HTHUMBNAIL, "struct*", $TSIZE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TSIZE
	ENDFUNC
	FUNC _WINAPI_DWMREGISTERTHUMBNAIL($HDESTINATION, $HSOURCE)
		LOCAL $ARET = DLLCALL("dwmapi.dll", "long", "DwmRegisterThumbnail", "hwnd", $HDESTINATION, "hwnd", $HSOURCE, "handle*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_DWMSETCOLORIZATIONPARAMETERS($TDWMCP)
		LOCAL $ARET = DLLCALL("dwmapi.dll", "uint", 131, "struct*", $TDWMCP, "uint", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMSETICONICLIVEPREVIEWBITMAP($HWND, $HBITMAP, $BFRAME = FALSE, $TCLIENT = 0)
		LOCAL $IFLAGS
		IF $BFRAME THEN
			$IFLAGS = 1
		ELSE
			$IFLAGS = 0
		ENDIF
		LOCAL $ARET = DLLCALL("dwmapi.dll", "uint", "DwmSetIconicLivePreviewBitmap", "hwnd", $HWND, "handle", $HBITMAP, "struct*", $TCLIENT, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMSETICONICTHUMBNAIL($HWND, $HBITMAP, $BFRAME = FALSE)
		LOCAL $IFLAGS
		IF $BFRAME THEN
			$IFLAGS = 1
		ELSE
			$IFLAGS = 0
		ENDIF
		LOCAL $ARET = DLLCALL("dwmapi.dll", "long", "DwmSetIconicThumbnail", "hwnd", $HWND, "handle", $HBITMAP, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMSETWINDOWATTRIBUTE($HWND, $IATTRIBUTE, $IDATA)
		SWITCH $IATTRIBUTE
			CASE 2, 3, 4, 6, 7, 8, 10, 11, 12
			CASE ELSE
				RETURN SETERROR(1, 0, 0)
		ENDSWITCH
		LOCAL $ARET = DLLCALL("dwmapi.dll", "long", "DwmSetWindowAttribute", "hwnd", $HWND, "dword", $IATTRIBUTE, "dword*", $IDATA, "dword", 4)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMUNREGISTERTHUMBNAIL($HTHUMBNAIL)
		LOCAL $ARET = DLLCALL("dwmapi.dll", "long", "DwmUnregisterThumbnail", "handle", $HTHUMBNAIL)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DWMUPDATETHUMBNAILPROPERTIES($HTHUMBNAIL, $BVISIBLE = TRUE, $BCLIENTAREAONLY = FALSE, $IOPACITY = 255, $TRECTDEST = 0, $TRECTSRC = 0)
		LOCAL CONST $TAGDWM_THUMBNAIL_PROPERTIES = "struct;dword dwFlags;int rcDestination[4];int rcSource[4];byte opacity;bool opacity;bool fSourceClientAreaOnly;endstruct"
		LOCAL $TTHUMBNAILPROPERTIES = DLLSTRUCTCREATE($TAGDWM_THUMBNAIL_PROPERTIES)
		LOCAL $TSIZE, $IFLAGS = 0
		IF NOT ISDLLSTRUCT($TRECTDEST) THEN
			$TSIZE = _WINAPI_DWMQUERYTHUMBNAILSOURCESIZE($HTHUMBNAIL)
			IF @ERROR THEN
				RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			ENDIF
			$TRECTDEST = _WINAPI_CREATERECTEX(0, 0, DLLSTRUCTGETDATA($TSIZE, 1), DLLSTRUCTGETDATA($TSIZE, 2))
		ENDIF
		FOR $I = 1 TO 4
			DLLSTRUCTSETDATA($TTHUMBNAILPROPERTIES, 2, DLLSTRUCTGETDATA($TRECTDEST, $I), $I)
		NEXT
		IF ISDLLSTRUCT($TRECTSRC) THEN
			$IFLAGS += 2
			FOR $I = 1 TO 4
				DLLSTRUCTSETDATA($TTHUMBNAILPROPERTIES, 3, DLLSTRUCTGETDATA($TRECTSRC, $I), $I)
			NEXT
		ENDIF
		DLLSTRUCTSETDATA($TTHUMBNAILPROPERTIES, 1, BITOR($IFLAGS, 29))
		DLLSTRUCTSETDATA($TTHUMBNAILPROPERTIES, 4, $IOPACITY)
		DLLSTRUCTSETDATA($TTHUMBNAILPROPERTIES, 5, $BVISIBLE)
		DLLSTRUCTSETDATA($TTHUMBNAILPROPERTIES, 6, $BCLIENTAREAONLY)
		LOCAL $ARET = DLLCALL("dwmapi.dll", "long", "DwmUpdateThumbnailProperties", "handle", $HTHUMBNAIL, "struct*", $TTHUMBNAILPROPERTIES)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_ELLIPSE($HDC, $TRECT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "Ellipse", "handle", $HDC, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ENDPAINT($HWND, BYREF $TPAINTSTRUCT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "EndPaint", "hwnd", $HWND, "struct*", $TPAINTSTRUCT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ENDPATH($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "EndPath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ENUMDISPLAYMONITORS($HDC = 0, $TRECT = 0)
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumDisplayMonitorsProc", "bool", "handle;handle;ptr;lparam")
		DIM $__G_VENUM[101][2] = [[0]]
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "EnumDisplayMonitors", "handle", $HDC, "struct*", $TRECT, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "lparam", 0)
		IF @ERROR OR NOT $ARET[0] OR NOT $__G_VENUM[0][0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_ENUMDISPLAYSETTINGS($SDEVICE, $IMODE)
		LOCAL $STYPEOFDEVICE = "wstr"
		IF NOT STRINGSTRIPWS($SDEVICE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFDEVICE = "ptr"
			$SDEVICE = 0
		ENDIF
		LOCAL $TDEVMODE = DLLSTRUCTCREATE($TAGDEVMODE_DISPLAY)
		DLLSTRUCTSETDATA($TDEVMODE, "Size", DLLSTRUCTGETSIZE($TDEVMODE))
		DLLSTRUCTSETDATA($TDEVMODE, "DriverExtra", 0)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "EnumDisplaySettingsW", $STYPEOFDEVICE, $SDEVICE, "dword", $IMODE, "struct*", $TDEVMODE)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARESULT[5]
		$ARESULT[0] = DLLSTRUCTGETDATA($TDEVMODE, "PelsWidth")
		$ARESULT[1] = DLLSTRUCTGETDATA($TDEVMODE, "PelsHeight")
		$ARESULT[2] = DLLSTRUCTGETDATA($TDEVMODE, "BitsPerPel")
		$ARESULT[3] = DLLSTRUCTGETDATA($TDEVMODE, "DisplayFrequency")
		$ARESULT[4] = DLLSTRUCTGETDATA($TDEVMODE, "DisplayFlags")
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_ENUMFONTFAMILIES($HDC = 0, $SFACENAME = "", $ICHARSET = 1, $IFONTTYPE = 7, $SPATTERN = "", $BEXCLUDE = FALSE)
		LOCAL $TLOGFONT = DLLSTRUCTCREATE($TAGLOGFONT)
		LOCAL $TPATTERN = DLLSTRUCTCREATE("uint;uint;ptr;wchar[" & (STRINGLEN($SPATTERN) + 1) & "]")
		DLLSTRUCTSETDATA($TPATTERN, 1, $IFONTTYPE)
		IF NOT $SPATTERN THEN
			DLLSTRUCTSETDATA($TPATTERN, 2, 0)
			DLLSTRUCTSETDATA($TPATTERN, 3, 0)
		ELSE
			DLLSTRUCTSETDATA($TPATTERN, 2, $BEXCLUDE)
			DLLSTRUCTSETDATA($TPATTERN, 3, DLLSTRUCTGETPTR($TPATTERN, 4))
			DLLSTRUCTSETDATA($TPATTERN, 4, $SPATTERN)
		ENDIF
		DLLSTRUCTSETDATA($TLOGFONT, 9, $ICHARSET)
		DLLSTRUCTSETDATA($TLOGFONT, 13, 0)
		DLLSTRUCTSETDATA($TLOGFONT, 14, STRINGLEFT($SFACENAME, 31))
		LOCAL $HCDC
		IF NOT $HDC THEN
			$HCDC = _WINAPI_CREATECOMPATIBLEDC(0)
		ELSE
			$HCDC = $HDC
		ENDIF
		DIM $__G_VENUM[101][8] = [[0]]
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumFontFamiliesProc", "int", "ptr;ptr;dword;PTR")
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "EnumFontFamiliesExW", "handle", $HCDC, "struct*", $TLOGFONT, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "struct*", $TPATTERN, "dword", 0)
		IF @ERROR OR NOT $ARET[0] OR NOT $__G_VENUM[0][0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF NOT $HDC THEN
			_WINAPI_DELETEDC($HCDC)
		ENDIF
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_EQUALRECT($TRECT1, $TRECT2)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "EqualRect", "struct*", $TRECT1, "struct*", $TRECT2)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_EQUALRGN($HRGN1, $HRGN2)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "EqualRgn", "handle", $HRGN1, "handle", $HRGN2)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_EXCLUDECLIPRECT($HDC, $TRECT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "ExcludeClipRect", "handle", $HDC, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_EXTCREATEPEN($IPENSTYLE, $IWIDTH, $IBRUSHSTYLE, $IRGB, $IHATCH = 0, $AUSERSTYLE = 0, $ISTART = 0, $IEND = -1)
		LOCAL $ICOUNT = 0, $TSTYLE = 0
		IF BITAND($IPENSTYLE, 255) = 7 THEN
			IF __CHECKERRORARRAYBOUNDS($AUSERSTYLE, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			$TSTYLE = DLLSTRUCTCREATE("dword[" & ($IEND - $ISTART + 1) & "]")
			FOR $I = $ISTART TO $IEND
				DLLSTRUCTSETDATA($TSTYLE, 1, $AUSERSTYLE[$I], $ICOUNT + 1)
				$ICOUNT += 1
			NEXT
		ENDIF
		LOCAL $TLOGBRUSH = DLLSTRUCTCREATE($TAGLOGBRUSH)
		DLLSTRUCTSETDATA($TLOGBRUSH, 1, $IBRUSHSTYLE)
		DLLSTRUCTSETDATA($TLOGBRUSH, 2, __RGB($IRGB))
		DLLSTRUCTSETDATA($TLOGBRUSH, 3, $IHATCH)
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "ExtCreatePen", "dword", $IPENSTYLE, "dword", $IWIDTH, "struct*", $TLOGBRUSH, "dword", $ICOUNT, "struct*", $TSTYLE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_EXTCREATEREGION($TRGNDATA, $TXFORM = 0)
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "ExtCreateRegion", "struct*", $TXFORM, "dword", DLLSTRUCTGETSIZE($TRGNDATA), "struct*", $TRGNDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_EXTFLOODFILL($HDC, $IX, $IY, $IRGB, $ITYPE = 0)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "ExtFloodFill", "handle", $HDC, "int", $IX, "int", $IY, "dword", __RGB($IRGB), "uint", $ITYPE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_EXTSELECTCLIPRGN($HDC, $HRGN, $IMODE = 5)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "ExtSelectClipRgn", "handle", $HDC, "handle", $HRGN, "int", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FILLPATH($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "FillPath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FILLRGN($HDC, $HRGN, $HBRUSH)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "FillRgn", "handle", $HDC, "handle", $HRGN, "handle", $HBRUSH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FLATTENPATH($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "FlattenPath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FRAMERGN($HDC, $HRGN, $HBRUSH, $IWIDTH, $IHEIGHT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "FrameRgn", "handle", $HDC, "handle", $HRGN, "handle", $HBRUSH, "int", $IWIDTH, "int", $IHEIGHT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GDICOMMENT($HDC, $PBUFFER, $ISIZE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "GdiComment", "handle", $HDC, "uint", $ISIZE, "struct*", $PBUFFER)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETARCDIRECTION($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetArcDirection", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF($ARET[0] < 1) OR($ARET[0] > 2) THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETBITMAPBITS($HBITMAP, $ISIZE, $PBITS)
		LOCAL $ARET = DLLCALL("gdi32.dll", "long", "GetBitmapBits", "handle", $HBITMAP, "long", $ISIZE, "struct*", $PBITS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETBITMAPDIMENSIONEX($HBITMAP)
		LOCAL $TSIZE = DLLSTRUCTCREATE($TAGSIZE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "GetBitmapDimensionEx", "handle", $HBITMAP, "struct*", $TSIZE)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TSIZE
	ENDFUNC
	FUNC _WINAPI_GETBKCOLOR($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "dword", "GetBkColor", "handle", $HDC)
		IF @ERROR OR($ARET[0] = -1) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN __RGB($ARET[0])
	ENDFUNC
	FUNC _WINAPI_GETBOUNDSRECT($HDC, $IFLAGS = 0)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "uint", "GetBoundsRect", "handle", $HDC, "struct*", $TRECT, "uint", $IFLAGS)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN SETEXTENDED($ARET[0], $TRECT)
	ENDFUNC
	FUNC _WINAPI_GETBRUSHORG($HDC)
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "GetBrushOrgEx", "handle", $HDC, "struct*", $TPOINT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_GETBVALUE($IRGB)
		RETURN BITSHIFT(BITAND(__RGB($IRGB), 16711680), 16)
	ENDFUNC
	FUNC _WINAPI_GETCLIPBOX($HDC, BYREF $TRECT)
		$TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetClipBox", "handle", $HDC, "struct*", $TRECT)
		IF @ERROR OR NOT $ARET[0] THEN
			$TRECT = 0
			RETURN SETERROR(@ERROR, @EXTENDED, 0)
		ENDIF
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETCLIPRGN($HDC)
		LOCAL $HRGN = _WINAPI_CREATERECTRGN(0, 0, 0, 0)
		LOCAL $IERROR = 0
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetClipRgn", "handle", $HDC, "handle", $HRGN)
		IF @ERROR OR($ARET[0] = -1) THEN $IERROR = @ERROR + 10
		IF $IERROR OR NOT $ARET[0] THEN
			_WINAPI_DELETEOBJECT($HRGN)
			$HRGN = 0
		ENDIF
		RETURN SETERROR($IERROR, 0, $HRGN)
	ENDFUNC
	FUNC _WINAPI_GETCOLORADJUSTMENT($HDC)
		LOCAL $TADJUSTMENT = DLLSTRUCTCREATE($TAGCOLORADJUSTMENT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "GetColorAdjustment", "handle", $HDC, "struct*", $TADJUSTMENT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TADJUSTMENT
	ENDFUNC
	FUNC _WINAPI_GETCURRENTPOSITION($HDC)
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetCurrentPositionEx", "handle", $HDC, "struct*", $TPOINT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_GETDEVICEGAMMARAMP($HDC, BYREF $ARAMP)
		$ARAMP = 0
		LOCAL $TDATA = DLLSTRUCTCREATE("word[256];word[256];word[256]")
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "GetDeviceGammaRamp", "handle", $HDC, "struct*", $TDATA)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		DIM $ARAMP[256][3]
		FOR $I = 0 TO 2
			FOR $J = 0 TO 255
				$ARAMP[$J][$I] = DLLSTRUCTGETDATA($TDATA, $I + 1, $J + 1)
			NEXT
		NEXT
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_GETDIBCOLORTABLE($HBITMAP)
		LOCAL $HDC = _WINAPI_CREATECOMPATIBLEDC(0)
		LOCAL $HSV = _WINAPI_SELECTOBJECT($HDC, $HBITMAP)
		LOCAL $TPEAK = DLLSTRUCTCREATE("dword[256]")
		LOCAL $IERROR = 0
		LOCAL $ARET = DLLCALL("gdi32.dll", "uint", "GetDIBColorTable", "handle", $HDC, "uint", 0, "uint", 256, "struct*", $TPEAK)
		IF @ERROR OR NOT $ARET[0] THEN $IERROR = @ERROR + 10
		_WINAPI_SELECTOBJECT($HDC, $HSV)
		_WINAPI_DELETEDC($HDC)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		LOCAL $TDATA = DLLSTRUCTCREATE("dword[" & $ARET[0] & "]")
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		_WINAPI_MOVEMEMORY($TDATA, $ARET[4], 4 * $ARET[0])
		RETURN SETEXTENDED($ARET[0], $TDATA)
	ENDFUNC
	FUNC _WINAPI_GETDIBITS($HDC, $HBITMAP, $ISTARTSCAN, $ISCANLINES, $PBITS, $TBI, $IUSAGE)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "int", "GetDIBits", "handle", $HDC, "handle", $HBITMAP, "uint", $ISTARTSCAN, "uint", $ISCANLINES, "struct*", $PBITS, "struct*", $TBI, "uint", $IUSAGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETENHMETAFILE($SFILEPATH)
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "GetEnhMetaFileW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETENHMETAFILEBITS($HEMF, BYREF $PBUFFER)
		LOCAL $ARET = DLLCALL("gdi32.dll", "uint", "GetEnhMetaFileBits", "handle", $HEMF, "uint", 0, "ptr", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 50, @EXTENDED, 0)
		$PBUFFER = __HEAPREALLOC($PBUFFER, $ARET[0], 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		$ARET = DLLCALL("gdi32.dll", "uint", "GetEnhMetaFileBits", "handle", $HEMF, "uint", $ARET[0], "ptr", $PBUFFER)
		IF NOT $ARET[0] THEN RETURN SETERROR(60, 0, 0)
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_GETENHMETAFILEDESCRIPTION($HEMF)
		LOCAL $TDATA = DLLSTRUCTCREATE("wchar[4096]")
		LOCAL $ARET = DLLCALL("gdi32.dll", "uint", "GetEnhMetaFileDescriptionW", "handle", $HEMF, "uint", 4096, "struct*", $TDATA)
		IF @ERROR OR($ARET[0] = 4294967295) THEN RETURN SETERROR(@ERROR + 20, $ARET[0], 0)
		IF NOT $ARET[0] THEN RETURN 0
		LOCAL $ADATA = _WINAPI_STRUCTTOARRAY($TDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARESULT[2]
		FOR $I = 0 TO 1
			IF $ADATA[0] > $I THEN
				$ARESULT[$I] = $ADATA[$I + 1]
			ELSE
				$ARESULT[$I] = ""
			ENDIF
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETENHMETAFILEDIMENSION($HEMF)
		LOCAL $TENHMETAHEADER = _WINAPI_GETENHMETAFILEHEADER($HEMF)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $TSIZE = DLLSTRUCTCREATE($TAGSIZE)
		DLLSTRUCTSETDATA($TSIZE, 1, ROUND((DLLSTRUCTGETDATA($TENHMETAHEADER, "rcFrame", 3) - DLLSTRUCTGETDATA($TENHMETAHEADER, "rcFrame", 1)) * DLLSTRUCTGETDATA($TENHMETAHEADER, "Device", 1) / DLLSTRUCTGETDATA($TENHMETAHEADER, "Millimeters", 1) / 100))
		DLLSTRUCTSETDATA($TSIZE, 2, ROUND((DLLSTRUCTGETDATA($TENHMETAHEADER, "rcFrame", 4) - DLLSTRUCTGETDATA($TENHMETAHEADER, "rcFrame", 2)) * DLLSTRUCTGETDATA($TENHMETAHEADER, "Device", 2) / DLLSTRUCTGETDATA($TENHMETAHEADER, "Millimeters", 2) / 100))
		RETURN $TSIZE
	ENDFUNC
	FUNC _WINAPI_GETENHMETAFILEHEADER($HEMF)
		LOCAL $TENHMETAHEADER = DLLSTRUCTCREATE($TAGENHMETAHEADER)
		LOCAL $ARET = DLLCALL("gdi32.dll", "uint", "GetEnhMetaFileHeader", "handle", $HEMF, "uint", DLLSTRUCTGETSIZE($TENHMETAHEADER), "struct*", $TENHMETAHEADER)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN SETEXTENDED($ARET[0], $TENHMETAHEADER)
	ENDFUNC
	FUNC _WINAPI_GETFONTNAME($SFACENAME, $ISTYLE = 0, $ICHARSET = 1)
		IF NOT $SFACENAME THEN RETURN SETERROR(1, 0, "")
		LOCAL $IFLAGS = 0
		IF BITAND($ISTYLE, 1) THEN
			$IFLAGS += 32
		ENDIF
		IF BITAND($ISTYLE, 2) THEN
			$IFLAGS += 1
		ENDIF
		IF NOT $IFLAGS THEN
			$IFLAGS = 64
		ENDIF
		LOCAL $TLOGFONT = DLLSTRUCTCREATE($TAGLOGFONT)
		DLLSTRUCTSETDATA($TLOGFONT, 9, $ICHARSET)
		DLLSTRUCTSETDATA($TLOGFONT, 13, 0)
		DLLSTRUCTSETDATA($TLOGFONT, 14, STRINGLEFT($SFACENAME, 31))
		LOCAL $TFN = DLLSTRUCTCREATE("dword;wchar[64]")
		DLLSTRUCTSETDATA($TFN, 1, $IFLAGS)
		DLLSTRUCTSETDATA($TFN, 2, "")
		LOCAL $HDC = _WINAPI_CREATECOMPATIBLEDC(0)
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumFontStylesProc", "int", "ptr;ptr;dword;lparam")
		LOCAL $SRET = ""
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "EnumFontFamiliesExW", "handle", $HDC, "struct*", $TLOGFONT, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "struct*", $TFN, "dword", 0)
		IF NOT @ERROR AND NOT $ARET[0] THEN $SRET = DLLSTRUCTGETDATA($TFN, 2)
		DLLCALLBACKFREE($HENUMPROC)
		_WINAPI_DELETEDC($HDC)
		IF NOT $SRET THEN RETURN SETERROR(2, 0, "")
		RETURN $SRET
	ENDFUNC
	FUNC _WINAPI_GETFONTRESOURCEINFO($SFONT, $BFORCE = FALSE, $IFLAG = DEFAULT)
		IF $IFLAG = DEFAULT THEN
			IF $BFORCE THEN
				IF NOT _WINAPI_ADDFONTRESOURCEEX($SFONT, $FR_NOT_ENUM) THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
			ENDIF
			LOCAL $IERROR = 0
			LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "GetFontResourceInfoW", "wstr", $SFONT, "dword*", 4096, "wstr", "", "dword", 1)
			IF @ERROR OR NOT $ARET[0] THEN $IERROR = @ERROR + 10
			IF $BFORCE THEN
				_WINAPI_REMOVEFONTRESOURCEEX($SFONT, $FR_NOT_ENUM)
			ENDIF
			IF $IERROR THEN RETURN SETERROR($IERROR, 0, "")
			RETURN $ARET[3]
		ELSE
			IF NOT FILEEXISTS($SFONT) THEN
				$SFONT = REGREAD("HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders", "Fonts") & "\" & $SFONT
				IF NOT FILEEXISTS($SFONT) THEN RETURN SETERROR(31, 0, "")
			ENDIF
			LOCAL CONST $HFILE = _WINAPI_CREATEFILE($SFONT, 2, 2, 2)
			IF NOT $HFILE THEN RETURN SETERROR(32, _WINAPI_GETLASTERROR(), "")
			LOCAL CONST $IFILE = FILEGETSIZE($SFONT)
			LOCAL CONST $TBUFFER = DLLSTRUCTCREATE("byte[" & $IFILE + 1 & "]")
			LOCAL CONST $PFILE = DLLSTRUCTGETPTR($TBUFFER)
			LOCAL $IREAD
			_WINAPI_READFILE($HFILE, $PFILE, $IFILE, $IREAD)
			_WINAPI_CLOSEHANDLE($HFILE)
			LOCAL $STTFNAME = _WINAPI_GETFONTMEMORYRESOURCEINFO($PFILE, $IFLAG)
			IF @ERROR THEN
				IF @ERROR = 1 AND $IFLAG = 4 THEN
					$STTFNAME = _WINAPI_GETFONTRESOURCEINFO($SFONT, TRUE)
					RETURN SETERROR(@ERROR, @EXTENDED, $STTFNAME)
				ENDIF
				RETURN SETERROR(33, @ERROR, "")
			ENDIF
			RETURN $STTFNAME
		ENDIF
	ENDFUNC
	FUNC _WINAPI_GETFONTMEMORYRESOURCEINFO($PMEMORY, $IFLAG = 1)
		LOCAL CONST $TAGTT_OFFSET_TABLE = "USHORT uMajorVersion;USHORT uMinorVersion;USHORT uNumOfTables;USHORT uSearchRange;USHORT uEntrySelector;USHORT uRangeShift"
		LOCAL CONST $TAGTT_TABLE_DIRECTORY = "char szTag[4];ULONG uCheckSum;ULONG uOffset;ULONG uLength"
		LOCAL CONST $TAGTT_NAME_TABLE_HEADER = "USHORT uFSelector;USHORT uNRCount;USHORT uStorageOffset"
		LOCAL CONST $TAGTT_NAME_RECORD = "USHORT uPlatformID;USHORT uEncodingID;USHORT uLanguageID;USHORT uNameID;USHORT uStringLength;USHORT uStringOffset"
		LOCAL $TTTOFFSETTABLE = DLLSTRUCTCREATE($TAGTT_OFFSET_TABLE, $PMEMORY)
		LOCAL $INUMOFTABLES = _WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TTTOFFSETTABLE, "uNumOfTables"))
		IF NOT(_WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TTTOFFSETTABLE, "uMajorVersion")) = 1 AND _WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TTTOFFSETTABLE, "uMinorVersion")) = 0) THEN RETURN SETERROR(1, 0, "")
		LOCAL $ITBLDIRSIZE = DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGTT_TABLE_DIRECTORY))
		LOCAL $BFOUND = FALSE, $IOFFSET, $TTBLDIR
		FOR $I = 0 TO $INUMOFTABLES - 1
			$TTBLDIR = DLLSTRUCTCREATE($TAGTT_TABLE_DIRECTORY, $PMEMORY + DLLSTRUCTGETSIZE($TTTOFFSETTABLE) + $I * $ITBLDIRSIZE)
			IF STRINGLEFT(DLLSTRUCTGETDATA($TTBLDIR, "szTag"), 4) = "name" THEN
				$BFOUND = TRUE
				$IOFFSET = _WINAPI_SWAPDWORD(DLLSTRUCTGETDATA($TTBLDIR, "uOffset"))
				EXITLOOP
			ENDIF
		NEXT
		IF NOT $BFOUND THEN RETURN SETERROR(2, 0, "")
		LOCAL $TNTHEADER = DLLSTRUCTCREATE($TAGTT_NAME_TABLE_HEADER, $PMEMORY + $IOFFSET)
		LOCAL $INTHEADERSIZE = DLLSTRUCTGETSIZE($TNTHEADER)
		LOCAL $INRCOUNT = _WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TNTHEADER, "uNRCount"))
		LOCAL $ISTORAGEOFFSET = _WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TNTHEADER, "uStorageOffset"))
		LOCAL $ITTRECORDSIZE = DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGTT_NAME_RECORD))
		LOCAL $TRESULT, $SRESULT, $ISTRINGLENGTH, $ISTRINGOFFSET, $IENCODINGID, $TTTRECORD
		FOR $I = 0 TO $INRCOUNT - 1
			$TTTRECORD = DLLSTRUCTCREATE($TAGTT_NAME_RECORD, $PMEMORY + $IOFFSET + $INTHEADERSIZE + $I * $ITTRECORDSIZE)
			IF _WINAPI_SWAPWORD($TTTRECORD.uNameID) = $IFLAG THEN
				$ISTRINGLENGTH = _WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TTTRECORD, "uStringLength"))
				$ISTRINGOFFSET = _WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TTTRECORD, "uStringOffset"))
				$IENCODINGID = _WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TTTRECORD, "uEncodingID"))
				LOCAL $SWCHAR = "char"
				IF $IENCODINGID = 1 THEN
					$SWCHAR = "word"
					$ISTRINGLENGTH = $ISTRINGLENGTH / 2
				ENDIF
				$TRESULT = DLLSTRUCTCREATE($SWCHAR & " szTTFName[" & $ISTRINGLENGTH & "]", $PMEMORY + $IOFFSET + $ISTRINGOFFSET + $ISTORAGEOFFSET)
				IF $IENCODINGID = 1 THEN
					$SRESULT = ""
					FOR $J = 1 TO $ISTRINGLENGTH
						$SRESULT &= CHRW(_WINAPI_SWAPWORD(DLLSTRUCTGETDATA($TRESULT, 1, $J)))
					NEXT
				ELSE
					$SRESULT = $TRESULT.szTTFName
				ENDIF
				IF STRINGLEN($SRESULT) > 0 THEN EXITLOOP
			ENDIF
		NEXT
		RETURN $SRESULT
	ENDFUNC
	FUNC _WINAPI_GETGLYPHOUTLINE($HDC, $SCHAR, $IFORMAT, BYREF $PBUFFER, $TMAT2 = 0)
		LOCAL $TGM = DLLSTRUCTCREATE($TAGGLYPHMETRICS)
		LOCAL $ARET, $ILENGTH = 0
		IF NOT ISDLLSTRUCT($TMAT2) THEN
			$TMAT2 = DLLSTRUCTCREATE("short[8]")
			DLLSTRUCTSETDATA($TMAT2, 1, 1, 2)
			DLLSTRUCTSETDATA($TMAT2, 1, 1, 8)
		ENDIF
		IF $IFORMAT THEN
			$ARET = DLLCALL("gdi32.dll", "dword", "GetGlyphOutlineW", "handle", $HDC, "uint", ASCW($SCHAR), "uint", $IFORMAT, "struct*", $TGM, "dword", 0, "ptr", 0, "struct*", $TMAT2)
			IF @ERROR OR($ARET[0] = 4294967295) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			$ILENGTH = $ARET[0]
			$PBUFFER = __HEAPREALLOC($PBUFFER, $ILENGTH, 1)
			IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		ENDIF
		$ARET = DLLCALL("gdi32.dll", "dword", "GetGlyphOutlineW", "handle", $HDC, "uint", ASCW($SCHAR), "uint", $IFORMAT, "struct*", $TGM, "dword", $ILENGTH, "ptr", $PBUFFER, "struct*", $TMAT2)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] = 4294967295 THEN RETURN SETERROR(10, -1, 0)
		RETURN SETEXTENDED($ILENGTH, $TGM)
	ENDFUNC
	FUNC _WINAPI_GETGRAPHICSMODE($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetGraphicsMode", "handle", $HDC)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETGVALUE($IRGB)
		RETURN BITSHIFT(BITAND(__RGB($IRGB), 65280), 8)
	ENDFUNC
	FUNC _WINAPI_GETMAPMODE($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetMapMode", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETMONITORINFO($HMONITOR)
		LOCAL $TMIEX = DLLSTRUCTCREATE("dword;long[4];long[4];dword;wchar[32]")
		DLLSTRUCTSETDATA($TMIEX, 1, DLLSTRUCTGETSIZE($TMIEX))
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetMonitorInfoW", "handle", $HMONITOR, "struct*", $TMIEX)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARESULT[4]
		FOR $I = 0 TO 1
			$ARESULT[$I] = DLLSTRUCTCREATE($TAGRECT)
			_WINAPI_MOVEMEMORY($ARESULT[$I], DLLSTRUCTGETPTR($TMIEX, $I + 2), 16)
		NEXT
		$ARESULT[3] = DLLSTRUCTGETDATA($TMIEX, 5)
		SWITCH DLLSTRUCTGETDATA($TMIEX, 4)
			CASE 1
				$ARESULT[2] = 1
			CASE ELSE
				$ARESULT[2] = 0
		ENDSWITCH
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETOUTLINETEXTMETRICS($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "uint", "GetOutlineTextMetricsW", "handle", $HDC, "uint", 0, "ptr", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[" & $ARET[0] & "]")
		LOCAL $TOLTM = DLLSTRUCTCREATE($TAGOUTLINETEXTMETRIC, DLLSTRUCTGETPTR($TDATA))
		$ARET = DLLCALL("gdi32.dll", "uint", "GetOutlineTextMetricsW", "handle", $HDC, "uint", $ARET[0], "struct*", $TDATA)
		IF NOT $ARET[0] THEN RETURN SETERROR(20, 0, 0)
		RETURN $TOLTM
	ENDFUNC
	FUNC _WINAPI_GETPIXEL($HDC, $IX, $IY)
		LOCAL $ARET = DLLCALL("gdi32.dll", "dword", "GetPixel", "handle", $HDC, "int", $IX, "int", $IY)
		IF @ERROR OR($ARET[0] = 4294967295) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN __RGB($ARET[0])
	ENDFUNC
	FUNC _WINAPI_GETPOLYFILLMODE($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetPolyFillMode", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETPOSFROMRECT($TRECT)
		LOCAL $ARESULT[4]
		FOR $I = 0 TO 3
			$ARESULT[$I] = DLLSTRUCTGETDATA($TRECT, $I + 1)
			IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		NEXT
		FOR $I = 2 TO 3
			$ARESULT[$I] -= $ARESULT[$I - 2]
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETREGIONDATA($HRGN, BYREF $TRGNDATA)
		LOCAL $ARET = DLLCALL("gdi32.dll", "dword", "GetRegionData", "handle", $HRGN, "dword", 0, "ptr", 0)
		IF @ERROR OR NOT $ARET[0] THEN
			$TRGNDATA = 0
			RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		ENDIF
		$TRGNDATA = DLLSTRUCTCREATE($TAGRGNDATAHEADER)
		LOCAL $IRECTSIZE = $ARET[0] - DLLSTRUCTGETSIZE($TRGNDATA)
		IF $IRECTSIZE > 0 THEN $TRGNDATA = DLLSTRUCTCREATE($TAGRGNDATAHEADER & ";byte[" & $IRECTSIZE & "]")
		$ARET = DLLCALL("gdi32.dll", "dword", "GetRegionData", "handle", $HRGN, "dword", $ARET[0], "struct*", $TRGNDATA)
		IF NOT $ARET[0] THEN $TRGNDATA = 0
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETRGNBOX($HRGN, BYREF $TRECT)
		$TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetRgnBox", "handle", $HRGN, "struct*", $TRECT)
		IF @ERROR OR NOT $ARET[0] THEN
			$TRECT = 0
			RETURN SETERROR(@ERROR, @EXTENDED, 0)
		ENDIF
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETROP2($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetROP2", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETRVALUE($IRGB)
		RETURN BITAND(__RGB($IRGB), 255)
	ENDFUNC
	FUNC _WINAPI_GETSTRETCHBLTMODE($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetStretchBltMode", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETTABBEDTEXTEXTENT($HDC, $STEXT, $ATAB = 0, $ISTART = 0, $IEND = -1)
		LOCAL $ITAB, $ICOUNT
		IF NOT ISARRAY($ATAB) THEN
			IF $ATAB THEN
				$ITAB = $ATAB
				DIM $ATAB[1] = [$ITAB]
				$ISTART = 0
				$IEND = 0
				$ICOUNT = 1
			ELSE
				$ICOUNT = 0
			ENDIF
		ELSE
			$ICOUNT = 1
		ENDIF
		LOCAL $TTAB = 0
		IF $ICOUNT THEN
			IF __CHECKERRORARRAYBOUNDS($ATAB, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			$ICOUNT = $IEND - $ISTART + 1
			$TTAB = DLLSTRUCTCREATE("uint[" & $ICOUNT & "]")
			$ITAB = 1
			FOR $I = $ISTART TO $IEND
				DLLSTRUCTSETDATA($TTAB, 1, $ATAB[$I], $ITAB)
				$ITAB += 1
			NEXT
		ENDIF
		LOCAL $ARET = DLLCALL("user32.dll", "dword", "GetTabbedTextExtentW", "handle", $HDC, "wstr", $STEXT, "int", STRINGLEN($STEXT), "int", $ICOUNT, "struct*", $TTAB)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		RETURN _WINAPI_CREATESIZE(_WINAPI_LOWORD($ARET[0]), _WINAPI_HIWORD($ARET[0]))
	ENDFUNC
	FUNC _WINAPI_GETTEXTALIGN($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "uint", "GetTextAlign", "handle", $HDC)
		IF @ERROR OR($ARET[0] = 4294967295) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETTEXTCHARACTEREXTRA($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetTextCharacterExtra", "handle", $HDC)
		IF @ERROR OR($ARET[0] = 134217728) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETTEXTFACE($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetTextFaceW", "handle", $HDC, "int", 2048, "wstr", "")
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_GETUDFCOLORMODE()
		RETURN NUMBER($__G_IRGBMODE)
	ENDFUNC
	FUNC _WINAPI_GETUPDATERECT($HWND, $BERASE = TRUE)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetUpdateRect", "hwnd", $HWND, "struct*", $TRECT, "bool", $BERASE)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_GETUPDATERGN($HWND, $HRGN, $BERASE = TRUE)
		LOCAL $ARET = DLLCALL("user32.dll", "int", "GetUpdateRgn", "hwnd", $HWND, "handle", $HRGN, "bool", $BERASE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETWINDOWEXT($HDC)
		LOCAL $TSIZE = DLLSTRUCTCREATE($TAGSIZE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "GetWindowExtEx", "handle", $HDC, "struct*", $TSIZE)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TSIZE
	ENDFUNC
	FUNC _WINAPI_GETWINDOWORG($HDC)
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "GetWindowOrgEx", "handle", $HDC, "struct*", $TPOINT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_GETWINDOWRGNBOX($HWND, BYREF $TRECT)
		$TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "GetWindowRgnBox", "hwnd", $HWND, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETWORLDTRANSFORM($HDC)
		LOCAL $TXFORM = DLLSTRUCTCREATE($TAGXFORM)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "GetWorldTransform", "handle", $HDC, "struct*", $TXFORM)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TXFORM
	ENDFUNC
	FUNC _WINAPI_GRADIENTFILL($HDC, CONST BYREF $AVERTEX, $ISTART = 0, $IEND = -1, $BROTATE = FALSE)
		IF __CHECKERRORARRAYBOUNDS($AVERTEX, $ISTART, $IEND, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		IF UBOUND($AVERTEX, $UBOUND_COLUMNS) < 3 THEN RETURN SETERROR(13, 0, 0)
		LOCAL $IPOINT = $IEND - $ISTART + 1
		IF $IPOINT > 3 THEN
			$IEND = $ISTART + 2
			$IPOINT = 3
		ENDIF
		LOCAL $IMODE
		SWITCH $IPOINT
			CASE 2
				$IMODE = NUMBER(NOT $BROTATE)
			CASE 3
				$IMODE = 2
			CASE ELSE
				RETURN SETERROR(15, 0, 0)
		ENDSWITCH
		LOCAL $TAGSTRUCT = ""
		FOR $I = $ISTART TO $IEND
			$TAGSTRUCT &= "ushort[8];"
		NEXT
		LOCAL $TVERTEX = DLLSTRUCTCREATE($TAGSTRUCT)
		LOCAL $ICOUNT = 1
		LOCAL $TGRADIENT = DLLSTRUCTCREATE("ulong[" & $IPOINT & "]")
		FOR $I = $ISTART TO $IEND
			DLLSTRUCTSETDATA($TGRADIENT, 1, $ICOUNT - 1, $ICOUNT)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, _WINAPI_LOWORD($AVERTEX[$I][0]), 1)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, _WINAPI_HIWORD($AVERTEX[$I][0]), 2)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, _WINAPI_LOWORD($AVERTEX[$I][1]), 3)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, _WINAPI_HIWORD($AVERTEX[$I][1]), 4)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, BITSHIFT(_WINAPI_GETRVALUE($AVERTEX[$I][2]), -8), 5)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, BITSHIFT(_WINAPI_GETGVALUE($AVERTEX[$I][2]), -8), 6)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, BITSHIFT(_WINAPI_GETBVALUE($AVERTEX[$I][2]), -8), 7)
			DLLSTRUCTSETDATA($TVERTEX, $ICOUNT, 0, 8)
			$ICOUNT += 1
		NEXT
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "GdiGradientFill", "handle", $HDC, "struct*", $TVERTEX, "ulong", $IPOINT, "struct*", $TGRADIENT, "ulong", 1, "ulong", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_INFLATERECT(BYREF $TRECT, $IDX, $IDY)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "InflateRect", "struct*", $TRECT, "int", $IDX, "int", $IDY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_INTERSECTCLIPRECT($HDC, $TRECT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "IntersectClipRect", "handle", $HDC, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_INTERSECTRECT($TRECT1, $TRECT2)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "IntersectRect", "struct*", $TRECT, "struct*", $TRECT1, "struct*", $TRECT2)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_INVALIDATERGN($HWND, $HRGN = 0, $BERASE = TRUE)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "InvalidateRgn", "hwnd", $HWND, "handle", $HRGN, "bool", $BERASE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_INVERTANDBITMAP($HBITMAP, $BDELETE = FALSE)
		LOCAL $TBITMAP = DLLSTRUCTCREATE($TAGBITMAP)
		IF NOT _WINAPI_GETOBJECT($HBITMAP, DLLSTRUCTGETSIZE($TBITMAP), $TBITMAP) OR(DLLSTRUCTGETDATA($TBITMAP, "bmBitsPixel") <> 1) THEN
			RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		ENDIF
		LOCAL $HRESULT = _WINAPI_CREATEDIB(DLLSTRUCTGETDATA($TBITMAP, "bmWidth"), DLLSTRUCTGETDATA($TBITMAP, "bmHeight"), 1)
		IF NOT $HRESULT THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $HSRCDC = _WINAPI_CREATECOMPATIBLEDC(0)
		LOCAL $HSRCSV = _WINAPI_SELECTOBJECT($HSRCDC, $HBITMAP)
		LOCAL $HDSTDC = _WINAPI_CREATECOMPATIBLEDC(0)
		LOCAL $HDSTSV = _WINAPI_SELECTOBJECT($HDSTDC, $HRESULT)
		_WINAPI_BITBLT($HDSTDC, 0, 0, DLLSTRUCTGETDATA($TBITMAP, "bmWidth"), DLLSTRUCTGETDATA($TBITMAP, "bmHeight"), $HSRCDC, 0, 0, 3342344)
		_WINAPI_SELECTOBJECT($HSRCDC, $HSRCSV)
		_WINAPI_DELETEDC($HSRCDC)
		_WINAPI_SELECTOBJECT($HDSTDC, $HDSTSV)
		_WINAPI_DELETEDC($HDSTDC)
		IF $BDELETE THEN
			_WINAPI_DELETEOBJECT($HBITMAP)
		ENDIF
		RETURN $HRESULT
	ENDFUNC
	FUNC _WINAPI_INVERTCOLOR($ICOLOR)
		IF $ICOLOR = -1 THEN RETURN 0
		RETURN 16777215 - BITAND($ICOLOR, 16777215)
	ENDFUNC
	FUNC _WINAPI_INVERTRECT($HDC, BYREF $TRECT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "InvertRect", "handle", $HDC, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_INVERTRGN($HDC, $HRGN)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "InvertRgn", "handle", $HDC, "handle", $HRGN)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ISRECTEMPTY(BYREF $TRECT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "IsRectEmpty", "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_LINEDDA($IX1, $IY1, $IX2, $IY2, $PLINEPROC, $PDATA = 0)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "LineDDA", "int", $IX1, "int", $IY1, "int", $IX2, "int", $IY2, "ptr", $PLINEPROC, "lparam", $PDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_LINETO($HDC, $IX, $IY)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "bool", "LineTo", "handle", $HDC, "int", $IX, "int", $IY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_LOCKWINDOWUPDATE($HWND)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "LockWindowUpdate", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_LPTODP($HDC, BYREF $TPOINT, $ICOUNT = 1)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "LPtoDP", "handle", $HDC, "struct*", $TPOINT, "int", $ICOUNT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_MASKBLT($HDESTDC, $IXDEST, $IYDEST, $IWIDTH, $IHEIGHT, $HSRCDC, $IXSRC, $IYSRC, $HMASK, $IXMASK, $IYMASK, $IROP)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "MaskBlt", "handle", $HDESTDC, "int", $IXDEST, "int", $IYDEST, "int", $IWIDTH, "int", $IHEIGHT, "hwnd", $HSRCDC, "int", $IXSRC, "int", $IYSRC, "handle", $HMASK, "int", $IXMASK, "int", $IYMASK, "dword", $IROP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_MODIFYWORLDTRANSFORM($HDC, BYREF $TXFORM, $IMODE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "ModifyWorldTransform", "handle", $HDC, "struct*", $TXFORM, "dword", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_MONITORFROMPOINT(BYREF $TPOINT, $IFLAG = 1)
		IF DLLSTRUCTGETSIZE($TPOINT) <> 8 THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "MonitorFromPoint", "struct", $TPOINT, "dword", $IFLAG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_MONITORFROMRECT(BYREF $TRECT, $IFLAG = 1)
		LOCAL $ARET = DLLCALL("user32.dll", "ptr", "MonitorFromRect", "struct*", $TRECT, "dword", $IFLAG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_MONITORFROMWINDOW($HWND, $IFLAG = 1)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "MonitorFromWindow", "hwnd", $HWND, "dword", $IFLAG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_MOVETO($HDC, $IX, $IY)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "bool", "MoveToEx", "handle", $HDC, "int", $IX, "int", $IY, "ptr", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_MOVETOEX($HDC, $IX, $IY)
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "MoveToEx", "handle", $HDC, "int", $IX, "int", $IY, "struct*", $TPOINT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_OFFSETCLIPRGN($HDC, $IXOFFSET, $IYOFFSET)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "OffsetClipRgn", "handle", $HDC, "int", $IXOFFSET, "int", $IYOFFSET)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_OFFSETPOINTS(BYREF $APOINT, $IXOFFSET, $IYOFFSET, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($APOINT, $ISTART, $IEND, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		IF UBOUND($APOINT, $UBOUND_COLUMNS) < 2 THEN RETURN SETERROR(13, 0, 0)
		FOR $I = $ISTART TO $IEND
			$APOINT[$I][0] += $IXOFFSET
			$APOINT[$I][1] += $IYOFFSET
		NEXT
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_OFFSETRECT(BYREF $TRECT, $IDX, $IDY)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "OffsetRect", "struct*", $TRECT, "int", $IDX, "int", $IDY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_OFFSETRGN($HRGN, $IXOFFSET, $IYOFFSET)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "OffsetRgn", "handle", $HRGN, "int", $IXOFFSET, "int", $IYOFFSET)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_OFFSETWINDOWORG($HDC, $IXOFFSET, $IYOFFSET)
		$__G_VEXT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "OffsetWindowOrgEx", "handle", $HDC, "int", $IXOFFSET, "int", $IYOFFSET, "struct*", $__G_VEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PAINTDESKTOP($HDC)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "PaintDesktop", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PAINTRGN($HDC, $HRGN)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "PaintRgn", "handle", $HDC, "handle", $HRGN)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATBLT($HDC, $IX, $IY, $IWIDTH, $IHEIGHT, $IROP)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "PatBlt", "handle", $HDC, "int", $IX, "int", $IY, "int", $IWIDTH, "int", $IHEIGHT, "dword", $IROP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHTOREGION($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "PathToRegion", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PLAYENHMETAFILE($HDC, $HEMF, BYREF $TRECT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "PlayEnhMetaFile", "handle", $HDC, "handle", $HEMF, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PLGBLT($HDESTDC, CONST BYREF $APOINT, $HSRCDC, $IXSRC, $IYSRC, $IWIDTH, $IHEIGHT, $HMASK = 0, $IXMASK = 0, $IYMASK = 0)
		IF(UBOUND($APOINT) < 3) OR(UBOUND($APOINT, $UBOUND_COLUMNS) < 2) THEN RETURN SETERROR(12, 0, FALSE)
		LOCAL $TPOINTS = DLLSTRUCTCREATE("long[2];long[2];long[2]")
		FOR $I = 0 TO 2
			FOR $J = 0 TO 1
				DLLSTRUCTSETDATA($TPOINTS, $I + 1, $APOINT[$I][$J], $J + 1)
			NEXT
		NEXT
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "PlgBlt", "handle", $HDESTDC, "struct*", $TPOINTS, "handle", $HSRCDC, "int", $IXSRC, "int", $IYSRC, "int", $IWIDTH, "int", $IHEIGHT, "handle", $HMASK, "int", $IXMASK, "int", $IYMASK)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_POLYBEZIER($HDC, CONST BYREF $APOINT, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($APOINT, $ISTART, $IEND, 2, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
		LOCAL $IPOINT = 1 + 3 * FLOOR(($IEND - $ISTART) / 3)
		IF $IPOINT < 1 THEN RETURN SETERROR(15, 0, FALSE)
		$IEND = $ISTART + $IPOINT - 1
		LOCAL $TAGSTRUCT = ""
		FOR $I = $ISTART TO $IEND
			$TAGSTRUCT &= "long[2];"
		NEXT
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGSTRUCT)
		LOCAL $ICOUNT = 0
		FOR $I = $ISTART TO $IEND
			$ICOUNT += 1
			FOR $J = 0 TO 1
				DLLSTRUCTSETDATA($TPOINT, $ICOUNT, $APOINT[$I][$J], $J + 1)
			NEXT
		NEXT
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "PolyBezier", "handle", $HDC, "struct*", $TPOINT, "dword", $IPOINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_POLYBEZIERTO($HDC, CONST BYREF $APOINT, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($APOINT, $ISTART, $IEND, 2, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
		LOCAL $IPOINT = 3 * FLOOR(($IEND - $ISTART + 1) / 3)
		IF $IPOINT < 3 THEN RETURN SETERROR(15, 0, FALSE)
		$IEND = $ISTART + $IPOINT - 1
		LOCAL $TAGSTRUCT = ""
		FOR $I = $ISTART TO $IEND
			$TAGSTRUCT &= "long[2];"
		NEXT
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGSTRUCT)
		LOCAL $ICOUNT = 0
		FOR $I = $ISTART TO $IEND
			$ICOUNT += 1
			FOR $J = 0 TO 1
				DLLSTRUCTSETDATA($TPOINT, $ICOUNT, $APOINT[$I][$J], $J + 1)
			NEXT
		NEXT
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "PolyBezierTo", "handle", $HDC, "struct*", $TPOINT, "dword", $IPOINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_POLYDRAW($HDC, CONST BYREF $APOINT, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($APOINT, $ISTART, $IEND, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		IF UBOUND($APOINT, $UBOUND_COLUMNS) < 3 THEN RETURN SETERROR(13, 0, FALSE)
		LOCAL $IPOINT = $IEND - $ISTART + 1
		LOCAL $TAGSTRUCT = ""
		FOR $I = $ISTART TO $IEND
			$TAGSTRUCT &= "long[2];"
		NEXT
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGSTRUCT)
		LOCAL $TTYPES = DLLSTRUCTCREATE("byte[" & $IPOINT & "]")
		LOCAL $ICOUNT = 0
		FOR $I = $ISTART TO $IEND
			$ICOUNT += 1
			FOR $J = 0 TO 1
				DLLSTRUCTSETDATA($TPOINT, $ICOUNT, $APOINT[$I][$J], $J + 1)
			NEXT
			DLLSTRUCTSETDATA($TTYPES, 1, $APOINT[$I][2], $ICOUNT)
		NEXT
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "PolyDraw", "handle", $HDC, "struct*", $TPOINT, "struct*", $TTYPES, "dword", $IPOINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_POLYGON($HDC, CONST BYREF $APOINT, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($APOINT, $ISTART, $IEND, 2, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
		LOCAL $TAGSTRUCT = ""
		FOR $I = $ISTART TO $IEND
			$TAGSTRUCT &= "int[2];"
		NEXT
		LOCAL $TDATA = DLLSTRUCTCREATE($TAGSTRUCT)
		LOCAL $ICOUNT = 1
		FOR $I = $ISTART TO $IEND
			FOR $J = 0 TO 1
				DLLSTRUCTSETDATA($TDATA, $ICOUNT, $APOINT[$I][$J], $J + 1)
			NEXT
			$ICOUNT += 1
		NEXT
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "Polygon", "handle", $HDC, "struct*", $TDATA, "int", $ICOUNT - 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PTINRECTEX($IX, $IY, $ILEFT, $ITOP, $IRIGHT, $IBOTTOM)
		LOCAL $TRECT = _WINAPI_CREATERECT($ILEFT, $ITOP, $IRIGHT, $IBOTTOM)
		LOCAL $TPOINT = _WINAPI_CREATEPOINT($IX, $IY)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "PtInRect", "struct*", $TRECT, "struct", $TPOINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PTINREGION($HRGN, $IX, $IY)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "PtInRegion", "handle", $HRGN, "int", $IX, "int", $IY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PTVISIBLE($HDC, $IX, $IY)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "PtVisible", "handle", $HDC, "int", $IX, "int", $IY)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		IF $ARET[0] = -1 THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_RADIALGRADIENTFILL($HDC, $IX, $IY, $IRADIUS, $IRGB1, $IRGB2, $FANGLESTART = 0, $FANGLEEND = 360, $FSTEP = 5)
		IF ABS($FANGLESTART) > 360 THEN
			$FANGLESTART = MOD($FANGLESTART, 360)
		ENDIF
		IF ABS($FANGLEEND) > 360 THEN
			$FANGLEEND = MOD($FANGLEEND, 360)
		ENDIF
		IF($FANGLESTART < 0) OR($FANGLEEND < 0) THEN
			$FANGLESTART += 360
			$FANGLEEND += 360
		ENDIF
		IF $FANGLESTART > $FANGLEEND THEN
			LOCAL $FVAL = $FANGLESTART
			$FANGLESTART = $FANGLEEND
			$FANGLEEND = $FVAL
		ENDIF
		IF $FSTEP < 1 THEN
			$FSTEP = 1
		ENDIF
		LOCAL $FKI = ATAN(1) / 45
		LOCAL $IXP = ROUND($IX + $IRADIUS * COS($FKI * $FANGLESTART))
		LOCAL $IYP = ROUND($IY + $IRADIUS * SIN($FKI * $FANGLESTART))
		LOCAL $IXN, $IYN, $FAN = $FANGLESTART
		LOCAL $AVERTEX[3][3]
		WHILE $FAN < $FANGLEEND
			$FAN += $FSTEP
			IF $FAN > $FANGLEEND THEN
				$FAN = $FANGLEEND
			ENDIF
			$IXN = ROUND($IX + $IRADIUS * COS($FKI * $FAN))
			$IYN = ROUND($IY + $IRADIUS * SIN($FKI * $FAN))
			$AVERTEX[0][0] = $IX
			$AVERTEX[0][1] = $IY
			$AVERTEX[0][2] = $IRGB1
			$AVERTEX[1][0] = $IXP
			$AVERTEX[1][1] = $IYP
			$AVERTEX[1][2] = $IRGB2
			$AVERTEX[2][0] = $IXN
			$AVERTEX[2][1] = $IYN
			$AVERTEX[2][2] = $IRGB2
			IF NOT _WINAPI_GRADIENTFILL($HDC, $AVERTEX, 0, 2) THEN
				RETURN SETERROR(@ERROR, @EXTENDED, 0)
			ENDIF
			$IXP = $IXN
			$IYP = $IYN
		WEND
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_RECTANGLE($HDC, $TRECT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "Rectangle", "handle", $HDC, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_RECTINREGION($HRGN, $TRECT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "RectInRegion", "handle", $HRGN, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_RECTISEMPTY(BYREF $TRECT)
		RETURN(DLLSTRUCTGETDATA($TRECT, "Left") = 0) AND(DLLSTRUCTGETDATA($TRECT, "Top") = 0) AND(DLLSTRUCTGETDATA($TRECT, "Right") = 0) AND(DLLSTRUCTGETDATA($TRECT, "Bottom") = 0)
	ENDFUNC
	FUNC _WINAPI_RECTVISIBLE($HDC, $TRECT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "RectVisible", "handle", $HDC, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		SWITCH $ARET[0]
			CASE 0, 1, 2
			CASE ELSE
				RETURN SETERROR(10, $ARET[0], 0)
		ENDSWITCH
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_REMOVEFONTMEMRESOURCEEX($HFONT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "RemoveFontMemResourceEx", "handle", $HFONT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_REMOVEFONTRESOURCEEX($SFONT, $IFLAG = 0, $BNOTIFY = FALSE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "RemoveFontResourceExW", "wstr", $SFONT, "dword", $IFLAG, "ptr", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		IF $BNOTIFY THEN
			LOCAL CONST $WM_FONTCHANGE = 29
			LOCAL CONST $HWND_BROADCAST = 65535
			DLLCALL("user32.dll", "none", "SendMessage", "hwnd", $HWND_BROADCAST, "uint", $WM_FONTCHANGE, "wparam", 0, "lparam", 0)
		ENDIF
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_RGB($IRED, $IGREEN, $IBLUE)
		RETURN __RGB(BITOR(BITSHIFT($IBLUE, -16), BITSHIFT($IGREEN, -8), $IRED))
	ENDFUNC
	FUNC _WINAPI_ROTATEPOINTS(BYREF $APOINT, $IXC, $IYC, $FANGLE, $ISTART = 0, $IEND = -1)
		IF __CHECKERRORARRAYBOUNDS($APOINT, $ISTART, $IEND, 2) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		IF UBOUND($APOINT, $UBOUND_COLUMNS) < 2 THEN RETURN SETERROR(13, 0, 0)
		LOCAL $FCOS = COS(ATAN(1) / 45 * $FANGLE)
		LOCAL $FSIN = SIN(ATAN(1) / 45 * $FANGLE)
		LOCAL $IXN, $IYN
		FOR $I = $ISTART TO $IEND
			$IXN = $APOINT[$I][0] - $IXC
			$IYN = $APOINT[$I][1] - $IYC
			$APOINT[$I][0] = $IXC + ROUND($IXN * $FCOS - $IYN * $FSIN)
			$APOINT[$I][1] = $IYC + ROUND($IXN * $FSIN + $IYN * $FCOS)
		NEXT
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_ROUNDRECT($HDC, $TRECT, $IWIDTH, $IHEIGHT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "RoundRect", "handle", $HDC, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4), "int", $IWIDTH, "int", $IHEIGHT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SAVEHBITMAPTOFILE($SFILEPATH, $HBITMAP, $IXPELSPERMETER = DEFAULT, $IYPELSPERMETER = DEFAULT)
		LOCAL $TBMP = DLLSTRUCTCREATE("align 1;ushort bfType;dword bfSize;ushort bfReserved1;ushort bfReserved2;dword bfOffset")
		LOCAL $TDIB = DLLSTRUCTCREATE($TAGDIBSECTION)
		LOCAL $HDC, $HSV, $HSOURCE = 0
		WHILE $HBITMAP
			IF(NOT _WINAPI_GETOBJECT($HBITMAP, DLLSTRUCTGETSIZE($TDIB), $TDIB)) OR(DLLSTRUCTGETDATA($TDIB, "biCompression")) THEN
				$HBITMAP = 0
			ELSE
				SWITCH DLLSTRUCTGETDATA($TDIB, "bmBitsPixel")
					CASE 32
						IF NOT _WINAPI_ISALPHABITMAP($HBITMAP) THEN
							IF NOT $HSOURCE THEN
								$HSOURCE = _WINAPI_CREATEDIB(DLLSTRUCTGETDATA($TDIB, "bmWidth"), DLLSTRUCTGETDATA($TDIB, "bmHeight"), 24)
								IF NOT $HSOURCE THEN
									$HBITMAP = 0
								ENDIF
								$HDC = _WINAPI_CREATECOMPATIBLEDC(0)
								$HSV = _WINAPI_SELECTOBJECT($HDC, $HSOURCE)
								IF _WINAPI_DRAWBITMAP($HDC, 0, 0, $HBITMAP) THEN
									$HBITMAP = $HSOURCE
								ELSE
									$HBITMAP = 0
								ENDIF
								_WINAPI_SELECTOBJECT($HDC, $HSV)
								_WINAPI_DELETEDC($HDC)
							ELSE
								$HBITMAP = 0
							ENDIF
							CONTINUELOOP
						ENDIF
					CASE ELSE
				ENDSWITCH
				IF(NOT DLLSTRUCTGETDATA($TDIB, "bmBits")) OR(NOT DLLSTRUCTGETDATA($TDIB, "biSizeImage")) THEN
					IF NOT $HSOURCE THEN
						$HBITMAP = _WINAPI_COPYBITMAP($HBITMAP)
						$HSOURCE = $HBITMAP
					ELSE
						$HBITMAP = 0
					ENDIF
				ELSE
					EXITLOOP
				ENDIF
			ENDIF
		WEND
		LOCAL $HFILE = 0, $IERROR = 0, $IRESULT = 0
		DO
			IF NOT $HBITMAP THEN
				$IERROR = 1
				EXITLOOP
			ENDIF
			LOCAL $ADATA[4][2]
			$ADATA[0][0] = DLLSTRUCTGETPTR($TBMP)
			$ADATA[0][1] = DLLSTRUCTGETSIZE($TBMP)
			$ADATA[1][0] = DLLSTRUCTGETPTR($TDIB, "biSize")
			$ADATA[1][1] = 40
			$ADATA[2][1] = DLLSTRUCTGETDATA($TDIB, "biClrUsed") * 4
			LOCAL $TTABLE = 0
			IF $ADATA[2][1] THEN
				$TTABLE = _WINAPI_GETDIBCOLORTABLE($HBITMAP)
				IF @ERROR OR(@EXTENDED <> $ADATA[2][1] / 4) THEN
					$IERROR = @ERROR + 10
					EXITLOOP
				ENDIF
			ENDIF
			$ADATA[2][0] = DLLSTRUCTGETPTR($TTABLE)
			$ADATA[3][0] = DLLSTRUCTGETDATA($TDIB, "bmBits")
			$ADATA[3][1] = DLLSTRUCTGETDATA($TDIB, "biSizeImage")
			DLLSTRUCTSETDATA($TBMP, "bfType", 19778)
			DLLSTRUCTSETDATA($TBMP, "bfSize", $ADATA[0][1] + $ADATA[1][1] + $ADATA[2][1] + $ADATA[3][1])
			DLLSTRUCTSETDATA($TBMP, "bfReserved1", 0)
			DLLSTRUCTSETDATA($TBMP, "bfReserved2", 0)
			DLLSTRUCTSETDATA($TBMP, "bfOffset", $ADATA[0][1] + $ADATA[1][1] + $ADATA[2][1])
			$HDC = _WINAPI_GETDC(0)
			IF $IXPELSPERMETER = DEFAULT THEN
				IF NOT DLLSTRUCTGETDATA($TDIB, "biXPelsPerMeter") THEN
					DLLSTRUCTSETDATA($TDIB, "biXPelsPerMeter", _WINAPI_GETDEVICECAPS($HDC, 8) / _WINAPI_GETDEVICECAPS($HDC, 4) * 1000)
				ENDIF
			ELSE
				DLLSTRUCTSETDATA($TDIB, "biXPelsPerMeter", $IXPELSPERMETER)
			ENDIF
			IF $IYPELSPERMETER = DEFAULT THEN
				IF NOT DLLSTRUCTGETDATA($TDIB, "biYPelsPerMeter") THEN
					DLLSTRUCTSETDATA($TDIB, "biYPelsPerMeter", _WINAPI_GETDEVICECAPS($HDC, 10) / _WINAPI_GETDEVICECAPS($HDC, 6) * 1000)
				ENDIF
			ELSE
				DLLSTRUCTSETDATA($TDIB, "biYPelsPerMeter", $IYPELSPERMETER)
			ENDIF
			_WINAPI_RELEASEDC(0, $HDC)
			$HFILE = _WINAPI_CREATEFILE($SFILEPATH, 1, 4)
			IF @ERROR THEN
				$IERROR = @ERROR + 20
				EXITLOOP
			ENDIF
			LOCAL $IBYTES
			FOR $I = 0 TO 3
				IF $ADATA[$I][1] THEN
					IF NOT _WINAPI_WRITEFILE($HFILE, $ADATA[$I][0], $ADATA[$I][1], $IBYTES) THEN
						$IERROR = @ERROR + 30
						EXITLOOP 2
					ENDIF
				ENDIF
			NEXT
			$IRESULT = 1
		UNTIL 1
		IF $HSOURCE THEN
			_WINAPI_DELETEOBJECT($HSOURCE)
		ENDIF
		_WINAPI_CLOSEHANDLE($HFILE)
		IF NOT $IRESULT THEN
			FILEDELETE($SFILEPATH)
		ENDIF
		RETURN SETERROR($IERROR, 0, $IRESULT)
	ENDFUNC
	FUNC _WINAPI_SAVEHICONTOFILE($SFILEPATH, CONST BYREF $VICON, $BCOMPRESS = 0, $ISTART = 0, $IEND = -1)
		LOCAL $AICON, $ATEMP, $ICOUNT = 1
		IF NOT ISARRAY($VICON) THEN
			DIM $AICON[1] = [$VICON]
			DIM $ATEMP[1] = [0]
		ELSE
			IF __CHECKERRORARRAYBOUNDS($VICON, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			$ICOUNT = $IEND - $ISTART + 1
			IF $ICOUNT THEN
				DIM $AICON[$ICOUNT]
				DIM $ATEMP[$ICOUNT]
				FOR $I = 0 TO $ICOUNT - 1
					$AICON[$I] = $VICON[$ISTART + $I]
					$ATEMP[$I] = 0
				NEXT
			ENDIF
		ENDIF
		LOCAL $HFILE = _WINAPI_CREATEFILE($SFILEPATH, 1, 4)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TICO = DLLSTRUCTCREATE("align 1;ushort Reserved;ushort Type;ushort Count;byte Data[" & (16 * $ICOUNT) & "]")
		LOCAL $ILENGTH = DLLSTRUCTGETSIZE($TICO)
		LOCAL $TBI = DLLSTRUCTCREATE($TAGBITMAPINFOHEADER)
		LOCAL $TII = DLLSTRUCTCREATE($TAGICONINFO)
		LOCAL $TDIB = DLLSTRUCTCREATE($TAGDIBSECTION)
		LOCAL $IDIB = DLLSTRUCTGETSIZE($TDIB)
		LOCAL $PDIB = DLLSTRUCTGETPTR($TDIB)
		LOCAL $IOFFSET = $ILENGTH
		DLLSTRUCTSETDATA($TBI, "biSize", 40)
		DLLSTRUCTSETDATA($TBI, "biPlanes", 1)
		DLLSTRUCTSETDATA($TBI, "biXPelsPerMeter", 0)
		DLLSTRUCTSETDATA($TBI, "biYPelsPerMeter", 0)
		DLLSTRUCTSETDATA($TBI, "biClrUsed", 0)
		DLLSTRUCTSETDATA($TBI, "biClrImportant", 0)
		DLLSTRUCTSETDATA($TICO, "Reserved", 0)
		DLLSTRUCTSETDATA($TICO, "Type", 1)
		DLLSTRUCTSETDATA($TICO, "Count", $ICOUNT)
		LOCAL $IRESULT = 0, $IERROR = 0, $IBYTES
		LOCAL $AINFO[8], $ARET, $PDATA = 0, $IINDEX = 0
		LOCAL $ASIZE[2], $TDATA = 0
		DO
			IF NOT _WINAPI_WRITEFILE($HFILE, $TICO, $ILENGTH, $IBYTES) THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			WHILE $ICOUNT > $IINDEX
				$ARET = DLLCALL("user32.dll", "bool", "GetIconInfo", "handle", $AICON[$IINDEX], "struct*", $TII)
				IF @ERROR OR NOT $ARET[0] THEN
					$IERROR = @ERROR + 40
					EXITLOOP 2
				ENDIF
				FOR $I = 4 TO 5
					$AINFO[$I] = _WINAPI_COPYIMAGE(DLLSTRUCTGETDATA($TII, $I), 0, 0, 0, 8200)
					IF _WINAPI_GETOBJECT($AINFO[$I], $IDIB, $PDIB) THEN
						$AINFO[$I - 4] = DLLSTRUCTGETDATA($TDIB, "biSizeImage")
						$AINFO[$I - 2] = DLLSTRUCTGETDATA($TDIB, "bmBits")
					ELSE
						$IERROR = @ERROR + 50
					ENDIF
				NEXT
				$AINFO[6] = 40
				$AINFO[7] = DLLSTRUCTGETDATA($TDIB, "bmBitsPixel")
				SWITCH $AINFO[7]
					CASE 16, 24
					CASE 32
						IF NOT _WINAPI_ISALPHABITMAP($AINFO[5]) THEN
							IF NOT $ATEMP[$IINDEX] THEN
								$AICON[$IINDEX] = _WINAPI_CREATE32BITHICON($AICON[$IINDEX])
								$ATEMP[$IINDEX] = $AICON[$IINDEX]
								IF NOT @ERROR THEN
									CONTINUELOOP
								ELSE
									CONTINUECASE
								ENDIF
							ENDIF
						ELSE
							IF($AINFO[1] >= 256 * 256 * 4) AND($BCOMPRESS) THEN
								$IBYTES = _WINAPI_COMPRESSBITMAPBITS($AINFO[5], $PDATA)
								IF NOT @ERROR THEN
									$AINFO[0] = 0
									$AINFO[1] = $IBYTES
									$AINFO[2] = 0
									$AINFO[3] = $PDATA
									$AINFO[6] = 0
								ENDIF
							ENDIF
						ENDIF
					CASE ELSE
						$IERROR = 60
				ENDSWITCH
				IF NOT $IERROR THEN
					$TDATA = DLLSTRUCTCREATE("byte Width;byte Height;byte ColorCount;byte Reserved;ushort Planes;ushort BitCount;long Size;long Offset", DLLSTRUCTGETPTR($TICO) + 6 + 16 * $IINDEX)
					DLLSTRUCTSETDATA($TDATA, "ColorCount", 0)
					DLLSTRUCTSETDATA($TDATA, "Reserved", 0)
					DLLSTRUCTSETDATA($TDATA, "Planes", 1)
					DLLSTRUCTSETDATA($TDATA, "BitCount", $AINFO[7])
					DLLSTRUCTSETDATA($TDATA, "Size", $AINFO[0] + $AINFO[1] + $AINFO[6])
					DLLSTRUCTSETDATA($TDATA, "Offset", $IOFFSET)
					FOR $I = 0 TO 1
						$ASIZE[$I] = DLLSTRUCTGETDATA($TDIB, $I + 2)
						IF $ASIZE[$I] < 256 THEN
							DLLSTRUCTSETDATA($TDATA, $I + 1, $ASIZE[$I])
						ELSE
							DLLSTRUCTSETDATA($TDATA, $I + 1, 0)
						ENDIF
					NEXT
					DLLSTRUCTSETDATA($TBI, "biWidth", $ASIZE[0])
					DLLSTRUCTSETDATA($TBI, "biHeight", 2 * $ASIZE[1])
					DLLSTRUCTSETDATA($TBI, "biBitCount", $AINFO[7])
					DLLSTRUCTSETDATA($TBI, "biCompression", 0)
					DLLSTRUCTSETDATA($TBI, "biSizeImage", $AINFO[0] + $AINFO[1])
					$IOFFSET += $AINFO[0] + $AINFO[1] + $AINFO[6]
					DO
						IF $AINFO[6] THEN
							IF NOT _WINAPI_WRITEFILE($HFILE, $TBI, $AINFO[6], $IBYTES) THEN
								$IERROR = @ERROR + 70
								EXITLOOP
							ENDIF
							FOR $I = 1 TO 0 STEP -1
								IF NOT _WINAPI_WRITEFILE($HFILE, $AINFO[$I + 2], $AINFO[$I], $IBYTES) THEN
									$IERROR = @ERROR + 80
									EXITLOOP 2
								ENDIF
							NEXT
						ELSE
							IF NOT _WINAPI_WRITEFILE($HFILE, $AINFO[3], $AINFO[1], $IBYTES) THEN
								$IERROR = @ERROR + 90
								EXITLOOP
							ENDIF
						ENDIF
					UNTIL 1
				ENDIF
				FOR $I = 4 TO 5
					_WINAPI_DELETEOBJECT($AINFO[$I])
				NEXT
				IF $IERROR THEN
					EXITLOOP 2
				ENDIF
				$IINDEX += 1
			WEND
			$ARET = DLLCALL("kernel32.dll", "bool", "SetFilePointerEx", "handle", $HFILE, "int64", 0, "int64*", 0, "dword", 0)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 100
				EXITLOOP
			ENDIF
			IF NOT _WINAPI_WRITEFILE($HFILE, $TICO, $ILENGTH, $IBYTES) THEN
				$IERROR = @ERROR + 110
				EXITLOOP
			ENDIF
			$IRESULT = 1
		UNTIL 1
		FOR $I = 0 TO $ICOUNT - 1
			IF $ATEMP[$I] THEN
				_WINAPI_DESTROYICON($ATEMP[$I])
			ENDIF
		NEXT
		IF $PDATA THEN
			__HEAPFREE($PDATA)
		ENDIF
		_WINAPI_CLOSEHANDLE($HFILE)
		IF NOT $IRESULT THEN
			FILEDELETE($SFILEPATH)
		ENDIF
		RETURN SETERROR($IERROR, 0, $IRESULT)
	ENDFUNC
	FUNC _WINAPI_SCALEWINDOWEXT($HDC, $IXNUM, $IXDENOM, $IYNUM, $IYDENOM)
		$__G_VEXT = DLLSTRUCTCREATE($TAGSIZE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "ScaleWindowExtEx", "handle", $HDC, "int", $IXNUM, "int", $IXDENOM, "int", $IYNUM, "int", $IYDENOM, "struct*", $__G_VEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SELECTCLIPPATH($HDC, $IMODE = 5)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "SelectClipPath", "handle", $HDC, "int", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SELECTCLIPRGN($HDC, $HRGN)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "SelectClipRgn", "handle", $HDC, "handle", $HRGN)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETARCDIRECTION($HDC, $IDIRECTION)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "SetArcDirection", "handle", $HDC, "int", $IDIRECTION)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETBITMAPBITS($HBITMAP, $ISIZE, $PBITS)
		LOCAL $ARET = DLLCALL("gdi32.dll", "long", "SetBitmapBits", "handle", $HBITMAP, "dword", $ISIZE, "struct*", $PBITS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETBITMAPDIMENSIONEX($HBITMAP, $IWIDTH, $IHEIGHT)
		$__G_VEXT = DLLSTRUCTCREATE($TAGSIZE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "SetBitmapDimensionEx", "handle", $HBITMAP, "int", $IWIDTH, "int", $IHEIGHT, "struct*", $__G_VEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETBOUNDSRECT($HDC, $IFLAGS, $TRECT = 0)
		LOCAL $ARET = DLLCALL("gdi32.dll", "uint", "SetBoundsRect", "handle", $HDC, "struct*", $TRECT, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETBRUSHORG($HDC, $IX, $IY)
		$__G_VEXT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "SetBrushOrgEx", "handle", $HDC, "int", $IX, "int", $IY, "struct*", $__G_VEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETCOLORADJUSTMENT($HDC, $TADJUSTMENT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "SetColorAdjustment", "handle", $HDC, "struct*", $TADJUSTMENT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETDCBRUSHCOLOR($HDC, $IRGB)
		LOCAL $ARET = DLLCALL("gdi32.dll", "dword", "SetDCBrushColor", "handle", $HDC, "dword", __RGB($IRGB))
		IF @ERROR OR($ARET[0] = 4294967295) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN __RGB($ARET[0])
	ENDFUNC
	FUNC _WINAPI_SETDCPENCOLOR($HDC, $IRGB)
		LOCAL $ARET = DLLCALL("gdi32.dll", "dword", "SetDCPenColor", "handle", $HDC, "dword", __RGB($IRGB))
		IF @ERROR OR($ARET[0] = 4294967295) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN __RGB($ARET[0])
	ENDFUNC
	FUNC _WINAPI_SETDEVICEGAMMARAMP($HDC, CONST BYREF $ARAMP)
		IF(UBOUND($ARAMP, $UBOUND_DIMENSIONS) <> 2) OR(UBOUND($ARAMP, $UBOUND_ROWS) <> 256) OR(UBOUND($ARAMP, $UBOUND_COLUMNS) <> 3) THEN
			RETURN SETERROR(12, 0, 0)
		ENDIF
		LOCAL $TDATA = DLLSTRUCTCREATE("ushort[256];ushort[256];ushort[256]")
		FOR $I = 0 TO 2
			FOR $J = 0 TO 255
				DLLSTRUCTSETDATA($TDATA, $I + 1, $ARAMP[$J][$I], $J + 1)
			NEXT
		NEXT
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "SetDeviceGammaRamp", "handle", $HDC, "struct*", $TDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETDIBCOLORTABLE($HBITMAP, $TCOLORTABLE, $ICOLORCOUNT)
		IF $ICOLORCOUNT > DLLSTRUCTGETSIZE($TCOLORTABLE) / 4 THEN RETURN SETERROR(1, 0, 0)
		LOCAL $HDC = _WINAPI_CREATECOMPATIBLEDC(0)
		LOCAL $HSV = _WINAPI_SELECTOBJECT($HDC, $HBITMAP)
		LOCAL $IERROR = 0
		LOCAL $ARET = DLLCALL("gdi32.dll", "uint", "SetDIBColorTable", "handle", $HDC, "uint", 0, "uint", $ICOLORCOUNT, "struct*", $TCOLORTABLE)
		IF @ERROR THEN $IERROR = @ERROR
		_WINAPI_SELECTOBJECT($HDC, $HSV)
		_WINAPI_DELETEDC($HDC)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETDIBITS($HDC, $HBITMAP, $ISTARTSCAN, $ISCANLINES, $PBITS, $TBMI, $ICOLORUSE = 0)
		LOCAL $ARESULT = DLLCALL("gdi32.dll", "int", "SetDIBits", "handle", $HDC, "handle", $HBITMAP, "uint", $ISTARTSCAN, "uint", $ISCANLINES, "struct*", $PBITS, "struct*", $TBMI, "INT", $ICOLORUSE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETDIBITSTODEVICE($HDC, $IXDEST, $IYDEST, $IWIDTH, $IHEIGHT, $IXSRC, $IYSRC, $ISTARTSCAN, $ISCANLINES, $TBITMAPINFO, $IUSAGE, $PBITS)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "SetDIBitsToDevice", "handle", $HDC, "int", $IXDEST, "int", $IYDEST, "dword", $IWIDTH, "dword", $IHEIGHT, "int", $IXSRC, "int", $IYSRC, "uint", $ISTARTSCAN, "uint", $ISCANLINES, "struct*", $PBITS, "struct*", $TBITMAPINFO, "uint", $IUSAGE)
		IF @ERROR OR($ARET[0] = -1) THEN RETURN SETERROR(@ERROR + 10, $ARET[0], 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETENHMETAFILEBITS($PDATA, $ILENGTH)
		LOCAL $ARET = DLLCALL("gdi32.dll", "handle", "SetEnhMetaFileBits", "uint", $ILENGTH, "struct*", $PDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETGRAPHICSMODE($HDC, $IMODE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "SetGraphicsMode", "handle", $HDC, "int", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETMAPMODE($HDC, $IMODE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "SetMapMode", "handle", $HDC, "int", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETPIXEL($HDC, $IX, $IY, $IRGB)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "SetPixelV", "handle", $HDC, "int", $IX, "int", $IY, "dword", __RGB($IRGB))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETPOLYFILLMODE($HDC, $IMODE = 1)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "SetPolyFillMode", "handle", $HDC, "int", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETRECTRGN($HRGN, $TRECT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "SetRectRgn", "handle", $HRGN, "int", DLLSTRUCTGETDATA($TRECT, 1), "int", DLLSTRUCTGETDATA($TRECT, 2), "int", DLLSTRUCTGETDATA($TRECT, 3), "int", DLLSTRUCTGETDATA($TRECT, 4))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETROP2($HDC, $IMODE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "SetROP2", "handle", $HDC, "int", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETSTRETCHBLTMODE($HDC, $IMODE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "SetStretchBltMode", "handle", $HDC, "int", $IMODE)
		IF @ERROR OR NOT $ARET[0] OR($ARET[0] = 87) THEN RETURN SETERROR(@ERROR + 10, $ARET[0], 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETTEXTALIGN($HDC, $IMODE = 0)
		LOCAL $ARET = DLLCALL("gdi32.dll", "uint", "SetTextAlign", "handle", $HDC, "uint", $IMODE)
		IF @ERROR OR($ARET[0] = 4294967295) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETTEXTCHARACTEREXTRA($HDC, $ICHAREXTRA)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "SetTextCharacterExtra", "handle", $HDC, "int", $ICHAREXTRA)
		IF @ERROR OR($ARET[0] = -2147483648) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETTEXTJUSTIFICATION($HDC, $IBREAKEXTRA, $IBREAKCOUNT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "SetTextJustification", "handle", $HDC, "int", $IBREAKEXTRA, "int", $IBREAKCOUNT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETUDFCOLORMODE($IMODE)
		$__G_IRGBMODE = NOT($IMODE = 0)
	ENDFUNC
	FUNC _WINAPI_SETWINDOWEXT($HDC, $IXEXTENT, $IYEXTENT)
		$__G_VEXT = DLLSTRUCTCREATE($TAGSIZE)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "SetWindowExtEx", "handle", $HDC, "int", $IXEXTENT, "int", $IYEXTENT, "struct*", $__G_VEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETWINDOWORG($HDC, $IX, $IY)
		$__G_VEXT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "SetWindowOrgEx", "handle", $HDC, "int", $IX, "int", $IY, "struct*", $__G_VEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETWORLDTRANSFORM($HDC, BYREF $TXFORM)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "SetWorldTransform", "handle", $HDC, "struct*", $TXFORM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_STRETCHBLT($HDESTDC, $IXDEST, $IYDEST, $IWIDTHDEST, $IHEIGHTDEST, $HSRCDC, $IXSRC, $IYSRC, $IWIDTHSRC, $IHEIGHTSRC, $IROP)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "StretchBlt", "handle", $HDESTDC, "int", $IXDEST, "int", $IYDEST, "int", $IWIDTHDEST, "int", $IHEIGHTDEST, "hwnd", $HSRCDC, "int", $IXSRC, "int", $IYSRC, "int", $IWIDTHSRC, "int", $IHEIGHTSRC, "dword", $IROP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_STRETCHDIBITS($HDESTDC, $IXDEST, $IYDEST, $IWIDTHDEST, $IHEIGHTDEST, $IXSRC, $IYSRC, $IWIDTHSRC, $IHEIGHTSRC, $TBITMAPINFO, $IUSAGE, $PBITS, $IROP)
		LOCAL $ARET = DLLCALL("gdi32.dll", "int", "StretchDIBits", "handle", $HDESTDC, "int", $IXDEST, "int", $IYDEST, "int", $IWIDTHDEST, "int", $IHEIGHTDEST, "int", $IXSRC, "int", $IYSRC, "int", $IWIDTHSRC, "int", $IHEIGHTSRC, "struct*", $PBITS, "struct*", $TBITMAPINFO, "uint", $IUSAGE, "dword", $IROP)
		IF @ERROR OR($ARET[0] = -1) THEN RETURN SETERROR(@ERROR + 10, $ARET[0], 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_STROKEANDFILLPATH($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "StrokeAndFillPath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_STROKEPATH($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "StrokePath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SUBTRACTRECT(BYREF $TRECT1, BYREF $TRECT2)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "SubtractRect", "struct*", $TRECT, "struct*", $TRECT1, "struct*", $TRECT2)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_TABBEDTEXTOUT($HDC, $IX, $IY, $STEXT, $ATAB = 0, $ISTART = 0, $IEND = -1, $IORIGIN = 0)
		LOCAL $ITAB, $ICOUNT
		IF NOT ISARRAY($ATAB) THEN
			IF $ATAB THEN
				$ITAB = $ATAB
				DIM $ATAB[1] = [$ITAB]
				$ISTART = 0
				$IEND = 0
				$ICOUNT = 1
			ELSE
				$ICOUNT = 0
			ENDIF
		ELSE
			$ICOUNT = 1
		ENDIF
		LOCAL $TTAB = 0
		IF $ICOUNT THEN
			IF __CHECKERRORARRAYBOUNDS($ATAB, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			$ICOUNT = $IEND - $ISTART + 1
			$TTAB = DLLSTRUCTCREATE("uint[" & $ICOUNT & "]")
			$ITAB = 1
			FOR $I = $ISTART TO $IEND
				DLLSTRUCTSETDATA($TTAB, 1, $ATAB[$I], $ITAB)
				$ITAB += 1
			NEXT
		ENDIF
		LOCAL $ARET = DLLCALL("user32.dll", "long", "TabbedTextOutW", "handle", $HDC, "int", $IX, "int", $IY, "wstr", $STEXT, "int", STRINGLEN($STEXT), "int", $ICOUNT, "struct*", $TTAB, "int", $IORIGIN)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		$__G_VEXT = _WINAPI_CREATESIZE(_WINAPI_LOWORD($ARET[0]), _WINAPI_HIWORD($ARET[0]))
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_TEXTOUT($HDC, $IX, $IY, $STEXT)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "TextOutW", "handle", $HDC, "int", $IX, "int", $IY, "wstr", $STEXT, "int", STRINGLEN($STEXT))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_TRANSPARENTBLT($HDESTDC, $IXDEST, $IYDEST, $IWIDTHDEST, $IHEIGHTDEST, $HSRCDC, $IXSRC, $IYSRC, $IWIDTHSRC, $IHEIGHTSRC, $IRGB)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "GdiTransparentBlt", "handle", $HDESTDC, "int", $IXDEST, "int", $IYDEST, "int", $IWIDTHDEST, "int", $IHEIGHTDEST, "hwnd", $HSRCDC, "int", $IXSRC, "int", $IYSRC, "int", $IWIDTHSRC, "int", $IHEIGHTSRC, "dword", __RGB($IRGB))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_UNIONRECT(BYREF $TRECT1, BYREF $TRECT2)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "UnionRect", "struct*", $TRECT, "struct*", $TRECT1, "struct*", $TRECT2)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, 0, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_VALIDATERECT($HWND, $TRECT = 0)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "ValidateRect", "hwnd", $HWND, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_VALIDATERGN($HWND, $HRGN = 0)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "ValidateRgn", "hwnd", $HWND, "handle", $HRGN)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_WIDENPATH($HDC)
		LOCAL $ARET = DLLCALL("gdi32.dll", "bool", "WidenPath", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_WINDOWFROMDC($HDC)
		LOCAL $ARET = DLLCALL("user32.dll", "hwnd", "WindowFromDC", "handle", $HDC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __ENUMDISPLAYMONITORSPROC($HMONITOR, $HDC, $PRECT, $LPARAM)
		#forceref $HDC, $LPARAM
		__INC($__G_VENUM)
		$__G_VENUM[$__G_VENUM[0][0]][0] = $HMONITOR
		IF NOT $PRECT THEN
			$__G_VENUM[$__G_VENUM[0][0]][1] = 0
		ELSE
			$__G_VENUM[$__G_VENUM[0][0]][1] = DLLSTRUCTCREATE($TAGRECT)
			IF NOT _WINAPI_MOVEMEMORY(DLLSTRUCTGETPTR($__G_VENUM[$__G_VENUM[0][0]][1]), $PRECT, 16) THEN RETURN 0
		ENDIF
		RETURN 1
	ENDFUNC
	FUNC __ENUMFONTFAMILIESPROC($PELFEX, $PNTMEX, $IFONTTYPE, $PPATTERN)
		LOCAL $TELFEX = DLLSTRUCTCREATE($TAGLOGFONT & ";wchar FullName[64];wchar Style[32];wchar Script[32]", $PELFEX)
		LOCAL $TNTMEX = DLLSTRUCTCREATE($TAGNEWTEXTMETRICEX, $PNTMEX)
		LOCAL $TPATTERN = DLLSTRUCTCREATE("uint;uint;ptr", $PPATTERN)
		IF $IFONTTYPE AND NOT BITAND($IFONTTYPE, DLLSTRUCTGETDATA($TPATTERN, 1)) THEN
			RETURN 1
		ENDIF
		IF DLLSTRUCTGETDATA($TPATTERN, 3) THEN
			LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathMatchSpecW", "ptr", DLLSTRUCTGETPTR($TELFEX, 14), "ptr", DLLSTRUCTGETDATA($TPATTERN, 3))
			IF NOT @ERROR THEN
				IF DLLSTRUCTGETDATA($TPATTERN, 2) THEN
					IF $ARET[0] THEN
						RETURN 1
					ELSE
					ENDIF
				ELSE
					IF $ARET[0] THEN
					ELSE
						RETURN 1
					ENDIF
				ENDIF
			ENDIF
		ENDIF
		__INC($__G_VENUM)
		$__G_VENUM[$__G_VENUM[0][0]][0] = DLLSTRUCTGETDATA($TELFEX, 14)
		$__G_VENUM[$__G_VENUM[0][0]][1] = DLLSTRUCTGETDATA($TELFEX, 16)
		$__G_VENUM[$__G_VENUM[0][0]][2] = DLLSTRUCTGETDATA($TELFEX, 15)
		$__G_VENUM[$__G_VENUM[0][0]][3] = DLLSTRUCTGETDATA($TELFEX, 17)
		$__G_VENUM[$__G_VENUM[0][0]][4] = $IFONTTYPE
		$__G_VENUM[$__G_VENUM[0][0]][5] = DLLSTRUCTGETDATA($TNTMEX, 19)
		$__G_VENUM[$__G_VENUM[0][0]][6] = DLLSTRUCTGETDATA($TNTMEX, 20)
		$__G_VENUM[$__G_VENUM[0][0]][7] = DLLSTRUCTGETDATA($TNTMEX, 21)
		RETURN 1
	ENDFUNC
	FUNC __ENUMFONTSTYLESPROC($PELFEX, $PNTMEX, $IFONTTYPE, $PFN)
		#forceref $IFONTTYPE
		LOCAL $TELFEX = DLLSTRUCTCREATE($TAGLOGFONT & ";wchar FullName[64];wchar Style[32];wchar Script[32]", $PELFEX)
		LOCAL $TNTMEX = DLLSTRUCTCREATE($TAGNEWTEXTMETRICEX, $PNTMEX)
		LOCAL $TFN = DLLSTRUCTCREATE("dword;wchar[64]", $PFN)
		IF BITAND(DLLSTRUCTGETDATA($TNTMEX, "ntmFlags"), 97) = DLLSTRUCTGETDATA($TFN, 1) THEN
			DLLSTRUCTSETDATA($TFN, 2, DLLSTRUCTGETDATA($TELFEX, "FullName"))
			RETURN 0
		ELSE
			RETURN 1
		ENDIF
	ENDFUNC
#EndRegion Internal Functions
GLOBAL $__G_HGDIPBRUSH = 0
GLOBAL $__G_HGDIPDLL = 0
GLOBAL $__G_HGDIPPEN = 0
GLOBAL $__G_IGDIPREF = 0
GLOBAL $__G_IGDIPTOKEN = 0
GLOBAL $__G_BGDIP_V1_0 = TRUE
FUNC _GDIPLUS_ARROWCAPCREATE($FHEIGHT, $FWIDTH, $BFILLED = TRUE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateAdjustableArrowCap", "float", $FHEIGHT, "float", $FWIDTH, "bool", $BFILLED, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[4]
ENDFUNC
FUNC _GDIPLUS_ARROWCAPDISPOSE($HCAP)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDeleteCustomLineCap", "handle", $HCAP)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_ARROWCAPGETFILLSTATE($HARROWCAP)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetAdjustableArrowCapFillState", "handle", $HARROWCAP, "bool*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_ARROWCAPGETHEIGHT($HARROWCAP)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetAdjustableArrowCapHeight", "handle", $HARROWCAP, "float*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_ARROWCAPGETMIDDLEINSET($HARROWCAP)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetAdjustableArrowCapMiddleInset", "handle", $HARROWCAP, "float*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_ARROWCAPGETWIDTH($HARROWCAP)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetAdjustableArrowCapWidth", "handle", $HARROWCAP, "float*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_ARROWCAPSETFILLSTATE($HARROWCAP, $BFILLED = TRUE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetAdjustableArrowCapFillState", "handle", $HARROWCAP, "bool", $BFILLED)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_ARROWCAPSETHEIGHT($HARROWCAP, $FHEIGHT)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetAdjustableArrowCapHeight", "handle", $HARROWCAP, "float", $FHEIGHT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_ARROWCAPSETMIDDLEINSET($HARROWCAP, $FINSET)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetAdjustableArrowCapMiddleInset", "handle", $HARROWCAP, "float", $FINSET)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_ARROWCAPSETWIDTH($HARROWCAP, $FWIDTH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetAdjustableArrowCapWidth", "handle", $HARROWCAP, "float", $FWIDTH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_BITMAPCLONEAREA($HBITMAP, $NLEFT, $NTOP, $NWIDTH, $NHEIGHT, $IFORMAT = 137224)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCloneBitmapArea", "float", $NLEFT, "float", $NTOP, "float", $NWIDTH, "float", $NHEIGHT, "int", $IFORMAT, "handle", $HBITMAP, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[7]
ENDFUNC
FUNC _GDIPLUS_BITMAPCREATEDIBFROMBITMAP($HBITMAP)
	LOCAL $ARET = DLLCALL($__G_HGDIPDLL, "uint", "GdipGetImageDimension", "handle", $HBITMAP, "float*", 0, "float*", 0)
	IF @ERROR OR $ARET[0] THEN RETURN SETERROR(@ERROR + 10, $ARET[0], 0)
	LOCAL $TDATA = _GDIPLUS_BITMAPLOCKBITS($HBITMAP, 0, 0, $ARET[2], $ARET[3], $GDIP_ILMREAD, $GDIP_PXF32ARGB)
	LOCAL $PBITS = DLLSTRUCTGETDATA($TDATA, "Scan0")
	IF NOT $PBITS THEN RETURN 0
	LOCAL $TBIHDR = DLLSTRUCTCREATE($TAGBITMAPV5HEADER)
	DLLSTRUCTSETDATA($TBIHDR, "bV5Size", DLLSTRUCTGETSIZE($TBIHDR))
	DLLSTRUCTSETDATA($TBIHDR, "bV5Width", $ARET[2])
	DLLSTRUCTSETDATA($TBIHDR, "bV5Height", $ARET[3])
	DLLSTRUCTSETDATA($TBIHDR, "bV5Planes", 1)
	DLLSTRUCTSETDATA($TBIHDR, "bV5BitCount", 32)
	DLLSTRUCTSETDATA($TBIHDR, "bV5Compression", 0)
	DLLSTRUCTSETDATA($TBIHDR, "bV5SizeImage", $ARET[3] * DLLSTRUCTGETDATA($TDATA, "Stride"))
	DLLSTRUCTSETDATA($TBIHDR, "bV5AlphaMask", -16777216)
	DLLSTRUCTSETDATA($TBIHDR, "bV5RedMask", 16711680)
	DLLSTRUCTSETDATA($TBIHDR, "bV5GreenMask", 65280)
	DLLSTRUCTSETDATA($TBIHDR, "bV5BlueMask", 255)
	DLLSTRUCTSETDATA($TBIHDR, "bV5CSType", 2)
	DLLSTRUCTSETDATA($TBIHDR, "bV5Intent", 4)
	LOCAL $HHBITMAPV5 = DLLCALL("gdi32.dll", "ptr", "CreateDIBSection", "hwnd", 0, "struct*", $TBIHDR, "uint", 0, "ptr*", 0, "ptr", 0, "dword", 0)
	IF NOT @ERROR AND $HHBITMAPV5[0] THEN
		DLLCALL("gdi32.dll", "dword", "SetBitmapBits", "ptr", $HHBITMAPV5[0], "dword", $ARET[2] * $ARET[3] * 4, "ptr", DLLSTRUCTGETDATA($TDATA, "Scan0"))
		$HHBITMAPV5 = $HHBITMAPV5[0]
	ELSE
		$HHBITMAPV5 = 0
	ENDIF
	_GDIPLUS_BITMAPUNLOCKBITS($HBITMAP, $TDATA)
	$TDATA = 0
	$TBIHDR = 0
	RETURN $HHBITMAPV5
ENDFUNC
FUNC _GDIPLUS_BITMAPCREATEFROMFILE($SFILENAME)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateBitmapFromFile", "wstr", $SFILENAME, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_BITMAPCREATEFROMGRAPHICS($IWIDTH, $IHEIGHT, $HGRAPHICS)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateBitmapFromGraphics", "int", $IWIDTH, "int", $IHEIGHT, "handle", $HGRAPHICS, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[4]
ENDFUNC
FUNC _GDIPLUS_BITMAPCREATEFROMHBITMAP($HBITMAP, $HPAL = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateBitmapFromHBITMAP", "handle", $HBITMAP, "handle", $HPAL, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_BITMAPCREATEFROMMEMORY($DIMAGE, $BHBITMAP = FALSE)
	IF NOT ISBINARY($DIMAGE) THEN RETURN SETERROR(1, 0, 0)
	LOCAL $ARESULT = 0
	LOCAL CONST $DMEMBITMAP = BINARY($DIMAGE)
	LOCAL CONST $ILEN = BINARYLEN($DMEMBITMAP)
	LOCAL CONST $GMEM_MOVEABLE = 2
	$ARESULT = DLLCALL("kernel32.dll", "handle", "GlobalAlloc", "uint", $GMEM_MOVEABLE, "ulong_ptr", $ILEN)
	IF @ERROR THEN RETURN SETERROR(4, 0, 0)
	LOCAL CONST $HDATA = $ARESULT[0]
	$ARESULT = DLLCALL("kernel32.dll", "ptr", "GlobalLock", "handle", $HDATA)
	IF @ERROR THEN RETURN SETERROR(5, 0, 0)
	LOCAL $TMEM = DLLSTRUCTCREATE("byte[" & $ILEN & "]", $ARESULT[0])
	DLLSTRUCTSETDATA($TMEM, 1, $DMEMBITMAP)
	DLLCALL("kernel32.dll", "bool", "GlobalUnlock", "handle", $HDATA)
	IF @ERROR THEN RETURN SETERROR(6, 0, 0)
	LOCAL CONST $HSTREAM = _WINAPI_CREATESTREAMONHGLOBAL($HDATA)
	IF @ERROR THEN RETURN SETERROR(2, 0, 0)
	LOCAL CONST $HBITMAP = _GDIPLUS_BITMAPCREATEFROMSTREAM($HSTREAM)
	IF @ERROR THEN RETURN SETERROR(3, 0, 0)
	DLLCALL("oleaut32.dll", "long", "DispCallFunc", "ptr", $HSTREAM, "ulong_ptr", 8 * (1 + @AUTOITX64), "uint", 4, "ushort", 23, "uint", 0, "ptr", 0, "ptr", 0, "str", "")
	IF $BHBITMAP THEN
		LOCAL CONST $HHBMP = _GDIPLUS_BITMAPCREATEDIBFROMBITMAP($HBITMAP)
		_GDIPLUS_BITMAPDISPOSE($HBITMAP)
		RETURN $HHBMP
	ENDIF
	RETURN $HBITMAP
ENDFUNC
FUNC _GDIPLUS_BITMAPCREATEFROMRESOURCE($HINST, $VRESOURCENAME)
	LOCAL $STYPE = "int"
	IF ISSTRING($VRESOURCENAME) THEN $STYPE = "wstr"
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateBitmapFromResource", "handle", $HINST, $STYPE, $VRESOURCENAME, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_BITMAPCREATEFROMSCAN0($IWIDTH, $IHEIGHT, $IPIXELFORMAT = $GDIP_PXF32ARGB, $ISTRIDE = 0, $PSCAN0 = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "uint", "GdipCreateBitmapFromScan0", "int", $IWIDTH, "int", $IHEIGHT, "int", $ISTRIDE, "int", $IPIXELFORMAT, "struct*", $PSCAN0, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[6]
ENDFUNC
FUNC _GDIPLUS_BITMAPCREATEFROMSTREAM($PSTREAM)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateBitmapFromStream", "ptr", $PSTREAM, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_BITMAPCREATEHBITMAPFROMBITMAP($HBITMAP, $IARGB = -16777216)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateHBITMAPFromBitmap", "handle", $HBITMAP, "handle*", 0, "dword", $IARGB)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_BITMAPDISPOSE($HBITMAP)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDisposeImage", "handle", $HBITMAP)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_BITMAPCREATEFROMHICON($HICON)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateBitmapFromHICON", "handle", $HICON, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_BITMAPCREATEFROMHICON32($HICON)
	LOCAL $TSIZE = _WINAPI_GETICONDIMENSION($HICON)
	LOCAL $IWIDTH = DLLSTRUCTGETDATA($TSIZE, "X")
	LOCAL $IHEIGHT = DLLSTRUCTGETDATA($TSIZE, "Y")
	IF $IWIDTH <= 0 OR $IHEIGHT <= 0 THEN RETURN SETERROR(10, -1, 0)
	LOCAL $TBITMAPINFO = DLLSTRUCTCREATE("dword Size;long Width;long Height;word Planes;word BitCount;dword Compression;dword SizeImage;long XPelsPerMeter;long YPelsPerMeter;dword ClrUsed;dword ClrImportant;dword RGBQuad")
	DLLSTRUCTSETDATA($TBITMAPINFO, "Size", DLLSTRUCTGETSIZE($TBITMAPINFO) - 4)
	DLLSTRUCTSETDATA($TBITMAPINFO, "Width", $IWIDTH)
	DLLSTRUCTSETDATA($TBITMAPINFO, "Height", -$IHEIGHT)
	DLLSTRUCTSETDATA($TBITMAPINFO, "Planes", 1)
	DLLSTRUCTSETDATA($TBITMAPINFO, "BitCount", 32)
	DLLSTRUCTSETDATA($TBITMAPINFO, "Compression", 0)
	DLLSTRUCTSETDATA($TBITMAPINFO, "SizeImage", 0)
	LOCAL $HDC = _WINAPI_CREATECOMPATIBLEDC(0)
	LOCAL $PBITS
	LOCAL $HBMP = _WINAPI_CREATEDIBSECTION(0, $TBITMAPINFO, 0, $PBITS)
	LOCAL $HORIG = _WINAPI_SELECTOBJECT($HDC, $HBMP)
	_WINAPI_DRAWICONEX($HDC, 0, 0, $HICON, $IWIDTH, $IHEIGHT)
	LOCAL $HBITMAPICON = _GDIPLUS_BITMAPCREATEFROMSCAN0($IWIDTH, $IHEIGHT, $GDIP_PXF32ARGB, $IWIDTH * 4, $PBITS)
	LOCAL $HBITMAP = _GDIPLUS_BITMAPCREATEFROMSCAN0($IWIDTH, $IHEIGHT)
	LOCAL $HCONTEXT = _GDIPLUS_IMAGEGETGRAPHICSCONTEXT($HBITMAP)
	_GDIPLUS_GRAPHICSDRAWIMAGE($HCONTEXT, $HBITMAPICON, 0, 0)
	_GDIPLUS_GRAPHICSDISPOSE($HCONTEXT)
	_GDIPLUS_BITMAPDISPOSE($HBITMAPICON)
	_WINAPI_SELECTOBJECT($HDC, $HORIG)
	_WINAPI_DELETEDC($HDC)
	_WINAPI_DELETEOBJECT($HBMP)
	RETURN $HBITMAP
ENDFUNC
FUNC _GDIPLUS_BITMAPGETPIXEL($HBITMAP, $IX, $IY)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipBitmapGetPixel", "handle", $HBITMAP, "int", $IX, "int", $IY, "uint*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[4]
ENDFUNC
FUNC _GDIPLUS_BITMAPLOCKBITS($HBITMAP, $ILEFT, $ITOP, $IWIDTH, $IHEIGHT, $IFLAGS = $GDIP_ILMREAD, $IFORMAT = $GDIP_PXF32RGB)
	LOCAL $TDATA = DLLSTRUCTCREATE($TAGGDIPBITMAPDATA)
	LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
	DLLSTRUCTSETDATA($TRECT, "Left", $ILEFT)
	DLLSTRUCTSETDATA($TRECT, "Top", $ITOP)
	DLLSTRUCTSETDATA($TRECT, "Right", $IWIDTH)
	DLLSTRUCTSETDATA($TRECT, "Bottom", $IHEIGHT)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipBitmapLockBits", "handle", $HBITMAP, "struct*", $TRECT, "uint", $IFLAGS, "int", $IFORMAT, "struct*", $TDATA)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $TDATA
ENDFUNC
FUNC _GDIPLUS_BITMAPSETPIXEL($HBITMAP, $IX, $IY, $IARGB)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipBitmapSetPixel", "handle", $HBITMAP, "int", $IX, "int", $IY, "uint", $IARGB)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_BITMAPSETRESOLUTION($HBITMAP, $FDPIX, $FDPIY)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipBitmapSetResolution", "handle", $HBITMAP, "float", $FDPIX, "float", $FDPIY)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_BITMAPUNLOCKBITS($HBITMAP, $TBITMAPDATA)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipBitmapUnlockBits", "handle", $HBITMAP, "struct*", $TBITMAPDATA)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_BRUSHCLONE($HBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCloneBrush", "handle", $HBRUSH, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_BRUSHCREATESOLID($IARGB = -16777216)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateSolidFill", "int", $IARGB, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_BRUSHDISPOSE($HBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDeleteBrush", "handle", $HBRUSH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_BRUSHGETSOLIDCOLOR($HBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetSolidFillColor", "handle", $HBRUSH, "dword*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_BRUSHGETTYPE($HBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetBrushType", "handle", $HBRUSH, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_BRUSHSETSOLIDCOLOR($HBRUSH, $IARGB = -16777216)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetSolidFillColor", "handle", $HBRUSH, "dword", $IARGB)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_COLORMATRIXCREATE()
	RETURN _GDIPLUS_COLORMATRIXCREATESCALE(1, 1, 1, 1)
ENDFUNC
FUNC _GDIPLUS_COLORMATRIXCREATEGRAYSCALE()
	LOCAL $II, $IJ, $TCM, $ALUMS[4] = [$GDIP_RLUM, $GDIP_GLUM, $GDIP_BLUM, 0]
	$TCM = DLLSTRUCTCREATE($TAGGDIPCOLORMATRIX)
	FOR $II = 0 TO 3
		FOR $IJ = 1 TO 3
			DLLSTRUCTSETDATA($TCM, "m", $ALUMS[$II], $II * 5 + $IJ)
		NEXT
	NEXT
	DLLSTRUCTSETDATA($TCM, "m", 1, 19)
	DLLSTRUCTSETDATA($TCM, "m", 1, 25)
	RETURN $TCM
ENDFUNC
FUNC _GDIPLUS_COLORMATRIXCREATENEGATIVE()
	LOCAL $II, $TCM
	$TCM = _GDIPLUS_COLORMATRIXCREATESCALE(-1, -1, -1, 1)
	FOR $II = 1 TO 4
		DLLSTRUCTSETDATA($TCM, "m", 1, 20 + $II)
	NEXT
	RETURN $TCM
ENDFUNC
FUNC _GDIPLUS_COLORMATRIXCREATESATURATION($FSAT)
	LOCAL $FSATCOMP, $TCM
	$TCM = DLLSTRUCTCREATE($TAGGDIPCOLORMATRIX)
	$FSATCOMP = (1 - $FSAT)
	DLLSTRUCTSETDATA($TCM, "m", $FSATCOMP * $GDIP_RLUM + $FSAT, 1)
	DLLSTRUCTSETDATA($TCM, "m", $FSATCOMP * $GDIP_RLUM, 2)
	DLLSTRUCTSETDATA($TCM, "m", $FSATCOMP * $GDIP_RLUM, 3)
	DLLSTRUCTSETDATA($TCM, "m", $FSATCOMP * $GDIP_GLUM, 6)
	DLLSTRUCTSETDATA($TCM, "m", $FSATCOMP * $GDIP_GLUM + $FSAT, 7)
	DLLSTRUCTSETDATA($TCM, "m", $FSATCOMP * $GDIP_GLUM, 8)
	DLLSTRUCTSETDATA($TCM, "m", $FSATCOMP * $GDIP_BLUM, 11)
	DLLSTRUCTSETDATA($TCM, "m", $FSATCOMP * $GDIP_BLUM, 12)
	DLLSTRUCTSETDATA($TCM, "m", $FSATCOMP * $GDIP_BLUM + $FSAT, 13)
	DLLSTRUCTSETDATA($TCM, "m", 1, 19)
	DLLSTRUCTSETDATA($TCM, "m", 1, 25)
	RETURN $TCM
ENDFUNC
FUNC _GDIPLUS_COLORMATRIXCREATESCALE($FRED, $FGREEN, $FBLUE, $FALPHA = 1)
	LOCAL $TCM
	$TCM = DLLSTRUCTCREATE($TAGGDIPCOLORMATRIX)
	DLLSTRUCTSETDATA($TCM, "m", $FRED, 1)
	DLLSTRUCTSETDATA($TCM, "m", $FGREEN, 7)
	DLLSTRUCTSETDATA($TCM, "m", $FBLUE, 13)
	DLLSTRUCTSETDATA($TCM, "m", $FALPHA, 19)
	DLLSTRUCTSETDATA($TCM, "m", 1, 25)
	RETURN $TCM
ENDFUNC
FUNC _GDIPLUS_COLORMATRIXCREATETRANSLATE($FRED, $FGREEN, $FBLUE, $FALPHA = 0)
	LOCAL $II, $TCM, $AFACTORS[4] = [$FRED, $FGREEN, $FBLUE, $FALPHA]
	$TCM = _GDIPLUS_COLORMATRIXCREATE()
	FOR $II = 0 TO 3
		DLLSTRUCTSETDATA($TCM, "m", $AFACTORS[$II], 21 + $II)
	NEXT
	RETURN $TCM
ENDFUNC
FUNC _GDIPLUS_CUSTOMLINECAPCLONE($HCUSTOMLINECAP)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCloneCustomLineCap", "handle", $HCUSTOMLINECAP, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_CUSTOMLINECAPCREATE($HPATHFILL, $HPATHSTROKE, $ILINECAP = 0, $NBASEINSET = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateCustomLineCap", "handle", $HPATHFILL, "handle", $HPATHSTROKE, "int", $ILINECAP, "float", $NBASEINSET, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[5]
ENDFUNC
FUNC _GDIPLUS_CUSTOMLINECAPDISPOSE($HCAP)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDeleteCustomLineCap", "handle", $HCAP)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_CUSTOMLINECAPGETSTROKECAPS($HCUSTOMLINECAP)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetCustomLineCapStrokeCaps", "hwnd", $HCUSTOMLINECAP, "ptr*", 0, "ptr*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN SETERROR(10, $ARESULT[0], 0)
	LOCAL $ACAPS[2]
	$ACAPS[0] = $ARESULT[2]
	$ACAPS[1] = $ARESULT[3]
	RETURN $ACAPS
ENDFUNC
FUNC _GDIPLUS_CUSTOMLINECAPSETSTROKECAPS($HCUSTOMLINECAP, $ISTARTCAP, $IENDCAP)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetCustomLineCapStrokeCaps", "handle", $HCUSTOMLINECAP, "int", $ISTARTCAP, "int", $IENDCAP)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_DECODERS()
	LOCAL $ICOUNT = _GDIPLUS_DECODERSGETCOUNT()
	LOCAL $ISIZE = _GDIPLUS_DECODERSGETSIZE()
	LOCAL $TBUFFER = DLLSTRUCTCREATE("byte[" & $ISIZE & "]")
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageDecoders", "uint", $ICOUNT, "uint", $ISIZE, "struct*", $TBUFFER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	LOCAL $PBUFFER = DLLSTRUCTGETPTR($TBUFFER)
	LOCAL $TCODEC, $AINFO[$ICOUNT + 1][14]
	$AINFO[0][0] = $ICOUNT
	FOR $II = 1 TO $ICOUNT
		$TCODEC = DLLSTRUCTCREATE($TAGGDIPIMAGECODECINFO, $PBUFFER)
		$AINFO[$II][1] = _WINAPI_STRINGFROMGUID(DLLSTRUCTGETPTR($TCODEC, "CLSID"))
		$AINFO[$II][2] = _WINAPI_STRINGFROMGUID(DLLSTRUCTGETPTR($TCODEC, "FormatID"))
		$AINFO[$II][3] = _WINAPI_WIDECHARTOMULTIBYTE(DLLSTRUCTGETDATA($TCODEC, "CodecName"))
		$AINFO[$II][4] = _WINAPI_WIDECHARTOMULTIBYTE(DLLSTRUCTGETDATA($TCODEC, "DllName"))
		$AINFO[$II][5] = _WINAPI_WIDECHARTOMULTIBYTE(DLLSTRUCTGETDATA($TCODEC, "FormatDesc"))
		$AINFO[$II][6] = _WINAPI_WIDECHARTOMULTIBYTE(DLLSTRUCTGETDATA($TCODEC, "FileExt"))
		$AINFO[$II][7] = _WINAPI_WIDECHARTOMULTIBYTE(DLLSTRUCTGETDATA($TCODEC, "MimeType"))
		$AINFO[$II][8] = DLLSTRUCTGETDATA($TCODEC, "Flags")
		$AINFO[$II][9] = DLLSTRUCTGETDATA($TCODEC, "Version")
		$AINFO[$II][10] = DLLSTRUCTGETDATA($TCODEC, "SigCount")
		$AINFO[$II][11] = DLLSTRUCTGETDATA($TCODEC, "SigSize")
		$AINFO[$II][12] = DLLSTRUCTGETDATA($TCODEC, "SigPattern")
		$AINFO[$II][13] = DLLSTRUCTGETDATA($TCODEC, "SigMask")
		$PBUFFER += DLLSTRUCTGETSIZE($TCODEC)
	NEXT
	RETURN $AINFO
ENDFUNC
FUNC _GDIPLUS_DECODERSGETCOUNT()
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageDecodersSize", "uint*", 0, "uint*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[1]
ENDFUNC
FUNC _GDIPLUS_DECODERSGETSIZE()
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageDecodersSize", "uint*", 0, "uint*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_DRAWIMAGEPOINTS($HGRAPHIC, $HIMAGE, $NULX, $NULY, $NURX, $NURY, $NLLX, $NLLY, $ICOUNT = 3)
	LOCAL $TPOINT = DLLSTRUCTCREATE("float X;float Y;float X2;float Y2;float X3;float Y3")
	DLLSTRUCTSETDATA($TPOINT, "X", $NULX)
	DLLSTRUCTSETDATA($TPOINT, "Y", $NULY)
	DLLSTRUCTSETDATA($TPOINT, "X2", $NURX)
	DLLSTRUCTSETDATA($TPOINT, "Y2", $NURY)
	DLLSTRUCTSETDATA($TPOINT, "X3", $NLLX)
	DLLSTRUCTSETDATA($TPOINT, "Y3", $NLLY)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawImagePoints", "handle", $HGRAPHIC, "handle", $HIMAGE, "struct*", $TPOINT, "int", $ICOUNT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_ENCODERS()
	LOCAL $ICOUNT = _GDIPLUS_ENCODERSGETCOUNT()
	LOCAL $ISIZE = _GDIPLUS_ENCODERSGETSIZE()
	LOCAL $TBUFFER = DLLSTRUCTCREATE("byte[" & $ISIZE & "]")
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageEncoders", "uint", $ICOUNT, "uint", $ISIZE, "struct*", $TBUFFER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	LOCAL $PBUFFER = DLLSTRUCTGETPTR($TBUFFER)
	LOCAL $TCODEC, $AINFO[$ICOUNT + 1][14]
	$AINFO[0][0] = $ICOUNT
	FOR $II = 1 TO $ICOUNT
		$TCODEC = DLLSTRUCTCREATE($TAGGDIPIMAGECODECINFO, $PBUFFER)
		$AINFO[$II][1] = _WINAPI_STRINGFROMGUID(DLLSTRUCTGETPTR($TCODEC, "CLSID"))
		$AINFO[$II][2] = _WINAPI_STRINGFROMGUID(DLLSTRUCTGETPTR($TCODEC, "FormatID"))
		$AINFO[$II][3] = _WINAPI_WIDECHARTOMULTIBYTE(DLLSTRUCTGETDATA($TCODEC, "CodecName"))
		$AINFO[$II][4] = _WINAPI_WIDECHARTOMULTIBYTE(DLLSTRUCTGETDATA($TCODEC, "DllName"))
		$AINFO[$II][5] = _WINAPI_WIDECHARTOMULTIBYTE(DLLSTRUCTGETDATA($TCODEC, "FormatDesc"))
		$AINFO[$II][6] = _WINAPI_WIDECHARTOMULTIBYTE(DLLSTRUCTGETDATA($TCODEC, "FileExt"))
		$AINFO[$II][7] = _WINAPI_WIDECHARTOMULTIBYTE(DLLSTRUCTGETDATA($TCODEC, "MimeType"))
		$AINFO[$II][8] = DLLSTRUCTGETDATA($TCODEC, "Flags")
		$AINFO[$II][9] = DLLSTRUCTGETDATA($TCODEC, "Version")
		$AINFO[$II][10] = DLLSTRUCTGETDATA($TCODEC, "SigCount")
		$AINFO[$II][11] = DLLSTRUCTGETDATA($TCODEC, "SigSize")
		$AINFO[$II][12] = DLLSTRUCTGETDATA($TCODEC, "SigPattern")
		$AINFO[$II][13] = DLLSTRUCTGETDATA($TCODEC, "SigMask")
		$PBUFFER += DLLSTRUCTGETSIZE($TCODEC)
	NEXT
	RETURN $AINFO
ENDFUNC
FUNC _GDIPLUS_ENCODERSGETCLSID($SFILEEXTENSION)
	LOCAL $AENCODERS = _GDIPLUS_ENCODERS()
	IF @ERROR THEN RETURN SETERROR(@ERROR, 0, "")
	FOR $II = 1 TO $AENCODERS[0][0]
		IF STRINGINSTR($AENCODERS[$II][6], "*." & $SFILEEXTENSION) > 0 THEN RETURN $AENCODERS[$II][1]
	NEXT
	RETURN SETERROR(-1, -1, "")
ENDFUNC
FUNC _GDIPLUS_ENCODERSGETCOUNT()
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[1]
ENDFUNC
FUNC _GDIPLUS_ENCODERSGETPARAMLIST($HIMAGE, $SENCODER)
	LOCAL $ISIZE = _GDIPLUS_ENCODERSGETPARAMLISTSIZE($HIMAGE, $SENCODER)
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	LOCAL $TGUID = _WINAPI_GUIDFROMSTRING($SENCODER)
	LOCAL $IREMAININGSIZE = $ISIZE - 4 - _GDIPLUS_PARAMSIZE()
	LOCAL $TBUFFER
	IF $IREMAININGSIZE THEN
		$TBUFFER = DLLSTRUCTCREATE("dword Count;" & $TAGGDIPENCODERPARAM & ";byte [" & $IREMAININGSIZE & "]")
	ELSE
		$TBUFFER = DLLSTRUCTCREATE("dword Count;" & $TAGGDIPENCODERPARAM)
	ENDIF
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetEncoderParameterList", "handle", $HIMAGE, "struct*", $TGUID, "uint", $ISIZE, "struct*", $TBUFFER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $TBUFFER
ENDFUNC
FUNC _GDIPLUS_ENCODERSGETPARAMLISTSIZE($HIMAGE, $SENCODER)
	LOCAL $TGUID = _WINAPI_GUIDFROMSTRING($SENCODER)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetEncoderParameterListSize", "handle", $HIMAGE, "struct*", $TGUID, "uint*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_ENCODERSGETSIZE()
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageEncodersSize", "uint*", 0, "uint*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_FONTCREATE($HFAMILY, $FSIZE, $ISTYLE = 0, $IUNIT = 3)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateFont", "handle", $HFAMILY, "float", $FSIZE, "int", $ISTYLE, "int", $IUNIT, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[5]
ENDFUNC
FUNC _GDIPLUS_FONTDISPOSE($HFONT)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDeleteFont", "handle", $HFONT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_FONTFAMILYCREATE($SFAMILY, $PCOLLECTION = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateFontFamilyFromName", "wstr", $SFAMILY, "ptr", $PCOLLECTION, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_FONTFAMILYCREATEFROMCOLLECTION($SFONTNAME, $HFONTCOLLECTION)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateFontFamilyFromName", "wstr", $SFONTNAME, "ptr", $HFONTCOLLECTION, "ptr*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], "")
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_FONTFAMILYDISPOSE($HFAMILY)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDeleteFontFamily", "handle", $HFAMILY)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_FONTFAMILYGETCELLASCENT($HFONTFAMILY, $ISTYLE = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetCellAscent", "handle", $HFONTFAMILY, "int", $ISTYLE, "ushort*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_FONTFAMILYGETCELLDESCENT($HFONTFAMILY, $ISTYLE = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetCellDescent", "handle", $HFONTFAMILY, "int", $ISTYLE, "ushort*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_FONTFAMILYGETEMHEIGHT($HFONTFAMILY, $ISTYLE = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetEmHeight", "handle", $HFONTFAMILY, "int", $ISTYLE, "ushort*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_FONTFAMILYGETLINESPACING($HFONTFAMILY, $ISTYLE = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetLineSpacing", "handle", $HFONTFAMILY, "int", $ISTYLE, "ushort*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_FONTGETHEIGHT($HFONT, $HGRAPHICS)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetFontHeight", "handle", $HFONT, "handle", $HGRAPHICS, "float*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_FONTPRIVATEADDFONT($HFONTCOLLECTION, $SFONTFILE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipPrivateAddFontFile", "ptr", $HFONTCOLLECTION, "wstr", $SFONTFILE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_FONTPRIVATEADDMEMORYFONT($HFONTCOLLECTION, $TFONT)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipPrivateAddMemoryFont", "handle", $HFONTCOLLECTION, "struct*", $TFONT, "int", DLLSTRUCTGETSIZE($TFONT))
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_FONTPRIVATECOLLECTIONDISPOSE($HFONTCOLLECTION)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDeletePrivateFontCollection", "handle*", $HFONTCOLLECTION)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_FONTPRIVATECREATECOLLECTION()
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipNewPrivateFontCollection", "ptr*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[1]
ENDFUNC
FUNC _GDIPLUS_GRAPHICSCLEAR($HGRAPHICS, $IARGB = -16777216)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGraphicsClear", "handle", $HGRAPHICS, "dword", $IARGB)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSCREATEFROMHDC($HDC)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateFromHDC", "handle", $HDC, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_GRAPHICSCREATEFROMHWND($HWND)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateFromHWND", "hwnd", $HWND, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDISPOSE($HGRAPHICS)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDeleteGraphics", "handle", $HGRAPHICS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWARC($HGRAPHICS, $NX, $NY, $NWIDTH, $NHEIGHT, $FSTARTANGLE, $FSWEEPANGLE, $HPEN = 0)
	__GDIPLUS_PENDEFCREATE($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawArc", "handle", $HGRAPHICS, "handle", $HPEN, "float", $NX, "float", $NY, "float", $NWIDTH, "float", $NHEIGHT, "float", $FSTARTANGLE, "float", $FSWEEPANGLE)
	__GDIPLUS_PENDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWBEZIER($HGRAPHICS, $NX1, $NY1, $NX2, $NY2, $NX3, $NY3, $NX4, $NY4, $HPEN = 0)
	__GDIPLUS_PENDEFCREATE($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawBezier", "handle", $HGRAPHICS, "handle", $HPEN, "float", $NX1, "float", $NY1, "float", $NX2, "float", $NY2, "float", $NX3, "float", $NY3, "float", $NX4, "float", $NY4)
	__GDIPLUS_PENDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWCLOSEDCURVE($HGRAPHICS, $APOINTS, $HPEN = 0)
	LOCAL $ICOUNT = $APOINTS[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	__GDIPLUS_PENDEFCREATE($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawClosedCurve", "handle", $HGRAPHICS, "handle", $HPEN, "struct*", $TPOINTS, "int", $ICOUNT)
	__GDIPLUS_PENDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWCLOSEDCURVE2($HGRAPHICS, $APOINTS, $NTENSION, $HPEN = 0)
	LOCAL $II, $ICOUNT, $TPOINTS, $ARESULT
	__GDIPLUS_PENDEFCREATE($HPEN)
	$ICOUNT = $APOINTS[0][0]
	$TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	$ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawClosedCurve2", "handle", $HGRAPHICS, "handle", $HPEN, "struct*", $TPOINTS, "int", $ICOUNT, "float", $NTENSION)
	__GDIPLUS_PENDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWCURVE($HGRAPHICS, $APOINTS, $HPEN = 0)
	LOCAL $ICOUNT = $APOINTS[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	__GDIPLUS_PENDEFCREATE($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawCurve", "handle", $HGRAPHICS, "handle", $HPEN, "struct*", $TPOINTS, "int", $ICOUNT)
	__GDIPLUS_PENDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWCURVE2($HGRAPHICS, $APOINTS, $NTENSION, $HPEN = 0)
	LOCAL $II, $ICOUNT, $TPOINTS, $ARESULT
	__GDIPLUS_PENDEFCREATE($HPEN)
	$ICOUNT = $APOINTS[0][0]
	$TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	$ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawCurve2", "handle", $HGRAPHICS, "handle", $HPEN, "struct*", $TPOINTS, "int", $ICOUNT, "float", $NTENSION)
	__GDIPLUS_PENDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWELLIPSE($HGRAPHICS, $NX, $NY, $NWIDTH, $NHEIGHT, $HPEN = 0)
	__GDIPLUS_PENDEFCREATE($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawEllipse", "handle", $HGRAPHICS, "handle", $HPEN, "float", $NX, "float", $NY, "float", $NWIDTH, "float", $NHEIGHT)
	__GDIPLUS_PENDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWIMAGE($HGRAPHICS, $HIMAGE, $NX, $NY)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawImage", "handle", $HGRAPHICS, "handle", $HIMAGE, "float", $NX, "float", $NY)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWIMAGEPOINTSRECT($HGRAPHICS, $HIMAGE, $NULX, $NULY, $NURX, $NURY, $NLLX, $NLLY, $NSRCX, $NSRCY, $NSRCWIDTH, $NSRCHEIGHT, $HIMAGEATTRIBUTES = 0, $IUNIT = 2)
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float X; float Y; float X2; float Y2; float X3; float Y3;")
	DLLSTRUCTSETDATA($TPOINTS, "X", $NULX)
	DLLSTRUCTSETDATA($TPOINTS, "Y", $NULY)
	DLLSTRUCTSETDATA($TPOINTS, "X2", $NURX)
	DLLSTRUCTSETDATA($TPOINTS, "Y2", $NURY)
	DLLSTRUCTSETDATA($TPOINTS, "X3", $NLLX)
	DLLSTRUCTSETDATA($TPOINTS, "Y3", $NLLY)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawImagePointsRect", "handle", $HGRAPHICS, "handle", $HIMAGE, "struct*", $TPOINTS, "int", 3, "float", $NSRCX, "float", $NSRCY, "float", $NSRCWIDTH, "float", $NSRCHEIGHT, "int", $IUNIT, "handle", $HIMAGEATTRIBUTES, "ptr", 0, "ptr", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWIMAGERECT($HGRAPHICS, $HIMAGE, $NX, $NY, $NW, $NH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawImageRect", "handle", $HGRAPHICS, "handle", $HIMAGE, "float", $NX, "float", $NY, "float", $NW, "float", $NH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWIMAGERECTRECT($HGRAPHICS, $HIMAGE, $NSRCX, $NSRCY, $NSRCWIDTH, $NSRCHEIGHT, $NDSTX, $NDSTY, $NDSTWIDTH, $NDSTHEIGHT, $PATTRIBUTES = 0, $IUNIT = 2)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawImageRectRect", "handle", $HGRAPHICS, "handle", $HIMAGE, "float", $NDSTX, "float", $NDSTY, "float", $NDSTWIDTH, "float", $NDSTHEIGHT, "float", $NSRCX, "float", $NSRCY, "float", $NSRCWIDTH, "float", $NSRCHEIGHT, "int", $IUNIT, "handle", $PATTRIBUTES, "ptr", 0, "ptr", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWLINE($HGRAPHICS, $NX1, $NY1, $NX2, $NY2, $HPEN = 0)
	__GDIPLUS_PENDEFCREATE($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawLine", "handle", $HGRAPHICS, "handle", $HPEN, "float", $NX1, "float", $NY1, "float", $NX2, "float", $NY2)
	__GDIPLUS_PENDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWPATH($HGRAPHICS, $HPATH, $HPEN = 0)
	__GDIPLUS_PENDEFCREATE($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawPath", "handle", $HGRAPHICS, "handle", $HPEN, "handle", $HPATH)
	__GDIPLUS_PENDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWPIE($HGRAPHICS, $NX, $NY, $NWIDTH, $NHEIGHT, $FSTARTANGLE, $FSWEEPANGLE, $HPEN = 0)
	__GDIPLUS_PENDEFCREATE($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawPie", "handle", $HGRAPHICS, "handle", $HPEN, "float", $NX, "float", $NY, "float", $NWIDTH, "float", $NHEIGHT, "float", $FSTARTANGLE, "float", $FSWEEPANGLE)
	__GDIPLUS_PENDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWPOLYGON($HGRAPHICS, $APOINTS, $HPEN = 0)
	LOCAL $ICOUNT = $APOINTS[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	__GDIPLUS_PENDEFCREATE($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawPolygon", "handle", $HGRAPHICS, "handle", $HPEN, "struct*", $TPOINTS, "int", $ICOUNT)
	__GDIPLUS_PENDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWRECT($HGRAPHICS, $NX, $NY, $NWIDTH, $NHEIGHT, $HPEN = 0)
	__GDIPLUS_PENDEFCREATE($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawRectangle", "handle", $HGRAPHICS, "handle", $HPEN, "float", $NX, "float", $NY, "float", $NWIDTH, "float", $NHEIGHT)
	__GDIPLUS_PENDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWSTRING($HGRAPHICS, $SSTRING, $NX, $NY, $SFONT = "Arial", $FSIZE = 10, $IFORMAT = 0)
	LOCAL $HBRUSH = _GDIPLUS_BRUSHCREATESOLID()
	LOCAL $HFORMAT = _GDIPLUS_STRINGFORMATCREATE($IFORMAT)
	LOCAL $HFAMILY = _GDIPLUS_FONTFAMILYCREATE($SFONT)
	LOCAL $HFONT = _GDIPLUS_FONTCREATE($HFAMILY, $FSIZE)
	LOCAL $TLAYOUT = _GDIPLUS_RECTFCREATE($NX, $NY, 0, 0)
	LOCAL $AINFO = _GDIPLUS_GRAPHICSMEASURESTRING($HGRAPHICS, $SSTRING, $HFONT, $TLAYOUT, $HFORMAT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	LOCAL $ARESULT = _GDIPLUS_GRAPHICSDRAWSTRINGEX($HGRAPHICS, $SSTRING, $HFONT, $AINFO[0], $HFORMAT, $HBRUSH)
	LOCAL $IERROR = @ERROR, $IEXTENDED = @EXTENDED
	_GDIPLUS_FONTDISPOSE($HFONT)
	_GDIPLUS_FONTFAMILYDISPOSE($HFAMILY)
	_GDIPLUS_STRINGFORMATDISPOSE($HFORMAT)
	_GDIPLUS_BRUSHDISPOSE($HBRUSH)
	RETURN SETERROR($IERROR, $IEXTENDED, $ARESULT)
ENDFUNC
FUNC _GDIPLUS_GRAPHICSDRAWSTRINGEX($HGRAPHICS, $SSTRING, $HFONT, $TLAYOUT, $HFORMAT, $HBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawString", "handle", $HGRAPHICS, "wstr", $SSTRING, "int", -1, "handle", $HFONT, "struct*", $TLAYOUT, "handle", $HFORMAT, "handle", $HBRUSH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSFILLCLOSEDCURVE($HGRAPHICS, $APOINTS, $HBRUSH = 0)
	LOCAL $ICOUNT = $APOINTS[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	__GDIPLUS_BRUSHDEFCREATE($HBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipFillClosedCurve", "handle", $HGRAPHICS, "handle", $HBRUSH, "struct*", $TPOINTS, "int", $ICOUNT)
	__GDIPLUS_BRUSHDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSFILLCLOSEDCURVE2($HGRAPHICS, $APOINTS, $NTENSION, $HBRUSH = 0, $IFILLMODE = 0)
	LOCAL $II, $ICOUNT, $TPOINTS, $ARESULT
	__GDIPLUS_BRUSHDEFCREATE($HBRUSH)
	$ICOUNT = $APOINTS[0][0]
	$TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	$ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipFillClosedCurve2", "handle", $HGRAPHICS, "handle", $HBRUSH, "struct*", $TPOINTS, "int", $ICOUNT, "float", $NTENSION, "int", $IFILLMODE)
	__GDIPLUS_BRUSHDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSFILLELLIPSE($HGRAPHICS, $NX, $NY, $NWIDTH, $NHEIGHT, $HBRUSH = 0)
	__GDIPLUS_BRUSHDEFCREATE($HBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipFillEllipse", "handle", $HGRAPHICS, "handle", $HBRUSH, "float", $NX, "float", $NY, "float", $NWIDTH, "float", $NHEIGHT)
	__GDIPLUS_BRUSHDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSFILLPATH($HGRAPHICS, $HPATH, $HBRUSH = 0)
	__GDIPLUS_BRUSHDEFCREATE($HBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipFillPath", "handle", $HGRAPHICS, "handle", $HBRUSH, "handle", $HPATH)
	__GDIPLUS_BRUSHDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSFILLPIE($HGRAPHICS, $NX, $NY, $NWIDTH, $NHEIGHT, $FSTARTANGLE, $FSWEEPANGLE, $HBRUSH = 0)
	__GDIPLUS_BRUSHDEFCREATE($HBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipFillPie", "handle", $HGRAPHICS, "handle", $HBRUSH, "float", $NX, "float", $NY, "float", $NWIDTH, "float", $NHEIGHT, "float", $FSTARTANGLE, "float", $FSWEEPANGLE)
	__GDIPLUS_BRUSHDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSFILLPOLYGON($HGRAPHICS, $APOINTS, $HBRUSH = 0)
	LOCAL $ICOUNT = $APOINTS[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	__GDIPLUS_BRUSHDEFCREATE($HBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipFillPolygon", "handle", $HGRAPHICS, "handle", $HBRUSH, "struct*", $TPOINTS, "int", $ICOUNT, "int", "FillModeAlternate")
	__GDIPLUS_BRUSHDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSFILLRECT($HGRAPHICS, $NX, $NY, $NWIDTH, $NHEIGHT, $HBRUSH = 0)
	__GDIPLUS_BRUSHDEFCREATE($HBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipFillRectangle", "handle", $HGRAPHICS, "handle", $HBRUSH, "float", $NX, "float", $NY, "float", $NWIDTH, "float", $NHEIGHT)
	__GDIPLUS_BRUSHDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSFILLREGION($HGRAPHICS, $HREGION, $HBRUSH = 0)
	__GDIPLUS_BRUSHDEFCREATE($HBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipFillRegion", "handle", $HGRAPHICS, "handle", $HBRUSH, "handle", $HREGION)
	__GDIPLUS_BRUSHDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSGETCOMPOSITINGMODE($HGRAPHICS)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetCompositingMode", "handle", $HGRAPHICS, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_GRAPHICSGETCOMPOSITINGQUALITY($HGRAPHICS)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetCompositingQuality", "handle", $HGRAPHICS, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_GRAPHICSGETDC($HGRAPHICS)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetDC", "handle", $HGRAPHICS, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_GRAPHICSGETINTERPOLATIONMODE($HGRAPHICS)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetInterpolationMode", "handle", $HGRAPHICS, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_GRAPHICSGETSMOOTHINGMODE($HGRAPHICS)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetSmoothingMode", "handle", $HGRAPHICS, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	SWITCH $ARESULT[2]
		CASE $GDIP_SMOOTHINGMODE_NONE
			RETURN 0
		CASE $GDIP_SMOOTHINGMODE_HIGHQUALITY, $GDIP_SMOOTHINGMODE_ANTIALIAS8X4
			RETURN 1
		CASE $GDIP_SMOOTHINGMODE_ANTIALIAS8X8
			RETURN 2
		CASE ELSE
			RETURN 0
	ENDSWITCH
ENDFUNC
FUNC _GDIPLUS_GRAPHICSGETTRANSFORM($HGRAPHICS, $HMATRIX)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetWorldTransform", "handle", $HGRAPHICS, "handle", $HMATRIX)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSMEASURECHARACTERRANGES($HGRAPHICS, $SSTRING, $HFONT, $TLAYOUT, $HSTRINGFORMAT)
	LOCAL $ICOUNT = _GDIPLUS_STRINGFORMATGETMEASURABLECHARACTERRANGECOUNT($HSTRINGFORMAT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	LOCAL $TREGIONS = DLLSTRUCTCREATE("handle[" & $ICOUNT & "]")
	LOCAL $AREGIONS[$ICOUNT + 1] = [$ICOUNT]
	FOR $II = 1 TO $ICOUNT
		$AREGIONS[$II] = _GDIPLUS_REGIONCREATE()
		DLLSTRUCTSETDATA($TREGIONS, 1, $AREGIONS[$II], $II)
	NEXT
	DLLCALL($__G_HGDIPDLL, "int", "GdipMeasureCharacterRanges", "handle", $HGRAPHICS, "wstr", $SSTRING, "int", -1, "hwnd", $HFONT, "struct*", $TLAYOUT, "handle", $HSTRINGFORMAT, "int", $ICOUNT, "struct*", $TREGIONS)
	LOCAL $IERROR = @ERROR, $IEXTENDED = @EXTENDED
	IF $IERROR THEN
		FOR $II = 1 TO $ICOUNT
			_GDIPLUS_REGIONDISPOSE($AREGIONS[$II])
		NEXT
		RETURN SETERROR($IERROR + 10, $IEXTENDED, 0)
	ENDIF
	RETURN $AREGIONS
ENDFUNC
FUNC _GDIPLUS_GRAPHICSMEASURESTRING($HGRAPHICS, $SSTRING, $HFONT, $TLAYOUT, $HFORMAT)
	LOCAL $TRECTF = DLLSTRUCTCREATE($TAGGDIPRECTF)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipMeasureString", "handle", $HGRAPHICS, "wstr", $SSTRING, "int", -1, "handle", $HFONT, "struct*", $TLAYOUT, "handle", $HFORMAT, "struct*", $TRECTF, "int*", 0, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	LOCAL $AINFO[3]
	$AINFO[0] = $TRECTF
	$AINFO[1] = $ARESULT[8]
	$AINFO[2] = $ARESULT[9]
	RETURN $AINFO
ENDFUNC
FUNC _GDIPLUS_GRAPHICSRELEASEDC($HGRAPHICS, $HDC)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipReleaseDC", "handle", $HGRAPHICS, "handle", $HDC)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_GRAPHICSRESETCLIP($HGRAPHICS)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipResetClip", "handle", $HGRAPHICS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSRESETTRANSFORM($HGRAPHICS)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipResetWorldTransform", "handle", $HGRAPHICS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSRESTORE($HGRAPHICS, $ISTATE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipRestoreGraphics", "handle", $HGRAPHICS, "uint", $ISTATE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSROTATETRANSFORM($HGRAPHICS, $FANGLE, $IORDER = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipRotateWorldTransform", "handle", $HGRAPHICS, "float", $FANGLE, "int", $IORDER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSSAVE($HGRAPHICS)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSaveGraphics", "handle", $HGRAPHICS, "uint*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_GRAPHICSSCALETRANSFORM($HGRAPHICS, $FSCALEX, $FSCALEY, $IORDER = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipScaleWorldTransform", "handle", $HGRAPHICS, "float", $FSCALEX, "float", $FSCALEY, "int", $IORDER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSSETCLIPPATH($HGRAPHICS, $HPATH, $ICOMBINEMODE = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetClipPath", "handle", $HGRAPHICS, "handle", $HPATH, "int", $ICOMBINEMODE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSSETCLIPRECT($HGRAPHICS, $NX, $NY, $NWIDTH, $NHEIGHT, $ICOMBINEMODE = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetClipRect", "handle", $HGRAPHICS, "float", $NX, "float", $NY, "float", $NWIDTH, "float", $NHEIGHT, "int", $ICOMBINEMODE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSSETCLIPREGION($HGRAPHICS, $HREGION, $ICOMBINEMODE = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetClipRegion", "handle", $HGRAPHICS, "handle", $HREGION, "int", $ICOMBINEMODE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSSETCOMPOSITINGMODE($HGRAPHICS, $ICOMPOSITIONMODE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetCompositingMode", "handle", $HGRAPHICS, "int", $ICOMPOSITIONMODE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSSETCOMPOSITINGQUALITY($HGRAPHICS, $ICOMPOSITIONQUALITY)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetCompositingQuality", "handle", $HGRAPHICS, "int", $ICOMPOSITIONQUALITY)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSSETINTERPOLATIONMODE($HGRAPHICS, $IINTERPOLATIONMODE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetInterpolationMode", "handle", $HGRAPHICS, "int", $IINTERPOLATIONMODE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSSETPIXELOFFSETMODE($HGRAPHICS, $IPIXELOFFSETMODE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPixelOffsetMode", "handle", $HGRAPHICS, "int", $IPIXELOFFSETMODE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSSETSMOOTHINGMODE($HGRAPHICS, $ISMOOTH)
	IF $ISMOOTH < $GDIP_SMOOTHINGMODE_DEFAULT OR $ISMOOTH > $GDIP_SMOOTHINGMODE_ANTIALIAS8X8 THEN $ISMOOTH = $GDIP_SMOOTHINGMODE_DEFAULT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetSmoothingMode", "handle", $HGRAPHICS, "int", $ISMOOTH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSSETTEXTRENDERINGHINT($HGRAPHICS, $ITEXTRENDERINGHINT)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetTextRenderingHint", "handle", $HGRAPHICS, "int", $ITEXTRENDERINGHINT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSSETTRANSFORM($HGRAPHICS, $HMATRIX)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetWorldTransform", "handle", $HGRAPHICS, "handle", $HMATRIX)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSTRANSFORMPOINTS($HGRAPHICS, BYREF $APOINTS, $ICOORDSPACETO = 0, $ICOORDSPACEFROM = 1)
	LOCAL $ICOUNT = $APOINTS[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], ($II - 1) * 2 + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], ($II - 1) * 2 + 2)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipTransformPoints", "handle", $HGRAPHICS, "int", $ICOORDSPACETO, "int", $ICOORDSPACEFROM, "struct*", $TPOINTS, "int", $ICOUNT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	FOR $II = 1 TO $ICOUNT
		$APOINTS[$II][0] = DLLSTRUCTGETDATA($TPOINTS, 1, ($II - 1) * 2 + 1)
		$APOINTS[$II][1] = DLLSTRUCTGETDATA($TPOINTS, 1, ($II - 1) * 2 + 2)
	NEXT
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_GRAPHICSTRANSLATETRANSFORM($HGRAPHICS, $NDX, $NDY, $IORDER = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipTranslateWorldTransform", "handle", $HGRAPHICS, "float", $NDX, "float", $NDY, "int", $IORDER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_HATCHBRUSHCREATE($IHATCHSTYLE = 0, $IARGBFOREGROUND = -1, $IARGBBACKGROUND = -1)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateHatchBrush", "int", $IHATCHSTYLE, "uint", $IARGBFOREGROUND, "uint", $IARGBBACKGROUND, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[4]
ENDFUNC
FUNC _GDIPLUS_HICONCREATEFROMBITMAP($HBITMAP)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateHICONFromBitmap", "handle", $HBITMAP, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_IMAGEATTRIBUTESCREATE()
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateImageAttributes", "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[1]
ENDFUNC
FUNC _GDIPLUS_IMAGEATTRIBUTESDISPOSE($HIMAGEATTRIBUTES)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDisposeImageAttributes", "handle", $HIMAGEATTRIBUTES)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_IMAGEATTRIBUTESSETCOLORKEYS($HIMAGEATTRIBUTES, $ICOLORADJUSTTYPE = 0, $BENABLE = FALSE, $IARGBLOW = 0, $IARGBHIGH = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetImageAttributesColorKeys", "handle", $HIMAGEATTRIBUTES, "int", $ICOLORADJUSTTYPE, "int", $BENABLE, "uint", $IARGBLOW, "uint", $IARGBHIGH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_IMAGEATTRIBUTESSETCOLORMATRIX($HIMAGEATTRIBUTES, $ICOLORADJUSTTYPE = 0, $BENABLE = FALSE, $TCLRMATRIX = 0, $TGRAYMATRIX = 0, $ICOLORMATRIXFLAGS = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetImageAttributesColorMatrix", "handle", $HIMAGEATTRIBUTES, "int", $ICOLORADJUSTTYPE, "int", $BENABLE, "struct*", $TCLRMATRIX, "struct*", $TGRAYMATRIX, "int", $ICOLORMATRIXFLAGS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_IMAGEATTRIBUTESSETREMAPTABLE($HIMAGEATTRIBUTES, $ACOLORMAP = 0, $ICOLORADJUSTTYPE = 0, $BENABLE = TRUE)
	LOCAL $ARESULT
	IF ISARRAY($ACOLORMAP) THEN
		LOCAL $ICOUNT = $ACOLORMAP[0][0]
		LOCAL $TCOLORMAP = DLLSTRUCTCREATE("uint[" & $ICOUNT * 2 & "]")
		FOR $I = 1 TO $ICOUNT
			DLLSTRUCTSETDATA($TCOLORMAP, 1, $ACOLORMAP[$I][0], ($I - 1) * 2 + 1)
			DLLSTRUCTSETDATA($TCOLORMAP, 1, $ACOLORMAP[$I][1], ($I - 1) * 2 + 2)
		NEXT
		$ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetImageAttributesRemapTable", "handle", $HIMAGEATTRIBUTES, "int", $ICOLORADJUSTTYPE, "int", $BENABLE, "int", $ICOUNT, "struct*", $TCOLORMAP)
	ELSE
		$ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetImageAttributesRemapTable", "handle", $HIMAGEATTRIBUTES, "int", $ICOLORADJUSTTYPE, "int", $BENABLE, "int", 0, "struct*", 0)
	ENDIF
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_IMAGEATTRIBUTESSETTHRESHOLD($HIMAGEATTRIBUTES, $FTHRESHOLD, $ICOLORADJUSTTYPE = $GDIP_COLORADJUSTTYPE_DEFAULT, $BENABLE = TRUE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetImageAttributesThreshold", "handle", $HIMAGEATTRIBUTES, "int", $ICOLORADJUSTTYPE, "bool", $BENABLE, "float", $FTHRESHOLD)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_IMAGECLONE($HIMAGE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCloneImage", "handle", $HIMAGE, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_IMAGEDISPOSE($HIMAGE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDisposeImage", "handle", $HIMAGE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_IMAGEGETDIMENSION($HIMAGE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageDimension", "handle", $HIMAGE, "float*", 0, "float*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	LOCAL $AIMGDIM[2] = [$ARESULT[2], $ARESULT[3]]
	RETURN $AIMGDIM
ENDFUNC
FUNC _GDIPLUS_IMAGEGETFLAGS($HIMAGE)
	LOCAL $AFLAG[2] = [0, ""]
	IF($HIMAGE = -1) OR(NOT $HIMAGE) THEN RETURN SETERROR(11, 0, $AFLAG)
	LOCAL $AIMAGEFLAGS[13][2] = [["Pixel data Cacheable", $GDIP_IMAGEFLAGS_CACHING], ["Pixel data read-only", $GDIP_IMAGEFLAGS_READONLY], ["Pixel size in image", $GDIP_IMAGEFLAGS_HASREALPIXELSIZE], ["DPI info in image", $GDIP_IMAGEFLAGS_HASREALDPI], ["YCCK color space", $GDIP_IMAGEFLAGS_COLORSPACE_YCCK], ["YCBCR color space", $GDIP_IMAGEFLAGS_COLORSPACE_YCBCR], ["Grayscale image", $GDIP_IMAGEFLAGS_COLORSPACE_GRAY], ["CMYK color space", $GDIP_IMAGEFLAGS_COLORSPACE_CMYK], ["RGB color space", $GDIP_IMAGEFLAGS_COLORSPACE_RGB], ["Partially scalable", $GDIP_IMAGEFLAGS_PARTIALLYSCALABLE], ["Alpha values other than 0 (transparent) and 255 (opaque)", $GDIP_IMAGEFLAGS_HASTRANSLUCENT], ["Alpha values", $GDIP_IMAGEFLAGS_HASALPHA], ["Scalable", $GDIP_IMAGEFLAGS_SCALABLE]]
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageFlags", "handle", $HIMAGE, "long*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, $AFLAG)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], $AFLAG)
	IF $ARESULT[2] = $GDIP_IMAGEFLAGS_NONE THEN
		$AFLAG[1] = "No pixel data"
		RETURN SETERROR(12, $ARESULT[2], $AFLAG)
	ENDIF
	$AFLAG[0] = $ARESULT[2]
	FOR $I = 0 TO 12
		IF BITAND($ARESULT[2], $AIMAGEFLAGS[$I][1]) = $AIMAGEFLAGS[$I][1] THEN
			IF STRINGLEN($AFLAG[1]) THEN $AFLAG[1] &= "|"
			$ARESULT[2] -= $AIMAGEFLAGS[$I][1]
			$AFLAG[1] &= $AIMAGEFLAGS[$I][0]
		ENDIF
	NEXT
	RETURN $AFLAG
ENDFUNC
FUNC _GDIPLUS_IMAGEGETFRAMECOUNT($HIMAGE, $SDIMENSIONID)
	LOCAL $TGUID = _WINAPI_GUIDFROMSTRING($SDIMENSIONID)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipImageGetFrameCount", "handle", $HIMAGE, "struct*", $TGUID, "uint*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_IMAGEGETGRAPHICSCONTEXT($HIMAGE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageGraphicsContext", "handle", $HIMAGE, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_IMAGEGETHEIGHT($HIMAGE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageHeight", "handle", $HIMAGE, "uint*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_IMAGEGETHORIZONTALRESOLUTION($HIMAGE)
	IF($HIMAGE = -1) OR(NOT $HIMAGE) THEN RETURN SETERROR(11, 0, 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageHorizontalResolution", "handle", $HIMAGE, "float*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN ROUND($ARESULT[2])
ENDFUNC
FUNC _GDIPLUS_IMAGEGETPIXELFORMAT($HIMAGE)
	LOCAL $AFORMAT[2] = [0, ""]
	IF($HIMAGE = -1) OR(NOT $HIMAGE) THEN RETURN SETERROR(11, 0, $AFORMAT)
	LOCAL $APIXELFORMAT[14][2] = [["1 Bpp Indexed", $GDIP_PXF01INDEXED], ["4 Bpp Indexed", $GDIP_PXF04INDEXED], ["8 Bpp Indexed", $GDIP_PXF08INDEXED], ["16 Bpp Grayscale", $GDIP_PXF16GRAYSCALE], ["16 Bpp RGB 555", $GDIP_PXF16RGB555], ["16 Bpp RGB 565", $GDIP_PXF16RGB565], ["16 Bpp ARGB 1555", $GDIP_PXF16ARGB1555], ["24 Bpp RGB", $GDIP_PXF24RGB], ["32 Bpp RGB", $GDIP_PXF32RGB], ["32 Bpp ARGB", $GDIP_PXF32ARGB], ["32 Bpp PARGB", $GDIP_PXF32PARGB], ["48 Bpp RGB", $GDIP_PXF48RGB], ["64 Bpp ARGB", $GDIP_PXF64ARGB], ["64 Bpp PARGB", $GDIP_PXF64PARGB]]
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImagePixelFormat", "handle", $HIMAGE, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, $AFORMAT)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], $AFORMAT)
	FOR $I = 0 TO 13
		IF $APIXELFORMAT[$I][1] = $ARESULT[2] THEN
			$AFORMAT[0] = $APIXELFORMAT[$I][1]
			$AFORMAT[1] = $APIXELFORMAT[$I][0]
			RETURN $AFORMAT
		ENDIF
	NEXT
	RETURN SETERROR(12, 0, $AFORMAT)
ENDFUNC
FUNC __GDIPLUS_IMAGEGETPROPERTYCOUNT($HIMAGE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPropertyCount", "handle", $HIMAGE, "uint*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_IMAGEGETPROPERTYIDLIST($HIMAGE)
	LOCAL $ICOUNT = __GDIPLUS_IMAGEGETPROPERTYCOUNT($HIMAGE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	LOCAL $TPROPERTIES = DLLSTRUCTCREATE("uint[" & $ICOUNT & "]")
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPropertyIdList", "handle", $HIMAGE, "int", $ICOUNT, "struct*", $TPROPERTIES)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	LOCAL $SPROPERTYTAGINFO = "0x0000=GpsVer;0x0001=GpsLatitudeRef;0x0002=GpsLatitude;0x0003=GpsLongitudeRef;0x0004=GpsLongitude;0x0005=GpsAltitudeRef;0x0006=GpsAltitude;0x0007=GpsGpsTime;0x0008=GpsGpsSatellites;0x0009=GpsGpsStatus;0x000A=GpsGpsMeasureMode;0x000B=GpsGpsDop;0x000C=GpsSpeedRef;0x000D=GpsSpeed;0x000E=GpsTrackRef;0x000F=GpsTrack;0x0010=GpsImgDirRef;0x0011=GpsImgDir;0x0012=GpsMapDatum;0x0013=GpsDestLatRef;0x0014=GpsDestLat;0x0015=GpsDestLongRef;0x0016=GpsDestLong;0x0017=GpsDestBearRef;0x0018=GpsDestBear;0x0019=GpsDestDistRef;0x001A=GpsDestDist;0x00FE=NewSubfileType;0x00FF=SubfileType;0x0100=ImageWidth;0x0101=ImageHeight;0x0102=BitsPerSample;0x0103=Compression;0x0106=PhotometricInterp;0x0107=ThreshHolding;0x0108=CellWidth;0x0109=CellHeight;0x010A=FillOrder;0x010D=DocumentName;0x010E=ImageDescription;0x010F=EquipMake;0x0110=EquipModel;0x0111=StripOffsets;0x0112=Orientation;0x0115=SamplesPerPixel;0x0116=RowsPerStrip;0x0117=StripBytesCount;0x0118=MinSampleValue;0x0119=MaxSampleValue;0x011A=XResolution;0x011B=YResolution;0x011C=PlanarConfig;0x011D=PageName;0x011E=XPosition;0x011F=YPosition;0x0120=FreeOffset;0x0121=FreeByteCounts;0x0122=GrayResponseUnit;0x0123=GrayResponseCurve;0x0124=T4Option;0x0125=T6Option;0x0128=ResolutionUnit;0x0129=PageNumber;0x012D=TransferFunction;0x0131=SoftwareUsed;0x0132=DateTime;0x013B=Artist;0x013C=HostComputer;0x013D=Predictor;0x013E=WhitePoint;0x013F=PrimaryChromaticities;0x0140=ColorMap;0x0141=HalftoneHints;0x0142=TileWidth;0x0143=TileLength;0x0144=TileOffset;0x0145=TileByteCounts;0x014C=InkSet;0x014D=InkNames;0x014E=NumberOfInks;0x0150=DotRange;0x0151=TargetPrinter;0x0152=ExtraSamples;0x0153=SampleFormat;0x0154=SMinSampleValue;0x0155=SMaxSampleValue;0x0156=TransferRange;0x0200=JPEGProc;0x0201=JPEGInterFormat;0x0202=JPEGInterLength;0x0203=JPEGRestartInterval;0x0205=JPEGLosslessPredictors;0x0206=JPEGPointTransforms;0x0207=JPEGQTables;0x0208=JPEGDCTables;0x0209=JPEGACTables;0x0211=YCbCrCoefficients;0x0212=YCbCrSubsampling;0x0213=YCbCrPositioning;0x0214=REFBlackWhite;0x0301=Gamma;0x0302=ICCProfileDescriptor;0x0303=SRGBRenderingIntent;0x0320=ImageTitle;0x5001=ResolutionXUnit;0x5002=ResolutionYUnit;0x5003=ResolutionXLengthUnit;0x5004=ResolutionYLengthUnit;0x5005=PrintFlags;0x5006=PrintFlagsVersion;0x5007=PrintFlagsCrop;0x5008=PrintFlagsBleedWidth;0x5009=PrintFlagsBleedWidthScale;0x500A=HalftoneLPI;0x500B=HalftoneLPIUnit;0x500C=HalftoneDegree;" &
	"0x500D=HalftoneShape;0x500E=HalftoneMisc;0x500F=HalftoneScreen;0x5010=JPEGQuality;0x5011=GridSize;0x5012=ThumbnailFormat;0x5013=ThumbnailWidth;0x5014=ThumbnailHeight;0x5015=ThumbnailColorDepth;0x5016=ThumbnailPlanes;0x5017=ThumbnailRawBytes;0x5018=ThumbnailSize;0x5019=ThumbnailCompressedSize;0x501A=ColorTransferFunction;0x501B=ThumbnailData;0x5020=ThumbnailImageWidth;0x5021=ThumbnailImageHeight;0x5022=ThumbnailBitsPerSample;0x5023=ThumbnailCompression;0x5024=ThumbnailPhotometricInterp;0x5025=ThumbnailImageDescription;0x5026=ThumbnailEquipMake;0x5027=ThumbnailEquipModel;0x5028=ThumbnailStripOffsets;0x5029=ThumbnailOrientation;0x502A=ThumbnailSamplesPerPixel;0x502B=ThumbnailRowsPerStrip;0x502C=ThumbnailStripBytesCount;0x502D=ThumbnailResolutionX;0x502E=ThumbnailResolutionY;0x502F=ThumbnailPlanarConfig;0x5030=ThumbnailResolutionUnit;0x5031=ThumbnailTransferFunction;0x5032=ThumbnailSoftwareUsed;0x5033=ThumbnailDateTime;0x5034=ThumbnailArtist;0x5035=ThumbnailWhitePoint;0x5036=ThumbnailPrimaryChromaticities;0x5037=ThumbnailYCbCrCoefficients;0x5038=ThumbnailYCbCrSubsampling;0x5039=ThumbnailYCbCrPositioning;0x503A=ThumbnailRefBlackWhite;0x503B=ThumbnailCopyRight;0x5090=LuminanceTable;0x5091=ChrominanceTable;0x5100=FrameDelay;0x5101=LoopCount;0x5102=GlobalPalette;0x5103=IndexBackground;0x5104=IndexTransparent;0x5110=PixelUnit;0x5111=PixelPerUnitX;0x5112=PixelPerUnitY;0x5113=PaletteHistogram;0x8298=Copyright;0x829A=ExifExposureTime;0x829D=ExifFNumber;0x8769=ExifIFD;0x8773=ICCProfile;0x8822=ExifExposureProg;0x8824=ExifSpectralSense;0x8825=GpsIFD;0x8827=ExifISOSpeed;0x8828=ExifOECF;0x9000=ExifVer;0x9003=ExifDTOrig;0x9004=ExifDTDigitized;0x9101=ExifCompConfig;0x9102=ExifCompBPP;0x9201=ExifShutterSpeed;0x9202=ExifAperture;0x9203=ExifBrightness;0x9204=ExifExposureBias;0x9205=ExifMaxAperture;0x9206=ExifSubjectDist;0x9207=ExifMeteringMode;0x9208=ExifLightSource;0x9209=ExifFlash;0x920A=ExifFocalLength;0x927C=ExifMakerNote;0x9286=ExifUserComment;0x9290=ExifDTSubsec;0x9291=ExifDTOrigSS;0x9292=ExifDTDigSS;0xA000=ExifFPXVer;0xA001=ExifColorSpace;0xA002=ExifPixXDim;0xA003=ExifPixYDim;0xA004=ExifRelatedWav;0xA005=ExifInterop;0xA20B=ExifFlashEnergy;0xA20C=ExifSpatialFR;0xA20E=ExifFocalXRes;0xA20F=ExifFocalYRes;0xA210=ExifFocalResUnit;0xA214=ExifSubjectLoc;0xA215=ExifExposureIndex;0xA217=ExifSensingMethod;0xA300=ExifFileSource;0xA301=ExifSceneType;0xA302=ExifCfaPattern"
	LOCAL $APROPERTIES[$ICOUNT + 1][2] = [[$ICOUNT]]
	LOCAL $AREGEXP
	FOR $I = 1 TO $ICOUNT
		$APROPERTIES[$I][0] = DLLSTRUCTGETDATA($TPROPERTIES, 1, $I)
		$AREGEXP = STRINGREGEXP($SPROPERTYTAGINFO, "(?i)" & HEX(DLLSTRUCTGETDATA($TPROPERTIES, 1, $I), 4) & "=(\w+)", 3)
		SWITCH ISARRAY($AREGEXP)
			CASE TRUE
				$APROPERTIES[$I][1] = $AREGEXP[0]
			CASE ELSE
				$APROPERTIES[$I][1] = "PropertyTagUnKnown"
		ENDSWITCH
	NEXT
	RETURN $APROPERTIES
ENDFUNC
FUNC __GDIPLUS_IMAGEGETPROPERTYITEMSIZE($HIMAGE, $IPROPID)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPropertyItemSize", "handle", $HIMAGE, "uint", $IPROPID, "uint*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_IMAGEGETPROPERTYITEM($HIMAGE, $IPROPID)
	LOCAL $ISIZE = __GDIPLUS_IMAGEGETPROPERTYITEMSIZE($HIMAGE, $IPROPID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	LOCAL $TBUFFER = DLLSTRUCTCREATE("byte[" & $ISIZE & "];")
	LOCAL $PBUFFER = DLLSTRUCTGETPTR($TBUFFER)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPropertyItem", "handle", $HIMAGE, "uint", $IPROPID, "uint", $ISIZE, "struct*", $TBUFFER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	LOCAL $TPROPERTYITEM = DLLSTRUCTCREATE("int id; int length; short type; ptr value;", $PBUFFER)
	LOCAL $IBYTES = DLLSTRUCTGETDATA($TPROPERTYITEM, "length")
	LOCAL $PVALUE = DLLSTRUCTGETDATA($TPROPERTYITEM, "value")
	LOCAL $TVALUES, $IVALUES
	SWITCH DLLSTRUCTGETDATA($TPROPERTYITEM, "type")
		CASE 2
			$IVALUES = 1
			$TVALUES = DLLSTRUCTCREATE("char[" & $IBYTES & "];", $PVALUE)
		CASE 3
			$IVALUES = INT($IBYTES / 2)
			$TVALUES = DLLSTRUCTCREATE("ushort[" & $IVALUES & "];", $PVALUE)
		CASE 4, 5
			$IVALUES = INT($IBYTES / 4)
			$TVALUES = DLLSTRUCTCREATE("uint[" & $IVALUES & "];", $PVALUE)
		CASE 9, 10
			$IVALUES = INT($IBYTES / 4)
			$TVALUES = DLLSTRUCTCREATE("int[" & $IVALUES & "];", $PVALUE)
		CASE ELSE
			$IVALUES = 1
			$TVALUES = DLLSTRUCTCREATE("byte[" & $IBYTES & "];", $PVALUE)
	ENDSWITCH
	LOCAL $AVALUES[$IVALUES + 1] = [$IVALUES]
	SWITCH DLLSTRUCTGETDATA($TPROPERTYITEM, "type")
		CASE 5, 10
			$IVALUES = INT($IVALUES / 2)
			REDIM $AVALUES[$IVALUES + 1]
			$AVALUES[0] = $IVALUES
			FOR $J = 1 TO $IVALUES
				$AVALUES[$J] = DLLSTRUCTGETDATA($TVALUES, 1, ($J - 1) * 2 + 1) / DLLSTRUCTGETDATA($TVALUES, 1, ($J - 1) * 2 + 2)
			NEXT
		CASE 3, 4, 9
			FOR $J = 1 TO $IVALUES
				$AVALUES[$J] = DLLSTRUCTGETDATA($TVALUES, 1, $J)
			NEXT
		CASE ELSE
			$AVALUES[1] = DLLSTRUCTGETDATA($TVALUES, 1)
	ENDSWITCH
	RETURN $AVALUES
ENDFUNC
FUNC _GDIPLUS_IMAGEGETRAWFORMAT($HIMAGE)
	LOCAL $AGUID[2]
	IF($HIMAGE = -1) OR(NOT $HIMAGE) THEN RETURN SETERROR(11, 0, $AGUID)
	LOCAL $AIMAGETYPE[11][2] = [["UNDEFINED", $GDIP_IMAGEFORMAT_UNDEFINED], ["MEMORYBMP", $GDIP_IMAGEFORMAT_MEMORYBMP], ["BMP", $GDIP_IMAGEFORMAT_BMP], ["EMF", $GDIP_IMAGEFORMAT_EMF], ["WMF", $GDIP_IMAGEFORMAT_WMF], ["JPEG", $GDIP_IMAGEFORMAT_JPEG], ["PNG", $GDIP_IMAGEFORMAT_PNG], ["GIF", $GDIP_IMAGEFORMAT_GIF], ["TIFF", $GDIP_IMAGEFORMAT_TIFF], ["EXIF", $GDIP_IMAGEFORMAT_EXIF], ["ICON", $GDIP_IMAGEFORMAT_ICON]]
	LOCAL $TSTRUCT = DLLSTRUCTCREATE("byte[16]")
	LOCAL $ARESULT1 = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageRawFormat", "handle", $HIMAGE, "struct*", $TSTRUCT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, $AGUID)
	IF $ARESULT1[0] THEN RETURN SETERROR(10, $ARESULT1[0], $AGUID)
	LOCAL $SRESULT2 = _WINAPI_STRINGFROMGUID($ARESULT1[2])
	IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, $AGUID)
	IF $SRESULT2 = "" THEN RETURN SETERROR(12, 0, $AGUID)
	FOR $I = 0 TO 10
		IF $AIMAGETYPE[$I][1] == $SRESULT2 THEN
			$AGUID[0] = $AIMAGETYPE[$I][1]
			$AGUID[1] = $AIMAGETYPE[$I][0]
			RETURN $AGUID
		ENDIF
	NEXT
	RETURN SETERROR(13, 0, $AGUID)
ENDFUNC
FUNC _GDIPLUS_IMAGEGETTHUMBNAIL($HIMAGE, $IWIDTH = 0, $IHEIGHT = 0, $BKEEPRATIO = TRUE, $HCALLBACK = NULL, $HCALLBACKDATA = NULL)
	IF $BKEEPRATIO THEN
		LOCAL $AIMGDIM = _GDIPLUS_IMAGEGETDIMENSION($HIMAGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, FALSE)
		LOCAL $F
		IF $IWIDTH < 1 OR $IHEIGHT < 1 THEN
			$IWIDTH = 0
			$IHEIGHT = 0
		ELSE
			IF($AIMGDIM[0] / $AIMGDIM[1]) > 1 THEN
				$F = $AIMGDIM[0] / $IWIDTH
			ELSE
				$F = $AIMGDIM[1] / $IHEIGHT
			ENDIF
			$IWIDTH = INT($AIMGDIM[0] / $F)
			$IHEIGHT = INT($AIMGDIM[1] / $F)
		ENDIF
	ENDIF
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageThumbnail", "handle", $HIMAGE, "uint", $IWIDTH, "uint", $IHEIGHT, "ptr*", 0, "ptr", $HCALLBACK, "ptr", $HCALLBACKDATA)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN $ARESULT[4]
ENDFUNC
FUNC _GDIPLUS_IMAGEGETTYPE($HIMAGE)
	IF($HIMAGE = -1) OR(NOT $HIMAGE) THEN RETURN SETERROR(11, 0, -1)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageType", "handle", $HIMAGE, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_IMAGEGETVERTICALRESOLUTION($HIMAGE)
	IF($HIMAGE = -1) OR(NOT $HIMAGE) THEN RETURN SETERROR(11, 0, 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageVerticalResolution", "handle", $HIMAGE, "float*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN ROUND($ARESULT[2])
ENDFUNC
FUNC _GDIPLUS_IMAGEGETWIDTH($HIMAGE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetImageWidth", "handle", $HIMAGE, "uint*", -1)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_IMAGELOADFROMFILE($SFILENAME)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipLoadImageFromFile", "wstr", $SFILENAME, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_IMAGELOADFROMSTREAM($PSTREAM)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipLoadImageFromStream", "ptr", $PSTREAM, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_IMAGEROTATEFLIP($HIMAGE, $IROTATEFLIPTYPE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipImageRotateFlip", "handle", $HIMAGE, "int", $IROTATEFLIPTYPE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_IMAGESAVEADD($HIMAGE, $TPARAMS)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSaveAdd", "handle", $HIMAGE, "struct*", $TPARAMS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_IMAGESAVEADDIMAGE($HIMAGE, $HIMAGENEW, $TPARAMS)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSaveAddImage", "handle", $HIMAGE, "handle", $HIMAGENEW, "struct*", $TPARAMS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_IMAGESAVETOFILE($HIMAGE, $SFILENAME)
	LOCAL $SEXT = __GDIPLUS_EXTRACTFILEEXT($SFILENAME)
	LOCAL $SCLSID = _GDIPLUS_ENCODERSGETCLSID($SEXT)
	IF $SCLSID = "" THEN RETURN SETERROR(-1, 0, FALSE)
	LOCAL $BRET = _GDIPLUS_IMAGESAVETOFILEEX($HIMAGE, $SFILENAME, $SCLSID, 0)
	RETURN SETERROR(@ERROR, @EXTENDED, $BRET)
ENDFUNC
FUNC _GDIPLUS_IMAGESAVETOFILEEX($HIMAGE, $SFILENAME, $SENCODER, $TPARAMS = 0)
	LOCAL $TGUID = _WINAPI_GUIDFROMSTRING($SENCODER)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSaveImageToFile", "handle", $HIMAGE, "wstr", $SFILENAME, "struct*", $TGUID, "struct*", $TPARAMS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_IMAGESAVETOSTREAM($HIMAGE, $PSTREAM, $TENCODER, $TPARAMS = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSaveImageToStream", "handle", $HIMAGE, "ptr", $PSTREAM, "struct*", $TENCODER, "struct*", $TPARAMS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_IMAGESCALE($HIMAGE, $ISCALEW, $ISCALEH, $IINTERPOLATIONMODE = $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
	LOCAL $IWIDTH = _GDIPLUS_IMAGEGETWIDTH($HIMAGE) * $ISCALEW
	IF @ERROR THEN RETURN SETERROR(1, 0, 0)
	LOCAL $IHEIGHT = _GDIPLUS_IMAGEGETHEIGHT($HIMAGE) * $ISCALEH
	IF @ERROR THEN RETURN SETERROR(2, 0, 0)
	LOCAL $HBITMAP = _GDIPLUS_BITMAPCREATEFROMSCAN0($IWIDTH, $IHEIGHT)
	IF @ERROR THEN RETURN SETERROR(3, 0, 0)
	LOCAL $HBMPCTXT = _GDIPLUS_IMAGEGETGRAPHICSCONTEXT($HBITMAP)
	IF @ERROR THEN
		_GDIPLUS_BITMAPDISPOSE($HBITMAP)
		RETURN SETERROR(4, 0, 0)
	ENDIF
	_GDIPLUS_GRAPHICSSETINTERPOLATIONMODE($HBMPCTXT, $IINTERPOLATIONMODE)
	IF @ERROR THEN
		_GDIPLUS_GRAPHICSDISPOSE($HBMPCTXT)
		_GDIPLUS_BITMAPDISPOSE($HBITMAP)
		RETURN SETERROR(5, 0, 0)
	ENDIF
	_GDIPLUS_GRAPHICSDRAWIMAGERECT($HBMPCTXT, $HIMAGE, 0, 0, $IWIDTH, $IHEIGHT)
	IF @ERROR THEN
		_GDIPLUS_GRAPHICSDISPOSE($HBMPCTXT)
		_GDIPLUS_BITMAPDISPOSE($HBITMAP)
		RETURN SETERROR(6, 0, 0)
	ENDIF
	_GDIPLUS_GRAPHICSDISPOSE($HBMPCTXT)
	RETURN $HBITMAP
ENDFUNC
FUNC _GDIPLUS_IMAGESELECTACTIVEFRAME($HIMAGE, $SDIMENSIONID, $IFRAMEINDEX)
	LOCAL $TGUID = _WINAPI_GUIDFROMSTRING($SDIMENSIONID)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipImageSelectActiveFrame", "handle", $HIMAGE, "struct*", $TGUID, "uint", $IFRAMEINDEX)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_IMAGERESIZE($HIMAGE, $INEWWIDTH, $INEWHEIGHT, $IINTERPOLATIONMODE = $GDIP_INTERPOLATIONMODE_HIGHQUALITYBICUBIC)
	LOCAL $HBITMAP = _GDIPLUS_BITMAPCREATEFROMSCAN0($INEWWIDTH, $INEWHEIGHT)
	IF @ERROR THEN RETURN SETERROR(1, 0, 0)
	LOCAL $HBMPCTXT = _GDIPLUS_IMAGEGETGRAPHICSCONTEXT($HBITMAP)
	IF @ERROR THEN
		_GDIPLUS_BITMAPDISPOSE($HBITMAP)
		RETURN SETERROR(2, @EXTENDED, 0)
	ENDIF
	_GDIPLUS_GRAPHICSSETINTERPOLATIONMODE($HBMPCTXT, $IINTERPOLATIONMODE)
	IF @ERROR THEN
		_GDIPLUS_GRAPHICSDISPOSE($HBMPCTXT)
		_GDIPLUS_BITMAPDISPOSE($HBITMAP)
		RETURN SETERROR(3, @EXTENDED, 0)
	ENDIF
	_GDIPLUS_GRAPHICSDRAWIMAGERECT($HBMPCTXT, $HIMAGE, 0, 0, $INEWWIDTH, $INEWHEIGHT)
	IF @ERROR THEN
		_GDIPLUS_GRAPHICSDISPOSE($HBMPCTXT)
		_GDIPLUS_BITMAPDISPOSE($HBITMAP)
		RETURN SETERROR(4, @EXTENDED, 0)
	ENDIF
	_GDIPLUS_GRAPHICSDISPOSE($HBMPCTXT)
	RETURN $HBITMAP
ENDFUNC
FUNC _GDIPLUS_LINEBRUSHCREATE($NX1, $NY1, $NX2, $NY2, $IARGBCLR1, $IARGBCLR2, $IWRAPMODE = 0)
	LOCAL $TPOINTF1, $TPOINTF2, $ARESULT
	$TPOINTF1 = DLLSTRUCTCREATE("float;float")
	$TPOINTF2 = DLLSTRUCTCREATE("float;float")
	DLLSTRUCTSETDATA($TPOINTF1, 1, $NX1)
	DLLSTRUCTSETDATA($TPOINTF1, 2, $NY1)
	DLLSTRUCTSETDATA($TPOINTF2, 1, $NX2)
	DLLSTRUCTSETDATA($TPOINTF2, 2, $NY2)
	$ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateLineBrush", "struct*", $TPOINTF1, "struct*", $TPOINTF2, "uint", $IARGBCLR1, "uint", $IARGBCLR2, "int", $IWRAPMODE, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[6]
ENDFUNC
FUNC _GDIPLUS_LINEBRUSHCREATEFROMRECT($TRECTF, $IARGBCLR1, $IARGBCLR2, $IGRADIENTMODE = 0, $IWRAPMODE = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateLineBrushFromRect", "struct*", $TRECTF, "uint", $IARGBCLR1, "uint", $IARGBCLR2, "int", $IGRADIENTMODE, "int", $IWRAPMODE, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[6]
ENDFUNC
FUNC _GDIPLUS_LINEBRUSHCREATEFROMRECTWITHANGLE($TRECTF, $IARGBCLR1, $IARGBCLR2, $FANGLE, $BISANGLESCALABLE = TRUE, $IWRAPMODE = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateLineBrushFromRectWithAngle", "struct*", $TRECTF, "uint", $IARGBCLR1, "uint", $IARGBCLR2, "float", $FANGLE, "int", $BISANGLESCALABLE, "int", $IWRAPMODE, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[7]
ENDFUNC
FUNC _GDIPLUS_LINEBRUSHGETCOLORS($HLINEGRADIENTBRUSH)
	LOCAL $TARGBS, $AARGBS[2], $ARESULT
	$TARGBS = DLLSTRUCTCREATE("uint;uint")
	$ARESULT = DLLCALL($__G_HGDIPDLL, "uint", "GdipGetLineColors", "handle", $HLINEGRADIENTBRUSH, "struct*", $TARGBS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	$AARGBS[0] = DLLSTRUCTGETDATA($TARGBS, 1)
	$AARGBS[1] = DLLSTRUCTGETDATA($TARGBS, 2)
	RETURN $AARGBS
ENDFUNC
FUNC _GDIPLUS_LINEBRUSHGETRECT($HLINEGRADIENTBRUSH)
	LOCAL $TRECTF = DLLSTRUCTCREATE($TAGGDIPRECTF)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetLineRect", "handle", $HLINEGRADIENTBRUSH, "struct*", $TRECTF)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	LOCAL $ARECTF[4]
	FOR $II = 1 TO 4
		$ARECTF[$II - 1] = DLLSTRUCTGETDATA($TRECTF, $II)
	NEXT
	RETURN $ARECTF
ENDFUNC
FUNC _GDIPLUS_LINEBRUSHMULTIPLYTRANSFORM($HLINEGRADIENTBRUSH, $HMATRIX, $IORDER = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipMultiplyLineTransform", "handle", $HLINEGRADIENTBRUSH, "handle", $HMATRIX, "int", $IORDER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_LINEBRUSHRESETTRANSFORM($HLINEGRADIENTBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipResetLineTransform", "handle", $HLINEGRADIENTBRUSH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_LINEBRUSHSETBLEND($HLINEGRADIENTBRUSH, $ABLENDS)
	LOCAL $II, $ICOUNT, $TFACTORS, $TPOSITIONS, $ARESULT
	$ICOUNT = $ABLENDS[0][0]
	$TFACTORS = DLLSTRUCTCREATE("float[" & $ICOUNT & "]")
	$TPOSITIONS = DLLSTRUCTCREATE("float[" & $ICOUNT & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TFACTORS, 1, $ABLENDS[$II][0], $II)
		DLLSTRUCTSETDATA($TPOSITIONS, 1, $ABLENDS[$II][1], $II)
	NEXT
	$ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetLineBlend", "handle", $HLINEGRADIENTBRUSH, "struct*", $TFACTORS, "struct*", $TPOSITIONS, "int", $ICOUNT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_LINEBRUSHSETCOLORS($HLINEGRADIENTBRUSH, $IARGBSTART, $IARGBEND)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetLineColors", "handle", $HLINEGRADIENTBRUSH, "uint", $IARGBSTART, "uint", $IARGBEND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_LINEBRUSHSETGAMMACORRECTION($HLINEGRADIENTBRUSH, $BUSEGAMMACORRECTION = TRUE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetLineGammaCorrection", "handle", $HLINEGRADIENTBRUSH, "int", $BUSEGAMMACORRECTION)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_LINEBRUSHSETLINEARBLEND($HLINEGRADIENTBRUSH, $FFOCUS, $FSCALE = 1)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetLineLinearBlend", "handle", $HLINEGRADIENTBRUSH, "float", $FFOCUS, "float", $FSCALE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_LINEBRUSHSETPRESETBLEND($HLINEGRADIENTBRUSH, $AINTERPOLATIONS)
	LOCAL $II, $ICOUNT, $TCOLORS, $TPOSITIONS, $ARESULT
	$ICOUNT = $AINTERPOLATIONS[0][0]
	$TCOLORS = DLLSTRUCTCREATE("uint[" & $ICOUNT & "]")
	$TPOSITIONS = DLLSTRUCTCREATE("float[" & $ICOUNT & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TCOLORS, 1, $AINTERPOLATIONS[$II][0], $II)
		DLLSTRUCTSETDATA($TPOSITIONS, 1, $AINTERPOLATIONS[$II][1], $II)
	NEXT
	$ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetLinePresetBlend", "handle", $HLINEGRADIENTBRUSH, "struct*", $TCOLORS, "struct*", $TPOSITIONS, "int", $ICOUNT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_LINEBRUSHSETSIGMABLEND($HLINEGRADIENTBRUSH, $FFOCUS, $FSCALE = 1)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetLineSigmaBlend", "handle", $HLINEGRADIENTBRUSH, "float", $FFOCUS, "float", $FSCALE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_LINEBRUSHSETTRANSFORM($HLINEGRADIENTBRUSH, $HMATRIX)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetLineTransform", "handle", $HLINEGRADIENTBRUSH, "handle", $HMATRIX)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_MATRIXCREATE()
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateMatrix", "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[1]
ENDFUNC
FUNC _GDIPLUS_MATRIXCREATE2($NM11 = 1, $NM12 = 1, $NM21 = 1, $NM22 = 1, $NDX = 0, $NDY = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateMatrix2", "float", $NM11, "float", $NM12, "float", $NM21, "float", $NM22, "float", $NDX, "float", $NDY, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[7]
ENDFUNC
FUNC _GDIPLUS_MATRIXCLONE($HMATRIX)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCloneMatrix", "handle", $HMATRIX, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_MATRIXDISPOSE($HMATRIX)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDeleteMatrix", "handle", $HMATRIX)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_MATRIXGETELEMENTS($HMATRIX)
	LOCAL $TELEMENTS = DLLSTRUCTCREATE("float[6]")
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetMatrixElements", "handle", $HMATRIX, "struct*", $TELEMENTS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	LOCAL $AELEMENTS[6]
	FOR $II = 1 TO 6
		$AELEMENTS[$II - 1] = DLLSTRUCTGETDATA($TELEMENTS, 1, $II)
	NEXT
	RETURN $AELEMENTS
ENDFUNC
FUNC _GDIPLUS_MATRIXINVERT($HMATRIX)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipInvertMatrix", "handle", $HMATRIX)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_MATRIXMULTIPLY($HMATRIX1, $HMATRIX2, $IORDER = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipMultiplyMatrix", "handle", $HMATRIX1, "handle", $HMATRIX2, "int", $IORDER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_MATRIXROTATE($HMATRIX, $FANGLE, $BAPPEND = FALSE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipRotateMatrix", "handle", $HMATRIX, "float", $FANGLE, "int", $BAPPEND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_MATRIXSCALE($HMATRIX, $FSCALEX, $FSCALEY, $BORDER = FALSE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipScaleMatrix", "handle", $HMATRIX, "float", $FSCALEX, "float", $FSCALEY, "int", $BORDER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_MATRIXSETELEMENTS($HMATRIX, $NM11 = 1, $NM12 = 0, $NM21 = 0, $NM22 = 1, $NDX = 0, $NDY = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetMatrixElements", "handle", $HMATRIX, "float", $NM11, "float", $NM12, "float", $NM21, "float", $NM22, "float", $NDX, "float", $NDY)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_MATRIXSHEAR($HMATRIX, $FSHEARX, $FSHEARY, $IORDER = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipShearMatrix", "handle", $HMATRIX, "float", $FSHEARX, "float", $FSHEARY, "int", $IORDER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_MATRIXTRANSFORMPOINTS($HMATRIX, BYREF $APOINTS)
	LOCAL $ICOUNT = $APOINTS[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], ($II - 1) * 2 + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], ($II - 1) * 2 + 2)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipTransformMatrixPoints", "handle", $HMATRIX, "struct*", $TPOINTS, "int", $ICOUNT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	FOR $II = 1 TO $ICOUNT
		$APOINTS[$II][0] = DLLSTRUCTGETDATA($TPOINTS, 1, ($II - 1) * 2 + 1)
		$APOINTS[$II][1] = DLLSTRUCTGETDATA($TPOINTS, 1, ($II - 1) * 2 + 2)
	NEXT
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_MATRIXTRANSLATE($HMATRIX, $FOFFSETX, $FOFFSETY, $BAPPEND = FALSE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipTranslateMatrix", "handle", $HMATRIX, "float", $FOFFSETX, "float", $FOFFSETY, "int", $BAPPEND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PARAMADD(BYREF $TPARAMS, $SGUID, $INBOFVALUES, $ITYPE, $PVALUES)
	LOCAL $ICOUNT = DLLSTRUCTGETDATA($TPARAMS, "Count")
	LOCAL $PGUID = DLLSTRUCTGETPTR($TPARAMS, "GUID") + ($ICOUNT * _GDIPLUS_PARAMSIZE())
	LOCAL $TPARAM = DLLSTRUCTCREATE($TAGGDIPENCODERPARAM, $PGUID)
	_WINAPI_GUIDFROMSTRINGEX($SGUID, $PGUID)
	DLLSTRUCTSETDATA($TPARAM, "Type", $ITYPE)
	DLLSTRUCTSETDATA($TPARAM, "NumberOfValues", $INBOFVALUES)
	DLLSTRUCTSETDATA($TPARAM, "Values", $PVALUES)
	DLLSTRUCTSETDATA($TPARAMS, "Count", $ICOUNT + 1)
ENDFUNC
FUNC _GDIPLUS_PARAMINIT($ICOUNT)
	LOCAL $SSTRUCT = $TAGGDIPENCODERPARAMS
	FOR $I = 2 TO $ICOUNT
		$SSTRUCT &= ";struct;byte[16];ulong;ulong;ptr;endstruct"
	NEXT
	RETURN DLLSTRUCTCREATE($SSTRUCT)
ENDFUNC
FUNC _GDIPLUS_PARAMSIZE()
	LOCAL $TPARAM = DLLSTRUCTCREATE($TAGGDIPENCODERPARAM)
	RETURN DLLSTRUCTGETSIZE($TPARAM)
ENDFUNC
FUNC _GDIPLUS_PATHADDARC($HPATH, $NX, $NY, $NWIDTH, $NHEIGHT, $FSTARTANGLE, $FSWEEPANGLE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipAddPathArc", "handle", $HPATH, "float", $NX, "float", $NY, "float", $NWIDTH, "float", $NHEIGHT, "float", $FSTARTANGLE, "float", $FSWEEPANGLE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHADDBEZIER($HPATH, $NX1, $NY1, $NX2, $NY2, $NX3, $NY3, $NX4, $NY4)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipAddPathBezier", "handle", $HPATH, "float", $NX1, "float", $NY1, "float", $NX2, "float", $NY2, "float", $NX3, "float", $NY3, "float", $NX4, "float", $NY4)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHADDCLOSEDCURVE($HPATH, $APOINTS)
	LOCAL $ICOUNT = $APOINTS[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipAddPathClosedCurve", "handle", $HPATH, "struct*", $TPOINTS, "int", $ICOUNT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHADDCLOSEDCURVE2($HPATH, $APOINTS, $NTENSION = 0.5)
	LOCAL $ICOUNT = $APOINTS[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipAddPathClosedCurve2", "handle", $HPATH, "struct*", $TPOINTS, "int", $ICOUNT, "float", $NTENSION)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHADDCURVE($HPATH, $APOINTS)
	LOCAL $ICOUNT = $APOINTS[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipAddPathCurve", "handle", $HPATH, "struct*", $TPOINTS, "int", $ICOUNT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHADDCURVE2($HPATH, $APOINTS, $NTENSION = 0.5)
	LOCAL $ICOUNT = $APOINTS[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipAddPathCurve2", "handle", $HPATH, "struct*", $TPOINTS, "int", $ICOUNT, "float", $NTENSION)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHADDCURVE3($HPATH, $APOINTS, $IOFFSET, $INUMOFSEGMENTS, $NTENSION = 0.5)
	LOCAL $ICOUNT = $APOINTS[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipAddPathCurve3", "handle", $HPATH, "struct*", $TPOINTS, "int", $ICOUNT, "int", $IOFFSET, "int", $INUMOFSEGMENTS, "float", $NTENSION)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHADDELLIPSE($HPATH, $NX, $NY, $NWIDTH, $NHEIGHT)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipAddPathEllipse", "handle", $HPATH, "float", $NX, "float", $NY, "float", $NWIDTH, "float", $NHEIGHT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHADDLINE($HPATH, $NX1, $NY1, $NX2, $NY2)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipAddPathLine", "handle", $HPATH, "float", $NX1, "float", $NY1, "float", $NX2, "float", $NY2)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHADDLINE2($HPATH, $APOINTS)
	LOCAL $ICOUNT = $APOINTS[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipAddPathLine2", "handle", $HPATH, "struct*", $TPOINTS, "int", $ICOUNT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHADDPATH($HPATH1, $HPATH2, $BCONNECT = TRUE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipAddPathPath", "handle", $HPATH1, "handle", $HPATH2, "int", $BCONNECT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHADDPIE($HPATH, $NX, $NY, $NWIDTH, $NHEIGHT, $FSTARTANGLE, $FSWEEPANGLE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipAddPathPie", "handle", $HPATH, "float", $NX, "float", $NY, "float", $NWIDTH, "float", $NHEIGHT, "float", $FSTARTANGLE, "float", $FSWEEPANGLE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHADDPOLYGON($HPATH, $APOINTS)
	LOCAL $ICOUNT = $APOINTS[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipAddPathPolygon", "handle", $HPATH, "struct*", $TPOINTS, "int", $ICOUNT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHADDRECTANGLE($HPATH, $NX, $NY, $NWIDTH, $NHEIGHT)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipAddPathRectangle", "handle", $HPATH, "float", $NX, "float", $NY, "float", $NWIDTH, "float", $NHEIGHT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHADDSTRING($HPATH, $SSTRING, $TLAYOUT, $HFAMILY, $ISTYLE = 0, $FSIZE = 8.5, $HFORMAT = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipAddPathString", "handle", $HPATH, "wstr", $SSTRING, "int", -1, "handle", $HFAMILY, "int", $ISTYLE, "float", $FSIZE, "struct*", $TLAYOUT, "handle", $HFORMAT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHCREATE($APOINTS, $IWRAPMODE = 0)
	LOCAL $ICOUNT = $APOINTS[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], (($II - 1) * 2) + 2)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreatePathGradient", "struct*", $TPOINTS, "int", $ICOUNT, "int", $IWRAPMODE, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[4]
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHCREATEFROMPATH($HPATH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreatePathGradientFromPath", "handle", $HPATH, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHGETCENTERPOINT($HPATHGRADIENTBRUSH)
	LOCAL $TPOINTF = DLLSTRUCTCREATE("float;float")
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPathGradientCenterPoint", "handle", $HPATHGRADIENTBRUSH, "struct*", $TPOINTF)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	LOCAL $APOINTF[2]
	$APOINTF[0] = DLLSTRUCTGETDATA($TPOINTF, 1)
	$APOINTF[1] = DLLSTRUCTGETDATA($TPOINTF, 2)
	RETURN $APOINTF
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHGETFOCUSSCALES($HPATHGRADIENTBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPathGradientFocusScales", "handle", $HPATHGRADIENTBRUSH, "float*", 0, "float*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	LOCAL $ASCALES[2]
	$ASCALES[0] = $ARESULT[2]
	$ASCALES[1] = $ARESULT[3]
	RETURN $ASCALES
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHGETPOINTCOUNT($HPATHGRADIENTBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPathGradientPointCount", "handle", $HPATHGRADIENTBRUSH, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHGETRECT($HPATHGRADIENTBRUSH)
	LOCAL $TRECTF = DLLSTRUCTCREATE($TAGGDIPRECTF)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPathGradientRect", "handle", $HPATHGRADIENTBRUSH, "struct*", $TRECTF)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	LOCAL $ARECTF[4]
	FOR $II = 1 TO 4
		$ARECTF[$II - 1] = DLLSTRUCTGETDATA($TRECTF, $II)
	NEXT
	RETURN $ARECTF
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHGETWRAPMODE($HPATHGRADIENTBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPathGradientWrapMode", "handle", $HPATHGRADIENTBRUSH, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHMULTIPLYTRANSFORM($HPATHGRADIENTBRUSH, $HMATRIX, $IORDER = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipMultiplyPathGradientTransform", "handle", $HPATHGRADIENTBRUSH, "handle", $HMATRIX, "int", $IORDER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHRESETTRANSFORM($HPATHGRADIENTBRUSH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipResetPathGradientTransform", "handle", $HPATHGRADIENTBRUSH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHSETBLEND($HPATHGRADIENTBRUSH, $ABLENDS)
	LOCAL $ICOUNT = $ABLENDS[0][0]
	LOCAL $TFACTORS = DLLSTRUCTCREATE("float[" & $ICOUNT & "]")
	LOCAL $TPOSITIONS = DLLSTRUCTCREATE("float[" & $ICOUNT & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TFACTORS, 1, $ABLENDS[$II][0], $II)
		DLLSTRUCTSETDATA($TPOSITIONS, 1, $ABLENDS[$II][1], $II)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPathGradientBlend", "handle", $HPATHGRADIENTBRUSH, "struct*", $TFACTORS, "struct*", $TPOSITIONS, "int", $ICOUNT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHSETCENTERCOLOR($HPATHGRADIENTBRUSH, $IARGB)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPathGradientCenterColor", "handle", $HPATHGRADIENTBRUSH, "uint", $IARGB)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHSETCENTERPOINT($HPATHGRADIENTBRUSH, $NX, $NY)
	LOCAL $TPOINTF = DLLSTRUCTCREATE("float;float")
	DLLSTRUCTSETDATA($TPOINTF, 1, $NX)
	DLLSTRUCTSETDATA($TPOINTF, 2, $NY)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPathGradientCenterPoint", "handle", $HPATHGRADIENTBRUSH, "struct*", $TPOINTF)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHSETFOCUSSCALES($HPATHGRADIENTBRUSH, $FSCALEX, $FSCALEY)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPathGradientFocusScales", "handle", $HPATHGRADIENTBRUSH, "float", $FSCALEX, "float", $FSCALEY)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHSETGAMMACORRECTION($HPATHGRADIENTBRUSH, $BUSEGAMMACORRECTION)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPathGradientGammaCorrection", "handle", $HPATHGRADIENTBRUSH, "int", $BUSEGAMMACORRECTION)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHSETLINEARBLEND($HPATHGRADIENTBRUSH, $FFOCUS, $FSCALE = 1)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPathGradientLinearBlend", "handle", $HPATHGRADIENTBRUSH, "float", $FFOCUS, "float", $FSCALE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHSETPRESETBLEND($HPATHGRADIENTBRUSH, $AINTERPOLATIONS)
	LOCAL $ICOUNT = $AINTERPOLATIONS[0][0]
	LOCAL $TCOLORS = DLLSTRUCTCREATE("uint[" & $ICOUNT & "]")
	LOCAL $TPOSITIONS = DLLSTRUCTCREATE("float[" & $ICOUNT & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TCOLORS, 1, $AINTERPOLATIONS[$II][0], $II)
		DLLSTRUCTSETDATA($TPOSITIONS, 1, $AINTERPOLATIONS[$II][1], $II)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPathGradientPresetBlend", "handle", $HPATHGRADIENTBRUSH, "struct*", $TCOLORS, "struct*", $TPOSITIONS, "int", $ICOUNT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHSETSIGMABLEND($HPATHGRADIENTBRUSH, $FFOCUS, $FSCALE = 1)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPathGradientSigmaBlend", "handle", $HPATHGRADIENTBRUSH, "float", $FFOCUS, "float", $FSCALE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHSETSURROUNDCOLOR($HPATHGRADIENTBRUSH, $IARGB)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPathGradientSurroundColorsWithCount", "handle", $HPATHGRADIENTBRUSH, "uint*", $IARGB, "int*", 1)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHSETSURROUNDCOLORSWITHCOUNT($HPATHGRADIENTBRUSH, $ACOLORS)
	LOCAL $ICOUNT = $ACOLORS[0]
	LOCAL $ICOLORS = _GDIPLUS_PATHBRUSHGETPOINTCOUNT($HPATHGRADIENTBRUSH)
	IF $ICOLORS < $ICOUNT THEN $ICOUNT = $ICOLORS
	LOCAL $TCOLORS = DLLSTRUCTCREATE("uint[" & $ICOUNT & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TCOLORS, 1, $ACOLORS[$II], $II)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPathGradientSurroundColorsWithCount", "handle", $HPATHGRADIENTBRUSH, "struct*", $TCOLORS, "int*", $ICOUNT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHSETTRANSFORM($HPATHGRADIENTBRUSH, $HMATRIX)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPathGradientTransform", "handle", $HPATHGRADIENTBRUSH, "handle", $HMATRIX)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHBRUSHSETWRAPMODE($HPATHGRADIENTBRUSH, $IWRAPMODE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPathGradientWrapMode", "handle", $HPATHGRADIENTBRUSH, "int", $IWRAPMODE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHCLONE($HPATH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipClonePath", "handle", $HPATH, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PATHCLOSEFIGURE($HPATH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipClosePathFigure", "handle", $HPATH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHCREATE($IFILLMODE = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreatePath", "int", $IFILLMODE, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PATHCREATE2($APATHDATA, $IFILLMODE = 0)
	LOCAL $ICOUNT = $APATHDATA[0][0]
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	LOCAL $TTYPES = DLLSTRUCTCREATE("byte[" & $ICOUNT & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APATHDATA[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APATHDATA[$II][1], (($II - 1) * 2) + 2)
		DLLSTRUCTSETDATA($TTYPES, 1, $APATHDATA[$II][2], $II)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreatePath2", "struct*", $TPOINTS, "struct*", $TTYPES, "int", $ICOUNT, "int", $IFILLMODE, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[5]
ENDFUNC
FUNC _GDIPLUS_PATHDISPOSE($HPATH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDeletePath", "handle", $HPATH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHFLATTEN($HPATH, $FFLATNESS = 0.25, $HMATRIX = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipFlattenPath", "handle", $HPATH, "handle", $HMATRIX, "float", $FFLATNESS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHGETDATA($HPATH)
	LOCAL $ICOUNT = _GDIPLUS_PATHGETPOINTCOUNT($HPATH)
	LOCAL $TPATHDATA = DLLSTRUCTCREATE("int Count; ptr Points; ptr Types;")
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	LOCAL $TTYPES = DLLSTRUCTCREATE("byte[" & $ICOUNT & "]")
	DLLSTRUCTSETDATA($TPATHDATA, "Count", $ICOUNT)
	DLLSTRUCTSETDATA($TPATHDATA, "Points", DLLSTRUCTGETPTR($TPOINTS))
	DLLSTRUCTSETDATA($TPATHDATA, "Types", DLLSTRUCTGETPTR($TTYPES))
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPathData", "handle", $HPATH, "struct*", $TPATHDATA)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR($ARESULT[0], $ARESULT[0], -1)
	LOCAL $ADATA[$ICOUNT + 1][3]
	$ADATA[0][0] = $ICOUNT
	FOR $II = 1 TO $ICOUNT
		$ADATA[$II][0] = DLLSTRUCTGETDATA($TPOINTS, 1, (($II - 1) * 2) + 1)
		$ADATA[$II][1] = DLLSTRUCTGETDATA($TPOINTS, 1, (($II - 1) * 2) + 2)
		$ADATA[$II][2] = DLLSTRUCTGETDATA($TTYPES, 1, $II)
	NEXT
	RETURN $ADATA
ENDFUNC
FUNC _GDIPLUS_PATHGETFILLMODE($HPATH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPathFillMode", "handle", $HPATH, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PATHGETLASTPOINT($HPATH)
	LOCAL $TPOINTF = DLLSTRUCTCREATE("float;float")
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPathLastPoint", "handle", $HPATH, "struct*", $TPOINTF)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	LOCAL $APOINTF[2]
	$APOINTF[0] = DLLSTRUCTGETDATA($TPOINTF, 1)
	$APOINTF[1] = DLLSTRUCTGETDATA($TPOINTF, 2)
	RETURN $APOINTF
ENDFUNC
FUNC _GDIPLUS_PATHGETPOINTCOUNT($HPATH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPointCount", "handle", $HPATH, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PATHGETPOINTS($HPATH)
	LOCAL $II, $ICOUNT, $TPOINTS, $APOINTS[1][1], $ARESULT
	$ICOUNT = _GDIPLUS_PATHGETPOINTCOUNT($HPATH)
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, -1)
	$TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	$ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPathPoints", "handle", $HPATH, "struct*", $TPOINTS, "int", $ICOUNT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	LOCAL $APOINTS[$ICOUNT + 1][2]
	$APOINTS[0][0] = $ICOUNT
	FOR $II = 1 TO $ICOUNT
		$APOINTS[$II][0] = DLLSTRUCTGETDATA($TPOINTS, 1, (($II - 1) * 2) + 1)
		$APOINTS[$II][1] = DLLSTRUCTGETDATA($TPOINTS, 1, (($II - 1) * 2) + 2)
	NEXT
	RETURN $APOINTS
ENDFUNC
FUNC _GDIPLUS_PATHGETWORLDBOUNDS($HPATH, $HMATRIX = 0, $HPEN = 0)
	LOCAL $TRECTF = DLLSTRUCTCREATE($TAGGDIPRECTF)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPathWorldBounds", "handle", $HPATH, "struct*", $TRECTF, "handle", $HMATRIX, "handle", $HPEN)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	LOCAL $ARECTF[4]
	FOR $II = 1 TO 4
		$ARECTF[$II - 1] = DLLSTRUCTGETDATA($TRECTF, $II)
	NEXT
	RETURN $ARECTF
ENDFUNC
FUNC _GDIPLUS_PATHISOUTLINEVISIBLEPOINT($HPATH, $NX, $NY, $HPEN = 0, $HGRAPHICS = 0)
	__GDIPLUS_PENDEFCREATE($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipIsOutlineVisiblePathPoint", "handle", $HPATH, "float", $NX, "float", $NY, "handle", $HPEN, "handle", $HGRAPHICS, "int*", 0)
	__GDIPLUS_PENDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN $ARESULT[6] <> 0
ENDFUNC
FUNC _GDIPLUS_PATHISVISIBLEPOINT($HPATH, $NX, $NY, $HGRAPHICS = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipIsVisiblePathPoint", "handle", $HPATH, "float", $NX, "float", $NY, "handle", $HGRAPHICS, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN $ARESULT[5] <> 0
ENDFUNC
FUNC _GDIPLUS_PATHITERCREATE($HPATH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreatePathIter", "handle*", 0, "handle", $HPATH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[1]
ENDFUNC
FUNC _GDIPLUS_PATHITERDISPOSE($HPATHITER)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDeletePathIter", "handle", $HPATHITER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHITERGETSUBPATHCOUNT($HPATHITER)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipPathIterGetSubpathCount", "handle", $HPATHITER, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PATHITERNEXTMARKERPATH($HPATHITER, $HPATH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipPathIterNextMarkerPath", "handle", $HPATHITER, "int*", 0, "handle", $HPATH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PATHITERNEXTSUBPATHPATH($HPATHITER, $HPATH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipPathIterNextSubpathPath", "handle", $HPATHITER, "int*", 0, "handle", $HPATH, "bool*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	LOCAL $ARETURN[2]
	$ARETURN[0] = $ARESULT[2]
	$ARETURN[1] = $ARESULT[4]
	RETURN $ARETURN
ENDFUNC
FUNC _GDIPLUS_PATHITERREWIND($HPATHITER)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipPathIterRewind", "handle", $HPATHITER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHRESET($HPATH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipResetPath", "handle", $HPATH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHREVERSE($HPATH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipReversePath", "handle", $HPATH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHSETFILLMODE($HPATH, $IFILLMODE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPathFillMode", "handle", $HPATH, "int", $IFILLMODE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHSETMARKER($HPATH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPathMarker", "handle", $HPATH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHSTARTFIGURE($HPATH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipStartPathFigure", "handle", $HPATH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHTRANSFORM($HPATH, $HMATRIX)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipTransformPath", "handle", $HPATH, "handle", $HMATRIX)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHWARP($HPATH, $HMATRIX, $APOINTS, $NX, $NY, $NWIDTH, $NHEIGHT, $IWARPMODE = 0, $FFLATNESS = 0.25)
	LOCAL $ICOUNT = $APOINTS[0][0]
	IF $ICOUNT <> 3 AND $ICOUNT <> 4 THEN RETURN SETERROR(11, 0, FALSE)
	LOCAL $TPOINTS = DLLSTRUCTCREATE("float[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][0], ($II - 1) * 2 + 1)
		DLLSTRUCTSETDATA($TPOINTS, 1, $APOINTS[$II][1], ($II - 1) * 2 + 2)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipWarpPath", "handle", $HPATH, "handle", $HMATRIX, "struct*", $TPOINTS, "int", $ICOUNT, "float", $NX, "float", $NY, "float", $NWIDTH, "float", $NHEIGHT, "int", $IWARPMODE, "float", $FFLATNESS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHWIDEN($HPATH, $HPEN, $HMATRIX = 0, $FFLATNESS = 0.25)
	__GDIPLUS_PENDEFCREATE($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipWidenPath", "handle", $HPATH, "handle", $HPEN, "handle", $HMATRIX, "float", $FFLATNESS)
	__GDIPLUS_PENDEFDISPOSE()
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PATHWINDINGMODEOUTLINE($HPATH, $HMATRIX = 0, $FFLATNESS = 0.25)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipWindingModeOutline", "handle", $HPATH, "handle", $HMATRIX, "float", $FFLATNESS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENCREATE($IARGB = -16777216, $NWIDTH = 1, $IUNIT = 2)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreatePen1", "dword", $IARGB, "float", $NWIDTH, "int", $IUNIT, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[4]
ENDFUNC
FUNC _GDIPLUS_PENCREATE2($HBRUSH, $NWIDTH = 1, $IUNIT = 2)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreatePen2", "handle", $HBRUSH, "float", $NWIDTH, "int", $IUNIT, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[4]
ENDFUNC
FUNC _GDIPLUS_PENDISPOSE($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDeletePen", "handle", $HPEN)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENGETALIGNMENT($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPenMode", "handle", $HPEN, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PENGETCOLOR($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPenColor", "handle", $HPEN, "dword*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PENGETCUSTOMENDCAP($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPenCustomEndCap", "handle", $HPEN, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PENGETDASHCAP($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPenDashCap197819", "handle", $HPEN, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PENGETDASHSTYLE($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPenDashStyle", "handle", $HPEN, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PENGETENDCAP($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPenEndCap", "handle", $HPEN, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PENGETMITERLIMIT($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPenMiterLimit", "handle", $HPEN, "float*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PENGETWIDTH($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetPenWidth", "handle", $HPEN, "float*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_PENRESETTRANSFORM($HPEN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipResetPenTransform", "handle", $HPEN)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENROTATETRANSFORM($HPEN, $FANGLE, $IORDER = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipRotatePenTransform", "handle", $HPEN, "float", $FANGLE, "int", $IORDER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENSCALETRANSFORM($HPEN, $FSCALEX, $FSCALEY, $IORDER = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipScalePenTransform", "handle", $HPEN, "float", $FSCALEX, "float", $FSCALEY, "int", $IORDER)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENSETALIGNMENT($HPEN, $IALIGNMENT = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPenMode", "handle", $HPEN, "int", $IALIGNMENT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENSETCOLOR($HPEN, $IARGB)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPenColor", "handle", $HPEN, "dword", $IARGB)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENSETCOMPOUND($HPEN, $ACOMPOUNDS)
	LOCAL $ICOUNT = $ACOMPOUNDS[0]
	LOCAL $TCOMPOUNDS = DLLSTRUCTCREATE("float[" & $ICOUNT & "];")
	FOR $I = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TCOMPOUNDS, 1, $ACOMPOUNDS[$I], $I)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPenCompoundArray", "handle", $HPEN, "struct*", $TCOMPOUNDS, "int", $ICOUNT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENSETCUSTOMENDCAP($HPEN, $HENDCAP)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPenCustomEndCap", "handle", $HPEN, "handle", $HENDCAP)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENSETDASHCAP($HPEN, $IDASH = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPenDashCap197819", "handle", $HPEN, "int", $IDASH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENSETDASHSTYLE($HPEN, $ISTYLE = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPenDashStyle", "handle", $HPEN, "int", $ISTYLE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENSETENDCAP($HPEN, $IENDCAP)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPenEndCap", "handle", $HPEN, "int", $IENDCAP)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENSETLINECAP($HPEN, $ISTARTCAP, $IENDCAP, $IDASHCAP)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPenLineCap197819", "handle", $HPEN, "int", $ISTARTCAP, "int", $IENDCAP, "int", $IDASHCAP)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENSETLINEJOIN($HPEN, $ILINEJOIN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPenLineJoin", "handle", $HPEN, "int", $ILINEJOIN)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENSETMITERLIMIT($HPEN, $FMITERLIMIT)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPenMiterLimit", "handle", $HPEN, "float", $FMITERLIMIT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENSETSTARTCAP($HPEN, $ILINECAP)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPenStartCap", "handle", $HPEN, "int", $ILINECAP)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENSETTRANSFORM($HPEN, $HMATRIX)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPenTransform", "handle", $HPEN, "handle", $HMATRIX)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PENSETWIDTH($HPEN, $FWIDTH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetPenWidth", "handle", $HPEN, "float", $FWIDTH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_RECTFCREATE($NX = 0, $NY = 0, $NWIDTH = 0, $NHEIGHT = 0)
	LOCAL $TRECTF = DLLSTRUCTCREATE($TAGGDIPRECTF)
	DLLSTRUCTSETDATA($TRECTF, "X", $NX)
	DLLSTRUCTSETDATA($TRECTF, "Y", $NY)
	DLLSTRUCTSETDATA($TRECTF, "Width", $NWIDTH)
	DLLSTRUCTSETDATA($TRECTF, "Height", $NHEIGHT)
	RETURN $TRECTF
ENDFUNC
FUNC _GDIPLUS_REGIONCLONE($HREGION)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCloneRegion", "handle", $HREGION, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_REGIONCOMBINEPATH($HREGION, $HPATH, $ICOMBINEMODE = 2)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCombineRegionPath", "handle", $HREGION, "handle", $HPATH, "int", $ICOMBINEMODE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_REGIONCOMBINERECT($HREGION, $NX, $NY, $NWIDTH, $NHEIGHT, $ICOMBINEMODE = 2)
	LOCAL $TRECTF = _GDIPLUS_RECTFCREATE($NX, $NY, $NWIDTH, $NHEIGHT)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCombineRegionRect", "handle", $HREGION, "struct*", $TRECTF, "int", $ICOMBINEMODE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_REGIONCOMBINEREGION($HREGIONDST, $HREGIONSRC, $ICOMBINEMODE = 2)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCombineRegionRegion", "handle", $HREGIONDST, "handle", $HREGIONSRC, "int", $ICOMBINEMODE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_REGIONCREATE()
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateRegion", "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[1]
ENDFUNC
FUNC _GDIPLUS_REGIONCREATEFROMPATH($HPATH)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateRegionPath", "handle", $HPATH, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_REGIONCREATEFROMRECT($NX, $NY, $NWIDTH, $NHEIGHT)
	LOCAL $TRECTF = _GDIPLUS_RECTFCREATE($NX, $NY, $NWIDTH, $NHEIGHT)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateRegionRect", "struct*", $TRECTF, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_REGIONDISPOSE($HREGION)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDeleteRegion", "handle", $HREGION)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_REGIONGETBOUNDS($HREGION, $HGRAPHICS)
	LOCAL $TRECTF = DLLSTRUCTCREATE($TAGGDIPRECTF)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetRegionBounds", "handle", $HREGION, "handle", $HGRAPHICS, "struct*", $TRECTF)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	LOCAL $ABOUNDS[4]
	FOR $II = 1 TO 4
		$ABOUNDS[$II - 1] = DLLSTRUCTGETDATA($TRECTF, $II)
	NEXT
	RETURN $ABOUNDS
ENDFUNC
FUNC _GDIPLUS_REGIONGETHRGN($HREGION, $HGRAPHICS = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetRegionHRgn", "handle", $HREGION, "handle", $HGRAPHICS, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_REGIONSETEMPTY($HREGION)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetEmpty", "handle", $HREGION)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_REGIONSETINFINITE($HREGION)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetInfinite", "handle", $HREGION)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_REGIONTRANSFORM($HREGION, $HMATRIX)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipTransformRegion", "handle", $HREGION, "handle", $HMATRIX)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_REGIONTRANSLATE($HREGION, $NDX, $NDY)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipTranslateRegion", "handle", $HREGION, "float", $NDX, "float", $NDY)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_SHUTDOWN()
	IF $__G_HGDIPDLL = 0 THEN RETURN SETERROR(-1, -1, FALSE)
	$__G_IGDIPREF -= 1
	IF $__G_IGDIPREF = 0 THEN
		DLLCALL($__G_HGDIPDLL, "none", "GdiplusShutdown", "ulong_ptr", $__G_IGDIPTOKEN)
		DLLCLOSE($__G_HGDIPDLL)
		$__G_HGDIPDLL = 0
	ENDIF
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_STARTUP($SGDIPDLL = DEFAULT, $BRETDLLHANDLE = FALSE)
	$__G_IGDIPREF += 1
	IF $__G_IGDIPREF > 1 THEN RETURN TRUE
	IF $SGDIPDLL = DEFAULT THEN $SGDIPDLL = "gdiplus.dll"
	$__G_HGDIPDLL = DLLOPEN($SGDIPDLL)
	IF $__G_HGDIPDLL = -1 THEN
		$__G_IGDIPREF = 0
		RETURN SETERROR(1, 2, FALSE)
	ENDIF
	LOCAL $SVER = FILEGETVERSION($SGDIPDLL)
	$SVER = STRINGSPLIT($SVER, ".")
	IF $SVER[1] > 5 THEN $__G_BGDIP_V1_0 = FALSE
	LOCAL $TINPUT = DLLSTRUCTCREATE($TAGGDIPSTARTUPINPUT)
	LOCAL $TTOKEN = DLLSTRUCTCREATE("ulong_ptr Data")
	DLLSTRUCTSETDATA($TINPUT, "Version", 1)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdiplusStartup", "struct*", $TTOKEN, "struct*", $TINPUT, "ptr", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	$__G_IGDIPTOKEN = DLLSTRUCTGETDATA($TTOKEN, "Data")
	IF $BRETDLLHANDLE THEN RETURN $__G_HGDIPDLL
	RETURN SETEXTENDED($SVER[1], TRUE)
ENDFUNC
FUNC _GDIPLUS_STRINGFORMATCREATE($IFORMAT = 0, $ILANGID = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateStringFormat", "int", $IFORMAT, "word", $ILANGID, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_STRINGFORMATDISPOSE($HFORMAT)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDeleteStringFormat", "handle", $HFORMAT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_STRINGFORMATGETMEASURABLECHARACTERRANGECOUNT($HSTRINGFORMAT)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetStringFormatMeasurableCharacterRangeCount", "handle", $HSTRINGFORMAT, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_STRINGFORMATSETALIGN($HSTRINGFORMAT, $IFLAG)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetStringFormatAlign", "handle", $HSTRINGFORMAT, "int", $IFLAG)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_STRINGFORMATSETLINEALIGN($HSTRINGFORMAT, $ISTRINGALIGN)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetStringFormatLineAlign", "handle", $HSTRINGFORMAT, "int", $ISTRINGALIGN)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_STRINGFORMATSETMEASURABLECHARACTERRANGES($HSTRINGFORMAT, $ARANGES)
	LOCAL $ICOUNT = $ARANGES[0][0]
	LOCAL $TCHARACTERRANGES = DLLSTRUCTCREATE("int[" & $ICOUNT * 2 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TCHARACTERRANGES, 1, $ARANGES[$II][0], (($II - 1) * 2) + 1)
		DLLSTRUCTSETDATA($TCHARACTERRANGES, 1, $ARANGES[$II][1], (($II - 1) * 2) + 2)
	NEXT
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetStringFormatMeasurableCharacterRanges", "handle", $HSTRINGFORMAT, "int", $ICOUNT, "struct*", $TCHARACTERRANGES)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_TEXTURECREATE($HIMAGE, $IWRAPMODE = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateTexture", "handle", $HIMAGE, "int", $IWRAPMODE, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_TEXTURECREATE2($HIMAGE, $NX, $NY, $NWIDTH, $NHEIGHT, $IWRAPMODE = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateTexture2", "handle", $HIMAGE, "int", $IWRAPMODE, "float", $NX, "float", $NY, "float", $NWIDTH, "float", $NHEIGHT, "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[7]
ENDFUNC
FUNC _GDIPLUS_TEXTURECREATEIA($HIMAGE, $NX, $NY, $NWIDTH, $NHEIGHT, $PIMAGEATTRIBUTES = 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateTextureIA", "handle", $HIMAGE, "handle", $PIMAGEATTRIBUTES, "float", $NX, "float", $NY, "float", $NWIDTH, "float", $NHEIGHT, "ptr*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[7]
ENDFUNC
FUNC __GDIPLUS_BRUSHDEFCREATE(BYREF $HBRUSH)
	IF $HBRUSH = 0 THEN
		$__G_HGDIPBRUSH = _GDIPLUS_BRUSHCREATESOLID()
		$HBRUSH = $__G_HGDIPBRUSH
	ENDIF
ENDFUNC
FUNC __GDIPLUS_BRUSHDEFDISPOSE($ICURERROR = @ERROR, $ICUREXTENDED = @EXTENDED)
	IF $__G_HGDIPBRUSH <> 0 THEN
		_GDIPLUS_BRUSHDISPOSE($__G_HGDIPBRUSH)
		$__G_HGDIPBRUSH = 0
	ENDIF
	RETURN SETERROR($ICURERROR, $ICUREXTENDED)
ENDFUNC
FUNC __GDIPLUS_EXTRACTFILEEXT($SFILENAME, $BNODOT = TRUE)
	LOCAL $IINDEX = __GDIPLUS_LASTDELIMITER(".\:", $SFILENAME)
	IF($IINDEX > 0) AND(STRINGMID($SFILENAME, $IINDEX, 1) = ".") THEN
		IF $BNODOT THEN
			RETURN STRINGMID($SFILENAME, $IINDEX + 1)
		ELSE
			RETURN STRINGMID($SFILENAME, $IINDEX)
		ENDIF
	ELSE
		RETURN ""
	ENDIF
ENDFUNC
FUNC __GDIPLUS_LASTDELIMITER($SDELIMITERS, $SSTRING)
	LOCAL $SDELIMITER, $IN
	FOR $II = 1 TO STRINGLEN($SDELIMITERS)
		$SDELIMITER = STRINGMID($SDELIMITERS, $II, 1)
		$IN = STRINGINSTR($SSTRING, $SDELIMITER, $STR_NOCASESENSEBASIC, -1)
		IF $IN > 0 THEN RETURN $IN
	NEXT
ENDFUNC
FUNC __GDIPLUS_PENDEFCREATE(BYREF $HPEN)
	IF $HPEN = 0 THEN
		$__G_HGDIPPEN = _GDIPLUS_PENCREATE()
		$HPEN = $__G_HGDIPPEN
	ENDIF
ENDFUNC
FUNC __GDIPLUS_PENDEFDISPOSE($ICURERROR = @ERROR, $ICUREXTENDED = @EXTENDED)
	IF $__G_HGDIPPEN <> 0 THEN
		_GDIPLUS_PENDISPOSE($__G_HGDIPPEN)
		$__G_HGDIPPEN = 0
	ENDIF
	RETURN SETERROR($ICURERROR, $ICUREXTENDED)
ENDFUNC
FUNC _GDIPLUS_BITMAPAPPLYEFFECT($HBITMAP, $HEFFECT, $TRECT = NULL)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, FALSE)
	IF NOT ISPTR($HEFFECT) THEN RETURN SETERROR(10, 0, FALSE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipBitmapApplyEffect", "handle", $HBITMAP, "handle", $HEFFECT, "struct*", $TRECT, "int", 0, "ptr*", 0, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_BITMAPAPPLYEFFECTEX($HBITMAP, $HEFFECT, $IX = 0, $IY = 0, $IW = 0, $IH = 0)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, FALSE)
	LOCAL $TRECT = 0
	IF BITOR($IX, $IY, $IW, $IH) THEN
		$TRECT = DLLSTRUCTCREATE("int Left; int Top; int Right; int Bottom;")
		DLLSTRUCTSETDATA($TRECT, "Right", $IW + DLLSTRUCTSETDATA($TRECT, "Left", $IX))
		DLLSTRUCTSETDATA($TRECT, "Bottom", $IH + DLLSTRUCTSETDATA($TRECT, "Top", $IY))
	ENDIF
	LOCAL $ISTATUS = _GDIPLUS_BITMAPAPPLYEFFECT($HBITMAP, $HEFFECT, $TRECT)
	IF NOT $ISTATUS THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_BITMAPCONVERTFORMAT($HBITMAP, $IPIXELFORMAT, $IDITHERTYPE, $IPALETTETYPE, $TPALETTE, $FALPHATHRESHOLDPERCENT = 0)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, FALSE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipBitmapConvertFormat", "handle", $HBITMAP, "uint", $IPIXELFORMAT, "uint", $IDITHERTYPE, "uint", $IPALETTETYPE, "struct*", $TPALETTE, "float", $FALPHATHRESHOLDPERCENT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_BITMAPCREATEAPPLYEFFECT($HBITMAP, $HEFFECT, $TRECT = NULL, $TOUTRECT = NULL)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipBitmapCreateApplyEffect", "handle*", $HBITMAP, "int", 1, "handle", $HEFFECT, "struct*", $TRECT, "struct*", $TOUTRECT, "handle*", 0, "int", 0, "ptr*", 0, "int*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[6]
ENDFUNC
FUNC _GDIPLUS_BITMAPCREATEAPPLYEFFECTEX($HBITMAP, $HEFFECT, $IX = 0, $IY = 0, $IW = 0, $IH = 0)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $TRECT = 0
	IF BITOR($IX, $IY, $IW, $IH) THEN
		$TRECT = DLLSTRUCTCREATE("int Left; int Top; int Right; int Bottom;")
		DLLSTRUCTSETDATA($TRECT, "Right", $IW + DLLSTRUCTSETDATA($TRECT, "Left", $IX))
		DLLSTRUCTSETDATA($TRECT, "Bottom", $IH + DLLSTRUCTSETDATA($TRECT, "Top", $IY))
	ENDIF
	LOCAL $HBITMAP_FX = _GDIPLUS_BITMAPCREATEAPPLYEFFECT($HBITMAP, $HEFFECT, $TRECT, NULL)
	RETURN SETERROR(@ERROR, @EXTENDED, $HBITMAP_FX)
ENDFUNC
FUNC _GDIPLUS_BITMAPGETHISTOGRAM($HBITMAP, $IHISTOGRAMFORMAT, $IHISTOGRAMSIZE, $TCHANNEL_0, $TCHANNEL_1 = 0, $TCHANNEL_2 = 0, $TCHANNEL_3 = 0)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, FALSE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipBitmapGetHistogram", "handle", $HBITMAP, "uint", $IHISTOGRAMFORMAT, "uint", $IHISTOGRAMSIZE, "struct*", $TCHANNEL_0, "struct*", $TCHANNEL_1, "struct*", $TCHANNEL_2, "struct*", $TCHANNEL_3)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_BITMAPGETHISTOGRAMEX($HBITMAP)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $ISIZE = _GDIPLUS_BITMAPGETHISTOGRAMSIZE($GDIP_HISTOGRAMFORMATARGB)
	LOCAL $THISTOGRAM = DLLSTRUCTCREATE("int Size; uint Red[" & $ISIZE & "]; uint MaxRed; uint Green[" & $ISIZE & "]; uint MaxGreen; uint Blue[" & $ISIZE & "]; uint MaxBlue; uint Alpha[" & $ISIZE & "]; uint MaxAlpha; uint Grey[" & $ISIZE & "]; uint MaxGrey;")
	DLLSTRUCTSETDATA($THISTOGRAM, "Size", $ISIZE)
	LOCAL $ISTATUS = _GDIPLUS_BITMAPGETHISTOGRAM($HBITMAP, $GDIP_HISTOGRAMFORMATARGB, $ISIZE, DLLSTRUCTGETPTR($THISTOGRAM, "Alpha"), DLLSTRUCTGETPTR($THISTOGRAM, "Red"), DLLSTRUCTGETPTR($THISTOGRAM, "Green"), DLLSTRUCTGETPTR($THISTOGRAM, "Blue"))
	IF NOT $ISTATUS THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	$ISTATUS = _GDIPLUS_BITMAPGETHISTOGRAM($HBITMAP, $GDIP_HISTOGRAMFORMATGRAY, $ISIZE, DLLSTRUCTGETPTR($THISTOGRAM, "Grey"))
	IF NOT $ISTATUS THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	LOCAL $IMAXRED = 0, $IMAXGREEN = 0, $IMAXBLUE = 0, $IMAXALPHA = 0, $IMAXGREY = 0
	FOR $I = 1 TO $ISIZE
		IF DLLSTRUCTGETDATA($THISTOGRAM, "Red", $I) > $IMAXRED THEN $IMAXRED = DLLSTRUCTGETDATA($THISTOGRAM, "Red", $I)
		IF DLLSTRUCTGETDATA($THISTOGRAM, "Green", $I) > $IMAXGREEN THEN $IMAXGREEN = DLLSTRUCTGETDATA($THISTOGRAM, "Green", $I)
		IF DLLSTRUCTGETDATA($THISTOGRAM, "Blue", $I) > $IMAXBLUE THEN $IMAXBLUE = DLLSTRUCTGETDATA($THISTOGRAM, "Blue", $I)
		IF DLLSTRUCTGETDATA($THISTOGRAM, "Alpha", $I) > $IMAXALPHA THEN $IMAXALPHA = DLLSTRUCTGETDATA($THISTOGRAM, "Alpha", $I)
		IF DLLSTRUCTGETDATA($THISTOGRAM, "Grey", $I) > $IMAXGREY THEN $IMAXGREY = DLLSTRUCTGETDATA($THISTOGRAM, "Grey", $I)
	NEXT
	DLLSTRUCTSETDATA($THISTOGRAM, "MaxRed", $IMAXRED)
	DLLSTRUCTSETDATA($THISTOGRAM, "MaxGreen", $IMAXGREEN)
	DLLSTRUCTSETDATA($THISTOGRAM, "MaxBlue", $IMAXBLUE)
	DLLSTRUCTSETDATA($THISTOGRAM, "MaxAlpha", $IMAXALPHA)
	DLLSTRUCTSETDATA($THISTOGRAM, "MaxGrey", $IMAXGREY)
	RETURN $THISTOGRAM
ENDFUNC
FUNC _GDIPLUS_BITMAPGETHISTOGRAMSIZE($IFORMAT)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipBitmapGetHistogramSize", "uint", $IFORMAT, "uint*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_DRAWIMAGEFX($HGRAPHICS, $HIMAGE, $HEFFECT, $TRECTF = 0, $HMATRIX = 0, $HIMGATTRIBUTES = 0, $IUNIT = 2)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, FALSE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDrawImageFX", "handle", $HGRAPHICS, "handle", $HIMAGE, "struct*", $TRECTF, "handle", $HMATRIX, "handle", $HEFFECT, "handle", $HIMGATTRIBUTES, "uint", $IUNIT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_DRAWIMAGEFXEX($HGRAPHICS, $HIMAGE, $HEFFECT, $NX = 0, $NY = 0, $NW = 0, $NH = 0, $HMATRIX = 0, $HIMGATTRIBUTES = 0, $IUNIT = 2)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, FALSE)
	LOCAL $TRECTF = 0
	IF BITOR($NX, $NY, $NW, $NH) THEN $TRECTF = _GDIPLUS_RECTFCREATE($NX, $NY, $NW, $NH)
	LOCAL $ISTATUS = _GDIPLUS_DRAWIMAGEFX($HGRAPHICS, $HIMAGE, $HEFFECT, $TRECTF, $HMATRIX, $HIMGATTRIBUTES, $IUNIT)
	RETURN SETERROR(@ERROR, @EXTENDED, $ISTATUS)
ENDFUNC
FUNC _GDIPLUS_EFFECTCREATE($SEFFECTGUID)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $TGUID = _WINAPI_GUIDFROMSTRING($SEFFECTGUID)
	LOCAL $ARESULT = 0
	IF @AUTOITX64 THEN
		$ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateEffect", "struct*", $TGUID, "handle*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
		RETURN $ARESULT[2]
	ENDIF
	LOCAL $TELEM = DLLSTRUCTCREATE("uint64[2];", DLLSTRUCTGETPTR($TGUID))
	$ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipCreateEffect", "uint64", DLLSTRUCTGETDATA($TELEM, 1, 1), "uint64", DLLSTRUCTGETDATA($TELEM, 1, 2), "handle*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $ARESULT[3]
ENDFUNC
FUNC _GDIPLUS_EFFECTCREATEBLUR($FRADIUS = 10, $BEXPANDEDGE = FALSE)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $TEFFECTPARAMETERS = DLLSTRUCTCREATE($TAGGDIP_EFFECTPARAMS_BLUR)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "Radius", $FRADIUS)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "ExpandEdge", $BEXPANDEDGE)
	LOCAL $HEFFECT = _GDIPLUS_EFFECTCREATE($GDIP_BLUREFFECTGUID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	_GDIPLUS_EFFECTSETPARAMETERS($HEFFECT, $TEFFECTPARAMETERS)
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $HEFFECT
ENDFUNC
FUNC _GDIPLUS_EFFECTCREATEBRIGHTNESSCONTRAST($IBRIGHTNESSLEVEL = 0, $ICONTRASTLEVEL = 0)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $TEFFECTPARAMETERS = DLLSTRUCTCREATE($TAGGDIP_EFFECTPARAMS_BRIGHTNESSCONTRAST)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "BrightnessLevel", $IBRIGHTNESSLEVEL)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "ContrastLevel", $ICONTRASTLEVEL)
	LOCAL $HEFFECT = _GDIPLUS_EFFECTCREATE($GDIP_BRIGHTNESSCONTRASTEFFECTGUID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	_GDIPLUS_EFFECTSETPARAMETERS($HEFFECT, $TEFFECTPARAMETERS)
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $HEFFECT
ENDFUNC
FUNC _GDIPLUS_EFFECTCREATECOLORBALANCE($ICYANRED = 0, $IMAGENTAGREEN = 0, $IYELLOWBLUE = 0)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $TEFFECTPARAMETERS = DLLSTRUCTCREATE($TAGGDIP_EFFECTPARAMS_COLORBALANCE)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "CyanRed", $ICYANRED)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "MagentaGreen", $IMAGENTAGREEN)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "YellowBlue", $IYELLOWBLUE)
	LOCAL $HEFFECT = _GDIPLUS_EFFECTCREATE($GDIP_COLORBALANCEEFFECTGUID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	_GDIPLUS_EFFECTSETPARAMETERS($HEFFECT, $TEFFECTPARAMETERS)
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $HEFFECT
ENDFUNC
FUNC _GDIPLUS_EFFECTCREATECOLORCURVE($IADJUSTMENT, $ICHANNEL, $IADJUSTVALUE)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $TEFFECTPARAMETERS = DLLSTRUCTCREATE($TAGGDIP_EFFECTPARAMS_COLORCURVE)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "Adjustment", $IADJUSTMENT)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "Channel", $ICHANNEL)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "AdjustValue", $IADJUSTVALUE)
	LOCAL $HEFFECT = _GDIPLUS_EFFECTCREATE($GDIP_COLORCURVEEFFECTGUID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	_GDIPLUS_EFFECTSETPARAMETERS($HEFFECT, $TEFFECTPARAMETERS)
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $HEFFECT
ENDFUNC
FUNC _GDIPLUS_EFFECTCREATECOLORLUT($ACOLORLUT)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $TEFFECTPARAMETERS = DLLSTRUCTCREATE($TAGGDIP_EFFECTPARAMS_COLORLUT)
	FOR $II = 0 TO 255
		DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "LutA", $ACOLORLUT[$II][0], $II + 1)
		DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "LutR", $ACOLORLUT[$II][1], $II + 1)
		DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "LutG", $ACOLORLUT[$II][2], $II + 1)
		DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "LutB", $ACOLORLUT[$II][3], $II + 1)
	NEXT
	LOCAL $HEFFECT = _GDIPLUS_EFFECTCREATE($GDIP_COLORLUTEFFECTGUID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	_GDIPLUS_EFFECTSETPARAMETERS($HEFFECT, $TEFFECTPARAMETERS)
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $HEFFECT
ENDFUNC
FUNC _GDIPLUS_EFFECTCREATECOLORMATRIX($TCOLORMATRIX)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $HEFFECT = _GDIPLUS_EFFECTCREATE($GDIP_COLORMATRIXEFFECTGUID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	_GDIPLUS_EFFECTSETPARAMETERS($HEFFECT, $TCOLORMATRIX)
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $HEFFECT
ENDFUNC
FUNC _GDIPLUS_EFFECTCREATEHUESATURATIONLIGHTNESS($IHUELEVEL = 0, $ISATURATIONLEVEL = 0, $ILIGHTNESSLEVEL = 0)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $TEFFECTPARAMETERS = DLLSTRUCTCREATE($TAGGDIP_EFFECTPARAMS_HUESATURATIONLIGHTNESS)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "HueLevel", $IHUELEVEL)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "SaturationLevel", $ISATURATIONLEVEL)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "LightnessLevel", $ILIGHTNESSLEVEL)
	LOCAL $HEFFECT = _GDIPLUS_EFFECTCREATE($GDIP_HUESATURATIONLIGHTNESSEFFECTGUID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	_GDIPLUS_EFFECTSETPARAMETERS($HEFFECT, $TEFFECTPARAMETERS)
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $HEFFECT
ENDFUNC
FUNC _GDIPLUS_EFFECTCREATELEVELS($IHIGHLIGHT = 100, $IMIDTONE = 0, $ISHADOW = 0)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $TEFFECTPARAMETERS = DLLSTRUCTCREATE($TAGGDIP_EFFECTPARAMS_LEVELS)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "Highlight", $IHIGHLIGHT)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "Midtone", $IMIDTONE)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "Shadow", $ISHADOW)
	LOCAL $HEFFECT = _GDIPLUS_EFFECTCREATE($GDIP_LEVELSEFFECTGUID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	_GDIPLUS_EFFECTSETPARAMETERS($HEFFECT, $TEFFECTPARAMETERS)
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $HEFFECT
ENDFUNC
FUNC _GDIPLUS_EFFECTCREATEREDEYECORRECTION($AAREAS)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $ICOUNT = $AAREAS[0][0]
	LOCAL $TAREAS = DLLSTRUCTCREATE("long[" & $ICOUNT * 4 & "]")
	FOR $II = 1 TO $ICOUNT
		DLLSTRUCTSETDATA($TAREAS, 1, DLLSTRUCTSETDATA($TAREAS, 1, $AAREAS[$II][0], (($II - 1) * 4) + 1) + $AAREAS[$II][2], (($II - 1) * 4) + 3)
		DLLSTRUCTSETDATA($TAREAS, 1, DLLSTRUCTSETDATA($TAREAS, 1, $AAREAS[$II][1], (($II - 1) * 4) + 2) + $AAREAS[$II][3], (($II - 1) * 4) + 4)
	NEXT
	LOCAL $TEFFECTPARAMETERS = DLLSTRUCTCREATE($TAGGDIP_EFFECTPARAMS_REDEYECORRECTION)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "NumberOfAreas", $ICOUNT)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "Areas", DLLSTRUCTGETPTR($TAREAS))
	LOCAL $HEFFECT = _GDIPLUS_EFFECTCREATE($GDIP_REDEYECORRECTIONEFFECTGUID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	_GDIPLUS_EFFECTSETPARAMETERS($HEFFECT, $TEFFECTPARAMETERS, (DLLSTRUCTGETSIZE($TAREAS) + DLLSTRUCTGETSIZE($TEFFECTPARAMETERS)) / DLLSTRUCTGETSIZE($TEFFECTPARAMETERS))
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $HEFFECT
ENDFUNC
FUNC _GDIPLUS_EFFECTCREATESHARPEN($FRADIUS = 10, $FAMOUNT = 50)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $TEFFECTPARAMETERS = DLLSTRUCTCREATE($TAGGDIP_EFFECTPARAMS_SHARPEN)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "Radius", $FRADIUS)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "Amount", $FAMOUNT)
	LOCAL $HEFFECT = _GDIPLUS_EFFECTCREATE($GDIP_SHARPENEFFECTGUID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	_GDIPLUS_EFFECTSETPARAMETERS($HEFFECT, $TEFFECTPARAMETERS)
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $HEFFECT
ENDFUNC
FUNC _GDIPLUS_EFFECTCREATETINT($IHUE = 0, $IAMOUNT = 0)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	LOCAL $TEFFECTPARAMETERS = DLLSTRUCTCREATE($TAGGDIP_EFFECTPARAMS_TINT)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "Hue", $IHUE)
	DLLSTRUCTSETDATA($TEFFECTPARAMETERS, "Amount", $IAMOUNT)
	LOCAL $HEFFECT = _GDIPLUS_EFFECTCREATE($GDIP_TINTEFFECTGUID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	_GDIPLUS_EFFECTSETPARAMETERS($HEFFECT, $TEFFECTPARAMETERS)
	IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $HEFFECT
ENDFUNC
FUNC _GDIPLUS_EFFECTDISPOSE($HEFFECT)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, FALSE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipDeleteEffect", "handle", $HEFFECT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_EFFECTGETPARAMETERS($HEFFECT, $TEFFECTPARAMETERS)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, FALSE)
	IF DLLSTRUCTGETSIZE($TEFFECTPARAMETERS) < __GDIPLUS_EFFECTGETPARAMETERSIZE($HEFFECT) THEN RETURN SETERROR(2, 5, FALSE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetEffectParameters", "handle", $HEFFECT, "uint*", DLLSTRUCTGETSIZE($TEFFECTPARAMETERS), "struct*", $TEFFECTPARAMETERS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC __GDIPLUS_EFFECTGETPARAMETERSIZE($HEFFECT)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, -1)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipGetEffectParameterSize", "handle", $HEFFECT, "uint*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], -1)
	RETURN $ARESULT[2]
ENDFUNC
FUNC _GDIPLUS_EFFECTSETPARAMETERS($HEFFECT, $TEFFECTPARAMETERS, $ISIZEADJUST = 1)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, FALSE)
	LOCAL $ISIZE = __GDIPLUS_EFFECTGETPARAMETERSIZE($HEFFECT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipSetEffectParameters", "handle", $HEFFECT, "struct*", $TEFFECTPARAMETERS, "uint", $ISIZE * $ISIZEADJUST)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], FALSE)
	RETURN TRUE
ENDFUNC
FUNC _GDIPLUS_PALETTEINITIALIZE($IENTRIES, $IPALETTETYPE = $GDIP_PALETTETYPEOPTIMAL, $IOPTIMALCOLORS = 0, $BUSETRANSPARENTCOLOR = TRUE, $HBITMAP = NULL)
	IF $__G_BGDIP_V1_0 THEN RETURN SETERROR(-1, 0, 0)
	IF $IOPTIMALCOLORS > 0 THEN $IPALETTETYPE = $GDIP_PALETTETYPEOPTIMAL
	LOCAL $TPALETTE = DLLSTRUCTCREATE("uint Flags; uint Count; uint ARGB[" & $IENTRIES & "];")
	DLLSTRUCTSETDATA($TPALETTE, "Flags", $IPALETTETYPE)
	DLLSTRUCTSETDATA($TPALETTE, "Count", $IENTRIES)
	LOCAL $ARESULT = DLLCALL($__G_HGDIPDLL, "int", "GdipInitializePalette", "struct*", $TPALETTE, "uint", $IPALETTETYPE, "uint", $IOPTIMALCOLORS, "bool", $BUSETRANSPARENTCOLOR, "handle", $HBITMAP)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ARESULT[0] THEN RETURN SETERROR(10, $ARESULT[0], 0)
	RETURN $TPALETTE
ENDFUNC
FUNC _SENDMESSAGE($HWND, $IMSG, $WPARAM = 0, $LPARAM = 0, $IRETURN = 0, $WPARAMTYPE = "wparam", $LPARAMTYPE = "lparam", $SRETURNTYPE = "lresult")
	LOCAL $ARESULT = DLLCALL("user32.dll", $SRETURNTYPE, "SendMessageW", "hwnd", $HWND, "uint", $IMSG, $WPARAMTYPE, $WPARAM, $LPARAMTYPE, $LPARAM)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
	IF $IRETURN >= 0 AND $IRETURN <= 4 THEN RETURN $ARESULT[$IRETURN]
	RETURN $ARESULT
ENDFUNC
FUNC _SENDMESSAGEA($HWND, $IMSG, $WPARAM = 0, $LPARAM = 0, $IRETURN = 0, $WPARAMTYPE = "wparam", $LPARAMTYPE = "lparam", $SRETURNTYPE = "lresult")
	LOCAL $ARESULT = DLLCALL("user32.dll", $SRETURNTYPE, "SendMessageA", "hwnd", $HWND, "uint", $IMSG, $WPARAMTYPE, $WPARAM, $LPARAMTYPE, $LPARAM)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
	IF $IRETURN >= 0 AND $IRETURN <= 4 THEN RETURN $ARESULT[$IRETURN]
	RETURN $ARESULT
ENDFUNC
#Region Global Variables and Constants
	GLOBAL $__G_AINPROCESS_WINAPI[64][2] = [[0, 0]]
	GLOBAL $__G_AWINLIST_WINAPI[64][2] = [[0, 0]]
	GLOBAL CONST $GW_HWNDFIRST = 0
	GLOBAL CONST $GW_HWNDLAST = 1
	GLOBAL CONST $GW_HWNDNEXT = 2
	GLOBAL CONST $GW_HWNDPREV = 3
	GLOBAL CONST $GW_OWNER = 4
	GLOBAL CONST $GW_CHILD = 5
	GLOBAL CONST $GW_ENABLEDPOPUP = 6
	GLOBAL CONST $GWL_WNDPROC = -4
	GLOBAL CONST $GWL_HINSTANCE = -6
	GLOBAL CONST $GWL_HWNDPARENT = -8
	GLOBAL CONST $GWL_ID = -12
	GLOBAL CONST $GWL_STYLE = -16
	GLOBAL CONST $GWL_EXSTYLE = -20
	GLOBAL CONST $GWL_USERDATA = -21
	GLOBAL CONST $__WINAPICONSTANT_WM_SETFONT = 48
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_CREATEWINDOWEX($IEXSTYLE, $SCLASS, $SNAME, $ISTYLE, $IX, $IY, $IWIDTH, $IHEIGHT, $HPARENT, $HMENU = 0, $HINSTANCE = 0, $PPARAM = 0)
		IF $HINSTANCE = 0 THEN $HINSTANCE = _WINAPI_GETMODULEHANDLE("")
		LOCAL $ARESULT = DLLCALL("user32.dll", "hwnd", "CreateWindowExW", "dword", $IEXSTYLE, "wstr", $SCLASS, "wstr", $SNAME, "dword", $ISTYLE, "int", $IX, "int", $IY, "int", $IWIDTH, "int", $IHEIGHT, "hwnd", $HPARENT, "handle", $HMENU, "handle", $HINSTANCE, "struct*", $PPARAM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETCLIENTRECT($HWND)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetClientRect", "hwnd", $HWND, "struct*", $TRECT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_GETDESKTOPWINDOW()
		LOCAL $ARESULT = DLLCALL("user32.dll", "hwnd", "GetDesktopWindow")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_DESTROYWINDOW($HWND)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "DestroyWindow", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_ENABLEWINDOW($HWND, $BENABLE = TRUE)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "EnableWindow", "hwnd", $HWND, "bool", $BENABLE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_ENUMWINDOWS($BVISIBLE = TRUE, $HWND = DEFAULT)
		__WINAPI_ENUMWINDOWSINIT()
		IF $HWND = DEFAULT THEN $HWND = _WINAPI_GETDESKTOPWINDOW()
		__WINAPI_ENUMWINDOWSCHILD($HWND, $BVISIBLE)
		RETURN $__G_AWINLIST_WINAPI
	ENDFUNC
	FUNC _WINAPI_ENUMWINDOWSPOPUP()
		__WINAPI_ENUMWINDOWSINIT()
		LOCAL $HWND = _WINAPI_GETWINDOW(_WINAPI_GETDESKTOPWINDOW(), $GW_CHILD)
		LOCAL $SCLASS
		WHILE $HWND <> 0
			IF _WINAPI_ISWINDOWVISIBLE($HWND) THEN
				$SCLASS = _WINAPI_GETCLASSNAME($HWND)
				IF $SCLASS = "#32768" THEN
					__WINAPI_ENUMWINDOWSADD($HWND)
				ELSEIF $SCLASS = "ToolbarWindow32" THEN
					__WINAPI_ENUMWINDOWSADD($HWND)
				ELSEIF $SCLASS = "ToolTips_Class32" THEN
					__WINAPI_ENUMWINDOWSADD($HWND)
				ELSEIF $SCLASS = "BaseBar" THEN
					__WINAPI_ENUMWINDOWSCHILD($HWND)
				ENDIF
			ENDIF
			$HWND = _WINAPI_GETWINDOW($HWND, $GW_HWNDNEXT)
		WEND
		RETURN $__G_AWINLIST_WINAPI
	ENDFUNC
	FUNC _WINAPI_ENUMWINDOWSTOP()
		__WINAPI_ENUMWINDOWSINIT()
		LOCAL $HWND = _WINAPI_GETWINDOW(_WINAPI_GETDESKTOPWINDOW(), $GW_CHILD)
		WHILE $HWND <> 0
			IF _WINAPI_ISWINDOWVISIBLE($HWND) THEN __WINAPI_ENUMWINDOWSADD($HWND)
			$HWND = _WINAPI_GETWINDOW($HWND, $GW_HWNDNEXT)
		WEND
		RETURN $__G_AWINLIST_WINAPI
	ENDFUNC
	FUNC _WINAPI_GETCLASSNAME($HWND)
		IF NOT ISHWND($HWND) THEN $HWND = GUICTRLGETHANDLE($HWND)
		LOCAL $ARESULT = DLLCALL("user32.dll", "int", "GetClassNameW", "hwnd", $HWND, "wstr", "", "int", 4096)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN SETEXTENDED($ARESULT[0], $ARESULT[2])
	ENDFUNC
	FUNC _WINAPI_GETFOCUS()
		LOCAL $ARESULT = DLLCALL("user32.dll", "hwnd", "GetFocus")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETPARENT($HWND)
		LOCAL $ARESULT = DLLCALL("user32.dll", "hwnd", "GetParent", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETSYSCOLOR($IINDEX)
		LOCAL $ARESULT = DLLCALL("user32.dll", "INT", "GetSysColor", "int", $IINDEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETSYSTEMMETRICS($IINDEX)
		LOCAL $ARESULT = DLLCALL("user32.dll", "int", "GetSystemMetrics", "int", $IINDEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETWINDOW($HWND, $ICMD)
		LOCAL $ARESULT = DLLCALL("user32.dll", "hwnd", "GetWindow", "hwnd", $HWND, "uint", $ICMD)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETWINDOWHEIGHT($HWND)
		LOCAL $TRECT = _WINAPI_GETWINDOWRECT($HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TRECT, "Bottom") - DLLSTRUCTGETDATA($TRECT, "Top")
	ENDFUNC
	FUNC _WINAPI_GETWINDOWLONG($HWND, $IINDEX)
		LOCAL $SFUNCNAME = "GetWindowLongW"
		IF @AUTOITX64 THEN $SFUNCNAME = "GetWindowLongPtrW"
		LOCAL $ARESULT = DLLCALL("user32.dll", "long_ptr", $SFUNCNAME, "hwnd", $HWND, "int", $IINDEX)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETWINDOWRECT($HWND)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetWindowRect", "hwnd", $HWND, "struct*", $TRECT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_GETWINDOWTEXT($HWND)
		LOCAL $ARESULT = DLLCALL("user32.dll", "int", "GetWindowTextW", "hwnd", $HWND, "wstr", "", "int", 4096)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN SETEXTENDED($ARESULT[0], $ARESULT[2])
	ENDFUNC
	FUNC _WINAPI_GETWINDOWTHREADPROCESSID($HWND, BYREF $IPID)
		LOCAL $ARESULT = DLLCALL("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $HWND, "dword*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		$IPID = $ARESULT[2]
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETWINDOWWIDTH($HWND)
		LOCAL $TRECT = _WINAPI_GETWINDOWRECT($HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TRECT, "Right") - DLLSTRUCTGETDATA($TRECT, "Left")
	ENDFUNC
	FUNC _WINAPI_INPROCESS($HWND, BYREF $HLASTWND)
		IF $HWND = $HLASTWND THEN RETURN TRUE
		FOR $II = $__G_AINPROCESS_WINAPI[0][0] TO 1 STEP -1
			IF $HWND = $__G_AINPROCESS_WINAPI[$II][0] THEN
				IF $__G_AINPROCESS_WINAPI[$II][1] THEN
					$HLASTWND = $HWND
					RETURN TRUE
				ELSE
					RETURN FALSE
				ENDIF
			ENDIF
		NEXT
		LOCAL $IPID
		_WINAPI_GETWINDOWTHREADPROCESSID($HWND, $IPID)
		LOCAL $ICOUNT = $__G_AINPROCESS_WINAPI[0][0] + 1
		IF $ICOUNT >= 64 THEN $ICOUNT = 1
		$__G_AINPROCESS_WINAPI[0][0] = $ICOUNT
		$__G_AINPROCESS_WINAPI[$ICOUNT][0] = $HWND
		$__G_AINPROCESS_WINAPI[$ICOUNT][1] = ($IPID = @AUTOITPID)
		RETURN $__G_AINPROCESS_WINAPI[$ICOUNT][1]
	ENDFUNC
	FUNC _WINAPI_INVALIDATERECT($HWND, $TRECT = 0, $BERASE = TRUE)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "InvalidateRect", "hwnd", $HWND, "struct*", $TRECT, "bool", $BERASE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_ISCLASSNAME($HWND, $SCLASSNAME)
		LOCAL $SSEPARATOR = OPT("GUIDataSeparatorChar")
		LOCAL $ACLASSNAME = STRINGSPLIT($SCLASSNAME, $SSEPARATOR)
		IF NOT ISHWND($HWND) THEN $HWND = GUICTRLGETHANDLE($HWND)
		LOCAL $SCLASSCHECK = _WINAPI_GETCLASSNAME($HWND)
		FOR $X = 1 TO UBOUND($ACLASSNAME) - 1
			IF STRINGUPPER(STRINGMID($SCLASSCHECK, 1, STRINGLEN($ACLASSNAME[$X]))) = STRINGUPPER($ACLASSNAME[$X]) THEN RETURN TRUE
		NEXT
		RETURN FALSE
	ENDFUNC
	FUNC _WINAPI_ISWINDOW($HWND)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "IsWindow", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_ISWINDOWVISIBLE($HWND)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "IsWindowVisible", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_MOVEWINDOW($HWND, $IX, $IY, $IWIDTH, $IHEIGHT, $BREPAINT = TRUE)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "MoveWindow", "hwnd", $HWND, "int", $IX, "int", $IY, "int", $IWIDTH, "int", $IHEIGHT, "bool", $BREPAINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETFOCUS($HWND)
		LOCAL $ARESULT = DLLCALL("user32.dll", "hwnd", "SetFocus", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETFONT($HWND, $HFONT, $BREDRAW = TRUE)
		_SENDMESSAGE($HWND, $__WINAPICONSTANT_WM_SETFONT, $HFONT, $BREDRAW, 0, "hwnd")
	ENDFUNC
	FUNC _WINAPI_SETPARENT($HWNDCHILD, $HWNDPARENT)
		LOCAL $ARESULT = DLLCALL("user32.dll", "hwnd", "SetParent", "hwnd", $HWNDCHILD, "hwnd", $HWNDPARENT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETWINDOWPOS($HWND, $HAFTER, $IX, $IY, $ICX, $ICY, $IFLAGS)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "SetWindowPos", "hwnd", $HWND, "hwnd", $HAFTER, "int", $IX, "int", $IY, "int", $ICX, "int", $ICY, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETWINDOWTEXT($HWND, $STEXT)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "SetWindowTextW", "hwnd", $HWND, "wstr", $STEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SHOWWINDOW($HWND, $ICMDSHOW = 5)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "ShowWindow", "hwnd", $HWND, "int", $ICMDSHOW)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_UPDATEWINDOW($HWND)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "UpdateWindow", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __WINAPI_ENUMWINDOWSADD($HWND, $SCLASS = "")
		IF $SCLASS = "" THEN $SCLASS = _WINAPI_GETCLASSNAME($HWND)
		$__G_AWINLIST_WINAPI[0][0] += 1
		LOCAL $ICOUNT = $__G_AWINLIST_WINAPI[0][0]
		IF $ICOUNT >= $__G_AWINLIST_WINAPI[0][1] THEN
			REDIM $__G_AWINLIST_WINAPI[$ICOUNT + 64][2]
			$__G_AWINLIST_WINAPI[0][1] += 64
		ENDIF
		$__G_AWINLIST_WINAPI[$ICOUNT][0] = $HWND
		$__G_AWINLIST_WINAPI[$ICOUNT][1] = $SCLASS
	ENDFUNC
	FUNC __WINAPI_ENUMWINDOWSCHILD($HWND, $BVISIBLE = TRUE)
		$HWND = _WINAPI_GETWINDOW($HWND, $GW_CHILD)
		WHILE $HWND <> 0
			IF(NOT $BVISIBLE) OR _WINAPI_ISWINDOWVISIBLE($HWND) THEN
				__WINAPI_ENUMWINDOWSADD($HWND)
				__WINAPI_ENUMWINDOWSCHILD($HWND, $BVISIBLE)
			ENDIF
			$HWND = _WINAPI_GETWINDOW($HWND, $GW_HWNDNEXT)
		WEND
	ENDFUNC
	FUNC __WINAPI_ENUMWINDOWSINIT()
		REDIM $__G_AWINLIST_WINAPI[64][2]
		$__G_AWINLIST_WINAPI[0][0] = 0
		$__G_AWINLIST_WINAPI[0][1] = 64
	ENDFUNC
#EndRegion Internal Functions
GLOBAL $__G_IBMPFORMAT = $GDIP_PXF24RGB
GLOBAL $__G_IJPGQUALITY = 100
GLOBAL $__G_ITIFCOLORDEPTH = 24
GLOBAL $__G_ITIFCOMPRESSION = $GDIP_EVTCOMPRESSIONLZW
GLOBAL CONST $__SCREENCAPTURECONSTANT_SM_CXSCREEN = 0
GLOBAL CONST $__SCREENCAPTURECONSTANT_SM_CYSCREEN = 1
GLOBAL CONST $__SCREENCAPTURECONSTANT_SRCCOPY = 13369376
FUNC _SCREENCAPTURE_CAPTURE($SFILENAME = "", $ILEFT = 0, $ITOP = 0, $IRIGHT = -1, $IBOTTOM = -1, $BCURSOR = TRUE)
	LOCAL $BRET = FALSE
	IF $IRIGHT = -1 THEN $IRIGHT = _WINAPI_GETSYSTEMMETRICS($__SCREENCAPTURECONSTANT_SM_CXSCREEN) - 1
	IF $IBOTTOM = -1 THEN $IBOTTOM = _WINAPI_GETSYSTEMMETRICS($__SCREENCAPTURECONSTANT_SM_CYSCREEN) - 1
	IF $IRIGHT < $ILEFT THEN RETURN SETERROR(-1, 0, $BRET)
	IF $IBOTTOM < $ITOP THEN RETURN SETERROR(-2, 0, $BRET)
	LOCAL $IW = ($IRIGHT - $ILEFT) + 1
	LOCAL $IH = ($IBOTTOM - $ITOP) + 1
	LOCAL $HWND = _WINAPI_GETDESKTOPWINDOW()
	LOCAL $HDDC = _WINAPI_GETDC($HWND)
	LOCAL $HCDC = _WINAPI_CREATECOMPATIBLEDC($HDDC)
	LOCAL $HBMP = _WINAPI_CREATECOMPATIBLEBITMAP($HDDC, $IW, $IH)
	_WINAPI_SELECTOBJECT($HCDC, $HBMP)
	_WINAPI_BITBLT($HCDC, 0, 0, $IW, $IH, $HDDC, $ILEFT, $ITOP, $__SCREENCAPTURECONSTANT_SRCCOPY)
	IF $BCURSOR THEN
		LOCAL $ACURSOR = _WINAPI_GETCURSORINFO()
		IF NOT @ERROR AND $ACURSOR[1] THEN
			$BCURSOR = TRUE
			LOCAL $HICON = _WINAPI_COPYICON($ACURSOR[2])
			LOCAL $AICON = _WINAPI_GETICONINFO($HICON)
			IF NOT @ERROR THEN
				_WINAPI_DELETEOBJECT($AICON[4])
				IF $AICON[5] <> 0 THEN _WINAPI_DELETEOBJECT($AICON[5])
				_WINAPI_DRAWICON($HCDC, $ACURSOR[3] - $AICON[2] - $ILEFT, $ACURSOR[4] - $AICON[3] - $ITOP, $HICON)
			ENDIF
			_WINAPI_DESTROYICON($HICON)
		ENDIF
	ENDIF
	_WINAPI_RELEASEDC($HWND, $HDDC)
	_WINAPI_DELETEDC($HCDC)
	IF $SFILENAME = "" THEN RETURN $HBMP
	$BRET = _SCREENCAPTURE_SAVEIMAGE($SFILENAME, $HBMP, TRUE)
	RETURN SETERROR(@ERROR, @EXTENDED, $BRET)
ENDFUNC
FUNC _SCREENCAPTURE_CAPTUREWND($SFILENAME, $HWND, $ILEFT = 0, $ITOP = 0, $IRIGHT = -1, $IBOTTOM = -1, $BCURSOR = TRUE)
	IF NOT ISHWND($HWND) THEN $HWND = WINGETHANDLE($HWND)
	LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
	LOCAL CONST $DWMWA_EXTENDED_FRAME_BOUNDS = 9
	LOCAL $BRET = DLLCALL("dwmapi.dll", "long", "DwmGetWindowAttribute", "hwnd", $HWND, "dword", $DWMWA_EXTENDED_FRAME_BOUNDS, "struct*", $TRECT, "dword", DLLSTRUCTGETSIZE($TRECT))
	IF(@ERROR OR $BRET[0] OR(ABS(DLLSTRUCTGETDATA($TRECT, "Left")) + ABS(DLLSTRUCTGETDATA($TRECT, "Top")) + ABS(DLLSTRUCTGETDATA($TRECT, "Right")) + ABS(DLLSTRUCTGETDATA($TRECT, "Bottom"))) = 0) THEN
		$TRECT = _WINAPI_GETWINDOWRECT($HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
	ENDIF
	$ILEFT += DLLSTRUCTGETDATA($TRECT, "Left")
	$ITOP += DLLSTRUCTGETDATA($TRECT, "Top")
	IF $IRIGHT = -1 THEN $IRIGHT = DLLSTRUCTGETDATA($TRECT, "Right") - DLLSTRUCTGETDATA($TRECT, "Left") - 1
	IF $IBOTTOM = -1 THEN $IBOTTOM = DLLSTRUCTGETDATA($TRECT, "Bottom") - DLLSTRUCTGETDATA($TRECT, "Top") - 1
	$IRIGHT += DLLSTRUCTGETDATA($TRECT, "Left")
	$IBOTTOM += DLLSTRUCTGETDATA($TRECT, "Top")
	IF $ILEFT > DLLSTRUCTGETDATA($TRECT, "Right") THEN $ILEFT = DLLSTRUCTGETDATA($TRECT, "Left")
	IF $ITOP > DLLSTRUCTGETDATA($TRECT, "Bottom") THEN $ITOP = DLLSTRUCTGETDATA($TRECT, "Top")
	IF $IRIGHT > DLLSTRUCTGETDATA($TRECT, "Right") THEN $IRIGHT = DLLSTRUCTGETDATA($TRECT, "Right") - 1
	IF $IBOTTOM > DLLSTRUCTGETDATA($TRECT, "Bottom") THEN $IBOTTOM = DLLSTRUCTGETDATA($TRECT, "Bottom") - 1
	$BRET = _SCREENCAPTURE_CAPTURE($SFILENAME, $ILEFT, $ITOP, $IRIGHT, $IBOTTOM, $BCURSOR)
	RETURN SETERROR(@ERROR, @EXTENDED, $BRET)
ENDFUNC
FUNC _SCREENCAPTURE_SAVEIMAGE($SFILENAME, $HBITMAP, $BFREEBMP = TRUE)
	_GDIPLUS_STARTUP()
	IF @ERROR THEN RETURN SETERROR(-1, -1, FALSE)
	LOCAL $SEXT = STRINGUPPER(__GDIPLUS_EXTRACTFILEEXT($SFILENAME))
	LOCAL $SCLSID = _GDIPLUS_ENCODERSGETCLSID($SEXT)
	IF $SCLSID = "" THEN RETURN SETERROR(-2, -2, FALSE)
	LOCAL $HIMAGE = _GDIPLUS_BITMAPCREATEFROMHBITMAP($HBITMAP)
	IF @ERROR THEN RETURN SETERROR(-3, -3, FALSE)
	LOCAL $TDATA, $TPARAMS
	SWITCH $SEXT
		CASE "BMP"
			LOCAL $IX = _GDIPLUS_IMAGEGETWIDTH($HIMAGE)
			LOCAL $IY = _GDIPLUS_IMAGEGETHEIGHT($HIMAGE)
			LOCAL $HCLONE = _GDIPLUS_BITMAPCLONEAREA($HIMAGE, 0, 0, $IX, $IY, $__G_IBMPFORMAT)
			_GDIPLUS_IMAGEDISPOSE($HIMAGE)
			$HIMAGE = $HCLONE
		CASE "JPG", "JPEG"
			$TPARAMS = _GDIPLUS_PARAMINIT(1)
			$TDATA = DLLSTRUCTCREATE("int Quality")
			DLLSTRUCTSETDATA($TDATA, "Quality", $__G_IJPGQUALITY)
			_GDIPLUS_PARAMADD($TPARAMS, $GDIP_EPGQUALITY, 1, $GDIP_EPTLONG, DLLSTRUCTGETPTR($TDATA))
		CASE "TIF", "TIFF"
			$TPARAMS = _GDIPLUS_PARAMINIT(2)
			$TDATA = DLLSTRUCTCREATE("int ColorDepth;int Compression")
			DLLSTRUCTSETDATA($TDATA, "ColorDepth", $__G_ITIFCOLORDEPTH)
			DLLSTRUCTSETDATA($TDATA, "Compression", $__G_ITIFCOMPRESSION)
			_GDIPLUS_PARAMADD($TPARAMS, $GDIP_EPGCOLORDEPTH, 1, $GDIP_EPTLONG, DLLSTRUCTGETPTR($TDATA, "ColorDepth"))
			_GDIPLUS_PARAMADD($TPARAMS, $GDIP_EPGCOMPRESSION, 1, $GDIP_EPTLONG, DLLSTRUCTGETPTR($TDATA, "Compression"))
	ENDSWITCH
	LOCAL $PPARAMS = 0
	IF ISDLLSTRUCT($TPARAMS) THEN $PPARAMS = $TPARAMS
	LOCAL $BRET = _GDIPLUS_IMAGESAVETOFILEEX($HIMAGE, $SFILENAME, $SCLSID, $PPARAMS)
	_GDIPLUS_IMAGEDISPOSE($HIMAGE)
	IF $BFREEBMP THEN _WINAPI_DELETEOBJECT($HBITMAP)
	_GDIPLUS_SHUTDOWN()
	RETURN SETERROR($BRET = FALSE, 0, $BRET)
ENDFUNC
FUNC _SCREENCAPTURE_SETBMPFORMAT($IFORMAT)
	SWITCH $IFORMAT
		CASE 0
			$__G_IBMPFORMAT = $GDIP_PXF16RGB555
		CASE 1
			$__G_IBMPFORMAT = $GDIP_PXF16RGB565
		CASE 2
			$__G_IBMPFORMAT = $GDIP_PXF24RGB
		CASE 3
			$__G_IBMPFORMAT = $GDIP_PXF32RGB
		CASE 4
			$__G_IBMPFORMAT = $GDIP_PXF32ARGB
		CASE ELSE
			$__G_IBMPFORMAT = $GDIP_PXF24RGB
	ENDSWITCH
ENDFUNC
FUNC _SCREENCAPTURE_SETJPGQUALITY($IQUALITY)
	IF $IQUALITY < 0 THEN $IQUALITY = 0
	IF $IQUALITY > 100 THEN $IQUALITY = 100
	$__G_IJPGQUALITY = $IQUALITY
ENDFUNC
FUNC _SCREENCAPTURE_SETTIFCOLORDEPTH($IDEPTH)
	SWITCH $IDEPTH
		CASE 24
			$__G_ITIFCOLORDEPTH = 24
		CASE 32
			$__G_ITIFCOLORDEPTH = 32
		CASE ELSE
			$__G_ITIFCOLORDEPTH = 0
	ENDSWITCH
ENDFUNC
FUNC _SCREENCAPTURE_SETTIFCOMPRESSION($ICOMPRESS)
	SWITCH $ICOMPRESS
		CASE 1
			$__G_ITIFCOMPRESSION = $GDIP_EVTCOMPRESSIONNONE
		CASE 2
			$__G_ITIFCOMPRESSION = $GDIP_EVTCOMPRESSIONLZW
		CASE ELSE
			$__G_ITIFCOMPRESSION = 0
	ENDSWITCH
ENDFUNC
#Region Global Variables and Constants
	GLOBAL CONST $_ARRAYCONSTANT_SORTINFOSIZE = 11
	GLOBAL $__G_AARRAYDISPLAY_SORTINFO[$_ARRAYCONSTANT_SORTINFOSIZE]
	GLOBAL CONST $ARRAYDISPLAY_COLALIGNLEFT = 0
	GLOBAL CONST $ARRAYDISPLAY_TRANSPOSE = 1
	GLOBAL CONST $ARRAYDISPLAY_COLALIGNRIGHT = 2
	GLOBAL CONST $ARRAYDISPLAY_COLALIGNCENTER = 4
	GLOBAL CONST $ARRAYDISPLAY_VERBOSE = 8
	GLOBAL CONST $ARRAYDISPLAY_NOROW = 64
	GLOBAL CONST $_ARRAYCONSTANT_TAGHDITEM = "uint Mask;int XY;ptr Text;handle hBMP;int TextMax;int Fmt;lparam Param;int Image;int Order;uint Type;ptr pFilter;uint State"
	GLOBAL CONST $_ARRAYCONSTANT_TAGLVITEM = "struct;uint Mask;int Item;int SubItem;uint State;uint StateMask;ptr Text;int TextMax;int Image;lparam Param;" & "int Indent;int GroupID;uint Columns;ptr pColumns;ptr piColFmt;int iGroup;endstruct"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
FUNC __ARRAYDISPLAY_SHARE(CONST BYREF $AARRAY, $STITLE = DEFAULT, $SARRAYRANGE = DEFAULT, $IFLAGS = DEFAULT, $VUSER_SEPARATOR = DEFAULT, $SHEADER = DEFAULT, $IMAX_COLWIDTH = DEFAULT, $HUSER_FUNCTION = DEFAULT, $BDEBUG = TRUE)
	LOCAL $VTMP, $SMSGBOXTITLE = (($BDEBUG) ? ("DebugArray") : ("ArrayDisplay"))
	IF $STITLE = DEFAULT THEN $STITLE = $SMSGBOXTITLE
	IF $SARRAYRANGE = DEFAULT THEN $SARRAYRANGE = ""
	IF $IFLAGS = DEFAULT THEN $IFLAGS = 0
	IF $VUSER_SEPARATOR = DEFAULT THEN $VUSER_SEPARATOR = ""
	IF $SHEADER = DEFAULT THEN $SHEADER = ""
	IF $IMAX_COLWIDTH = DEFAULT THEN $IMAX_COLWIDTH = 350
	IF $HUSER_FUNCTION = DEFAULT THEN $HUSER_FUNCTION = 0
	LOCAL $ITRANSPOSE = BITAND($IFLAGS, $ARRAYDISPLAY_TRANSPOSE)
	LOCAL $ICOLALIGN = BITAND($IFLAGS, 6)
	LOCAL $IVERBOSE = BITAND($IFLAGS, $ARRAYDISPLAY_VERBOSE)
	LOCAL $INOROW = BITAND($IFLAGS, $ARRAYDISPLAY_NOROW)
	LOCAL $IBUTTONBORDER = (($BDEBUG) ? (40) : (20))
	LOCAL $SMSG = "", $IRET = 1
	IF ISARRAY($AARRAY) THEN
		LOCAL $IDIMENSION = UBOUND($AARRAY, $UBOUND_DIMENSIONS), $IROWCOUNT = UBOUND($AARRAY, $UBOUND_ROWS), $ICOLCOUNT = UBOUND($AARRAY, $UBOUND_COLUMNS)
		IF $IDIMENSION > 2 THEN
			$SMSG = "Larger than 2D array passed to function"
			$IRET = 2
		ENDIF
		IF $IDIMENSION = 1 THEN
			$ITRANSPOSE = 0
		ENDIF
	ELSE
		$SMSG = "No array variable passed to function"
	ENDIF
	IF $SMSG THEN
		IF $IVERBOSE AND MSGBOX($MB_SYSTEMMODAL + $MB_ICONERROR + $MB_YESNO, $SMSGBOXTITLE & " Error: " & $STITLE, $SMSG & @CRLF & @CRLF & "Exit the script?") = $IDYES THEN
			EXIT
		ELSE
			RETURN SETERROR($IRET, 0, 0)
		ENDIF
	ENDIF
	LOCAL $ICW_COLWIDTH = NUMBER($VUSER_SEPARATOR)
	LOCAL $SCURR_SEPARATOR = OPT("GUIDataSeparatorChar")
	IF $VUSER_SEPARATOR = "" THEN $VUSER_SEPARATOR = $SCURR_SEPARATOR
	LOCAL $IITEM_START = 0, $IITEM_END = $IROWCOUNT - 1, $ISUBITEM_START = 0, $ISUBITEM_END = (($IDIMENSION = 2) ? ($ICOLCOUNT - 1) : (0))
	LOCAL $BRANGE_FLAG = FALSE, $AVRANGESPLIT
	IF $SARRAYRANGE THEN
		LOCAL $AARRAY_RANGE = STRINGREGEXP($SARRAYRANGE & "||", "(?U)(.*)\|", 3)
		IF $AARRAY_RANGE[0] THEN
			$AVRANGESPLIT = STRINGSPLIT($AARRAY_RANGE[0], ":")
			IF @ERROR THEN
				$IITEM_END = NUMBER($AVRANGESPLIT[1])
			ELSE
				$IITEM_START = NUMBER($AVRANGESPLIT[1])
				IF $AVRANGESPLIT[2] <> "" THEN
					$IITEM_END = NUMBER($AVRANGESPLIT[2])
				ENDIF
			ENDIF
		ENDIF
		IF $IITEM_START < 0 THEN $IITEM_START = 0
		IF $IITEM_END > $IROWCOUNT - 1 THEN $IITEM_END = $IROWCOUNT - 1
		IF $IITEM_START > $IITEM_END THEN
			$VTMP = $IITEM_START
			$IITEM_START = $IITEM_END
			$IITEM_END = $VTMP
		ENDIF
		IF $IITEM_START <> 0 OR $IITEM_END <> $IROWCOUNT - 1 THEN $BRANGE_FLAG = TRUE
		IF $IDIMENSION = 2 AND $AARRAY_RANGE[1] THEN
			$AVRANGESPLIT = STRINGSPLIT($AARRAY_RANGE[1], ":")
			IF @ERROR THEN
				$ISUBITEM_END = NUMBER($AVRANGESPLIT[1])
			ELSE
				$ISUBITEM_START = NUMBER($AVRANGESPLIT[1])
				IF $AVRANGESPLIT[2] <> "" THEN
					$ISUBITEM_END = NUMBER($AVRANGESPLIT[2])
				ENDIF
			ENDIF
			IF $ISUBITEM_START > $ISUBITEM_END THEN
				$VTMP = $ISUBITEM_START
				$ISUBITEM_START = $ISUBITEM_END
				$ISUBITEM_END = $VTMP
			ENDIF
			IF $ISUBITEM_START < 0 THEN $ISUBITEM_START = 0
			IF $ISUBITEM_END > $ICOLCOUNT - 1 THEN $ISUBITEM_END = $ICOLCOUNT - 1
			IF $ISUBITEM_START <> 0 OR $ISUBITEM_END <> $ICOLCOUNT - 1 THEN $BRANGE_FLAG = TRUE
		ENDIF
	ENDIF
	LOCAL $SDISPLAYDATA = "[" & $IROWCOUNT & "]"
	IF $IDIMENSION = 2 THEN
		$SDISPLAYDATA &= " [" & $ICOLCOUNT & "]"
	ENDIF
	LOCAL $STIPDATA = ""
	IF $BRANGE_FLAG THEN
		IF $STIPDATA THEN $STIPDATA &= " - "
		$STIPDATA &= "Range set"
	ENDIF
	IF $ITRANSPOSE THEN
		IF $STIPDATA THEN $STIPDATA &= " - "
		$STIPDATA &= "Transposed"
	ENDIF
	LOCAL $ASHEADER = STRINGSPLIT($SHEADER, $SCURR_SEPARATOR, $STR_NOCOUNT)
	IF UBOUND($ASHEADER) = 0 THEN LOCAL $ASHEADER[1] = [""]
	$SHEADER = "Row"
	LOCAL $IINDEX = $ISUBITEM_START
	IF $ITRANSPOSE THEN
		$SHEADER = "Col"
		FOR $J = $IITEM_START TO $IITEM_END
			$SHEADER &= $SCURR_SEPARATOR & "Row " & $J
		NEXT
	ELSE
		IF $ASHEADER[0] THEN
			FOR $IINDEX = $ISUBITEM_START TO $ISUBITEM_END
				IF $IINDEX >= UBOUND($ASHEADER) THEN EXITLOOP
				$SHEADER &= $SCURR_SEPARATOR & $ASHEADER[$IINDEX]
			NEXT
		ENDIF
		FOR $J = $IINDEX TO $ISUBITEM_END
			$SHEADER &= $SCURR_SEPARATOR & "Col " & $J
		NEXT
	ENDIF
	IF $INOROW THEN $SHEADER = STRINGTRIMLEFT($SHEADER, 4)
	IF $IVERBOSE AND($IITEM_END - $IITEM_START + 1) * ($ISUBITEM_END - $ISUBITEM_START + 1) > 10000 THEN
		SPLASHTEXTON($SMSGBOXTITLE, "Preparing display" & @CRLF & @CRLF & "Please be patient", 300, 100)
	ENDIF
	LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKBOTTOM = 64
	LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKBORDERS = 102
	LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKHEIGHT = 512
	LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKLEFT = 2
	LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKRIGHT = 4
	LOCAL CONST $_ARRAYCONSTANT_GUI_DOCKHCENTER = 8
	LOCAL CONST $_ARRAYCONSTANT_GUI_EVENT_CLOSE = -3
	LOCAL CONST $_ARRAYCONSTANT_GUI_FOCUS = 256
	LOCAL CONST $_ARRAYCONSTANT_SS_CENTER = 1
	LOCAL CONST $_ARRAYCONSTANT_SS_CENTERIMAGE = 512
	LOCAL CONST $_ARRAYCONSTANT_LVM_GETITEMCOUNT = (4096 + 4)
	LOCAL CONST $_ARRAYCONSTANT_LVM_GETITEMRECT = (4096 + 14)
	LOCAL CONST $_ARRAYCONSTANT_LVM_GETCOLUMNWIDTH = (4096 + 29)
	LOCAL CONST $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH = (4096 + 30)
	LOCAL CONST $_ARRAYCONSTANT_LVM_GETITEMSTATE = (4096 + 44)
	LOCAL CONST $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT = (4096 + 50)
	LOCAL CONST $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE = (4096 + 54)
	LOCAL CONST $_ARRAYCONSTANT_LVS_EX_GRIDLINES = 1
	LOCAL CONST $_ARRAYCONSTANT_LVIS_SELECTED = 2
	LOCAL CONST $_ARRAYCONSTANT_LVS_SHOWSELALWAYS = 8
	LOCAL CONST $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT = 32
	LOCAL CONST $_ARRAYCONSTANT_WS_EX_CLIENTEDGE = 512
	LOCAL CONST $_ARRAYCONSTANT_WS_MAXIMIZEBOX = 65536
	LOCAL CONST $_ARRAYCONSTANT_WS_MINIMIZEBOX = 131072
	LOCAL CONST $_ARRAYCONSTANT_WS_SIZEBOX = 262144
	LOCAL CONST $_ARRAYCONSTANT_WM_SETREDRAW = 11
	LOCAL CONST $_ARRAYCONSTANT_LVSCW_AUTOSIZE = -1
	LOCAL CONST $_ARRAYCONSTANT_LVSCW_AUTOSIZE_USEHEADER = -2
	LOCAL $ICOORDMODE = OPT("GUICoordMode", 1)
	LOCAL $IORGWIDTH = 210, $IHEIGHT = 200, $IMINSIZE = 250
	LOCAL $HGUI = GUICREATE($STITLE, $IORGWIDTH, $IHEIGHT, DEFAULT, DEFAULT, BITOR($_ARRAYCONSTANT_WS_SIZEBOX, $_ARRAYCONSTANT_WS_MINIMIZEBOX, $_ARRAYCONSTANT_WS_MAXIMIZEBOX))
	LOCAL $AIGUISIZE = WINGETCLIENTSIZE($HGUI)
	LOCAL $IBUTTONWIDTH_1 = $AIGUISIZE[0] / 2
	LOCAL $IBUTTONWIDTH_2 = $AIGUISIZE[0] / 3
	LOCAL $IDLISTVIEW = GUICTRLCREATELISTVIEW($SHEADER, 0, 0, $AIGUISIZE[0], $AIGUISIZE[1] - $IBUTTONBORDER, $_ARRAYCONSTANT_LVS_SHOWSELALWAYS)
	GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_GRIDLINES, $_ARRAYCONSTANT_LVS_EX_GRIDLINES)
	GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT, $_ARRAYCONSTANT_LVS_EX_FULLROWSELECT)
	GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_SETEXTENDEDLISTVIEWSTYLE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE, $_ARRAYCONSTANT_WS_EX_CLIENTEDGE)
	LOCAL $IDCOPY_ID = 9999, $IDCOPY_DATA = 99999, $IDDATA_LABEL = 99999, $IDUSER_FUNC = 99999, $IDEXIT_SCRIPT = 99999
	IF $BDEBUG THEN
		$IDCOPY_ID = GUICTRLCREATEBUTTON("Copy Data && Hdr/Row", 0, $AIGUISIZE[1] - $IBUTTONBORDER, $IBUTTONWIDTH_1, 20)
		$IDCOPY_DATA = GUICTRLCREATEBUTTON("Copy Data Only", $IBUTTONWIDTH_1, $AIGUISIZE[1] - $IBUTTONBORDER, $IBUTTONWIDTH_1, 20)
		LOCAL $IBUTTONWIDTH_VAR = $IBUTTONWIDTH_1
		LOCAL $IOFFSET = $IBUTTONWIDTH_1
		IF ISFUNC($HUSER_FUNCTION) THEN
			$IDUSER_FUNC = GUICTRLCREATEBUTTON("Run User Func", $IBUTTONWIDTH_2, $AIGUISIZE[1] - 20, $IBUTTONWIDTH_2, 20)
			$IBUTTONWIDTH_VAR = $IBUTTONWIDTH_2
			$IOFFSET = $IBUTTONWIDTH_2 * 2
		ENDIF
		$IDEXIT_SCRIPT = GUICTRLCREATEBUTTON("Exit Script", $IOFFSET, $AIGUISIZE[1] - 20, $IBUTTONWIDTH_VAR, 20)
		$IDDATA_LABEL = GUICTRLCREATELABEL($SDISPLAYDATA, 0, $AIGUISIZE[1] - 20, $IBUTTONWIDTH_VAR, 18, BITOR($_ARRAYCONSTANT_SS_CENTER, $_ARRAYCONSTANT_SS_CENTERIMAGE))
	ELSE
		$IDDATA_LABEL = GUICTRLCREATELABEL($SDISPLAYDATA, 0, $AIGUISIZE[1] - 20, $AIGUISIZE[0], 18, BITOR($_ARRAYCONSTANT_SS_CENTER, $_ARRAYCONSTANT_SS_CENTERIMAGE))
	ENDIF
	SELECT
		CASE $ITRANSPOSE OR $BRANGE_FLAG
			GUICTRLSETCOLOR($IDDATA_LABEL, 16711680)
			GUICTRLSETTIP($IDDATA_LABEL, $STIPDATA)
	ENDSELECT
	GUICTRLSETRESIZING($IDLISTVIEW, $_ARRAYCONSTANT_GUI_DOCKBORDERS)
	GUICTRLSETRESIZING($IDCOPY_ID, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
	GUICTRLSETRESIZING($IDCOPY_DATA, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
	GUICTRLSETRESIZING($IDDATA_LABEL, $_ARRAYCONSTANT_GUI_DOCKLEFT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
	GUICTRLSETRESIZING($IDUSER_FUNC, $_ARRAYCONSTANT_GUI_DOCKHCENTER + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
	GUICTRLSETRESIZING($IDEXIT_SCRIPT, $_ARRAYCONSTANT_GUI_DOCKRIGHT + $_ARRAYCONSTANT_GUI_DOCKBOTTOM + $_ARRAYCONSTANT_GUI_DOCKHEIGHT)
	GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_WM_SETREDRAW, 0, 0)
	LOCAL $IROWINDEX, $ICOLFILL
	IF $ITRANSPOSE THEN
		FOR $I = $ISUBITEM_START TO $ISUBITEM_END
			$IROWINDEX = __ARRAYDISPLAY_ADDITEM($IDLISTVIEW, "NULL")
			IF $INOROW THEN
				$ICOLFILL = 0
			ELSE
				__ARRAYDISPLAY_ADDSUBITEM($IDLISTVIEW, $IROWINDEX, "Col " & $I, 0)
				$ICOLFILL = 1
			ENDIF
			FOR $J = $IITEM_START TO $IITEM_END
				IF $IDIMENSION = 2 THEN
					$VTMP = $AARRAY[$J][$I]
				ELSE
					$VTMP = $AARRAY[$J]
				ENDIF
				SWITCH VARGETTYPE($VTMP)
					CASE "Array"
						__ARRAYDISPLAY_ADDSUBITEM($IDLISTVIEW, $IROWINDEX, "{Array}", $ICOLFILL)
					CASE ELSE
						__ARRAYDISPLAY_ADDSUBITEM($IDLISTVIEW, $IROWINDEX, $VTMP, $ICOLFILL)
				ENDSWITCH
				$ICOLFILL += 1
			NEXT
		NEXT
	ELSE
		FOR $I = $IITEM_START TO $IITEM_END
			$IROWINDEX = __ARRAYDISPLAY_ADDITEM($IDLISTVIEW, "NULL")
			IF $INOROW THEN
				$ICOLFILL = 0
			ELSE
				__ARRAYDISPLAY_ADDSUBITEM($IDLISTVIEW, $IROWINDEX, "Row " & $I, 0)
				$ICOLFILL = 1
			ENDIF
			FOR $J = $ISUBITEM_START TO $ISUBITEM_END
				IF $IDIMENSION = 2 THEN
					$VTMP = $AARRAY[$I][$J]
				ELSE
					$VTMP = $AARRAY[$I]
				ENDIF
				SWITCH VARGETTYPE($VTMP)
					CASE "Array"
						__ARRAYDISPLAY_ADDSUBITEM($IDLISTVIEW, $IROWINDEX, "{Array}", $ICOLFILL)
					CASE ELSE
						__ARRAYDISPLAY_ADDSUBITEM($IDLISTVIEW, $IROWINDEX, $VTMP, $ICOLFILL)
				ENDSWITCH
				$ICOLFILL += 1
			NEXT
		NEXT
	ENDIF
	IF $ICOLALIGN THEN
		FOR $I = 0 TO $ICOLFILL - 1
			__ARRAYDISPLAY_JUSTIFYCOLUMN($IDLISTVIEW, $I, $ICOLALIGN / 2)
		NEXT
	ENDIF
	GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_WM_SETREDRAW, 1, 0)
	LOCAL $IBORDER = (($IROWINDEX > 19) ? (65) : (45))
	LOCAL $IWIDTH = $IBORDER, $ICOLWIDTH = 0, $AICOLWIDTH[$ICOLFILL], $IMIN_COLWIDTH = 55
	FOR $I = 0 TO UBOUND($AICOLWIDTH) - 1
		GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $I, $_ARRAYCONSTANT_LVSCW_AUTOSIZE)
		$ICOLWIDTH = GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_GETCOLUMNWIDTH, $I, 0)
		IF $SHEADER <> "" THEN
			GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $I, $_ARRAYCONSTANT_LVSCW_AUTOSIZE_USEHEADER)
			LOCAL $ICOLWIDTHHEADER = GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_GETCOLUMNWIDTH, $I, 0)
			IF $ICOLWIDTH < $IMIN_COLWIDTH AND $ICOLWIDTHHEADER < $IMIN_COLWIDTH THEN
				GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $I, $IMIN_COLWIDTH)
				$ICOLWIDTH = $IMIN_COLWIDTH
			ELSEIF $ICOLWIDTHHEADER < $ICOLWIDTH THEN
				GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $I, $ICOLWIDTH)
			ELSE
				$ICOLWIDTH = $ICOLWIDTHHEADER
			ENDIF
		ELSE
			IF $ICOLWIDTH < $IMIN_COLWIDTH THEN
				GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $I, $IMIN_COLWIDTH)
				$ICOLWIDTH = $IMIN_COLWIDTH
			ENDIF
		ENDIF
		$IWIDTH += $ICOLWIDTH
		$AICOLWIDTH[$I] = $ICOLWIDTH
	NEXT
	IF $IWIDTH > @DESKTOPWIDTH - 100 THEN
		$IWIDTH = $IBORDER
		FOR $I = 0 TO UBOUND($AICOLWIDTH) - 1
			IF $AICOLWIDTH[$I] > $IMAX_COLWIDTH THEN
				GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_SETCOLUMNWIDTH, $I, $IMAX_COLWIDTH)
				$IWIDTH += $IMAX_COLWIDTH
			ELSE
				$IWIDTH += $AICOLWIDTH[$I]
			ENDIF
		NEXT
	ENDIF
	IF $IWIDTH > @DESKTOPWIDTH - 100 THEN
		$IWIDTH = @DESKTOPWIDTH - 100
	ELSEIF $IWIDTH < $IMINSIZE THEN
		$IWIDTH = $IMINSIZE
	ENDIF
	LOCAL $TRECT = DLLSTRUCTCREATE("struct; long Left;long Top;long Right;long Bottom; endstruct")
	DLLCALL("user32.dll", "struct*", "SendMessageW", "hwnd", GUICTRLGETHANDLE($IDLISTVIEW), "uint", $_ARRAYCONSTANT_LVM_GETITEMRECT, "wparam", 0, "struct*", $TRECT)
	LOCAL $AIWIN_POS = WINGETPOS($HGUI)
	LOCAL $AILV_POS = CONTROLGETPOS($HGUI, "", $IDLISTVIEW)
	$IHEIGHT = (($IROWINDEX + 4) * (DLLSTRUCTGETDATA($TRECT, "Bottom") - DLLSTRUCTGETDATA($TRECT, "Top"))) + $AIWIN_POS[3] - $AILV_POS[3]
	IF $IHEIGHT > @DESKTOPHEIGHT - 100 THEN
		$IHEIGHT = @DESKTOPHEIGHT - 100
	ELSEIF $IHEIGHT < $IMINSIZE THEN
		$IHEIGHT = $IMINSIZE
	ENDIF
	IF $IVERBOSE THEN SPLASHOFF()
	GUISETSTATE(@SW_HIDE, $HGUI)
	WINMOVE($HGUI, "", (@DESKTOPWIDTH - $IWIDTH) / 2, (@DESKTOPHEIGHT - $IHEIGHT) / 2, $IWIDTH, $IHEIGHT)
	GUISETSTATE(@SW_SHOW, $HGUI)
	LOCAL $IONEVENTMODE = OPT("GUIOnEventMode", 0), $IMSG
	__ARRAYDISPLAY_REGISTERSORTCALLBACK($IDLISTVIEW, 2, TRUE, "__ArrayDisplay_SortCallBack")
	WHILE 1
		$IMSG = GUIGETMSG()
		SWITCH $IMSG
			CASE $_ARRAYCONSTANT_GUI_EVENT_CLOSE
				EXITLOOP
			CASE $IDCOPY_ID, $IDCOPY_DATA
				LOCAL $ISEL_COUNT = GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_GETSELECTEDCOUNT, 0, 0)
				IF $IVERBOSE AND(NOT $ISEL_COUNT) AND($IITEM_END - $IITEM_START) * ($ISUBITEM_END - $ISUBITEM_START) > 10000 THEN
					SPLASHTEXTON($SMSGBOXTITLE, "Copying data" & @CRLF & @CRLF & "Please be patient", 300, 100)
				ENDIF
				LOCAL $SCLIP = "", $SITEM, $ASPLIT
				FOR $I = 0 TO GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_GETITEMCOUNT, 0, 0) - 1
					IF $ISEL_COUNT AND NOT(GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $I, $_ARRAYCONSTANT_LVIS_SELECTED) <> 0) THEN
						CONTINUELOOP
					ENDIF
					$SITEM = __ARRAYDISPLAY_GETITEMTEXTSTRING($IDLISTVIEW, $I)
					IF $IMSG = $IDCOPY_ID AND $INOROW THEN
						$SITEM = "Row " & ($I + (($ITRANSPOSE) ? ($ISUBITEM_START) : ($IITEM_START))) & $SCURR_SEPARATOR & $SITEM
					ENDIF
					IF $IMSG = $IDCOPY_DATA AND NOT $INOROW THEN
						$SITEM = STRINGREGEXPREPLACE($SITEM, "^Row\s\d+\|(.*)$", "$1")
					ENDIF
					IF $ICW_COLWIDTH THEN
						$ASPLIT = STRINGSPLIT($SITEM, $SCURR_SEPARATOR)
						$SITEM = ""
						FOR $J = 1 TO $ASPLIT[0]
							$SITEM &= STRINGFORMAT("%-" & $ICW_COLWIDTH + 1 & "s", STRINGLEFT($ASPLIT[$J], $ICW_COLWIDTH))
						NEXT
					ELSE
						$SITEM = STRINGREPLACE($SITEM, $SCURR_SEPARATOR, $VUSER_SEPARATOR)
					ENDIF
					$SCLIP &= $SITEM & @CRLF
				NEXT
				$SITEM = $SHEADER
				IF $IMSG = $IDCOPY_ID THEN
					$SITEM = $SHEADER
					IF $INOROW THEN
						$SITEM = "Row|" & $SITEM
					ENDIF
					IF $ICW_COLWIDTH THEN
						$ASPLIT = STRINGSPLIT($SITEM, $SCURR_SEPARATOR)
						$SITEM = ""
						FOR $J = 1 TO $ASPLIT[0]
							$SITEM &= STRINGFORMAT("%-" & $ICW_COLWIDTH + 1 & "s", STRINGLEFT($ASPLIT[$J], $ICW_COLWIDTH))
						NEXT
					ELSE
						$SITEM = STRINGREPLACE($SITEM, $SCURR_SEPARATOR, $VUSER_SEPARATOR)
					ENDIF
					$SCLIP = $SITEM & @CRLF & $SCLIP
				ENDIF
				CLIPPUT($SCLIP)
				SPLASHOFF()
				GUICTRLSETSTATE($IDLISTVIEW, $_ARRAYCONSTANT_GUI_FOCUS)
			CASE $IDLISTVIEW
				__ARRAYDISPLAY_SORTITEMS($IDLISTVIEW, GUICTRLGETSTATE($IDLISTVIEW))
			CASE $IDUSER_FUNC
				LOCAL $AISELITEMS[1] = [0]
				FOR $I = 0 TO GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_GETITEMCOUNT, 0, 0) - 1
					IF(GUICTRLSENDMSG($IDLISTVIEW, $_ARRAYCONSTANT_LVM_GETITEMSTATE, $I, $_ARRAYCONSTANT_LVIS_SELECTED) <> 0) THEN
						$AISELITEMS[0] += 1
						REDIM $AISELITEMS[$AISELITEMS[0] + 1]
						$AISELITEMS[$AISELITEMS[0]] = $I + $IITEM_START
					ENDIF
				NEXT
				$HUSER_FUNCTION($AARRAY, $AISELITEMS)
				GUICTRLSETSTATE($IDLISTVIEW, $_ARRAYCONSTANT_GUI_FOCUS)
			CASE $IDEXIT_SCRIPT
				GUIDELETE($HGUI)
				EXIT
		ENDSWITCH
	WEND
	GUIDELETE($HGUI)
	OPT("GUICoordMode", $ICOORDMODE)
	OPT("GUIOnEventMode", $IONEVENTMODE)
	RETURN 1
ENDFUNC
FUNC __ARRAYDISPLAY_REGISTERSORTCALLBACK($HWND, $VCOMPARETYPE = 2, $BARROWS = TRUE, $SSORT_CALLBACK = "__ArrayDisplay_SortCallBack")
	#Au3Stripper_Ignore_Funcs=$sSort_Callback
	IF NOT ISHWND($HWND) THEN $HWND = GUICTRLGETHANDLE($HWND)
	LOCAL $HHEADER = HWND(GUICTRLSENDMSG($HWND, 4127, 0, 0))
	$__G_AARRAYDISPLAY_SORTINFO[1] = $HWND
	$__G_AARRAYDISPLAY_SORTINFO[2] = DLLCALLBACKREGISTER($SSORT_CALLBACK, "int", "int;int;hwnd")
	$__G_AARRAYDISPLAY_SORTINFO[3] = -1
	$__G_AARRAYDISPLAY_SORTINFO[4] = -1
	$__G_AARRAYDISPLAY_SORTINFO[5] = 1
	$__G_AARRAYDISPLAY_SORTINFO[6] = -1
	$__G_AARRAYDISPLAY_SORTINFO[7] = 0
	$__G_AARRAYDISPLAY_SORTINFO[8] = $VCOMPARETYPE
	$__G_AARRAYDISPLAY_SORTINFO[9] = $BARROWS
	$__G_AARRAYDISPLAY_SORTINFO[10] = $HHEADER
	RETURN $__G_AARRAYDISPLAY_SORTINFO[2] <> 0
ENDFUNC
#Au3Stripper_Ignore_Funcs=__ArrayDisplay_SortCallBack
FUNC __ARRAYDISPLAY_SORTCALLBACK($NITEM1, $NITEM2, $HWND)
	IF $__G_AARRAYDISPLAY_SORTINFO[3] = $__G_AARRAYDISPLAY_SORTINFO[4] THEN
		IF NOT $__G_AARRAYDISPLAY_SORTINFO[7] THEN
			$__G_AARRAYDISPLAY_SORTINFO[5] *= -1
			$__G_AARRAYDISPLAY_SORTINFO[7] = 1
		ENDIF
	ELSE
		$__G_AARRAYDISPLAY_SORTINFO[7] = 1
	ENDIF
	$__G_AARRAYDISPLAY_SORTINFO[6] = $__G_AARRAYDISPLAY_SORTINFO[3]
	LOCAL $SVAL1 = __ARRAYDISPLAY_GETITEMTEXT($HWND, $NITEM1, $__G_AARRAYDISPLAY_SORTINFO[3])
	LOCAL $SVAL2 = __ARRAYDISPLAY_GETITEMTEXT($HWND, $NITEM2, $__G_AARRAYDISPLAY_SORTINFO[3])
	IF $__G_AARRAYDISPLAY_SORTINFO[8] = 1 THEN
		IF(STRINGISFLOAT($SVAL1) OR STRINGISINT($SVAL1)) THEN $SVAL1 = NUMBER($SVAL1)
		IF(STRINGISFLOAT($SVAL2) OR STRINGISINT($SVAL2)) THEN $SVAL2 = NUMBER($SVAL2)
	ENDIF
	LOCAL $NRESULT
	IF $__G_AARRAYDISPLAY_SORTINFO[8] < 2 THEN
		$NRESULT = 0
		IF $SVAL1 < $SVAL2 THEN
			$NRESULT = -1
		ELSEIF $SVAL1 > $SVAL2 THEN
			$NRESULT = 1
		ENDIF
	ELSE
		$NRESULT = DLLCALL("shlwapi.dll", "int", "StrCmpLogicalW", "wstr", $SVAL1, "wstr", $SVAL2)[0]
	ENDIF
	$NRESULT = $NRESULT * $__G_AARRAYDISPLAY_SORTINFO[5]
	RETURN $NRESULT
ENDFUNC
FUNC __ARRAYDISPLAY_SORTITEMS($HWND, $ICOL)
	IF NOT ISHWND($HWND) THEN $HWND = GUICTRLGETHANDLE($HWND)
	LOCAL $PFUNCTION = DLLCALLBACKGETPTR($__G_AARRAYDISPLAY_SORTINFO[2])
	$__G_AARRAYDISPLAY_SORTINFO[3] = $ICOL
	$__G_AARRAYDISPLAY_SORTINFO[7] = 0
	$__G_AARRAYDISPLAY_SORTINFO[4] = $__G_AARRAYDISPLAY_SORTINFO[6]
	LOCAL $ARESULT = DLLCALL("user32.dll", "lresult", "SendMessageW", "hwnd", $HWND, "uint", 4177, "hwnd", $HWND, "ptr", $PFUNCTION)
	IF $ARESULT[0] <> 0 THEN
		IF $__G_AARRAYDISPLAY_SORTINFO[9] THEN
			LOCAL $HHEADER = $__G_AARRAYDISPLAY_SORTINFO[10], $IFORMAT
			FOR $X = 0 TO __ARRAYDISPLAY_GETITEMCOUNT($HHEADER) - 1
				$IFORMAT = __ARRAYDISPLAY_GETITEMFORMAT($HHEADER, $X)
				IF BITAND($IFORMAT, 512) THEN
					__ARRAYDISPLAY_SETITEMFORMAT($HHEADER, $X, BITXOR($IFORMAT, 512))
				ELSEIF BITAND($IFORMAT, 1024) THEN
					__ARRAYDISPLAY_SETITEMFORMAT($HHEADER, $X, BITXOR($IFORMAT, 1024))
				ENDIF
			NEXT
			$IFORMAT = __ARRAYDISPLAY_GETITEMFORMAT($HHEADER, $ICOL)
			IF $__G_AARRAYDISPLAY_SORTINFO[5] = 1 THEN
				__ARRAYDISPLAY_SETITEMFORMAT($HHEADER, $ICOL, BITOR($IFORMAT, 1024))
			ELSE
				__ARRAYDISPLAY_SETITEMFORMAT($HHEADER, $ICOL, BITOR($IFORMAT, 512))
			ENDIF
		ENDIF
		RETURN TRUE
	ENDIF
	RETURN FALSE
ENDFUNC
FUNC __ARRAYDISPLAY_ADDITEM($HWND, $STEXT)
	LOCAL $TITEM = DLLSTRUCTCREATE($_ARRAYCONSTANT_TAGLVITEM)
	DLLSTRUCTSETDATA($TITEM, "Param", 0)
	LOCAL $IBUFFER = STRINGLEN($STEXT) + 1
	LOCAL $TBUFFER = DLLSTRUCTCREATE("wchar Text[" & $IBUFFER & "]")
	$IBUFFER *= 2
	DLLSTRUCTSETDATA($TBUFFER, "Text", $STEXT)
	DLLSTRUCTSETDATA($TITEM, "Text", DLLSTRUCTGETPTR($TBUFFER))
	DLLSTRUCTSETDATA($TITEM, "TextMax", $IBUFFER)
	LOCAL $IMASK = 5
	DLLSTRUCTSETDATA($TITEM, "Mask", $IMASK)
	DLLSTRUCTSETDATA($TITEM, "Item", 999999999)
	DLLSTRUCTSETDATA($TITEM, "Image", -1)
	LOCAL $PITEM = DLLSTRUCTGETPTR($TITEM)
	LOCAL $IRET = GUICTRLSENDMSG($HWND, 4173, 0, $PITEM)
	RETURN $IRET
ENDFUNC
FUNC __ARRAYDISPLAY_ADDSUBITEM($HWND, $IINDEX, $STEXT, $ISUBITEM)
	LOCAL $IBUFFER = STRINGLEN($STEXT) + 1
	LOCAL $TBUFFER = DLLSTRUCTCREATE("wchar Text[" & $IBUFFER & "]")
	$IBUFFER *= 2
	LOCAL $PBUFFER = DLLSTRUCTGETPTR($TBUFFER)
	LOCAL $TITEM = DLLSTRUCTCREATE($_ARRAYCONSTANT_TAGLVITEM)
	LOCAL $IMASK = 1
	DLLSTRUCTSETDATA($TBUFFER, "Text", $STEXT)
	DLLSTRUCTSETDATA($TITEM, "Mask", $IMASK)
	DLLSTRUCTSETDATA($TITEM, "Item", $IINDEX)
	DLLSTRUCTSETDATA($TITEM, "SubItem", $ISUBITEM)
	DLLSTRUCTSETDATA($TITEM, "Image", -1)
	LOCAL $PITEM = DLLSTRUCTGETPTR($TITEM)
	DLLSTRUCTSETDATA($TITEM, "Text", $PBUFFER)
	LOCAL $IRET = GUICTRLSENDMSG($HWND, 4172, 0, $PITEM)
	RETURN $IRET <> 0
ENDFUNC
FUNC __ARRAYDISPLAY_GETCOLUMNCOUNT($HWND)
	LOCAL $HHEADER = HWND(GUICTRLSENDMSG($HWND, 4127, 0, 0))
	RETURN __ARRAYDISPLAY_GETITEMCOUNT($HHEADER)
ENDFUNC
FUNC __ARRAYDISPLAY_GETHEADER($HWND)
	RETURN HWND(GUICTRLSENDMSG($HWND, 4127, 0, 0))
ENDFUNC
FUNC __ARRAYDISPLAY_GETITEM($HWND, $IINDEX, BYREF $TITEM)
	LOCAL $ARESULT = DLLCALL("user32.dll", "lresult", "SendMessageW", "hwnd", $HWND, "uint", 4619, "wparam", $IINDEX, "struct*", $TITEM)
	RETURN $ARESULT[0] <> 0
ENDFUNC
FUNC __ARRAYDISPLAY_GETITEMCOUNT($HWND)
	LOCAL $ARESULT = DLLCALL("user32.dll", "lresult", "SendMessageW", "hwnd", $HWND, "uint", 4608, "wparam", 0, "lparam", 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC __ARRAYDISPLAY_GETITEMFORMAT($HWND, $IINDEX)
	LOCAL $TITEM = DLLSTRUCTCREATE($_ARRAYCONSTANT_TAGHDITEM)
	DLLSTRUCTSETDATA($TITEM, "Mask", 4)
	__ARRAYDISPLAY_GETITEM($HWND, $IINDEX, $TITEM)
	RETURN DLLSTRUCTGETDATA($TITEM, "Fmt")
ENDFUNC
FUNC __ARRAYDISPLAY_GETITEMTEXT($HWND, $IINDEX, $ISUBITEM = 0)
	LOCAL $TBUFFER = DLLSTRUCTCREATE("wchar Text[4096]")
	LOCAL $PBUFFER = DLLSTRUCTGETPTR($TBUFFER)
	LOCAL $TITEM = DLLSTRUCTCREATE($_ARRAYCONSTANT_TAGLVITEM)
	DLLSTRUCTSETDATA($TITEM, "SubItem", $ISUBITEM)
	DLLSTRUCTSETDATA($TITEM, "TextMax", 4096)
	DLLSTRUCTSETDATA($TITEM, "Text", $PBUFFER)
	IF ISHWND($HWND) THEN
		DLLCALL("user32.dll", "lresult", "SendMessageW", "hwnd", $HWND, "uint", 4211, "wparam", $IINDEX, "struct*", $TITEM)
	ELSE
		LOCAL $PITEM = DLLSTRUCTGETPTR($TITEM)
		GUICTRLSENDMSG($HWND, 4211, $IINDEX, $PITEM)
	ENDIF
	RETURN DLLSTRUCTGETDATA($TBUFFER, "Text")
ENDFUNC
FUNC __ARRAYDISPLAY_GETITEMTEXTSTRING($HWND, $IITEM)
	LOCAL $SROW = "", $SSEPARATORCHAR = OPT("GUIDataSeparatorChar")
	LOCAL $ISELECTED = $IITEM
	FOR $X = 0 TO __ARRAYDISPLAY_GETCOLUMNCOUNT($HWND) - 1
		$SROW &= __ARRAYDISPLAY_GETITEMTEXT($HWND, $ISELECTED, $X) & $SSEPARATORCHAR
	NEXT
	RETURN STRINGTRIMRIGHT($SROW, 1)
ENDFUNC
FUNC __ARRAYDISPLAY_JUSTIFYCOLUMN($IDLISTVIEW, $IINDEX, $IALIGN = -1)
	LOCAL $TCOLUMN = DLLSTRUCTCREATE("uint Mask;int Fmt;int CX;ptr Text;int TextMax;int SubItem;int Image;int Order;int cxMin;int cxDefault;int cxIdeal")
	IF $IALIGN < 0 OR $IALIGN > 2 THEN $IALIGN = 0
	DLLSTRUCTSETDATA($TCOLUMN, "Mask", 1)
	DLLSTRUCTSETDATA($TCOLUMN, "Fmt", $IALIGN)
	LOCAL $PCOLUMN = DLLSTRUCTGETPTR($TCOLUMN)
	LOCAL $IRET = GUICTRLSENDMSG($IDLISTVIEW, 4192, $IINDEX, $PCOLUMN)
	RETURN $IRET <> 0
ENDFUNC
FUNC __ARRAYDISPLAY_SETITEMFORMAT($HWND, $IINDEX, $IFORMAT)
	LOCAL $TITEM = DLLSTRUCTCREATE($_ARRAYCONSTANT_TAGHDITEM)
	DLLSTRUCTSETDATA($TITEM, "Mask", 4)
	DLLSTRUCTSETDATA($TITEM, "Fmt", $IFORMAT)
	LOCAL $ARESULT = DLLCALL("user32.dll", "lresult", "SendMessageW", "hwnd", $HWND, "uint", 4620, "wparam", $IINDEX, "struct*", $TITEM)
	RETURN $ARESULT[0] <> 0
ENDFUNC
GLOBAL ENUM $ARRAYFILL_FORCE_DEFAULT, $ARRAYFILL_FORCE_SINGLEITEM, $ARRAYFILL_FORCE_INT, $ARRAYFILL_FORCE_NUMBER, $ARRAYFILL_FORCE_PTR, $ARRAYFILL_FORCE_HWND, $ARRAYFILL_FORCE_STRING, $ARRAYFILL_FORCE_BOOLEAN
GLOBAL ENUM $ARRAYUNIQUE_NOCOUNT, $ARRAYUNIQUE_COUNT
GLOBAL ENUM $ARRAYUNIQUE_AUTO, $ARRAYUNIQUE_FORCE32, $ARRAYUNIQUE_FORCE64, $ARRAYUNIQUE_MATCH, $ARRAYUNIQUE_DISTINCT
FUNC _ARRAYADD(BYREF $AARRAY, $VVALUE, $ISTART = 0, $SDELIM_ITEM = "|", $SDELIM_ROW = @CRLF, $IFORCE = $ARRAYFILL_FORCE_DEFAULT)
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $SDELIM_ITEM = DEFAULT THEN $SDELIM_ITEM = "|"
	IF $SDELIM_ROW = DEFAULT THEN $SDELIM_ROW = @CRLF
	IF $IFORCE = DEFAULT THEN $IFORCE = $ARRAYFILL_FORCE_DEFAULT
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS)
	LOCAL $HDATATYPE = 0
	SWITCH $IFORCE
		CASE $ARRAYFILL_FORCE_INT
			$HDATATYPE = INT
		CASE $ARRAYFILL_FORCE_NUMBER
			$HDATATYPE = NUMBER
		CASE $ARRAYFILL_FORCE_PTR
			$HDATATYPE = PTR
		CASE $ARRAYFILL_FORCE_HWND
			$HDATATYPE = HWND
		CASE $ARRAYFILL_FORCE_STRING
			$HDATATYPE = STRING
		CASE $ARRAYFILL_FORCE_BOOLEAN
			$HDATATYPE = "Boolean"
	ENDSWITCH
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			IF $IFORCE = $ARRAYFILL_FORCE_SINGLEITEM THEN
				REDIM $AARRAY[$IDIM_1 + 1]
				$AARRAY[$IDIM_1] = $VVALUE
				RETURN $IDIM_1
			ENDIF
			IF ISARRAY($VVALUE) THEN
				IF UBOUND($VVALUE, $UBOUND_DIMENSIONS) <> 1 THEN RETURN SETERROR(5, 0, -1)
				$HDATATYPE = 0
			ELSE
				LOCAL $ATMP = STRINGSPLIT($VVALUE, $SDELIM_ITEM, $STR_NOCOUNT + $STR_ENTIRESPLIT)
				IF UBOUND($ATMP, $UBOUND_ROWS) = 1 THEN
					$ATMP[0] = $VVALUE
				ENDIF
				$VVALUE = $ATMP
			ENDIF
			LOCAL $IADD = UBOUND($VVALUE, $UBOUND_ROWS)
			REDIM $AARRAY[$IDIM_1 + $IADD]
			FOR $I = 0 TO $IADD - 1
				IF STRING($HDATATYPE) = "Boolean" THEN
					SWITCH $VVALUE[$I]
						CASE "True", "1"
							$AARRAY[$IDIM_1 + $I] = TRUE
						CASE "False", "0", ""
							$AARRAY[$IDIM_1 + $I] = FALSE
					ENDSWITCH
				ELSEIF ISFUNC($HDATATYPE) THEN
					$AARRAY[$IDIM_1 + $I] = $HDATATYPE($VVALUE[$I])
				ELSE
					$AARRAY[$IDIM_1 + $I] = $VVALUE[$I]
				ENDIF
			NEXT
			RETURN $IDIM_1 + $IADD - 1
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS)
			IF $ISTART < 0 OR $ISTART > $IDIM_2 - 1 THEN RETURN SETERROR(4, 0, -1)
			LOCAL $IVALDIM_1, $IVALDIM_2 = 0, $ICOLCOUNT
			IF ISARRAY($VVALUE) THEN
				IF UBOUND($VVALUE, $UBOUND_DIMENSIONS) <> 2 THEN RETURN SETERROR(5, 0, -1)
				$IVALDIM_1 = UBOUND($VVALUE, $UBOUND_ROWS)
				$IVALDIM_2 = UBOUND($VVALUE, $UBOUND_COLUMNS)
				$HDATATYPE = 0
			ELSE
				LOCAL $ASPLIT_1 = STRINGSPLIT($VVALUE, $SDELIM_ROW, $STR_NOCOUNT + $STR_ENTIRESPLIT)
				$IVALDIM_1 = UBOUND($ASPLIT_1, $UBOUND_ROWS)
				LOCAL $ATMP[$IVALDIM_1][0], $ASPLIT_2
				FOR $I = 0 TO $IVALDIM_1 - 1
					$ASPLIT_2 = STRINGSPLIT($ASPLIT_1[$I], $SDELIM_ITEM, $STR_NOCOUNT + $STR_ENTIRESPLIT)
					$ICOLCOUNT = UBOUND($ASPLIT_2)
					IF $ICOLCOUNT > $IVALDIM_2 THEN
						$IVALDIM_2 = $ICOLCOUNT
						REDIM $ATMP[$IVALDIM_1][$IVALDIM_2]
					ENDIF
					FOR $J = 0 TO $ICOLCOUNT - 1
						$ATMP[$I][$J] = $ASPLIT_2[$J]
					NEXT
				NEXT
				$VVALUE = $ATMP
			ENDIF
			IF UBOUND($VVALUE, $UBOUND_COLUMNS) + $ISTART > UBOUND($AARRAY, $UBOUND_COLUMNS) THEN RETURN SETERROR(3, 0, -1)
			REDIM $AARRAY[$IDIM_1 + $IVALDIM_1][$IDIM_2]
			FOR $IWRITETO_INDEX = 0 TO $IVALDIM_1 - 1
				FOR $J = 0 TO $IDIM_2 - 1
					IF $J < $ISTART THEN
						$AARRAY[$IWRITETO_INDEX + $IDIM_1][$J] = ""
					ELSEIF $J - $ISTART > $IVALDIM_2 - 1 THEN
						$AARRAY[$IWRITETO_INDEX + $IDIM_1][$J] = ""
					ELSE
						IF STRING($HDATATYPE) = "Boolean" THEN
							SWITCH $VVALUE[$IWRITETO_INDEX][$J - $ISTART]
								CASE "True", "1"
									$AARRAY[$IWRITETO_INDEX + $IDIM_1][$J] = TRUE
								CASE "False", "0", ""
									$AARRAY[$IWRITETO_INDEX + $IDIM_1][$J] = FALSE
							ENDSWITCH
						ELSEIF ISFUNC($HDATATYPE) THEN
							$AARRAY[$IWRITETO_INDEX + $IDIM_1][$J] = $HDATATYPE($VVALUE[$IWRITETO_INDEX][$J - $ISTART])
						ELSE
							$AARRAY[$IWRITETO_INDEX + $IDIM_1][$J] = $VVALUE[$IWRITETO_INDEX][$J - $ISTART]
						ENDIF
					ENDIF
				NEXT
			NEXT
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN UBOUND($AARRAY, $UBOUND_ROWS) - 1
ENDFUNC
FUNC _ARRAYBINARYSEARCH(CONST BYREF $AARRAY, $VVALUE, $ISTART = 0, $IEND = 0, $ICOLUMN = 0)
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $IEND = DEFAULT THEN $IEND = 0
	IF $ICOLUMN = DEFAULT THEN $ICOLUMN = 0
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS)
	IF $IDIM_1 = 0 THEN RETURN SETERROR(6, 0, -1)
	IF $IEND < 1 OR $IEND > $IDIM_1 - 1 THEN $IEND = $IDIM_1 - 1
	IF $ISTART < 0 THEN $ISTART = 0
	IF $ISTART > $IEND THEN RETURN SETERROR(4, 0, -1)
	LOCAL $IMID = INT(($IEND + $ISTART) / 2)
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			IF $AARRAY[$ISTART] > $VVALUE OR $AARRAY[$IEND] < $VVALUE THEN RETURN SETERROR(2, 0, -1)
			WHILE $ISTART <= $IMID AND $VVALUE <> $AARRAY[$IMID]
				IF $VVALUE < $AARRAY[$IMID] THEN
					$IEND = $IMID - 1
				ELSE
					$ISTART = $IMID + 1
				ENDIF
				$IMID = INT(($IEND + $ISTART) / 2)
			WEND
			IF $ISTART > $IEND THEN RETURN SETERROR(3, 0, -1)
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
			IF $ICOLUMN < 0 OR $ICOLUMN > $IDIM_2 THEN RETURN SETERROR(7, 0, -1)
			IF $AARRAY[$ISTART][$ICOLUMN] > $VVALUE OR $AARRAY[$IEND][$ICOLUMN] < $VVALUE THEN RETURN SETERROR(2, 0, -1)
			WHILE $ISTART <= $IMID AND $VVALUE <> $AARRAY[$IMID][$ICOLUMN]
				IF $VVALUE < $AARRAY[$IMID][$ICOLUMN] THEN
					$IEND = $IMID - 1
				ELSE
					$ISTART = $IMID + 1
				ENDIF
				$IMID = INT(($IEND + $ISTART) / 2)
			WEND
			IF $ISTART > $IEND THEN RETURN SETERROR(3, 0, -1)
		CASE ELSE
			RETURN SETERROR(5, 0, -1)
	ENDSWITCH
	RETURN $IMID
ENDFUNC
FUNC _ARRAYCOLDELETE(BYREF $AARRAY, $ICOLUMN, $BCONVERT = FALSE)
	IF $BCONVERT = DEFAULT THEN $BCONVERT = FALSE
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS)
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) <> 2 THEN RETURN SETERROR(2, 0, -1)
	LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS)
	SWITCH $IDIM_2
		CASE 2
			IF $ICOLUMN < 0 OR $ICOLUMN > 1 THEN RETURN SETERROR(3, 0, -1)
			IF $BCONVERT THEN
				LOCAL $ATEMPARRAY[$IDIM_1]
				FOR $I = 0 TO $IDIM_1 - 1
					$ATEMPARRAY[$I] = $AARRAY[$I][(NOT $ICOLUMN)]
				NEXT
				$AARRAY = $ATEMPARRAY
			ELSE
				CONTINUECASE
			ENDIF
		CASE ELSE
			IF $ICOLUMN < 0 OR $ICOLUMN > $IDIM_2 - 1 THEN RETURN SETERROR(3, 0, -1)
			FOR $I = 0 TO $IDIM_1 - 1
				FOR $J = $ICOLUMN TO $IDIM_2 - 2
					$AARRAY[$I][$J] = $AARRAY[$I][$J + 1]
				NEXT
			NEXT
			REDIM $AARRAY[$IDIM_1][$IDIM_2 - 1]
	ENDSWITCH
	RETURN UBOUND($AARRAY, $UBOUND_COLUMNS)
ENDFUNC
FUNC _ARRAYCOLINSERT(BYREF $AARRAY, $ICOLUMN)
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS)
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			LOCAL $ATEMPARRAY[$IDIM_1][2]
			SWITCH $ICOLUMN
				CASE 0, 1
					FOR $I = 0 TO $IDIM_1 - 1
						$ATEMPARRAY[$I][(NOT $ICOLUMN)] = $AARRAY[$I]
					NEXT
				CASE ELSE
					RETURN SETERROR(3, 0, -1)
			ENDSWITCH
			$AARRAY = $ATEMPARRAY
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS)
			IF $ICOLUMN < 0 OR $ICOLUMN > $IDIM_2 THEN RETURN SETERROR(3, 0, -1)
			REDIM $AARRAY[$IDIM_1][$IDIM_2 + 1]
			FOR $I = 0 TO $IDIM_1 - 1
				FOR $J = $IDIM_2 TO $ICOLUMN + 1 STEP -1
					$AARRAY[$I][$J] = $AARRAY[$I][$J - 1]
				NEXT
				$AARRAY[$I][$ICOLUMN] = ""
			NEXT
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN UBOUND($AARRAY, $UBOUND_COLUMNS)
ENDFUNC
FUNC _ARRAYCOMBINATIONS(CONST BYREF $AARRAY, $ISET, $SDELIMITER = "")
	IF $SDELIMITER = DEFAULT THEN $SDELIMITER = ""
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, 0)
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) <> 1 THEN RETURN SETERROR(2, 0, 0)
	LOCAL $IN = UBOUND($AARRAY)
	LOCAL $IR = $ISET
	LOCAL $AIDX[$IR]
	FOR $I = 0 TO $IR - 1
		$AIDX[$I] = $I
	NEXT
	LOCAL $ITOTAL = __ARRAY_COMBINATIONS($IN, $IR)
	LOCAL $ILEFT = $ITOTAL
	LOCAL $ARESULT[$ITOTAL + 1]
	$ARESULT[0] = $ITOTAL
	LOCAL $ICOUNT = 1
	WHILE $ILEFT > 0
		__ARRAY_GETNEXT($IN, $IR, $ILEFT, $ITOTAL, $AIDX)
		FOR $I = 0 TO $ISET - 1
			$ARESULT[$ICOUNT] &= $AARRAY[$AIDX[$I]] & $SDELIMITER
		NEXT
		IF $SDELIMITER <> "" THEN $ARESULT[$ICOUNT] = STRINGTRIMRIGHT($ARESULT[$ICOUNT], 1)
		$ICOUNT += 1
	WEND
	RETURN $ARESULT
ENDFUNC
FUNC _ARRAYCONCATENATE(BYREF $AARRAYTARGET, CONST BYREF $AARRAYSOURCE, $ISTART = 0)
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF NOT ISARRAY($AARRAYTARGET) THEN RETURN SETERROR(1, 0, -1)
	IF NOT ISARRAY($AARRAYSOURCE) THEN RETURN SETERROR(2, 0, -1)
	LOCAL $IDIM_TOTAL_TGT = UBOUND($AARRAYTARGET, $UBOUND_DIMENSIONS)
	LOCAL $IDIM_TOTAL_SRC = UBOUND($AARRAYSOURCE, $UBOUND_DIMENSIONS)
	LOCAL $IDIM_1_TGT = UBOUND($AARRAYTARGET, $UBOUND_ROWS)
	LOCAL $IDIM_1_SRC = UBOUND($AARRAYSOURCE, $UBOUND_ROWS)
	IF $ISTART < 0 OR $ISTART > $IDIM_1_SRC - 1 THEN RETURN SETERROR(6, 0, -1)
	SWITCH $IDIM_TOTAL_TGT
		CASE 1
			IF $IDIM_TOTAL_SRC <> 1 THEN RETURN SETERROR(4, 0, -1)
			REDIM $AARRAYTARGET[$IDIM_1_TGT + $IDIM_1_SRC - $ISTART]
			FOR $I = $ISTART TO $IDIM_1_SRC - 1
				$AARRAYTARGET[$IDIM_1_TGT + $I - $ISTART] = $AARRAYSOURCE[$I]
			NEXT
		CASE 2
			IF $IDIM_TOTAL_SRC <> 2 THEN RETURN SETERROR(4, 0, -1)
			LOCAL $IDIM_2_TGT = UBOUND($AARRAYTARGET, $UBOUND_COLUMNS)
			IF UBOUND($AARRAYSOURCE, $UBOUND_COLUMNS) <> $IDIM_2_TGT THEN RETURN SETERROR(5, 0, -1)
			REDIM $AARRAYTARGET[$IDIM_1_TGT + $IDIM_1_SRC - $ISTART][$IDIM_2_TGT]
			FOR $I = $ISTART TO $IDIM_1_SRC - 1
				FOR $J = 0 TO $IDIM_2_TGT - 1
					$AARRAYTARGET[$IDIM_1_TGT + $I - $ISTART][$J] = $AARRAYSOURCE[$I][$J]
				NEXT
			NEXT
		CASE ELSE
			RETURN SETERROR(3, 0, -1)
	ENDSWITCH
	RETURN UBOUND($AARRAYTARGET, $UBOUND_ROWS)
ENDFUNC
FUNC _ARRAYDELETE(BYREF $AARRAY, $VRANGE)
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS) - 1
	IF ISARRAY($VRANGE) THEN
		IF UBOUND($VRANGE, $UBOUND_DIMENSIONS) <> 1 OR UBOUND($VRANGE, $UBOUND_ROWS) < 2 THEN RETURN SETERROR(4, 0, -1)
	ELSE
		LOCAL $INUMBER, $ASPLIT_1, $ASPLIT_2
		$VRANGE = STRINGSTRIPWS($VRANGE, 8)
		$ASPLIT_1 = STRINGSPLIT($VRANGE, ";")
		$VRANGE = ""
		FOR $I = 1 TO $ASPLIT_1[0]
			IF NOT STRINGREGEXP($ASPLIT_1[$I], "^\d+(-\d+)?$") THEN RETURN SETERROR(3, 0, -1)
			$ASPLIT_2 = STRINGSPLIT($ASPLIT_1[$I], "-")
			SWITCH $ASPLIT_2[0]
				CASE 1
					$VRANGE &= $ASPLIT_2[1] & ";"
				CASE 2
					IF NUMBER($ASPLIT_2[2]) >= NUMBER($ASPLIT_2[1]) THEN
						$INUMBER = $ASPLIT_2[1] - 1
						DO
							$INUMBER += 1
							$VRANGE &= $INUMBER & ";"
						UNTIL $INUMBER = $ASPLIT_2[2]
					ENDIF
			ENDSWITCH
		NEXT
		$VRANGE = STRINGSPLIT(STRINGTRIMRIGHT($VRANGE, 1), ";")
	ENDIF
	IF $VRANGE[1] < 0 OR $VRANGE[$VRANGE[0]] > $IDIM_1 THEN RETURN SETERROR(5, 0, -1)
	LOCAL $ICOPYTO_INDEX = 0
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			FOR $I = 1 TO $VRANGE[0]
				$AARRAY[$VRANGE[$I]] = CHRW(64177)
			NEXT
			FOR $IREADFROM_INDEX = 0 TO $IDIM_1
				IF $AARRAY[$IREADFROM_INDEX] == CHRW(64177) THEN
					CONTINUELOOP
				ELSE
					IF $IREADFROM_INDEX <> $ICOPYTO_INDEX THEN
						$AARRAY[$ICOPYTO_INDEX] = $AARRAY[$IREADFROM_INDEX]
					ENDIF
					$ICOPYTO_INDEX += 1
				ENDIF
			NEXT
			REDIM $AARRAY[$IDIM_1 - $VRANGE[0] + 1]
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
			FOR $I = 1 TO $VRANGE[0]
				$AARRAY[$VRANGE[$I]][0] = CHRW(64177)
			NEXT
			FOR $IREADFROM_INDEX = 0 TO $IDIM_1
				IF $AARRAY[$IREADFROM_INDEX][0] == CHRW(64177) THEN
					CONTINUELOOP
				ELSE
					IF $IREADFROM_INDEX <> $ICOPYTO_INDEX THEN
						FOR $J = 0 TO $IDIM_2
							$AARRAY[$ICOPYTO_INDEX][$J] = $AARRAY[$IREADFROM_INDEX][$J]
						NEXT
					ENDIF
					$ICOPYTO_INDEX += 1
				ENDIF
			NEXT
			REDIM $AARRAY[$IDIM_1 - $VRANGE[0] + 1][$IDIM_2 + 1]
		CASE ELSE
			RETURN SETERROR(2, 0, FALSE)
	ENDSWITCH
	RETURN UBOUND($AARRAY, $UBOUND_ROWS)
ENDFUNC
FUNC _ARRAYDISPLAY(CONST BYREF $AARRAY, $STITLE = DEFAULT, $SARRAYRANGE = DEFAULT, $IFLAGS = DEFAULT, $VUSER_SEPARATOR = DEFAULT, $SHEADER = DEFAULT, $IMAX_COLWIDTH = DEFAULT)
	#forceref $VUSER_SEPARATOR
	LOCAL $IRET = __ARRAYDISPLAY_SHARE($AARRAY, $STITLE, $SARRAYRANGE, $IFLAGS, DEFAULT, $SHEADER, $IMAX_COLWIDTH, 0, FALSE)
	RETURN SETERROR(@ERROR, @EXTENDED, $IRET)
ENDFUNC
FUNC _ARRAYEXTRACT(CONST BYREF $AARRAY, $ISTART_ROW = -1, $IEND_ROW = -1, $ISTART_COL = -1, $IEND_COL = -1)
	IF $ISTART_ROW = DEFAULT THEN $ISTART_ROW = -1
	IF $IEND_ROW = DEFAULT THEN $IEND_ROW = -1
	IF $ISTART_COL = DEFAULT THEN $ISTART_COL = -1
	IF $IEND_COL = DEFAULT THEN $IEND_COL = -1
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS) - 1
	IF $IEND_ROW = -1 THEN $IEND_ROW = $IDIM_1
	IF $ISTART_ROW = -1 THEN $ISTART_ROW = 0
	IF $ISTART_ROW < -1 OR $IEND_ROW < -1 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART_ROW > $IDIM_1 OR $IEND_ROW > $IDIM_1 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART_ROW > $IEND_ROW THEN RETURN SETERROR(4, 0, -1)
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			LOCAL $ARETARRAY[$IEND_ROW - $ISTART_ROW + 1]
			FOR $I = 0 TO $IEND_ROW - $ISTART_ROW
				$ARETARRAY[$I] = $AARRAY[$I + $ISTART_ROW]
			NEXT
			RETURN $ARETARRAY
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
			IF $IEND_COL = -1 THEN $IEND_COL = $IDIM_2
			IF $ISTART_COL = -1 THEN $ISTART_COL = 0
			IF $ISTART_COL < -1 OR $IEND_COL < -1 THEN RETURN SETERROR(5, 0, -1)
			IF $ISTART_COL > $IDIM_2 OR $IEND_COL > $IDIM_2 THEN RETURN SETERROR(5, 0, -1)
			IF $ISTART_COL > $IEND_COL THEN RETURN SETERROR(6, 0, -1)
			IF $ISTART_COL = $IEND_COL THEN
				LOCAL $ARETARRAY[$IEND_ROW - $ISTART_ROW + 1]
			ELSE
				LOCAL $ARETARRAY[$IEND_ROW - $ISTART_ROW + 1][$IEND_COL - $ISTART_COL + 1]
			ENDIF
			FOR $I = 0 TO $IEND_ROW - $ISTART_ROW
				FOR $J = 0 TO $IEND_COL - $ISTART_COL
					IF $ISTART_COL = $IEND_COL THEN
						$ARETARRAY[$I] = $AARRAY[$I + $ISTART_ROW][$J + $ISTART_COL]
					ELSE
						$ARETARRAY[$I][$J] = $AARRAY[$I + $ISTART_ROW][$J + $ISTART_COL]
					ENDIF
				NEXT
			NEXT
			RETURN $ARETARRAY
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN 1
ENDFUNC
FUNC _ARRAYFINDALL(CONST BYREF $AARRAY, $VVALUE, $ISTART = 0, $IEND = 0, $ICASE = 0, $ICOMPARE = 0, $ISUBITEM = 0, $BROW = FALSE)
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $IEND = DEFAULT THEN $IEND = 0
	IF $ICASE = DEFAULT THEN $ICASE = 0
	IF $ICOMPARE = DEFAULT THEN $ICOMPARE = 0
	IF $ISUBITEM = DEFAULT THEN $ISUBITEM = 0
	IF $BROW = DEFAULT THEN $BROW = FALSE
	$ISTART = _ARRAYSEARCH($AARRAY, $VVALUE, $ISTART, $IEND, $ICASE, $ICOMPARE, 1, $ISUBITEM, $BROW)
	IF @ERROR THEN RETURN SETERROR(@ERROR, 0, -1)
	LOCAL $IINDEX = 0, $AVRESULT[UBOUND($AARRAY, ($BROW ? $UBOUND_COLUMNS : $UBOUND_ROWS))]
	DO
		$AVRESULT[$IINDEX] = $ISTART
		$IINDEX += 1
		$ISTART = _ARRAYSEARCH($AARRAY, $VVALUE, $ISTART + 1, $IEND, $ICASE, $ICOMPARE, 1, $ISUBITEM, $BROW)
	UNTIL @ERROR
	REDIM $AVRESULT[$IINDEX]
	RETURN $AVRESULT
ENDFUNC
FUNC _ARRAYINSERT(BYREF $AARRAY, $VRANGE, $VVALUE = "", $ISTART = 0, $SDELIM_ITEM = "|", $SDELIM_ROW = @CRLF, $IFORCE = $ARRAYFILL_FORCE_DEFAULT)
	IF $VVALUE = DEFAULT THEN $VVALUE = ""
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $SDELIM_ITEM = DEFAULT THEN $SDELIM_ITEM = "|"
	IF $SDELIM_ROW = DEFAULT THEN $SDELIM_ROW = @CRLF
	IF $IFORCE = DEFAULT THEN $IFORCE = $ARRAYFILL_FORCE_DEFAULT
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS) - 1
	LOCAL $HDATATYPE = 0
	SWITCH $IFORCE
		CASE $ARRAYFILL_FORCE_INT
			$HDATATYPE = INT
		CASE $ARRAYFILL_FORCE_NUMBER
			$HDATATYPE = NUMBER
		CASE $ARRAYFILL_FORCE_PTR
			$HDATATYPE = PTR
		CASE $ARRAYFILL_FORCE_HWND
			$HDATATYPE = HWND
		CASE $ARRAYFILL_FORCE_STRING
			$HDATATYPE = STRING
	ENDSWITCH
	LOCAL $ASPLIT_1, $ASPLIT_2
	IF ISARRAY($VRANGE) THEN
		IF UBOUND($VRANGE, $UBOUND_DIMENSIONS) <> 1 OR UBOUND($VRANGE, $UBOUND_ROWS) < 2 THEN RETURN SETERROR(4, 0, -1)
	ELSE
		LOCAL $INUMBER
		$VRANGE = STRINGSTRIPWS($VRANGE, 8)
		$ASPLIT_1 = STRINGSPLIT($VRANGE, ";")
		$VRANGE = ""
		FOR $I = 1 TO $ASPLIT_1[0]
			IF NOT STRINGREGEXP($ASPLIT_1[$I], "^\d+(-\d+)?$") THEN RETURN SETERROR(3, 0, -1)
			$ASPLIT_2 = STRINGSPLIT($ASPLIT_1[$I], "-")
			SWITCH $ASPLIT_2[0]
				CASE 1
					$VRANGE &= $ASPLIT_2[1] & ";"
				CASE 2
					IF NUMBER($ASPLIT_2[2]) >= NUMBER($ASPLIT_2[1]) THEN
						$INUMBER = $ASPLIT_2[1] - 1
						DO
							$INUMBER += 1
							$VRANGE &= $INUMBER & ";"
						UNTIL $INUMBER = $ASPLIT_2[2]
					ENDIF
			ENDSWITCH
		NEXT
		$VRANGE = STRINGSPLIT(STRINGTRIMRIGHT($VRANGE, 1), ";")
	ENDIF
	IF $VRANGE[1] < 0 OR $VRANGE[$VRANGE[0]] > $IDIM_1 THEN RETURN SETERROR(5, 0, -1)
	FOR $I = 2 TO $VRANGE[0]
		IF $VRANGE[$I] < $VRANGE[$I - 1] THEN RETURN SETERROR(3, 0, -1)
	NEXT
	LOCAL $ICOPYTO_INDEX = $IDIM_1 + $VRANGE[0]
	LOCAL $IINSERTPOINT_INDEX = $VRANGE[0]
	LOCAL $IINSERT_INDEX = $VRANGE[$IINSERTPOINT_INDEX]
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			IF $IFORCE = $ARRAYFILL_FORCE_SINGLEITEM THEN
				REDIM $AARRAY[$IDIM_1 + $VRANGE[0] + 1]
				FOR $IREADFROMINDEX = $IDIM_1 TO 0 STEP -1
					$AARRAY[$ICOPYTO_INDEX] = $AARRAY[$IREADFROMINDEX]
					$ICOPYTO_INDEX -= 1
					$IINSERT_INDEX = $VRANGE[$IINSERTPOINT_INDEX]
					WHILE $IREADFROMINDEX = $IINSERT_INDEX
						$AARRAY[$ICOPYTO_INDEX] = $VVALUE
						$ICOPYTO_INDEX -= 1
						$IINSERTPOINT_INDEX -= 1
						IF $IINSERTPOINT_INDEX < 1 THEN EXITLOOP 2
						$IINSERT_INDEX = $VRANGE[$IINSERTPOINT_INDEX]
					WEND
				NEXT
				RETURN $IDIM_1 + $VRANGE[0] + 1
			ENDIF
			REDIM $AARRAY[$IDIM_1 + $VRANGE[0] + 1]
			IF ISARRAY($VVALUE) THEN
				IF UBOUND($VVALUE, $UBOUND_DIMENSIONS) <> 1 THEN RETURN SETERROR(5, 0, -1)
				$HDATATYPE = 0
			ELSE
				LOCAL $ATMP = STRINGSPLIT($VVALUE, $SDELIM_ITEM, $STR_NOCOUNT + $STR_ENTIRESPLIT)
				IF UBOUND($ATMP, $UBOUND_ROWS) = 1 THEN
					$ATMP[0] = $VVALUE
					$HDATATYPE = 0
				ENDIF
				$VVALUE = $ATMP
			ENDIF
			FOR $IREADFROMINDEX = $IDIM_1 TO 0 STEP -1
				$AARRAY[$ICOPYTO_INDEX] = $AARRAY[$IREADFROMINDEX]
				$ICOPYTO_INDEX -= 1
				$IINSERT_INDEX = $VRANGE[$IINSERTPOINT_INDEX]
				WHILE $IREADFROMINDEX = $IINSERT_INDEX
					IF $IINSERTPOINT_INDEX <= UBOUND($VVALUE, $UBOUND_ROWS) THEN
						IF ISFUNC($HDATATYPE) THEN
							$AARRAY[$ICOPYTO_INDEX] = $HDATATYPE($VVALUE[$IINSERTPOINT_INDEX - 1])
						ELSE
							$AARRAY[$ICOPYTO_INDEX] = $VVALUE[$IINSERTPOINT_INDEX - 1]
						ENDIF
					ELSE
						$AARRAY[$ICOPYTO_INDEX] = ""
					ENDIF
					$ICOPYTO_INDEX -= 1
					$IINSERTPOINT_INDEX -= 1
					IF $IINSERTPOINT_INDEX = 0 THEN EXITLOOP 2
					$IINSERT_INDEX = $VRANGE[$IINSERTPOINT_INDEX]
				WEND
			NEXT
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS)
			IF $ISTART < 0 OR $ISTART > $IDIM_2 - 1 THEN RETURN SETERROR(6, 0, -1)
			LOCAL $IVALDIM_1, $IVALDIM_2
			IF ISARRAY($VVALUE) THEN
				IF UBOUND($VVALUE, $UBOUND_DIMENSIONS) <> 2 THEN RETURN SETERROR(7, 0, -1)
				$IVALDIM_1 = UBOUND($VVALUE, $UBOUND_ROWS)
				$IVALDIM_2 = UBOUND($VVALUE, $UBOUND_COLUMNS)
				$HDATATYPE = 0
			ELSE
				$ASPLIT_1 = STRINGSPLIT($VVALUE, $SDELIM_ROW, $STR_NOCOUNT + $STR_ENTIRESPLIT)
				$IVALDIM_1 = UBOUND($ASPLIT_1, $UBOUND_ROWS)
				STRINGREPLACE($ASPLIT_1[0], $SDELIM_ITEM, "")
				$IVALDIM_2 = @EXTENDED + 1
				LOCAL $ATMP[$IVALDIM_1][$IVALDIM_2]
				FOR $I = 0 TO $IVALDIM_1 - 1
					$ASPLIT_2 = STRINGSPLIT($ASPLIT_1[$I], $SDELIM_ITEM, $STR_NOCOUNT + $STR_ENTIRESPLIT)
					FOR $J = 0 TO $IVALDIM_2 - 1
						$ATMP[$I][$J] = $ASPLIT_2[$J]
					NEXT
				NEXT
				$VVALUE = $ATMP
			ENDIF
			IF UBOUND($VVALUE, $UBOUND_COLUMNS) + $ISTART > UBOUND($AARRAY, $UBOUND_COLUMNS) THEN RETURN SETERROR(8, 0, -1)
			REDIM $AARRAY[$IDIM_1 + $VRANGE[0] + 1][$IDIM_2]
			FOR $IREADFROMINDEX = $IDIM_1 TO 0 STEP -1
				FOR $J = 0 TO $IDIM_2 - 1
					$AARRAY[$ICOPYTO_INDEX][$J] = $AARRAY[$IREADFROMINDEX][$J]
				NEXT
				$ICOPYTO_INDEX -= 1
				$IINSERT_INDEX = $VRANGE[$IINSERTPOINT_INDEX]
				WHILE $IREADFROMINDEX = $IINSERT_INDEX
					FOR $J = 0 TO $IDIM_2 - 1
						IF $J < $ISTART THEN
							$AARRAY[$ICOPYTO_INDEX][$J] = ""
						ELSEIF $J - $ISTART > $IVALDIM_2 - 1 THEN
							$AARRAY[$ICOPYTO_INDEX][$J] = ""
						ELSE
							IF $IINSERTPOINT_INDEX - 1 < $IVALDIM_1 THEN
								IF ISFUNC($HDATATYPE) THEN
									$AARRAY[$ICOPYTO_INDEX][$J] = $HDATATYPE($VVALUE[$IINSERTPOINT_INDEX - 1][$J - $ISTART])
								ELSE
									$AARRAY[$ICOPYTO_INDEX][$J] = $VVALUE[$IINSERTPOINT_INDEX - 1][$J - $ISTART]
								ENDIF
							ELSE
								$AARRAY[$ICOPYTO_INDEX][$J] = ""
							ENDIF
						ENDIF
					NEXT
					$ICOPYTO_INDEX -= 1
					$IINSERTPOINT_INDEX -= 1
					IF $IINSERTPOINT_INDEX = 0 THEN EXITLOOP 2
					$IINSERT_INDEX = $VRANGE[$IINSERTPOINT_INDEX]
				WEND
			NEXT
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN UBOUND($AARRAY, $UBOUND_ROWS)
ENDFUNC
FUNC _ARRAYMAX(CONST BYREF $AARRAY, $ICOMPNUMERIC = 0, $ISTART = -1, $IEND = -1, $ISUBITEM = 0)
	LOCAL $IRESULT = _ARRAYMAXINDEX($AARRAY, $ICOMPNUMERIC, $ISTART, $IEND, $ISUBITEM)
	IF @ERROR THEN RETURN SETERROR(@ERROR, 0, "")
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) = 1 THEN
		RETURN $AARRAY[$IRESULT]
	ELSE
		RETURN $AARRAY[$IRESULT][$ISUBITEM]
	ENDIF
ENDFUNC
FUNC _ARRAYMAXINDEX(CONST BYREF $AARRAY, $ICOMPNUMERIC = 0, $ISTART = -1, $IEND = -1, $ISUBITEM = 0)
	IF $ICOMPNUMERIC = DEFAULT THEN $ICOMPNUMERIC = 0
	IF $ISTART = DEFAULT THEN $ISTART = -1
	IF $IEND = DEFAULT THEN $IEND = -1
	IF $ISUBITEM = DEFAULT THEN $ISUBITEM = 0
	LOCAL $IRET = __ARRAY_MINMAXINDEX($AARRAY, $ICOMPNUMERIC, $ISTART, $IEND, $ISUBITEM, __ARRAY_GREATERTHAN)
	RETURN SETERROR(@ERROR, 0, $IRET)
ENDFUNC
FUNC _ARRAYMIN(CONST BYREF $AARRAY, $ICOMPNUMERIC = 0, $ISTART = -1, $IEND = -1, $ISUBITEM = 0)
	LOCAL $IRESULT = _ARRAYMININDEX($AARRAY, $ICOMPNUMERIC, $ISTART, $IEND, $ISUBITEM)
	IF @ERROR THEN RETURN SETERROR(@ERROR, 0, "")
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) = 1 THEN
		RETURN $AARRAY[$IRESULT]
	ELSE
		RETURN $AARRAY[$IRESULT][$ISUBITEM]
	ENDIF
ENDFUNC
FUNC _ARRAYMININDEX(CONST BYREF $AARRAY, $ICOMPNUMERIC = 0, $ISTART = -1, $IEND = -1, $ISUBITEM = 0)
	IF $ICOMPNUMERIC = DEFAULT THEN $ICOMPNUMERIC = 0
	IF $ISTART = DEFAULT THEN $ISTART = -1
	IF $IEND = DEFAULT THEN $IEND = -1
	IF $ISUBITEM = DEFAULT THEN $ISUBITEM = 0
	LOCAL $IRET = __ARRAY_MINMAXINDEX($AARRAY, $ICOMPNUMERIC, $ISTART, $IEND, $ISUBITEM, __ARRAY_LESSTHAN)
	RETURN SETERROR(@ERROR, 0, $IRET)
ENDFUNC
FUNC _ARRAYPERMUTE(BYREF $AARRAY, $SDELIMITER = "")
	IF $SDELIMITER = DEFAULT THEN $SDELIMITER = ""
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, 0)
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) <> 1 THEN RETURN SETERROR(2, 0, 0)
	LOCAL $ISIZE = UBOUND($AARRAY), $IFACTORIAL = 1, $AIDX[$ISIZE], $ARESULT[1], $ICOUNT = 1
	IF UBOUND($AARRAY) THEN
		FOR $I = 0 TO $ISIZE - 1
			$AIDX[$I] = $I
		NEXT
		FOR $I = $ISIZE TO 1 STEP -1
			$IFACTORIAL *= $I
		NEXT
		REDIM $ARESULT[$IFACTORIAL + 1]
		$ARESULT[0] = $IFACTORIAL
		__ARRAY_EXETERINTERNAL($AARRAY, 0, $ISIZE, $SDELIMITER, $AIDX, $ARESULT, $ICOUNT)
	ELSE
		$ARESULT[0] = 0
	ENDIF
	RETURN $ARESULT
ENDFUNC
FUNC _ARRAYPOP(BYREF $AARRAY)
	IF(NOT ISARRAY($AARRAY)) THEN RETURN SETERROR(1, 0, "")
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) <> 1 THEN RETURN SETERROR(2, 0, "")
	LOCAL $IUBOUND = UBOUND($AARRAY) - 1
	IF $IUBOUND = -1 THEN RETURN SETERROR(3, 0, "")
	LOCAL $SLASTVAL = $AARRAY[$IUBOUND]
	IF $IUBOUND > -1 THEN
		REDIM $AARRAY[$IUBOUND]
	ENDIF
	RETURN $SLASTVAL
ENDFUNC
FUNC _ARRAYPUSH(BYREF $AARRAY, $VVALUE, $IDIRECTION = 0)
	IF $IDIRECTION = DEFAULT THEN $IDIRECTION = 0
	IF(NOT ISARRAY($AARRAY)) THEN RETURN SETERROR(1, 0, 0)
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) <> 1 THEN RETURN SETERROR(3, 0, 0)
	LOCAL $IUBOUND = UBOUND($AARRAY) - 1
	IF ISARRAY($VVALUE) THEN
		LOCAL $IUBOUNDS = UBOUND($VVALUE)
		IF($IUBOUNDS - 1) > $IUBOUND THEN RETURN SETERROR(2, 0, 0)
		IF $IDIRECTION THEN
			FOR $I = $IUBOUND TO $IUBOUNDS STEP -1
				$AARRAY[$I] = $AARRAY[$I - $IUBOUNDS]
			NEXT
			FOR $I = 0 TO $IUBOUNDS - 1
				$AARRAY[$I] = $VVALUE[$I]
			NEXT
		ELSE
			FOR $I = 0 TO $IUBOUND - $IUBOUNDS
				$AARRAY[$I] = $AARRAY[$I + $IUBOUNDS]
			NEXT
			FOR $I = 0 TO $IUBOUNDS - 1
				$AARRAY[$I + $IUBOUND - $IUBOUNDS + 1] = $VVALUE[$I]
			NEXT
		ENDIF
	ELSE
		IF $IUBOUND > -1 THEN
			IF $IDIRECTION THEN
				FOR $I = $IUBOUND TO 1 STEP -1
					$AARRAY[$I] = $AARRAY[$I - 1]
				NEXT
				$AARRAY[0] = $VVALUE
			ELSE
				FOR $I = 0 TO $IUBOUND - 1
					$AARRAY[$I] = $AARRAY[$I + 1]
				NEXT
				$AARRAY[$IUBOUND] = $VVALUE
			ENDIF
		ENDIF
	ENDIF
	RETURN 1
ENDFUNC
FUNC _ARRAYREVERSE(BYREF $AARRAY, $ISTART = 0, $IEND = 0)
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $IEND = DEFAULT THEN $IEND = 0
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, 0)
	IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) <> 1 THEN RETURN SETERROR(3, 0, 0)
	IF NOT UBOUND($AARRAY) THEN RETURN SETERROR(4, 0, 0)
	LOCAL $VTMP, $IUBOUND = UBOUND($AARRAY) - 1
	IF $IEND < 1 OR $IEND > $IUBOUND THEN $IEND = $IUBOUND
	IF $ISTART < 0 THEN $ISTART = 0
	IF $ISTART > $IEND THEN RETURN SETERROR(2, 0, 0)
	FOR $I = $ISTART TO INT(($ISTART + $IEND - 1) / 2)
		$VTMP = $AARRAY[$I]
		$AARRAY[$I] = $AARRAY[$IEND]
		$AARRAY[$IEND] = $VTMP
		$IEND -= 1
	NEXT
	RETURN 1
ENDFUNC
FUNC _ARRAYSEARCH(CONST BYREF $AARRAY, $VVALUE, $ISTART = 0, $IEND = 0, $ICASE = 0, $ICOMPARE = 0, $IFORWARD = 1, $ISUBITEM = -1, $BROW = FALSE)
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $IEND = DEFAULT THEN $IEND = 0
	IF $ICASE = DEFAULT THEN $ICASE = 0
	IF $ICOMPARE = DEFAULT THEN $ICOMPARE = 0
	IF $IFORWARD = DEFAULT THEN $IFORWARD = 1
	IF $ISUBITEM = DEFAULT THEN $ISUBITEM = -1
	IF $BROW = DEFAULT THEN $BROW = FALSE
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY) - 1
	IF $IDIM_1 = -1 THEN RETURN SETERROR(3, 0, -1)
	LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
	LOCAL $BCOMPTYPE = FALSE
	IF $ICOMPARE = 2 THEN
		$ICOMPARE = 0
		$BCOMPTYPE = TRUE
	ENDIF
	IF $BROW THEN
		IF UBOUND($AARRAY, $UBOUND_DIMENSIONS) = 1 THEN RETURN SETERROR(5, 0, -1)
		IF $IEND < 1 OR $IEND > $IDIM_2 THEN $IEND = $IDIM_2
		IF $ISTART < 0 THEN $ISTART = 0
		IF $ISTART > $IEND THEN RETURN SETERROR(4, 0, -1)
	ELSE
		IF $IEND < 1 OR $IEND > $IDIM_1 THEN $IEND = $IDIM_1
		IF $ISTART < 0 THEN $ISTART = 0
		IF $ISTART > $IEND THEN RETURN SETERROR(4, 0, -1)
	ENDIF
	LOCAL $ISTEP = 1
	IF NOT $IFORWARD THEN
		LOCAL $ITMP = $ISTART
		$ISTART = $IEND
		$IEND = $ITMP
		$ISTEP = -1
	ENDIF
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			IF NOT $ICOMPARE THEN
				IF NOT $ICASE THEN
					FOR $I = $ISTART TO $IEND STEP $ISTEP
						IF $BCOMPTYPE AND VARGETTYPE($AARRAY[$I]) <> VARGETTYPE($VVALUE) THEN CONTINUELOOP
						IF $AARRAY[$I] = $VVALUE THEN RETURN $I
					NEXT
				ELSE
					FOR $I = $ISTART TO $IEND STEP $ISTEP
						IF $BCOMPTYPE AND VARGETTYPE($AARRAY[$I]) <> VARGETTYPE($VVALUE) THEN CONTINUELOOP
						IF $AARRAY[$I] == $VVALUE THEN RETURN $I
					NEXT
				ENDIF
			ELSE
				FOR $I = $ISTART TO $IEND STEP $ISTEP
					IF $ICOMPARE = 3 THEN
						IF STRINGREGEXP($AARRAY[$I], $VVALUE) THEN RETURN $I
					ELSE
						IF STRINGINSTR($AARRAY[$I], $VVALUE, $ICASE) > 0 THEN RETURN $I
					ENDIF
				NEXT
			ENDIF
		CASE 2
			LOCAL $IDIM_SUB
			IF $BROW THEN
				$IDIM_SUB = $IDIM_1
				IF $ISUBITEM > $IDIM_SUB THEN $ISUBITEM = $IDIM_SUB
				IF $ISUBITEM < 0 THEN
					$ISUBITEM = 0
				ELSE
					$IDIM_SUB = $ISUBITEM
				ENDIF
			ELSE
				$IDIM_SUB = $IDIM_2
				IF $ISUBITEM > $IDIM_SUB THEN $ISUBITEM = $IDIM_SUB
				IF $ISUBITEM < 0 THEN
					$ISUBITEM = 0
				ELSE
					$IDIM_SUB = $ISUBITEM
				ENDIF
			ENDIF
			FOR $J = $ISUBITEM TO $IDIM_SUB
				IF NOT $ICOMPARE THEN
					IF NOT $ICASE THEN
						FOR $I = $ISTART TO $IEND STEP $ISTEP
							IF $BROW THEN
								IF $BCOMPTYPE AND VARGETTYPE($AARRAY[$J][$I]) <> VARGETTYPE($VVALUE) THEN CONTINUELOOP
								IF $AARRAY[$J][$I] = $VVALUE THEN RETURN $I
							ELSE
								IF $BCOMPTYPE AND VARGETTYPE($AARRAY[$I][$J]) <> VARGETTYPE($VVALUE) THEN CONTINUELOOP
								IF $AARRAY[$I][$J] = $VVALUE THEN RETURN $I
							ENDIF
						NEXT
					ELSE
						FOR $I = $ISTART TO $IEND STEP $ISTEP
							IF $BROW THEN
								IF $BCOMPTYPE AND VARGETTYPE($AARRAY[$J][$I]) <> VARGETTYPE($VVALUE) THEN CONTINUELOOP
								IF $AARRAY[$J][$I] == $VVALUE THEN RETURN $I
							ELSE
								IF $BCOMPTYPE AND VARGETTYPE($AARRAY[$I][$J]) <> VARGETTYPE($VVALUE) THEN CONTINUELOOP
								IF $AARRAY[$I][$J] == $VVALUE THEN RETURN $I
							ENDIF
						NEXT
					ENDIF
				ELSE
					FOR $I = $ISTART TO $IEND STEP $ISTEP
						IF $ICOMPARE = 3 THEN
							IF $BROW THEN
								IF STRINGREGEXP($AARRAY[$J][$I], $VVALUE) THEN RETURN $I
							ELSE
								IF STRINGREGEXP($AARRAY[$I][$J], $VVALUE) THEN RETURN $I
							ENDIF
						ELSE
							IF $BROW THEN
								IF STRINGINSTR($AARRAY[$J][$I], $VVALUE, $ICASE) > 0 THEN RETURN $I
							ELSE
								IF STRINGINSTR($AARRAY[$I][$J], $VVALUE, $ICASE) > 0 THEN RETURN $I
							ENDIF
						ENDIF
					NEXT
				ENDIF
			NEXT
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN SETERROR(6, 0, -1)
ENDFUNC
FUNC _ARRAYSHUFFLE(BYREF $AARRAY, $ISTART_ROW = 0, $IEND_ROW = 0, $ICOL = -1)
	IF $ISTART_ROW = DEFAULT THEN $ISTART_ROW = 0
	IF $IEND_ROW = DEFAULT THEN $IEND_ROW = 0
	IF $ICOL = DEFAULT THEN $ICOL = -1
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS)
	IF $IEND_ROW = 0 THEN $IEND_ROW = $IDIM_1 - 1
	IF $ISTART_ROW < 0 OR $ISTART_ROW > $IDIM_1 - 1 THEN RETURN SETERROR(3, 0, -1)
	IF $IEND_ROW < 1 OR $IEND_ROW > $IDIM_1 - 1 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART_ROW > $IEND_ROW THEN RETURN SETERROR(4, 0, -1)
	LOCAL $VTMP, $IRAND
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			FOR $I = $IEND_ROW TO $ISTART_ROW + 1 STEP -1
				$IRAND = RANDOM($ISTART_ROW, $I, 1)
				$VTMP = $AARRAY[$I]
				$AARRAY[$I] = $AARRAY[$IRAND]
				$AARRAY[$IRAND] = $VTMP
			NEXT
			RETURN 1
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS)
			IF $ICOL < -1 OR $ICOL > $IDIM_2 - 1 THEN RETURN SETERROR(5, 0, -1)
			LOCAL $ICOL_START, $ICOL_END
			IF $ICOL = -1 THEN
				$ICOL_START = 0
				$ICOL_END = $IDIM_2 - 1
			ELSE
				$ICOL_START = $ICOL
				$ICOL_END = $ICOL
			ENDIF
			FOR $I = $IEND_ROW TO $ISTART_ROW + 1 STEP -1
				$IRAND = RANDOM($ISTART_ROW, $I, 1)
				FOR $J = $ICOL_START TO $ICOL_END
					$VTMP = $AARRAY[$I][$J]
					$AARRAY[$I][$J] = $AARRAY[$IRAND][$J]
					$AARRAY[$IRAND][$J] = $VTMP
				NEXT
			NEXT
			RETURN 1
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
ENDFUNC
FUNC _ARRAYSORT(BYREF $AARRAY, $IDESCENDING = 0, $ISTART = 0, $IEND = 0, $ISUBITEM = 0, $IPIVOT = 0)
	IF $IDESCENDING = DEFAULT THEN $IDESCENDING = 0
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $IEND = DEFAULT THEN $IEND = 0
	IF $ISUBITEM = DEFAULT THEN $ISUBITEM = 0
	IF $IPIVOT = DEFAULT THEN $IPIVOT = 0
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, 0)
	LOCAL $IUBOUND = UBOUND($AARRAY) - 1
	IF $IUBOUND = -1 THEN RETURN SETERROR(5, 0, 0)
	IF $IEND = DEFAULT THEN $IEND = 0
	IF $IEND < 1 OR $IEND > $IUBOUND OR $IEND = DEFAULT THEN $IEND = $IUBOUND
	IF $ISTART < 0 OR $ISTART = DEFAULT THEN $ISTART = 0
	IF $ISTART > $IEND THEN RETURN SETERROR(2, 0, 0)
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			IF $IPIVOT THEN
				__ARRAYDUALPIVOTSORT($AARRAY, $ISTART, $IEND)
			ELSE
				__ARRAYQUICKSORT1D($AARRAY, $ISTART, $IEND)
			ENDIF
			IF $IDESCENDING THEN _ARRAYREVERSE($AARRAY, $ISTART, $IEND)
		CASE 2
			IF $IPIVOT THEN RETURN SETERROR(6, 0, 0)
			LOCAL $ISUBMAX = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
			IF $ISUBITEM > $ISUBMAX THEN RETURN SETERROR(3, 0, 0)
			IF $IDESCENDING THEN
				$IDESCENDING = -1
			ELSE
				$IDESCENDING = 1
			ENDIF
			__ARRAYQUICKSORT2D($AARRAY, $IDESCENDING, $ISTART, $IEND, $ISUBITEM, $ISUBMAX)
		CASE ELSE
			RETURN SETERROR(4, 0, 0)
	ENDSWITCH
	RETURN 1
ENDFUNC
FUNC __ARRAYQUICKSORT1D(BYREF $AARRAY, CONST BYREF $ISTART, CONST BYREF $IEND)
	IF $IEND <= $ISTART THEN RETURN
	LOCAL $VTMP
	IF($IEND - $ISTART) < 15 THEN
		LOCAL $VCUR
		FOR $I = $ISTART + 1 TO $IEND
			$VTMP = $AARRAY[$I]
			IF ISNUMBER($VTMP) THEN
				FOR $J = $I - 1 TO $ISTART STEP -1
					$VCUR = $AARRAY[$J]
					IF($VTMP >= $VCUR AND ISNUMBER($VCUR)) OR(NOT ISNUMBER($VCUR) AND STRINGCOMPARE($VTMP, $VCUR) >= 0) THEN EXITLOOP
					$AARRAY[$J + 1] = $VCUR
				NEXT
			ELSE
				FOR $J = $I - 1 TO $ISTART STEP -1
					IF(STRINGCOMPARE($VTMP, $AARRAY[$J]) >= 0) THEN EXITLOOP
					$AARRAY[$J + 1] = $AARRAY[$J]
				NEXT
			ENDIF
			$AARRAY[$J + 1] = $VTMP
		NEXT
		RETURN
	ENDIF
	LOCAL $L = $ISTART, $R = $IEND, $VPIVOT = $AARRAY[INT(($ISTART + $IEND) / 2)], $BNUM = ISNUMBER($VPIVOT)
	DO
		IF $BNUM THEN
			WHILE($AARRAY[$L] < $VPIVOT AND ISNUMBER($AARRAY[$L])) OR(NOT ISNUMBER($AARRAY[$L]) AND STRINGCOMPARE($AARRAY[$L], $VPIVOT) < 0)
				$L += 1
			WEND
			WHILE($AARRAY[$R] > $VPIVOT AND ISNUMBER($AARRAY[$R])) OR(NOT ISNUMBER($AARRAY[$R]) AND STRINGCOMPARE($AARRAY[$R], $VPIVOT) > 0)
				$R -= 1
			WEND
		ELSE
			WHILE(STRINGCOMPARE($AARRAY[$L], $VPIVOT) < 0)
				$L += 1
			WEND
			WHILE(STRINGCOMPARE($AARRAY[$R], $VPIVOT) > 0)
				$R -= 1
			WEND
		ENDIF
		IF $L <= $R THEN
			$VTMP = $AARRAY[$L]
			$AARRAY[$L] = $AARRAY[$R]
			$AARRAY[$R] = $VTMP
			$L += 1
			$R -= 1
		ENDIF
	UNTIL $L > $R
	__ARRAYQUICKSORT1D($AARRAY, $ISTART, $R)
	__ARRAYQUICKSORT1D($AARRAY, $L, $IEND)
ENDFUNC
FUNC __ARRAYQUICKSORT2D(BYREF $AARRAY, CONST BYREF $ISTEP, CONST BYREF $ISTART, CONST BYREF $IEND, CONST BYREF $ISUBITEM, CONST BYREF $ISUBMAX)
	IF $IEND <= $ISTART THEN RETURN
	LOCAL $VTMP, $L = $ISTART, $R = $IEND, $VPIVOT = $AARRAY[INT(($ISTART + $IEND) / 2)][$ISUBITEM], $BNUM = ISNUMBER($VPIVOT)
	DO
		IF $BNUM THEN
			WHILE($ISTEP * ($AARRAY[$L][$ISUBITEM] - $VPIVOT) < 0 AND ISNUMBER($AARRAY[$L][$ISUBITEM])) OR(NOT ISNUMBER($AARRAY[$L][$ISUBITEM]) AND $ISTEP * STRINGCOMPARE($AARRAY[$L][$ISUBITEM], $VPIVOT) < 0)
				$L += 1
			WEND
			WHILE($ISTEP * ($AARRAY[$R][$ISUBITEM] - $VPIVOT) > 0 AND ISNUMBER($AARRAY[$R][$ISUBITEM])) OR(NOT ISNUMBER($AARRAY[$R][$ISUBITEM]) AND $ISTEP * STRINGCOMPARE($AARRAY[$R][$ISUBITEM], $VPIVOT) > 0)
				$R -= 1
			WEND
		ELSE
			WHILE($ISTEP * STRINGCOMPARE($AARRAY[$L][$ISUBITEM], $VPIVOT) < 0)
				$L += 1
			WEND
			WHILE($ISTEP * STRINGCOMPARE($AARRAY[$R][$ISUBITEM], $VPIVOT) > 0)
				$R -= 1
			WEND
		ENDIF
		IF $L <= $R THEN
			FOR $I = 0 TO $ISUBMAX
				$VTMP = $AARRAY[$L][$I]
				$AARRAY[$L][$I] = $AARRAY[$R][$I]
				$AARRAY[$R][$I] = $VTMP
			NEXT
			$L += 1
			$R -= 1
		ENDIF
	UNTIL $L > $R
	__ARRAYQUICKSORT2D($AARRAY, $ISTEP, $ISTART, $R, $ISUBITEM, $ISUBMAX)
	__ARRAYQUICKSORT2D($AARRAY, $ISTEP, $L, $IEND, $ISUBITEM, $ISUBMAX)
ENDFUNC
FUNC __ARRAYDUALPIVOTSORT(BYREF $AARRAY, $IPIVOT_LEFT, $IPIVOT_RIGHT, $BLEFTMOST = TRUE)
	IF $IPIVOT_LEFT > $IPIVOT_RIGHT THEN RETURN
	LOCAL $ILENGTH = $IPIVOT_RIGHT - $IPIVOT_LEFT + 1
	LOCAL $I, $J, $K, $IAI, $IAK, $IA1, $IA2, $ILAST
	IF $ILENGTH < 45 THEN
		IF $BLEFTMOST THEN
			$I = $IPIVOT_LEFT
			WHILE $I < $IPIVOT_RIGHT
				$J = $I
				$IAI = $AARRAY[$I + 1]
				WHILE $IAI < $AARRAY[$J]
					$AARRAY[$J + 1] = $AARRAY[$J]
					$J -= 1
					IF $J + 1 = $IPIVOT_LEFT THEN EXITLOOP
				WEND
				$AARRAY[$J + 1] = $IAI
				$I += 1
			WEND
		ELSE
			WHILE 1
				IF $IPIVOT_LEFT >= $IPIVOT_RIGHT THEN RETURN 1
				$IPIVOT_LEFT += 1
				IF $AARRAY[$IPIVOT_LEFT] < $AARRAY[$IPIVOT_LEFT - 1] THEN EXITLOOP
			WEND
			WHILE 1
				$K = $IPIVOT_LEFT
				$IPIVOT_LEFT += 1
				IF $IPIVOT_LEFT > $IPIVOT_RIGHT THEN EXITLOOP
				$IA1 = $AARRAY[$K]
				$IA2 = $AARRAY[$IPIVOT_LEFT]
				IF $IA1 < $IA2 THEN
					$IA2 = $IA1
					$IA1 = $AARRAY[$IPIVOT_LEFT]
				ENDIF
				$K -= 1
				WHILE $IA1 < $AARRAY[$K]
					$AARRAY[$K + 2] = $AARRAY[$K]
					$K -= 1
				WEND
				$AARRAY[$K + 2] = $IA1
				WHILE $IA2 < $AARRAY[$K]
					$AARRAY[$K + 1] = $AARRAY[$K]
					$K -= 1
				WEND
				$AARRAY[$K + 1] = $IA2
				$IPIVOT_LEFT += 1
			WEND
			$ILAST = $AARRAY[$IPIVOT_RIGHT]
			$IPIVOT_RIGHT -= 1
			WHILE $ILAST < $AARRAY[$IPIVOT_RIGHT]
				$AARRAY[$IPIVOT_RIGHT + 1] = $AARRAY[$IPIVOT_RIGHT]
				$IPIVOT_RIGHT -= 1
			WEND
			$AARRAY[$IPIVOT_RIGHT + 1] = $ILAST
		ENDIF
		RETURN 1
	ENDIF
	LOCAL $ISEVENTH = BITSHIFT($ILENGTH, 3) + BITSHIFT($ILENGTH, 6) + 1
	LOCAL $IE1, $IE2, $IE3, $IE4, $IE5, $T
	$IE3 = CEILING(($IPIVOT_LEFT + $IPIVOT_RIGHT) / 2)
	$IE2 = $IE3 - $ISEVENTH
	$IE1 = $IE2 - $ISEVENTH
	$IE4 = $IE3 + $ISEVENTH
	$IE5 = $IE4 + $ISEVENTH
	IF $AARRAY[$IE2] < $AARRAY[$IE1] THEN
		$T = $AARRAY[$IE2]
		$AARRAY[$IE2] = $AARRAY[$IE1]
		$AARRAY[$IE1] = $T
	ENDIF
	IF $AARRAY[$IE3] < $AARRAY[$IE2] THEN
		$T = $AARRAY[$IE3]
		$AARRAY[$IE3] = $AARRAY[$IE2]
		$AARRAY[$IE2] = $T
		IF $T < $AARRAY[$IE1] THEN
			$AARRAY[$IE2] = $AARRAY[$IE1]
			$AARRAY[$IE1] = $T
		ENDIF
	ENDIF
	IF $AARRAY[$IE4] < $AARRAY[$IE3] THEN
		$T = $AARRAY[$IE4]
		$AARRAY[$IE4] = $AARRAY[$IE3]
		$AARRAY[$IE3] = $T
		IF $T < $AARRAY[$IE2] THEN
			$AARRAY[$IE3] = $AARRAY[$IE2]
			$AARRAY[$IE2] = $T
			IF $T < $AARRAY[$IE1] THEN
				$AARRAY[$IE2] = $AARRAY[$IE1]
				$AARRAY[$IE1] = $T
			ENDIF
		ENDIF
	ENDIF
	IF $AARRAY[$IE5] < $AARRAY[$IE4] THEN
		$T = $AARRAY[$IE5]
		$AARRAY[$IE5] = $AARRAY[$IE4]
		$AARRAY[$IE4] = $T
		IF $T < $AARRAY[$IE3] THEN
			$AARRAY[$IE4] = $AARRAY[$IE3]
			$AARRAY[$IE3] = $T
			IF $T < $AARRAY[$IE2] THEN
				$AARRAY[$IE3] = $AARRAY[$IE2]
				$AARRAY[$IE2] = $T
				IF $T < $AARRAY[$IE1] THEN
					$AARRAY[$IE2] = $AARRAY[$IE1]
					$AARRAY[$IE1] = $T
				ENDIF
			ENDIF
		ENDIF
	ENDIF
	LOCAL $ILESS = $IPIVOT_LEFT
	LOCAL $IGREATER = $IPIVOT_RIGHT
	IF(($AARRAY[$IE1] <> $AARRAY[$IE2]) AND($AARRAY[$IE2] <> $AARRAY[$IE3]) AND($AARRAY[$IE3] <> $AARRAY[$IE4]) AND($AARRAY[$IE4] <> $AARRAY[$IE5])) THEN
		LOCAL $IPIVOT_1 = $AARRAY[$IE2]
		LOCAL $IPIVOT_2 = $AARRAY[$IE4]
		$AARRAY[$IE2] = $AARRAY[$IPIVOT_LEFT]
		$AARRAY[$IE4] = $AARRAY[$IPIVOT_RIGHT]
		DO
			$ILESS += 1
		UNTIL $AARRAY[$ILESS] >= $IPIVOT_1
		DO
			$IGREATER -= 1
		UNTIL $AARRAY[$IGREATER] <= $IPIVOT_2
		$K = $ILESS
		WHILE $K <= $IGREATER
			$IAK = $AARRAY[$K]
			IF $IAK < $IPIVOT_1 THEN
				$AARRAY[$K] = $AARRAY[$ILESS]
				$AARRAY[$ILESS] = $IAK
				$ILESS += 1
			ELSEIF $IAK > $IPIVOT_2 THEN
				WHILE $AARRAY[$IGREATER] > $IPIVOT_2
					$IGREATER -= 1
					IF $IGREATER + 1 = $K THEN EXITLOOP 2
				WEND
				IF $AARRAY[$IGREATER] < $IPIVOT_1 THEN
					$AARRAY[$K] = $AARRAY[$ILESS]
					$AARRAY[$ILESS] = $AARRAY[$IGREATER]
					$ILESS += 1
				ELSE
					$AARRAY[$K] = $AARRAY[$IGREATER]
				ENDIF
				$AARRAY[$IGREATER] = $IAK
				$IGREATER -= 1
			ENDIF
			$K += 1
		WEND
		$AARRAY[$IPIVOT_LEFT] = $AARRAY[$ILESS - 1]
		$AARRAY[$ILESS - 1] = $IPIVOT_1
		$AARRAY[$IPIVOT_RIGHT] = $AARRAY[$IGREATER + 1]
		$AARRAY[$IGREATER + 1] = $IPIVOT_2
		__ARRAYDUALPIVOTSORT($AARRAY, $IPIVOT_LEFT, $ILESS - 2, TRUE)
		__ARRAYDUALPIVOTSORT($AARRAY, $IGREATER + 2, $IPIVOT_RIGHT, FALSE)
		IF($ILESS < $IE1) AND($IE5 < $IGREATER) THEN
			WHILE $AARRAY[$ILESS] = $IPIVOT_1
				$ILESS += 1
			WEND
			WHILE $AARRAY[$IGREATER] = $IPIVOT_2
				$IGREATER -= 1
			WEND
			$K = $ILESS
			WHILE $K <= $IGREATER
				$IAK = $AARRAY[$K]
				IF $IAK = $IPIVOT_1 THEN
					$AARRAY[$K] = $AARRAY[$ILESS]
					$AARRAY[$ILESS] = $IAK
					$ILESS += 1
				ELSEIF $IAK = $IPIVOT_2 THEN
					WHILE $AARRAY[$IGREATER] = $IPIVOT_2
						$IGREATER -= 1
						IF $IGREATER + 1 = $K THEN EXITLOOP 2
					WEND
					IF $AARRAY[$IGREATER] = $IPIVOT_1 THEN
						$AARRAY[$K] = $AARRAY[$ILESS]
						$AARRAY[$ILESS] = $IPIVOT_1
						$ILESS += 1
					ELSE
						$AARRAY[$K] = $AARRAY[$IGREATER]
					ENDIF
					$AARRAY[$IGREATER] = $IAK
					$IGREATER -= 1
				ENDIF
				$K += 1
			WEND
		ENDIF
		__ARRAYDUALPIVOTSORT($AARRAY, $ILESS, $IGREATER, FALSE)
	ELSE
		LOCAL $IPIVOT = $AARRAY[$IE3]
		$K = $ILESS
		WHILE $K <= $IGREATER
			IF $AARRAY[$K] = $IPIVOT THEN
				$K += 1
				CONTINUELOOP
			ENDIF
			$IAK = $AARRAY[$K]
			IF $IAK < $IPIVOT THEN
				$AARRAY[$K] = $AARRAY[$ILESS]
				$AARRAY[$ILESS] = $IAK
				$ILESS += 1
			ELSE
				WHILE $AARRAY[$IGREATER] > $IPIVOT
					$IGREATER -= 1
				WEND
				IF $AARRAY[$IGREATER] < $IPIVOT THEN
					$AARRAY[$K] = $AARRAY[$ILESS]
					$AARRAY[$ILESS] = $AARRAY[$IGREATER]
					$ILESS += 1
				ELSE
					$AARRAY[$K] = $IPIVOT
				ENDIF
				$AARRAY[$IGREATER] = $IAK
				$IGREATER -= 1
			ENDIF
			$K += 1
		WEND
		__ARRAYDUALPIVOTSORT($AARRAY, $IPIVOT_LEFT, $ILESS - 1, TRUE)
		__ARRAYDUALPIVOTSORT($AARRAY, $IGREATER + 1, $IPIVOT_RIGHT, FALSE)
	ENDIF
ENDFUNC
FUNC _ARRAYSWAP(BYREF $AARRAY, $IINDEX_1, $IINDEX_2, $BCOL = FALSE, $ISTART = -1, $IEND = -1)
	IF $BCOL = DEFAULT THEN $BCOL = FALSE
	IF $ISTART = DEFAULT THEN $ISTART = -1
	IF $IEND = DEFAULT THEN $IEND = -1
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS) - 1
	LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
	IF $IDIM_2 = -1 THEN
		$BCOL = FALSE
		$ISTART = -1
		$IEND = -1
	ENDIF
	IF $ISTART > $IEND THEN RETURN SETERROR(5, 0, -1)
	IF $BCOL THEN
		IF $IINDEX_1 < 0 OR $IINDEX_2 > $IDIM_2 THEN RETURN SETERROR(3, 0, -1)
		IF $ISTART = -1 THEN $ISTART = 0
		IF $IEND = -1 THEN $IEND = $IDIM_1
	ELSE
		IF $IINDEX_1 < 0 OR $IINDEX_2 > $IDIM_1 THEN RETURN SETERROR(3, 0, -1)
		IF $ISTART = -1 THEN $ISTART = 0
		IF $IEND = -1 THEN $IEND = $IDIM_2
	ENDIF
	LOCAL $VTMP
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			$VTMP = $AARRAY[$IINDEX_1]
			$AARRAY[$IINDEX_1] = $AARRAY[$IINDEX_2]
			$AARRAY[$IINDEX_2] = $VTMP
		CASE 2
			IF $ISTART < -1 OR $IEND < -1 THEN RETURN SETERROR(4, 0, -1)
			IF $BCOL THEN
				IF $ISTART > $IDIM_1 OR $IEND > $IDIM_1 THEN RETURN SETERROR(4, 0, -1)
				FOR $J = $ISTART TO $IEND
					$VTMP = $AARRAY[$J][$IINDEX_1]
					$AARRAY[$J][$IINDEX_1] = $AARRAY[$J][$IINDEX_2]
					$AARRAY[$J][$IINDEX_2] = $VTMP
				NEXT
			ELSE
				IF $ISTART > $IDIM_2 OR $IEND > $IDIM_2 THEN RETURN SETERROR(4, 0, -1)
				FOR $J = $ISTART TO $IEND
					$VTMP = $AARRAY[$IINDEX_1][$J]
					$AARRAY[$IINDEX_1][$J] = $AARRAY[$IINDEX_2][$J]
					$AARRAY[$IINDEX_2][$J] = $VTMP
				NEXT
			ENDIF
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN 1
ENDFUNC
FUNC _ARRAYTOCLIP(CONST BYREF $AARRAY, $SDELIM_COL = "|", $ISTART_ROW = -1, $IEND_ROW = -1, $SDELIM_ROW = @CRLF, $ISTART_COL = -1, $IEND_COL = -1)
	LOCAL $SRESULT = _ARRAYTOSTRING($AARRAY, $SDELIM_COL, $ISTART_ROW, $IEND_ROW, $SDELIM_ROW, $ISTART_COL, $IEND_COL)
	IF @ERROR THEN RETURN SETERROR(@ERROR, 0, 0)
	IF CLIPPUT($SRESULT) THEN RETURN 1
	RETURN SETERROR(-1, 0, 0)
ENDFUNC
FUNC _ARRAYTOSTRING(CONST BYREF $AARRAY, $SDELIM_COL = "|", $ISTART_ROW = -1, $IEND_ROW = -1, $SDELIM_ROW = @CRLF, $ISTART_COL = -1, $IEND_COL = -1)
	IF $SDELIM_COL = DEFAULT THEN $SDELIM_COL = "|"
	IF $SDELIM_ROW = DEFAULT THEN $SDELIM_ROW = @CRLF
	IF $ISTART_ROW = DEFAULT THEN $ISTART_ROW = -1
	IF $IEND_ROW = DEFAULT THEN $IEND_ROW = -1
	IF $ISTART_COL = DEFAULT THEN $ISTART_COL = -1
	IF $IEND_COL = DEFAULT THEN $IEND_COL = -1
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS) - 1
	IF $ISTART_ROW = -1 THEN $ISTART_ROW = 0
	IF $IEND_ROW = -1 THEN $IEND_ROW = $IDIM_1
	IF $ISTART_ROW < -1 OR $IEND_ROW < -1 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART_ROW > $IDIM_1 OR $IEND_ROW > $IDIM_1 THEN RETURN SETERROR(3, 0, "")
	IF $ISTART_ROW > $IEND_ROW THEN RETURN SETERROR(4, 0, -1)
	LOCAL $SRET = ""
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			FOR $I = $ISTART_ROW TO $IEND_ROW
				$SRET &= $AARRAY[$I] & $SDELIM_COL
			NEXT
			RETURN STRINGTRIMRIGHT($SRET, STRINGLEN($SDELIM_COL))
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
			IF $ISTART_COL = -1 THEN $ISTART_COL = 0
			IF $IEND_COL = -1 THEN $IEND_COL = $IDIM_2
			IF $ISTART_COL < -1 OR $IEND_COL < -1 THEN RETURN SETERROR(5, 0, -1)
			IF $ISTART_COL > $IDIM_2 OR $IEND_COL > $IDIM_2 THEN RETURN SETERROR(5, 0, -1)
			IF $ISTART_COL > $IEND_COL THEN RETURN SETERROR(6, 0, -1)
			FOR $I = $ISTART_ROW TO $IEND_ROW
				FOR $J = $ISTART_COL TO $IEND_COL
					$SRET &= $AARRAY[$I][$J] & $SDELIM_COL
				NEXT
				$SRET = STRINGTRIMRIGHT($SRET, STRINGLEN($SDELIM_COL)) & $SDELIM_ROW
			NEXT
			RETURN STRINGTRIMRIGHT($SRET, STRINGLEN($SDELIM_ROW))
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN 1
ENDFUNC
FUNC _ARRAYTRANSPOSE(BYREF $AARRAY)
	SWITCH UBOUND($AARRAY, 0)
		CASE 0
			RETURN SETERROR(2, 0, 0)
		CASE 1
			LOCAL $ATEMP[1][UBOUND($AARRAY)]
			FOR $I = 0 TO UBOUND($AARRAY) - 1
				$ATEMP[0][$I] = $AARRAY[$I]
			NEXT
			$AARRAY = $ATEMP
		CASE 2
			LOCAL $IDIM_1 = UBOUND($AARRAY, 1), $IDIM_2 = UBOUND($AARRAY, 2)
			IF $IDIM_1 <> $IDIM_2 THEN
				LOCAL $ATEMP[$IDIM_2][$IDIM_1]
				FOR $I = 0 TO $IDIM_1 - 1
					FOR $J = 0 TO $IDIM_2 - 1
						$ATEMP[$J][$I] = $AARRAY[$I][$J]
					NEXT
				NEXT
				$AARRAY = $ATEMP
			ELSE
				LOCAL $VELEMENT
				FOR $I = 0 TO $IDIM_1 - 1
					FOR $J = $I + 1 TO $IDIM_2 - 1
						$VELEMENT = $AARRAY[$I][$J]
						$AARRAY[$I][$J] = $AARRAY[$J][$I]
						$AARRAY[$J][$I] = $VELEMENT
					NEXT
				NEXT
			ENDIF
		CASE ELSE
			RETURN SETERROR(1, 0, 0)
	ENDSWITCH
	RETURN 1
ENDFUNC
FUNC _ARRAYTRIM(BYREF $AARRAY, $ITRIMNUM, $IDIRECTION = 0, $ISTART = 0, $IEND = 0, $ISUBITEM = 0)
	IF $IDIRECTION = DEFAULT THEN $IDIRECTION = 0
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $IEND = DEFAULT THEN $IEND = 0
	IF $ISUBITEM = DEFAULT THEN $ISUBITEM = 0
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, 0)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS) - 1
	IF $IEND = 0 THEN $IEND = $IDIM_1
	IF $ISTART > $IEND THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART < 0 OR $IEND < 0 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART > $IDIM_1 OR $IEND > $IDIM_1 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART > $IEND THEN RETURN SETERROR(4, 0, -1)
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			IF $IDIRECTION THEN
				FOR $I = $ISTART TO $IEND
					$AARRAY[$I] = STRINGTRIMRIGHT($AARRAY[$I], $ITRIMNUM)
				NEXT
			ELSE
				FOR $I = $ISTART TO $IEND
					$AARRAY[$I] = STRINGTRIMLEFT($AARRAY[$I], $ITRIMNUM)
				NEXT
			ENDIF
		CASE 2
			LOCAL $IDIM_2 = UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
			IF $ISUBITEM < 0 OR $ISUBITEM > $IDIM_2 THEN RETURN SETERROR(5, 0, -1)
			IF $IDIRECTION THEN
				FOR $I = $ISTART TO $IEND
					$AARRAY[$I][$ISUBITEM] = STRINGTRIMRIGHT($AARRAY[$I][$ISUBITEM], $ITRIMNUM)
				NEXT
			ELSE
				FOR $I = $ISTART TO $IEND
					$AARRAY[$I][$ISUBITEM] = STRINGTRIMLEFT($AARRAY[$I][$ISUBITEM], $ITRIMNUM)
				NEXT
			ENDIF
		CASE ELSE
			RETURN SETERROR(2, 0, 0)
	ENDSWITCH
	RETURN 1
ENDFUNC
FUNC _ARRAYUNIQUE(CONST BYREF $AARRAY, $ICOLUMN = 0, $IBASE = 0, $ICASE = 0, $ICOUNT = $ARRAYUNIQUE_COUNT, $IINTTYPE = $ARRAYUNIQUE_AUTO)
	IF $ICOLUMN = DEFAULT THEN $ICOLUMN = 0
	IF $IBASE = DEFAULT THEN $IBASE = 0
	IF $ICASE = DEFAULT THEN $ICASE = 0
	IF $ICOUNT = DEFAULT THEN $ICOUNT = $ARRAYUNIQUE_COUNT
	IF UBOUND($AARRAY, $UBOUND_ROWS) = 0 THEN RETURN SETERROR(1, 0, 0)
	LOCAL $IDIMS = UBOUND($AARRAY, $UBOUND_DIMENSIONS), $INUMCOLUMNS = UBOUND($AARRAY, $UBOUND_COLUMNS)
	IF $IDIMS > 2 THEN RETURN SETERROR(2, 0, 0)
	IF $IBASE < 0 OR $IBASE > 1 OR(NOT ISINT($IBASE)) THEN RETURN SETERROR(3, 0, 0)
	IF $ICASE < 0 OR $ICASE > 1 OR(NOT ISINT($ICASE)) THEN RETURN SETERROR(3, 0, 0)
	IF $ICOUNT < 0 OR $ICOUNT > 1 OR(NOT ISINT($ICOUNT)) THEN RETURN SETERROR(4, 0, 0)
	IF $IINTTYPE < 0 OR $IINTTYPE > 4 OR(NOT ISINT($IINTTYPE)) THEN RETURN SETERROR(5, 0, 0)
	IF $ICOLUMN < 0 OR($INUMCOLUMNS = 0 AND $ICOLUMN > 0) OR($INUMCOLUMNS > 0 AND $ICOLUMN >= $INUMCOLUMNS) THEN RETURN SETERROR(6, 0, 0)
	IF $IINTTYPE = $ARRAYUNIQUE_AUTO THEN
		LOCAL $BINT, $SVARTYPE
		IF $IDIMS = 1 THEN
			$BINT = ISINT($AARRAY[$IBASE])
			$SVARTYPE = VARGETTYPE($AARRAY[$IBASE])
		ELSE
			$BINT = ISINT($AARRAY[$IBASE][$ICOLUMN])
			$SVARTYPE = VARGETTYPE($AARRAY[$IBASE][$ICOLUMN])
		ENDIF
		IF $BINT AND $SVARTYPE = "Int64" THEN
			$IINTTYPE = $ARRAYUNIQUE_FORCE64
		ELSE
			$IINTTYPE = $ARRAYUNIQUE_FORCE32
		ENDIF
	ENDIF
	OBJEVENT("AutoIt.Error", __ARRAYUNIQUE_AUTOERRFUNC)
	LOCAL $ODICTIONARY = OBJCREATE("Scripting.Dictionary")
	$ODICTIONARY.CompareMode = NUMBER(NOT $ICASE)
	LOCAL $VELEM, $STYPE, $VKEY, $BCOMERROR = FALSE
	FOR $I = $IBASE TO UBOUND($AARRAY) - 1
		IF $IDIMS = 1 THEN
			$VELEM = $AARRAY[$I]
		ELSE
			$VELEM = $AARRAY[$I][$ICOLUMN]
		ENDIF
		SWITCH $IINTTYPE
			CASE $ARRAYUNIQUE_FORCE32
				$ODICTIONARY.Item($VELEM)
				IF @ERROR THEN
					$BCOMERROR = TRUE
					EXITLOOP
				ENDIF
			CASE $ARRAYUNIQUE_FORCE64
				$STYPE = VARGETTYPE($VELEM)
				IF $STYPE = "Int32" THEN
					$BCOMERROR = TRUE
					EXITLOOP
				ENDIF
				$VKEY = "#" & $STYPE & "#" & STRING($VELEM)
				IF NOT $ODICTIONARY.Item($VKEY) THEN
					$ODICTIONARY($VKEY) = $VELEM
				ENDIF
			CASE $ARRAYUNIQUE_MATCH
				$STYPE = VARGETTYPE($VELEM)
				IF STRINGLEFT($STYPE, 3) = "Int" THEN
					$VKEY = "#Int#" & STRING($VELEM)
				ELSE
					$VKEY = "#" & $STYPE & "#" & STRING($VELEM)
				ENDIF
				IF NOT $ODICTIONARY.Item($VKEY) THEN
					$ODICTIONARY($VKEY) = $VELEM
				ENDIF
			CASE $ARRAYUNIQUE_DISTINCT
				$VKEY = "#" & VARGETTYPE($VELEM) & "#" & STRING($VELEM)
				IF NOT $ODICTIONARY.Item($VKEY) THEN
					$ODICTIONARY($VKEY) = $VELEM
				ENDIF
		ENDSWITCH
	NEXT
	LOCAL $AVALUES, $J = 0
	IF $BCOMERROR THEN
		RETURN SETERROR(7, 0, 0)
	ELSEIF $IINTTYPE <> $ARRAYUNIQUE_FORCE32 THEN
		LOCAL $AVALUES[$ODICTIONARY.Count]
		FOR $VKEY IN $ODICTIONARY.Keys()
			$AVALUES[$J] = $ODICTIONARY($VKEY)
			IF STRINGLEFT($VKEY, 5) = "#Ptr#" THEN
				$AVALUES[$J] = PTR($AVALUES[$J])
			ENDIF
			$J += 1
		NEXT
	ELSE
		$AVALUES = $ODICTIONARY.Keys()
	ENDIF
	IF $ICOUNT THEN
		_ARRAYINSERT($AVALUES, 0, $ODICTIONARY.Count)
	ENDIF
	RETURN $AVALUES
ENDFUNC
FUNC _ARRAY1DTOHISTOGRAM($AARRAY, $ISIZING = 100)
	IF UBOUND($AARRAY, 0) > 1 THEN RETURN SETERROR(1, 0, "")
	$ISIZING = $ISIZING * 8
	LOCAL $T, $N, $IMIN = 0, $IMAX = 0, $IOFFSET = 0
	FOR $I = 0 TO UBOUND($AARRAY) - 1
		$T = $AARRAY[$I]
		$T = ISNUMBER($T) ? ROUND($T) : 0
		IF $T < $IMIN THEN $IMIN = $T
		IF $T > $IMAX THEN $IMAX = $T
	NEXT
	LOCAL $IRANGE = INT(ROUND(($IMAX - $IMIN) / 8)) * 8
	LOCAL $ISPACERATIO = 4
	FOR $I = 0 TO UBOUND($AARRAY) - 1
		$T = $AARRAY[$I]
		IF $T THEN
			$N = ABS(ROUND(($ISIZING * $T) / $IRANGE) / 8)
			$AARRAY[$I] = ""
			IF $T > 0 THEN
				IF $IMIN THEN
					$IOFFSET = INT(ABS(ROUND(($ISIZING * $IMIN) / $IRANGE) / 8) / 8 * $ISPACERATIO)
					$AARRAY[$I] = __ARRAY_STRINGREPEAT(CHRW(32), $IOFFSET)
				ENDIF
			ELSE
				IF $IMIN <> $T THEN
					$IOFFSET = INT(ABS(ROUND(($ISIZING * ($T - $IMIN)) / $IRANGE) / 8) / 8 * $ISPACERATIO)
					$AARRAY[$I] = __ARRAY_STRINGREPEAT(CHRW(32), $IOFFSET)
				ENDIF
			ENDIF
			$AARRAY[$I] &= __ARRAY_STRINGREPEAT(CHRW(9608), INT($N / 8))
			$N = MOD($N, 8)
			IF $N > 0 THEN $AARRAY[$I] &= CHRW(9608 + 8 - $N)
			$AARRAY[$I] &= " " & $T
		ELSE
			$AARRAY[$I] = ""
		ENDIF
	NEXT
	RETURN $AARRAY
ENDFUNC
FUNC __ARRAY_STRINGREPEAT($SSTRING, $IREPEATCOUNT)
	$IREPEATCOUNT = INT($IREPEATCOUNT)
	IF STRINGLEN($SSTRING) < 1 OR $IREPEATCOUNT <= 0 THEN RETURN SETERROR(1, 0, "")
	LOCAL $SRESULT = ""
	WHILE $IREPEATCOUNT > 1
		IF BITAND($IREPEATCOUNT, 1) THEN $SRESULT &= $SSTRING
		$SSTRING &= $SSTRING
		$IREPEATCOUNT = BITSHIFT($IREPEATCOUNT, 1)
	WEND
	RETURN $SSTRING & $SRESULT
ENDFUNC
FUNC __ARRAY_EXETERINTERNAL(BYREF $AARRAY, $ISTART, $ISIZE, $SDELIMITER, BYREF $AIDX, BYREF $ARESULT, BYREF $ICOUNT)
	IF $ISTART == $ISIZE - 1 THEN
		FOR $I = 0 TO $ISIZE - 1
			$ARESULT[$ICOUNT] &= $AARRAY[$AIDX[$I]] & $SDELIMITER
		NEXT
		IF $SDELIMITER <> "" THEN $ARESULT[$ICOUNT] = STRINGTRIMRIGHT($ARESULT[$ICOUNT], STRINGLEN($SDELIMITER))
		$ICOUNT += 1
	ELSE
		LOCAL $ITEMP
		FOR $I = $ISTART TO $ISIZE - 1
			$ITEMP = $AIDX[$I]
			$AIDX[$I] = $AIDX[$ISTART]
			$AIDX[$ISTART] = $ITEMP
			__ARRAY_EXETERINTERNAL($AARRAY, $ISTART + 1, $ISIZE, $SDELIMITER, $AIDX, $ARESULT, $ICOUNT)
			$AIDX[$ISTART] = $AIDX[$I]
			$AIDX[$I] = $ITEMP
		NEXT
	ENDIF
ENDFUNC
FUNC __ARRAY_COMBINATIONS($IN, $IR)
	LOCAL $I_TOTAL = 1
	FOR $I = $IR TO 1 STEP -1
		$I_TOTAL *= ($IN / $I)
		$IN -= 1
	NEXT
	RETURN ROUND($I_TOTAL)
ENDFUNC
FUNC __ARRAY_GETNEXT($IN, $IR, BYREF $ILEFT, $ITOTAL, BYREF $AIDX)
	IF $ILEFT == $ITOTAL THEN
		$ILEFT -= 1
		RETURN
	ENDIF
	LOCAL $I = $IR - 1
	WHILE $AIDX[$I] == $IN - $IR + $I
		$I -= 1
	WEND
	$AIDX[$I] += 1
	FOR $J = $I + 1 TO $IR - 1
		$AIDX[$J] = $AIDX[$I] + $J - $I
	NEXT
	$ILEFT -= 1
ENDFUNC
FUNC __ARRAY_MINMAXINDEX(CONST BYREF $AARRAY, $ICOMPNUMERIC, $ISTART, $IEND, $ISUBITEM, $FUCOMPARISON)
	IF $ICOMPNUMERIC = DEFAULT THEN $ICOMPNUMERIC = 0
	IF $ICOMPNUMERIC <> 1 THEN $ICOMPNUMERIC = 0
	IF $ISTART = DEFAULT THEN $ISTART = 0
	IF $IEND = DEFAULT THEN $IEND = 0
	IF $ISUBITEM = DEFAULT THEN $ISUBITEM = 0
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(1, 0, -1)
	LOCAL $IDIM_1 = UBOUND($AARRAY, $UBOUND_ROWS) - 1
	IF $IDIM_1 < 0 THEN RETURN SETERROR(1, 0, -1)
	IF $IEND = -1 THEN $IEND = $IDIM_1
	IF $ISTART = -1 THEN $ISTART = 0
	IF $ISTART < -1 OR $IEND < -1 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART > $IDIM_1 OR $IEND > $IDIM_1 THEN RETURN SETERROR(3, 0, -1)
	IF $ISTART > $IEND THEN RETURN SETERROR(4, 0, -1)
	IF $IDIM_1 < 0 THEN RETURN SETERROR(5, 0, -1)
	LOCAL $IMAXMININDEX = $ISTART
	SWITCH UBOUND($AARRAY, $UBOUND_DIMENSIONS)
		CASE 1
			IF $ICOMPNUMERIC THEN
				FOR $I = $ISTART TO $IEND
					IF $FUCOMPARISON(NUMBER($AARRAY[$I]), NUMBER($AARRAY[$IMAXMININDEX])) THEN $IMAXMININDEX = $I
				NEXT
			ELSE
				FOR $I = $ISTART TO $IEND
					IF $FUCOMPARISON($AARRAY[$I], $AARRAY[$IMAXMININDEX]) THEN $IMAXMININDEX = $I
				NEXT
			ENDIF
		CASE 2
			IF $ISUBITEM < 0 OR $ISUBITEM > UBOUND($AARRAY, $UBOUND_COLUMNS) - 1 THEN RETURN SETERROR(6, 0, -1)
			IF $ICOMPNUMERIC THEN
				FOR $I = $ISTART TO $IEND
					IF $FUCOMPARISON(NUMBER($AARRAY[$I][$ISUBITEM]), NUMBER($AARRAY[$IMAXMININDEX][$ISUBITEM])) THEN $IMAXMININDEX = $I
				NEXT
			ELSE
				FOR $I = $ISTART TO $IEND
					IF $FUCOMPARISON($AARRAY[$I][$ISUBITEM], $AARRAY[$IMAXMININDEX][$ISUBITEM]) THEN $IMAXMININDEX = $I
				NEXT
			ENDIF
		CASE ELSE
			RETURN SETERROR(2, 0, -1)
	ENDSWITCH
	RETURN $IMAXMININDEX
ENDFUNC
FUNC __ARRAY_GREATERTHAN($VVALUE1, $VVALUE2)
	RETURN $VVALUE1 > $VVALUE2
ENDFUNC
FUNC __ARRAY_LESSTHAN($VVALUE1, $VVALUE2)
	RETURN $VVALUE1 < $VVALUE2
ENDFUNC
FUNC __ARRAYUNIQUE_AUTOERRFUNC()
ENDFUNC
GLOBAL CONST $FW_DONTCARE = 0
GLOBAL CONST $FW_THIN = 100
GLOBAL CONST $FW_EXTRALIGHT = 200
GLOBAL CONST $FW_ULTRALIGHT = 200
GLOBAL CONST $FW_LIGHT = 300
GLOBAL CONST $FW_NORMAL = 400
GLOBAL CONST $FW_REGULAR = 400
GLOBAL CONST $FW_MEDIUM = 500
GLOBAL CONST $FW_SEMIBOLD = 600
GLOBAL CONST $FW_DEMIBOLD = 600
GLOBAL CONST $FW_BOLD = 700
GLOBAL CONST $FW_EXTRABOLD = 800
GLOBAL CONST $FW_ULTRABOLD = 800
GLOBAL CONST $FW_HEAVY = 900
GLOBAL CONST $FW_BLACK = 900
GLOBAL CONST $CF_EFFECTS = 256
GLOBAL CONST $CF_PRINTERFONTS = 2
GLOBAL CONST $CF_SCREENFONTS = 1
GLOBAL CONST $CF_NOSCRIPTSEL = 8388608
GLOBAL CONST $CF_INITTOLOGFONTSTRUCT = 64
GLOBAL CONST $LOGPIXELSX = 88
GLOBAL CONST $LOGPIXELSY = 90
GLOBAL CONST $ANSI_CHARSET = 0
GLOBAL CONST $ARABIC_CHARSET = 178
GLOBAL CONST $BALTIC_CHARSET = 186
GLOBAL CONST $CHINESEBIG5_CHARSET = 136
GLOBAL CONST $DEFAULT_CHARSET = 1
GLOBAL CONST $EASTEUROPE_CHARSET = 238
GLOBAL CONST $GB2312_CHARSET = 134
GLOBAL CONST $GREEK_CHARSET = 161
GLOBAL CONST $HANGEUL_CHARSET = 129
GLOBAL CONST $HEBREW_CHARSET = 177
GLOBAL CONST $JOHAB_CHARSET = 130
GLOBAL CONST $MAC_CHARSET = 77
GLOBAL CONST $OEM_CHARSET = 255
GLOBAL CONST $RUSSIAN_CHARSET = 204
GLOBAL CONST $SHIFTJIS_CHARSET = 128
GLOBAL CONST $SYMBOL_CHARSET = 2
GLOBAL CONST $THAI_CHARSET = 222
GLOBAL CONST $TURKISH_CHARSET = 162
GLOBAL CONST $VIETNAMESE_CHARSET = 163
GLOBAL CONST $OUT_CHARACTER_PRECIS = 2
GLOBAL CONST $OUT_DEFAULT_PRECIS = 0
GLOBAL CONST $OUT_DEVICE_PRECIS = 5
GLOBAL CONST $OUT_OUTLINE_PRECIS = 8
GLOBAL CONST $OUT_PS_ONLY_PRECIS = 10
GLOBAL CONST $OUT_RASTER_PRECIS = 6
GLOBAL CONST $OUT_STRING_PRECIS = 1
GLOBAL CONST $OUT_STROKE_PRECIS = 3
GLOBAL CONST $OUT_TT_ONLY_PRECIS = 7
GLOBAL CONST $OUT_TT_PRECIS = 4
GLOBAL CONST $CLIP_CHARACTER_PRECIS = 1
GLOBAL CONST $CLIP_DEFAULT_PRECIS = 0
GLOBAL CONST $CLIP_DFA_DISABLE = 48
GLOBAL CONST $CLIP_EMBEDDED = 128
GLOBAL CONST $CLIP_LH_ANGLES = 16
GLOBAL CONST $CLIP_MASK = 15
GLOBAL CONST $CLIP_DFA_OVERRIDE = 64
GLOBAL CONST $CLIP_STROKE_PRECIS = 2
GLOBAL CONST $CLIP_TT_ALWAYS = 32
GLOBAL CONST $ANTIALIASED_QUALITY = 4
GLOBAL CONST $DEFAULT_QUALITY = 0
GLOBAL CONST $DRAFT_QUALITY = 1
GLOBAL CONST $NONANTIALIASED_QUALITY = 3
GLOBAL CONST $PROOF_QUALITY = 2
GLOBAL CONST $CLEARTYPE_QUALITY = 5
GLOBAL CONST $DEFAULT_PITCH = 0
GLOBAL CONST $FIXED_PITCH = 1
GLOBAL CONST $VARIABLE_PITCH = 2
GLOBAL CONST $FF_DECORATIVE = 80
GLOBAL CONST $FF_DONTCARE = 0
GLOBAL CONST $FF_MODERN = 48
GLOBAL CONST $FF_ROMAN = 16
GLOBAL CONST $FF_SCRIPT = 64
GLOBAL CONST $FF_SWISS = 32
GLOBAL CONST $FS_REGULAR = 0
GLOBAL CONST $FS_BOLD = 1
GLOBAL CONST $FS_ITALIC = 2
GLOBAL CONST $__MISCCONSTANT_CC_ANYCOLOR = 256
GLOBAL CONST $__MISCCONSTANT_CC_FULLOPEN = 2
GLOBAL CONST $__MISCCONSTANT_CC_RGBINIT = 1
GLOBAL CONST $TAGCHOOSECOLOR = "dword Size;hwnd hWndOwnder;handle hInstance;dword rgbResult;ptr CustColors;dword Flags;lparam lCustData;" & "ptr lpfnHook;ptr lpTemplateName"
GLOBAL CONST $TAGCHOOSEFONT = "dword Size;hwnd hWndOwner;handle hDC;ptr LogFont;int PointSize;dword Flags;dword rgbColors;lparam CustData;" & "ptr fnHook;ptr TemplateName;handle hInstance;ptr szStyle;word FontType;int SizeMin;int SizeMax"
FUNC _CHOOSECOLOR($IRETURNTYPE = 0, $ICOLORREF = 0, $IREFTYPE = 0, $HWNDOWNDER = 0)
	LOCAL $TAGCUSTCOLORS = "dword[16]"
	LOCAL $TCHOOSE = DLLSTRUCTCREATE($TAGCHOOSECOLOR)
	LOCAL $TCC = DLLSTRUCTCREATE($TAGCUSTCOLORS)
	IF $IREFTYPE = 1 THEN
		$ICOLORREF = INT($ICOLORREF)
	ELSEIF $IREFTYPE = 2 THEN
		$ICOLORREF = HEX(STRING($ICOLORREF), 6)
		$ICOLORREF = "0x" & STRINGMID($ICOLORREF, 5, 2) & STRINGMID($ICOLORREF, 3, 2) & STRINGMID($ICOLORREF, 1, 2)
	ENDIF
	DLLSTRUCTSETDATA($TCHOOSE, "Size", DLLSTRUCTGETSIZE($TCHOOSE))
	DLLSTRUCTSETDATA($TCHOOSE, "hWndOwnder", $HWNDOWNDER)
	DLLSTRUCTSETDATA($TCHOOSE, "rgbResult", $ICOLORREF)
	DLLSTRUCTSETDATA($TCHOOSE, "CustColors", DLLSTRUCTGETPTR($TCC))
	DLLSTRUCTSETDATA($TCHOOSE, "Flags", BITOR($__MISCCONSTANT_CC_ANYCOLOR, $__MISCCONSTANT_CC_FULLOPEN, $__MISCCONSTANT_CC_RGBINIT))
	LOCAL $ARESULT = DLLCALL("comdlg32.dll", "bool", "ChooseColor", "struct*", $TCHOOSE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] = 0 THEN RETURN SETERROR(-3, -3, -1)
	LOCAL $SCOLOR_PICKED = DLLSTRUCTGETDATA($TCHOOSE, "rgbResult")
	IF $IRETURNTYPE = 1 THEN
		RETURN "0x" & HEX(STRING($SCOLOR_PICKED), 6)
	ELSEIF $IRETURNTYPE = 2 THEN
		$SCOLOR_PICKED = HEX(STRING($SCOLOR_PICKED), 6)
		RETURN "0x" & STRINGMID($SCOLOR_PICKED, 5, 2) & STRINGMID($SCOLOR_PICKED, 3, 2) & STRINGMID($SCOLOR_PICKED, 1, 2)
	ELSEIF $IRETURNTYPE = 0 THEN
		RETURN $SCOLOR_PICKED
	ELSE
		RETURN SETERROR(-4, -4, -1)
	ENDIF
ENDFUNC
FUNC _CHOOSEFONT($SFONTNAME = "Courier New", $IPOINTSIZE = 10, $IFONTCOLORREF = 0, $IFONTWEIGHT = 0, $BITALIC = FALSE, $BUNDERLINE = FALSE, $BSTRIKETHRU = FALSE, $HWNDOWNER = 0)
	LOCAL $IITALIC = 0, $IUNDERLINE = 0, $ISTRIKEOUT = 0
	$IFONTCOLORREF = BITOR(BITSHIFT(BITAND($IFONTCOLORREF, 255), -16), BITAND($IFONTCOLORREF, 65280), BITSHIFT(BITAND($IFONTCOLORREF, 16711680), 16))
	LOCAL $HDC = __MISC_GETDC(0)
	LOCAL $IHEIGHT = ROUND(($IPOINTSIZE * __MISC_GETDEVICECAPS($HDC, $LOGPIXELSX)) / 72, 0)
	__MISC_RELEASEDC(0, $HDC)
	LOCAL $TCHOOSEFONT = DLLSTRUCTCREATE($TAGCHOOSEFONT)
	LOCAL $TLOGFONT = DLLSTRUCTCREATE($TAGLOGFONT)
	DLLSTRUCTSETDATA($TCHOOSEFONT, "Size", DLLSTRUCTGETSIZE($TCHOOSEFONT))
	DLLSTRUCTSETDATA($TCHOOSEFONT, "hWndOwner", $HWNDOWNER)
	DLLSTRUCTSETDATA($TCHOOSEFONT, "LogFont", DLLSTRUCTGETPTR($TLOGFONT))
	DLLSTRUCTSETDATA($TCHOOSEFONT, "PointSize", $IPOINTSIZE)
	DLLSTRUCTSETDATA($TCHOOSEFONT, "Flags", BITOR($CF_SCREENFONTS, $CF_PRINTERFONTS, $CF_EFFECTS, $CF_INITTOLOGFONTSTRUCT, $CF_NOSCRIPTSEL))
	DLLSTRUCTSETDATA($TCHOOSEFONT, "rgbColors", $IFONTCOLORREF)
	DLLSTRUCTSETDATA($TCHOOSEFONT, "FontType", 0)
	DLLSTRUCTSETDATA($TLOGFONT, "Height", $IHEIGHT)
	DLLSTRUCTSETDATA($TLOGFONT, "Weight", $IFONTWEIGHT)
	DLLSTRUCTSETDATA($TLOGFONT, "Italic", $BITALIC)
	DLLSTRUCTSETDATA($TLOGFONT, "Underline", $BUNDERLINE)
	DLLSTRUCTSETDATA($TLOGFONT, "Strikeout", $BSTRIKETHRU)
	DLLSTRUCTSETDATA($TLOGFONT, "FaceName", $SFONTNAME)
	LOCAL $ARESULT = DLLCALL("comdlg32.dll", "bool", "ChooseFontW", "struct*", $TCHOOSEFONT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF $ARESULT[0] = 0 THEN RETURN SETERROR(-3, -3, -1)
	LOCAL $SFACENAME = DLLSTRUCTGETDATA($TLOGFONT, "FaceName")
	IF STRINGLEN($SFACENAME) = 0 AND STRINGLEN($SFONTNAME) > 0 THEN $SFACENAME = $SFONTNAME
	IF DLLSTRUCTGETDATA($TLOGFONT, "Italic") THEN $IITALIC = 2
	IF DLLSTRUCTGETDATA($TLOGFONT, "Underline") THEN $IUNDERLINE = 4
	IF DLLSTRUCTGETDATA($TLOGFONT, "Strikeout") THEN $ISTRIKEOUT = 8
	LOCAL $IATTRIBUTES = BITOR($IITALIC, $IUNDERLINE, $ISTRIKEOUT)
	LOCAL $ISIZE = DLLSTRUCTGETDATA($TCHOOSEFONT, "PointSize") / 10
	LOCAL $ICOLORREF = DLLSTRUCTGETDATA($TCHOOSEFONT, "rgbColors")
	LOCAL $IWEIGHT = DLLSTRUCTGETDATA($TLOGFONT, "Weight")
	LOCAL $SCOLOR_PICKED = HEX(STRING($ICOLORREF), 6)
	RETURN STRINGSPLIT($IATTRIBUTES & "," & $SFACENAME & "," & $ISIZE & "," & $IWEIGHT & "," & $ICOLORREF & "," & "0x" & $SCOLOR_PICKED & "," & "0x" & STRINGMID($SCOLOR_PICKED, 5, 2) & STRINGMID($SCOLOR_PICKED, 3, 2) & STRINGMID($SCOLOR_PICKED, 1, 2), ",")
ENDFUNC
FUNC _CLIPPUTFILE($SFILEPATH, $SDELIMITER = "|")
	LOCAL CONST $GMEM_MOVEABLE = 2, $CF_HDROP = 15
	$SFILEPATH &= $SDELIMITER & $SDELIMITER
	LOCAL $NGLOBMEMSIZE = 2 * (STRINGLEN($SFILEPATH) + 20)
	LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "OpenClipboard", "hwnd", 0)
	IF @ERROR OR $ARESULT[0] = 0 THEN RETURN SETERROR(1, _WINAPI_GETLASTERROR(), FALSE)
	LOCAL $IERROR = 0, $ILASTERROR = 0
	$ARESULT = DLLCALL("user32.dll", "bool", "EmptyClipboard")
	IF @ERROR OR NOT $ARESULT[0] THEN
		$IERROR = 2
		$ILASTERROR = _WINAPI_GETLASTERROR()
	ELSE
		$ARESULT = DLLCALL("kernel32.dll", "handle", "GlobalAlloc", "uint", $GMEM_MOVEABLE, "ulong_ptr", $NGLOBMEMSIZE)
		IF @ERROR OR NOT $ARESULT[0] THEN
			$IERROR = 3
			$ILASTERROR = _WINAPI_GETLASTERROR()
		ELSE
			LOCAL $HGLOBAL = $ARESULT[0]
			$ARESULT = DLLCALL("kernel32.dll", "ptr", "GlobalLock", "handle", $HGLOBAL)
			IF @ERROR OR NOT $ARESULT[0] THEN
				$IERROR = 4
				$ILASTERROR = _WINAPI_GETLASTERROR()
			ELSE
				LOCAL $HLOCK = $ARESULT[0]
				LOCAL $TDROPFILES = DLLSTRUCTCREATE("dword pFiles;" & $TAGPOINT & ";bool fNC;bool fWide;wchar[" & STRINGLEN($SFILEPATH) + 1 & "]", $HLOCK)
				IF @ERROR THEN RETURN SETERROR(5, 6, FALSE)
				LOCAL $TSTRUCT = DLLSTRUCTCREATE("dword;long;long;bool;bool")
				DLLSTRUCTSETDATA($TDROPFILES, "pFiles", DLLSTRUCTGETSIZE($TSTRUCT))
				DLLSTRUCTSETDATA($TDROPFILES, "X", 0)
				DLLSTRUCTSETDATA($TDROPFILES, "Y", 0)
				DLLSTRUCTSETDATA($TDROPFILES, "fNC", 0)
				DLLSTRUCTSETDATA($TDROPFILES, "fWide", 1)
				DLLSTRUCTSETDATA($TDROPFILES, 6, $SFILEPATH)
				FOR $I = 1 TO STRINGLEN($SFILEPATH)
					IF DLLSTRUCTGETDATA($TDROPFILES, 6, $I) = $SDELIMITER THEN DLLSTRUCTSETDATA($TDROPFILES, 6, CHR(0), $I)
				NEXT
				$ARESULT = DLLCALL("user32.dll", "handle", "SetClipboardData", "uint", $CF_HDROP, "handle", $HGLOBAL)
				IF @ERROR OR NOT $ARESULT[0] THEN
					$IERROR = 6
					$ILASTERROR = _WINAPI_GETLASTERROR()
				ENDIF
				$ARESULT = DLLCALL("kernel32.dll", "bool", "GlobalUnlock", "handle", $HGLOBAL)
				IF(@ERROR OR NOT $ARESULT[0]) AND NOT $IERROR AND _WINAPI_GETLASTERROR() THEN
					$IERROR = 8
					$ILASTERROR = _WINAPI_GETLASTERROR()
				ENDIF
			ENDIF
			$ARESULT = DLLCALL("kernel32.dll", "ptr", "GlobalFree", "handle", $HGLOBAL)
			IF(@ERROR OR $ARESULT[0]) AND NOT $IERROR THEN
				$IERROR = 9
				$ILASTERROR = _WINAPI_GETLASTERROR()
			ENDIF
		ENDIF
	ENDIF
	$ARESULT = DLLCALL("user32.dll", "bool", "CloseClipboard")
	IF(@ERROR OR NOT $ARESULT[0]) AND NOT $IERROR THEN RETURN SETERROR(7, _WINAPI_GETLASTERROR(), FALSE)
	IF $IERROR THEN RETURN SETERROR($IERROR, $ILASTERROR, FALSE)
	RETURN TRUE
ENDFUNC
FUNC _MOUSETRAP($ILEFT = 0, $ITOP = 0, $IRIGHT = 0, $IBOTTOM = 0)
	LOCAL $ARETURN = 0
	IF $ILEFT = DEFAULT THEN $ILEFT = 0
	IF $ITOP = DEFAULT THEN $ITOP = 0
	IF $IRIGHT = DEFAULT THEN $IRIGHT = 0
	IF $IBOTTOM = DEFAULT THEN $IBOTTOM = 0
	IF @NUMPARAMS = 0 THEN
		$ARETURN = DLLCALL("user32.dll", "bool", "ClipCursor", "ptr", 0)
		IF @ERROR OR NOT $ARETURN[0] THEN RETURN SETERROR(1, _WINAPI_GETLASTERROR(), FALSE)
	ELSE
		IF @NUMPARAMS = 2 THEN
			$IRIGHT = $ILEFT + 1
			$IBOTTOM = $ITOP + 1
		ENDIF
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		DLLSTRUCTSETDATA($TRECT, "Left", $ILEFT)
		DLLSTRUCTSETDATA($TRECT, "Top", $ITOP)
		DLLSTRUCTSETDATA($TRECT, "Right", $IRIGHT)
		DLLSTRUCTSETDATA($TRECT, "Bottom", $IBOTTOM)
		$ARETURN = DLLCALL("user32.dll", "bool", "ClipCursor", "struct*", $TRECT)
		IF @ERROR OR NOT $ARETURN[0] THEN RETURN SETERROR(2, _WINAPI_GETLASTERROR(), FALSE)
	ENDIF
	RETURN TRUE
ENDFUNC
FUNC _SINGLETON($SOCCURRENCENAME, $IFLAG = 0)
	LOCAL CONST $ERROR_ALREADY_EXISTS = 183
	LOCAL CONST $SECURITY_DESCRIPTOR_REVISION = 1
	LOCAL $TSECURITYATTRIBUTES = 0
	IF BITAND($IFLAG, 2) THEN
		LOCAL $TSECURITYDESCRIPTOR = DLLSTRUCTCREATE("byte;byte;word;ptr[4]")
		LOCAL $ARET = DLLCALL("advapi32.dll", "bool", "InitializeSecurityDescriptor", "struct*", $TSECURITYDESCRIPTOR, "dword", $SECURITY_DESCRIPTOR_REVISION)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN
			$ARET = DLLCALL("advapi32.dll", "bool", "SetSecurityDescriptorDacl", "struct*", $TSECURITYDESCRIPTOR, "bool", 1, "ptr", 0, "bool", 0)
			IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
			IF $ARET[0] THEN
				$TSECURITYATTRIBUTES = DLLSTRUCTCREATE($TAGSECURITY_ATTRIBUTES)
				DLLSTRUCTSETDATA($TSECURITYATTRIBUTES, 1, DLLSTRUCTGETSIZE($TSECURITYATTRIBUTES))
				DLLSTRUCTSETDATA($TSECURITYATTRIBUTES, 2, DLLSTRUCTGETPTR($TSECURITYDESCRIPTOR))
				DLLSTRUCTSETDATA($TSECURITYATTRIBUTES, 3, 0)
			ENDIF
		ENDIF
	ENDIF
	LOCAL $AHANDLE = DLLCALL("kernel32.dll", "handle", "CreateMutexW", "struct*", $TSECURITYATTRIBUTES, "bool", 1, "wstr", $SOCCURRENCENAME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	LOCAL $ALASTERROR = DLLCALL("kernel32.dll", "dword", "GetLastError")
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF $ALASTERROR[0] = $ERROR_ALREADY_EXISTS THEN
		IF BITAND($IFLAG, 1) THEN
			DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $AHANDLE[0])
			IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
			RETURN SETERROR($ALASTERROR[0], $ALASTERROR[0], 0)
		ELSE
			EXIT -1
		ENDIF
	ENDIF
	RETURN $AHANDLE[0]
ENDFUNC
FUNC _ISPRESSED($SHEXKEY, $VDLL = "user32.dll")
	LOCAL $ARETURN = DLLCALL($VDLL, "short", "GetAsyncKeyState", "int", "0x" & $SHEXKEY)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN BITAND($ARETURN[0], 32768) <> 0
ENDFUNC
FUNC _VERSIONCOMPARE($SVERSION1, $SVERSION2)
	IF $SVERSION1 = $SVERSION2 THEN RETURN 0
	LOCAL $SSUBVERSION1 = "", $SSUBVERSION2 = ""
	IF STRINGISALPHA(STRINGRIGHT($SVERSION1, 1)) THEN
		$SSUBVERSION1 = STRINGRIGHT($SVERSION1, 1)
		$SVERSION1 = STRINGTRIMRIGHT($SVERSION1, 1)
	ENDIF
	IF STRINGISALPHA(STRINGRIGHT($SVERSION2, 1)) THEN
		$SSUBVERSION2 = STRINGRIGHT($SVERSION2, 1)
		$SVERSION2 = STRINGTRIMRIGHT($SVERSION2, 1)
	ENDIF
	LOCAL $AVERSION1 = STRINGSPLIT($SVERSION1, ".,"), $AVERSION2 = STRINGSPLIT($SVERSION2, ".,")
	LOCAL $IPARTDIFFERENCE = ($AVERSION1[0] - $AVERSION2[0])
	IF $IPARTDIFFERENCE < 0 THEN
		REDIM $AVERSION1[UBOUND($AVERSION2)]
		$AVERSION1[0] = UBOUND($AVERSION1) - 1
		FOR $I = (UBOUND($AVERSION1) - ABS($IPARTDIFFERENCE)) TO $AVERSION1[0]
			$AVERSION1[$I] = "0"
		NEXT
	ELSEIF $IPARTDIFFERENCE > 0 THEN
		REDIM $AVERSION2[UBOUND($AVERSION1)]
		$AVERSION2[0] = UBOUND($AVERSION2) - 1
		FOR $I = (UBOUND($AVERSION2) - ABS($IPARTDIFFERENCE)) TO $AVERSION2[0]
			$AVERSION2[$I] = "0"
		NEXT
	ENDIF
	FOR $I = 1 TO $AVERSION1[0]
		IF STRINGISDIGIT($AVERSION1[$I]) AND STRINGISDIGIT($AVERSION2[$I]) THEN
			IF NUMBER($AVERSION1[$I]) > NUMBER($AVERSION2[$I]) THEN
				RETURN SETEXTENDED(2, 1)
			ELSEIF NUMBER($AVERSION1[$I]) < NUMBER($AVERSION2[$I]) THEN
				RETURN SETEXTENDED(2, -1)
			ELSEIF $I = $AVERSION1[0] THEN
				IF $SSUBVERSION1 > $SSUBVERSION2 THEN
					RETURN SETEXTENDED(3, 1)
				ELSEIF $SSUBVERSION1 < $SSUBVERSION2 THEN
					RETURN SETEXTENDED(3, -1)
				ENDIF
			ENDIF
		ELSE
			IF $AVERSION1[$I] > $AVERSION2[$I] THEN
				RETURN SETEXTENDED(1, 1)
			ELSEIF $AVERSION1[$I] < $AVERSION2[$I] THEN
				RETURN SETEXTENDED(1, -1)
			ENDIF
		ENDIF
	NEXT
	RETURN SETEXTENDED(ABS($IPARTDIFFERENCE), 0)
ENDFUNC
FUNC __MISC_GETDC($HWND)
	LOCAL $ARESULT = DLLCALL("user32.dll", "handle", "GetDC", "hwnd", $HWND)
	IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(1, _WINAPI_GETLASTERROR(), 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC __MISC_GETDEVICECAPS($HDC, $IINDEX)
	LOCAL $ARESULT = DLLCALL("gdi32.dll", "int", "GetDeviceCaps", "handle", $HDC, "int", $IINDEX)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC __MISC_RELEASEDC($HWND, $HDC)
	LOCAL $ARESULT = DLLCALL("user32.dll", "int", "ReleaseDC", "hwnd", $HWND, "handle", $HDC)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0] <> 0
ENDFUNC
FUNC _FILECOUNTLINES($SFILEPATH)
	FILEREADTOARRAY($SFILEPATH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN @EXTENDED
ENDFUNC
FUNC _FILECREATE($SFILEPATH)
	LOCAL $HFILEOPEN = FILEOPEN($SFILEPATH, BITOR($FO_OVERWRITE, $FO_CREATEPATH))
	IF $HFILEOPEN = -1 THEN RETURN SETERROR(1, 0, 0)
	LOCAL $IFILEWRITE = FILEWRITE($HFILEOPEN, "")
	FILECLOSE($HFILEOPEN)
	IF NOT $IFILEWRITE THEN RETURN SETERROR(2, 0, 0)
	RETURN 1
ENDFUNC
FUNC _FILELISTTOARRAY($SFILEPATH, $SFILTER = "*", $IFLAG = $FLTA_FILESFOLDERS, $BRETURNPATH = FALSE)
	LOCAL $SDELIMITER = "|", $SFILELIST = "", $SFILENAME = "", $SFULLPATH = ""
	$SFILEPATH = STRINGREGEXPREPLACE($SFILEPATH, "[\\/]+$", "") & "\"
	IF $IFLAG = DEFAULT THEN $IFLAG = $FLTA_FILESFOLDERS
	IF $BRETURNPATH THEN $SFULLPATH = $SFILEPATH
	IF $SFILTER = DEFAULT THEN $SFILTER = "*"
	IF NOT FILEEXISTS($SFILEPATH) THEN RETURN SETERROR(1, 0, 0)
	IF STRINGREGEXP($SFILTER, "[\\/:><\|]|(?s)^\s*$") THEN RETURN SETERROR(2, 0, 0)
	IF NOT($IFLAG = 0 OR $IFLAG = 1 OR $IFLAG = 2) THEN RETURN SETERROR(3, 0, 0)
	LOCAL $HSEARCH = FILEFINDFIRSTFILE($SFILEPATH & $SFILTER)
	IF @ERROR THEN RETURN SETERROR(4, 0, 0)
	WHILE 1
		$SFILENAME = FILEFINDNEXTFILE($HSEARCH)
		IF @ERROR THEN EXITLOOP
		IF($IFLAG + @EXTENDED = 2) THEN CONTINUELOOP
		$SFILELIST &= $SDELIMITER & $SFULLPATH & $SFILENAME
	WEND
	FILECLOSE($HSEARCH)
	IF $SFILELIST = "" THEN RETURN SETERROR(4, 0, 0)
	RETURN STRINGSPLIT(STRINGTRIMLEFT($SFILELIST, 1), $SDELIMITER)
ENDFUNC
FUNC _FILELISTTOARRAYREC($SFILEPATH, $SMASK = "*", $IRETURN = $FLTAR_FILESFOLDERS, $IRECUR = $FLTAR_NORECUR, $ISORT = $FLTAR_NOSORT, $IRETURNPATH = $FLTAR_RELPATH)
	IF NOT FILEEXISTS($SFILEPATH) THEN RETURN SETERROR(1, 1, "")
	IF $SMASK = DEFAULT THEN $SMASK = "*"
	IF $IRETURN = DEFAULT THEN $IRETURN = $FLTAR_FILESFOLDERS
	IF $IRECUR = DEFAULT THEN $IRECUR = $FLTAR_NORECUR
	IF $ISORT = DEFAULT THEN $ISORT = $FLTAR_NOSORT
	IF $IRETURNPATH = DEFAULT THEN $IRETURNPATH = $FLTAR_RELPATH
	IF $IRECUR > 1 OR NOT ISINT($IRECUR) THEN RETURN SETERROR(1, 6, "")
	LOCAL $BLONGPATH = FALSE
	IF STRINGLEFT($SFILEPATH, 4) == "\\?\" THEN
		$BLONGPATH = TRUE
	ENDIF
	LOCAL $SFOLDERSLASH = ""
	IF STRINGRIGHT($SFILEPATH, 1) = "\" THEN
		$SFOLDERSLASH = "\"
	ELSE
		$SFILEPATH = $SFILEPATH & "\"
	ENDIF
	LOCAL $ASFOLDERSEARCHLIST[100] = [1]
	$ASFOLDERSEARCHLIST[1] = $SFILEPATH
	LOCAL $IHIDE_HS = 0, $SHIDE_HS = ""
	IF BITAND($IRETURN, $FLTAR_NOHIDDEN) THEN
		$IHIDE_HS += 2
		$SHIDE_HS &= "H"
		$IRETURN -= $FLTAR_NOHIDDEN
	ENDIF
	IF BITAND($IRETURN, $FLTAR_NOSYSTEM) THEN
		$IHIDE_HS += 4
		$SHIDE_HS &= "S"
		$IRETURN -= $FLTAR_NOSYSTEM
	ENDIF
	LOCAL $IHIDE_LINK = 0
	IF BITAND($IRETURN, $FLTAR_NOLINK) THEN
		$IHIDE_LINK = 1024
		$IRETURN -= $FLTAR_NOLINK
	ENDIF
	LOCAL $IMAXLEVEL = 0
	IF $IRECUR < 0 THEN
		STRINGREPLACE($SFILEPATH, "\", "", 0, $STR_NOCASESENSEBASIC)
		$IMAXLEVEL = @EXTENDED - $IRECUR
	ENDIF
	LOCAL $SEXCLUDE_LIST = "", $SEXCLUDE_LIST_FOLDER = "", $SINCLUDE_LIST = "*"
	LOCAL $AMASKSPLIT = STRINGSPLIT($SMASK, "|")
	SWITCH $AMASKSPLIT[0]
		CASE 3
			$SEXCLUDE_LIST_FOLDER = $AMASKSPLIT[3]
			CONTINUECASE
		CASE 2
			$SEXCLUDE_LIST = $AMASKSPLIT[2]
			CONTINUECASE
		CASE 1
			$SINCLUDE_LIST = $AMASKSPLIT[1]
	ENDSWITCH
	LOCAL $SINCLUDE_FILE_MASK = ".+"
	IF $SINCLUDE_LIST <> "*" THEN
		IF NOT __FLTAR_LISTTOMASK($SINCLUDE_FILE_MASK, $SINCLUDE_LIST) THEN RETURN SETERROR(1, 2, "")
	ENDIF
	LOCAL $SINCLUDE_FOLDER_MASK = ".+"
	SWITCH $IRETURN
		CASE 0
			SWITCH $IRECUR
				CASE 0
					$SINCLUDE_FOLDER_MASK = $SINCLUDE_FILE_MASK
			ENDSWITCH
		CASE 2
			$SINCLUDE_FOLDER_MASK = $SINCLUDE_FILE_MASK
	ENDSWITCH
	LOCAL $SEXCLUDE_FILE_MASK = ":"
	IF $SEXCLUDE_LIST <> "" THEN
		IF NOT __FLTAR_LISTTOMASK($SEXCLUDE_FILE_MASK, $SEXCLUDE_LIST) THEN RETURN SETERROR(1, 3, "")
	ENDIF
	LOCAL $SEXCLUDE_FOLDER_MASK = ":"
	IF $IRECUR THEN
		IF $SEXCLUDE_LIST_FOLDER THEN
			IF NOT __FLTAR_LISTTOMASK($SEXCLUDE_FOLDER_MASK, $SEXCLUDE_LIST_FOLDER) THEN RETURN SETERROR(1, 4, "")
		ENDIF
		IF $IRETURN = 2 THEN
			$SEXCLUDE_FOLDER_MASK = $SEXCLUDE_FILE_MASK
		ENDIF
	ELSE
		$SEXCLUDE_FOLDER_MASK = $SEXCLUDE_FILE_MASK
	ENDIF
	IF NOT($IRETURN = 0 OR $IRETURN = 1 OR $IRETURN = 2) THEN RETURN SETERROR(1, 5, "")
	IF NOT($ISORT = 0 OR $ISORT = 1 OR $ISORT = 2) THEN RETURN SETERROR(1, 7, "")
	IF NOT($IRETURNPATH = 0 OR $IRETURNPATH = 1 OR $IRETURNPATH = 2) THEN RETURN SETERROR(1, 8, "")
	IF $IHIDE_LINK THEN
		LOCAL $TFILE_DATA = DLLSTRUCTCREATE("struct;align 4;dword FileAttributes;uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;" & "dword FileSizeHigh;dword FileSizeLow;dword Reserved0;dword Reserved1;wchar FileName[260];wchar AlternateFileName[14];endstruct")
		LOCAL $HDLL = DLLOPEN("kernel32.dll"), $ADLL_RET
	ENDIF
	LOCAL $ASRETURNLIST[100] = [0]
	LOCAL $ASFILEMATCHLIST = $ASRETURNLIST, $ASROOTFILEMATCHLIST = $ASRETURNLIST, $ASFOLDERMATCHLIST = $ASRETURNLIST
	LOCAL $BFOLDER = FALSE, $HSEARCH = 0, $SCURRENTPATH = "", $SNAME = "", $SRETPATH = ""
	LOCAL $IATTRIBS = 0, $SATTRIBS = ""
	LOCAL $ASFOLDERFILESECTIONLIST[100][2] = [[0, 0]]
	WHILE $ASFOLDERSEARCHLIST[0] > 0
		$SCURRENTPATH = $ASFOLDERSEARCHLIST[$ASFOLDERSEARCHLIST[0]]
		$ASFOLDERSEARCHLIST[0] -= 1
		SWITCH $IRETURNPATH
			CASE 1
				$SRETPATH = STRINGREPLACE($SCURRENTPATH, $SFILEPATH, "")
			CASE 2
				IF $BLONGPATH THEN
					$SRETPATH = STRINGTRIMLEFT($SCURRENTPATH, 4)
				ELSE
					$SRETPATH = $SCURRENTPATH
				ENDIF
		ENDSWITCH
		IF $IHIDE_LINK THEN
			$ADLL_RET = DLLCALL($HDLL, "handle", "FindFirstFileW", "wstr", $SCURRENTPATH & "*", "struct*", $TFILE_DATA)
			IF @ERROR OR NOT $ADLL_RET[0] THEN
				CONTINUELOOP
			ENDIF
			$HSEARCH = $ADLL_RET[0]
		ELSE
			$HSEARCH = FILEFINDFIRSTFILE($SCURRENTPATH & "*")
			IF $HSEARCH = -1 THEN
				CONTINUELOOP
			ENDIF
		ENDIF
		IF $IRETURN = 0 AND $ISORT AND $IRETURNPATH THEN
			__FLTAR_ADDTOLIST($ASFOLDERFILESECTIONLIST, $SRETPATH, $ASFILEMATCHLIST[0] + 1)
		ENDIF
		$SATTRIBS = ""
		WHILE 1
			IF $IHIDE_LINK THEN
				$ADLL_RET = DLLCALL($HDLL, "int", "FindNextFileW", "handle", $HSEARCH, "struct*", $TFILE_DATA)
				IF @ERROR OR NOT $ADLL_RET[0] THEN
					EXITLOOP
				ENDIF
				$SNAME = DLLSTRUCTGETDATA($TFILE_DATA, "FileName")
				IF $SNAME = ".." THEN
					CONTINUELOOP
				ENDIF
				$IATTRIBS = DLLSTRUCTGETDATA($TFILE_DATA, "FileAttributes")
				IF $IHIDE_HS AND BITAND($IATTRIBS, $IHIDE_HS) THEN
					CONTINUELOOP
				ENDIF
				IF BITAND($IATTRIBS, $IHIDE_LINK) THEN
					CONTINUELOOP
				ENDIF
				$BFOLDER = FALSE
				IF BITAND($IATTRIBS, 16) THEN
					$BFOLDER = TRUE
				ENDIF
			ELSE
				$BFOLDER = FALSE
				$SNAME = FILEFINDNEXTFILE($HSEARCH, 1)
				IF @ERROR THEN
					EXITLOOP
				ENDIF
				$SATTRIBS = @EXTENDED
				IF STRINGINSTR($SATTRIBS, "D") THEN
					$BFOLDER = TRUE
				ENDIF
				IF STRINGREGEXP($SATTRIBS, "[" & $SHIDE_HS & "]") THEN
					CONTINUELOOP
				ENDIF
			ENDIF
			IF $BFOLDER THEN
				SELECT
					CASE $IRECUR < 0
						STRINGREPLACE($SCURRENTPATH, "\", "", 0, $STR_NOCASESENSEBASIC)
						IF @EXTENDED < $IMAXLEVEL THEN
							CONTINUECASE
						ENDIF
					CASE $IRECUR = 1
						IF NOT STRINGREGEXP($SNAME, $SEXCLUDE_FOLDER_MASK) THEN
							__FLTAR_ADDTOLIST($ASFOLDERSEARCHLIST, $SCURRENTPATH & $SNAME & "\")
						ENDIF
				ENDSELECT
			ENDIF
			IF $ISORT THEN
				IF $BFOLDER THEN
					IF STRINGREGEXP($SNAME, $SINCLUDE_FOLDER_MASK) AND NOT STRINGREGEXP($SNAME, $SEXCLUDE_FOLDER_MASK) THEN
						__FLTAR_ADDTOLIST($ASFOLDERMATCHLIST, $SRETPATH & $SNAME & $SFOLDERSLASH)
					ENDIF
				ELSE
					IF STRINGREGEXP($SNAME, $SINCLUDE_FILE_MASK) AND NOT STRINGREGEXP($SNAME, $SEXCLUDE_FILE_MASK) THEN
						IF $SCURRENTPATH = $SFILEPATH THEN
							__FLTAR_ADDTOLIST($ASROOTFILEMATCHLIST, $SRETPATH & $SNAME)
						ELSE
							__FLTAR_ADDTOLIST($ASFILEMATCHLIST, $SRETPATH & $SNAME)
						ENDIF
					ENDIF
				ENDIF
			ELSE
				IF $BFOLDER THEN
					IF $IRETURN <> 1 AND STRINGREGEXP($SNAME, $SINCLUDE_FOLDER_MASK) AND NOT STRINGREGEXP($SNAME, $SEXCLUDE_FOLDER_MASK) THEN
						__FLTAR_ADDTOLIST($ASRETURNLIST, $SRETPATH & $SNAME & $SFOLDERSLASH)
					ENDIF
				ELSE
					IF $IRETURN <> 2 AND STRINGREGEXP($SNAME, $SINCLUDE_FILE_MASK) AND NOT STRINGREGEXP($SNAME, $SEXCLUDE_FILE_MASK) THEN
						__FLTAR_ADDTOLIST($ASRETURNLIST, $SRETPATH & $SNAME)
					ENDIF
				ENDIF
			ENDIF
		WEND
		IF $IHIDE_LINK THEN
			DLLCALL($HDLL, "int", "FindClose", "ptr", $HSEARCH)
		ELSE
			FILECLOSE($HSEARCH)
		ENDIF
	WEND
	IF $IHIDE_LINK THEN
		DLLCLOSE($HDLL)
	ENDIF
	IF $ISORT THEN
		SWITCH $IRETURN
			CASE 2
				IF $ASFOLDERMATCHLIST[0] = 0 THEN RETURN SETERROR(1, 9, "")
				REDIM $ASFOLDERMATCHLIST[$ASFOLDERMATCHLIST[0] + 1]
				$ASRETURNLIST = $ASFOLDERMATCHLIST
				__ARRAYDUALPIVOTSORT($ASRETURNLIST, 1, $ASRETURNLIST[0])
			CASE 1
				IF $ASROOTFILEMATCHLIST[0] = 0 AND $ASFILEMATCHLIST[0] = 0 THEN RETURN SETERROR(1, 9, "")
				IF $IRETURNPATH = 0 THEN
					__FLTAR_ADDFILELISTS($ASRETURNLIST, $ASROOTFILEMATCHLIST, $ASFILEMATCHLIST)
					__ARRAYDUALPIVOTSORT($ASRETURNLIST, 1, $ASRETURNLIST[0])
				ELSE
					__FLTAR_ADDFILELISTS($ASRETURNLIST, $ASROOTFILEMATCHLIST, $ASFILEMATCHLIST, 1)
				ENDIF
			CASE 0
				IF $ASROOTFILEMATCHLIST[0] = 0 AND $ASFOLDERMATCHLIST[0] = 0 THEN RETURN SETERROR(1, 9, "")
				IF $IRETURNPATH = 0 THEN
					__FLTAR_ADDFILELISTS($ASRETURNLIST, $ASROOTFILEMATCHLIST, $ASFILEMATCHLIST)
					$ASRETURNLIST[0] += $ASFOLDERMATCHLIST[0]
					REDIM $ASFOLDERMATCHLIST[$ASFOLDERMATCHLIST[0] + 1]
					_ARRAYCONCATENATE($ASRETURNLIST, $ASFOLDERMATCHLIST, 1)
					__ARRAYDUALPIVOTSORT($ASRETURNLIST, 1, $ASRETURNLIST[0])
				ELSE
					LOCAL $ASRETURNLIST[$ASFILEMATCHLIST[0] + $ASROOTFILEMATCHLIST[0] + $ASFOLDERMATCHLIST[0] + 1]
					$ASRETURNLIST[0] = $ASFILEMATCHLIST[0] + $ASROOTFILEMATCHLIST[0] + $ASFOLDERMATCHLIST[0]
					__ARRAYDUALPIVOTSORT($ASROOTFILEMATCHLIST, 1, $ASROOTFILEMATCHLIST[0])
					FOR $I = 1 TO $ASROOTFILEMATCHLIST[0]
						$ASRETURNLIST[$I] = $ASROOTFILEMATCHLIST[$I]
					NEXT
					LOCAL $INEXTINSERTIONINDEX = $ASROOTFILEMATCHLIST[0] + 1
					__ARRAYDUALPIVOTSORT($ASFOLDERMATCHLIST, 1, $ASFOLDERMATCHLIST[0])
					LOCAL $SFOLDERTOFIND = ""
					FOR $I = 1 TO $ASFOLDERMATCHLIST[0]
						$ASRETURNLIST[$INEXTINSERTIONINDEX] = $ASFOLDERMATCHLIST[$I]
						$INEXTINSERTIONINDEX += 1
						IF $SFOLDERSLASH THEN
							$SFOLDERTOFIND = $ASFOLDERMATCHLIST[$I]
						ELSE
							$SFOLDERTOFIND = $ASFOLDERMATCHLIST[$I] & "\"
						ENDIF
						LOCAL $IFILESECTIONENDINDEX = 0, $IFILESECTIONSTARTINDEX = 0
						FOR $J = 1 TO $ASFOLDERFILESECTIONLIST[0][0]
							IF $SFOLDERTOFIND = $ASFOLDERFILESECTIONLIST[$J][0] THEN
								$IFILESECTIONSTARTINDEX = $ASFOLDERFILESECTIONLIST[$J][1]
								IF $J = $ASFOLDERFILESECTIONLIST[0][0] THEN
									$IFILESECTIONENDINDEX = $ASFILEMATCHLIST[0]
								ELSE
									$IFILESECTIONENDINDEX = $ASFOLDERFILESECTIONLIST[$J + 1][1] - 1
								ENDIF
								IF $ISORT = 1 THEN
									__ARRAYDUALPIVOTSORT($ASFILEMATCHLIST, $IFILESECTIONSTARTINDEX, $IFILESECTIONENDINDEX)
								ENDIF
								FOR $K = $IFILESECTIONSTARTINDEX TO $IFILESECTIONENDINDEX
									$ASRETURNLIST[$INEXTINSERTIONINDEX] = $ASFILEMATCHLIST[$K]
									$INEXTINSERTIONINDEX += 1
								NEXT
								EXITLOOP
							ENDIF
						NEXT
					NEXT
				ENDIF
		ENDSWITCH
	ELSE
		IF $ASRETURNLIST[0] = 0 THEN RETURN SETERROR(1, 9, "")
		REDIM $ASRETURNLIST[$ASRETURNLIST[0] + 1]
	ENDIF
	RETURN $ASRETURNLIST
ENDFUNC
FUNC __FLTAR_ADDFILELISTS(BYREF $ASTARGET, $ASSOURCE_1, $ASSOURCE_2, $ISORT = 0)
	REDIM $ASSOURCE_1[$ASSOURCE_1[0] + 1]
	IF $ISORT = 1 THEN __ARRAYDUALPIVOTSORT($ASSOURCE_1, 1, $ASSOURCE_1[0])
	$ASTARGET = $ASSOURCE_1
	$ASTARGET[0] += $ASSOURCE_2[0]
	REDIM $ASSOURCE_2[$ASSOURCE_2[0] + 1]
	IF $ISORT = 1 THEN __ARRAYDUALPIVOTSORT($ASSOURCE_2, 1, $ASSOURCE_2[0])
	_ARRAYCONCATENATE($ASTARGET, $ASSOURCE_2, 1)
ENDFUNC
FUNC __FLTAR_ADDTOLIST(BYREF $ALIST, $VVALUE_0, $VVALUE_1 = -1)
	IF $VVALUE_1 = -1 THEN
		$ALIST[0] += 1
		IF UBOUND($ALIST) <= $ALIST[0] THEN REDIM $ALIST[UBOUND($ALIST) * 2]
		$ALIST[$ALIST[0]] = $VVALUE_0
	ELSE
		$ALIST[0][0] += 1
		IF UBOUND($ALIST) <= $ALIST[0][0] THEN REDIM $ALIST[UBOUND($ALIST) * 2][2]
		$ALIST[$ALIST[0][0]][0] = $VVALUE_0
		$ALIST[$ALIST[0][0]][1] = $VVALUE_1
	ENDIF
ENDFUNC
FUNC __FLTAR_LISTTOMASK(BYREF $SMASK, $SLIST)
	IF STRINGREGEXP($SLIST, "\\|/|:|\<|\>|\|") THEN RETURN 0
	$SLIST = STRINGREPLACE(STRINGSTRIPWS(STRINGREGEXPREPLACE($SLIST, "\s*;\s*", ";"), BITOR($STR_STRIPLEADING, $STR_STRIPTRAILING)), ";", "|")
	$SLIST = STRINGREPLACE(STRINGREPLACE(STRINGREGEXPREPLACE($SLIST, "[][$^.{}()+\-]", "\\$0"), "?", "."), "*", ".*?")
	$SMASK = "(?i)^(" & $SLIST & ")\z"
	RETURN 1
ENDFUNC
FUNC _FILEPRINT($SFILEPATH, $ISHOW = @SW_HIDE)
	RETURN SHELLEXECUTE($SFILEPATH, "", @WORKINGDIR, "print", $ISHOW = DEFAULT ? @SW_HIDE : $ISHOW)
ENDFUNC
FUNC _FILEREADTOARRAY($SFILEPATH, BYREF $VRETURN, $IFLAGS = $FRTA_COUNT, $SDELIMITER = "")
	$VRETURN = 0
	IF $IFLAGS = DEFAULT THEN $IFLAGS = $FRTA_COUNT
	IF $SDELIMITER = DEFAULT THEN $SDELIMITER = ""
	LOCAL $BEXPAND = TRUE
	IF BITAND($IFLAGS, $FRTA_INTARRAYS) THEN
		$BEXPAND = FALSE
		$IFLAGS -= $FRTA_INTARRAYS
	ENDIF
	LOCAL $IENTIRE = $STR_CHRSPLIT
	IF BITAND($IFLAGS, $FRTA_ENTIRESPLIT) THEN
		$IENTIRE = $STR_ENTIRESPLIT
		$IFLAGS -= $FRTA_ENTIRESPLIT
	ENDIF
	LOCAL $INOCOUNT = 0
	IF $IFLAGS <> $FRTA_COUNT THEN
		$IFLAGS = $FRTA_NOCOUNT
		$INOCOUNT = $STR_NOCOUNT
	ENDIF
	IF $SDELIMITER THEN
		LOCAL $ALINES = FILEREADTOARRAY($SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, 0, 0)
		LOCAL $IDIM_1 = UBOUND($ALINES) + $IFLAGS
		IF $BEXPAND THEN
			LOCAL $IDIM_2 = UBOUND(STRINGSPLIT($ALINES[0], $SDELIMITER, $IENTIRE + $STR_NOCOUNT))
			LOCAL $ATEMP_ARRAY[$IDIM_1][$IDIM_2]
			LOCAL $IFIELDS, $ASPLIT
			FOR $I = 0 TO $IDIM_1 - $IFLAGS - 1
				$ASPLIT = STRINGSPLIT($ALINES[$I], $SDELIMITER, $IENTIRE + $STR_NOCOUNT)
				$IFIELDS = UBOUND($ASPLIT)
				IF $IFIELDS <> $IDIM_2 THEN
					RETURN SETERROR(3, 0, 0)
				ENDIF
				FOR $J = 0 TO $IFIELDS - 1
					$ATEMP_ARRAY[$I + $IFLAGS][$J] = $ASPLIT[$J]
				NEXT
			NEXT
			IF $IDIM_2 < 2 THEN RETURN SETERROR(4, 0, 0)
			IF $IFLAGS THEN
				$ATEMP_ARRAY[0][0] = $IDIM_1 - $IFLAGS
				$ATEMP_ARRAY[0][1] = $IDIM_2
			ENDIF
		ELSE
			LOCAL $ATEMP_ARRAY[$IDIM_1]
			FOR $I = 0 TO $IDIM_1 - $IFLAGS - 1
				$ATEMP_ARRAY[$I + $IFLAGS] = STRINGSPLIT($ALINES[$I], $SDELIMITER, $IENTIRE + $INOCOUNT)
			NEXT
			IF $IFLAGS THEN
				$ATEMP_ARRAY[0] = $IDIM_1 - $IFLAGS
			ENDIF
		ENDIF
		$VRETURN = $ATEMP_ARRAY
	ELSE
		IF $IFLAGS THEN
			LOCAL $HFILEOPEN = FILEOPEN($SFILEPATH, $FO_READ)
			IF $HFILEOPEN = -1 THEN RETURN SETERROR(1, 0, 0)
			LOCAL $SFILEREAD = FILEREAD($HFILEOPEN)
			FILECLOSE($HFILEOPEN)
			IF STRINGLEN($SFILEREAD) THEN
				$VRETURN = STRINGREGEXP(@LF & $SFILEREAD, "(?|(\N+)\z|(\N*)(?:\R))", $STR_REGEXPARRAYGLOBALMATCH)
				$VRETURN[0] = UBOUND($VRETURN) - 1
			ELSE
				RETURN SETERROR(2, 0, 0)
			ENDIF
		ELSE
			$VRETURN = FILEREADTOARRAY($SFILEPATH)
			IF @ERROR THEN
				$VRETURN = 0
				RETURN SETERROR(@ERROR, 0, 0)
			ENDIF
		ENDIF
	ENDIF
	RETURN 1
ENDFUNC
FUNC _FILEWRITEFROMARRAY($SFILEPATH, CONST BYREF $AARRAY, $IBASE = DEFAULT, $IUBOUND = DEFAULT, $SDELIMITER = "|")
	LOCAL $IRETURN = 0
	IF NOT ISARRAY($AARRAY) THEN RETURN SETERROR(2, 0, $IRETURN)
	LOCAL $IDIMS = UBOUND($AARRAY, $UBOUND_DIMENSIONS)
	IF $IDIMS > 2 THEN RETURN SETERROR(4, 0, 0)
	LOCAL $ILAST = UBOUND($AARRAY) - 1
	IF $IUBOUND = DEFAULT OR $IUBOUND > $ILAST THEN $IUBOUND = $ILAST
	IF $IBASE < 0 OR $IBASE = DEFAULT THEN $IBASE = 0
	IF $IBASE > $IUBOUND THEN RETURN SETERROR(5, 0, $IRETURN)
	IF $SDELIMITER = DEFAULT THEN $SDELIMITER = "|"
	LOCAL $HFILEOPEN = $SFILEPATH
	IF ISSTRING($SFILEPATH) THEN
		$HFILEOPEN = FILEOPEN($SFILEPATH, $FO_OVERWRITE)
		IF $HFILEOPEN = -1 THEN RETURN SETERROR(1, 0, $IRETURN)
	ENDIF
	LOCAL $IERROR = 0
	$IRETURN = 1
	SWITCH $IDIMS
		CASE 1
			FOR $I = $IBASE TO $IUBOUND
				IF NOT FILEWRITE($HFILEOPEN, $AARRAY[$I] & @CRLF) THEN
					$IERROR = 3
					$IRETURN = 0
					EXITLOOP
				ENDIF
			NEXT
		CASE 2
			LOCAL $STEMP = ""
			FOR $I = $IBASE TO $IUBOUND
				$STEMP = $AARRAY[$I][0]
				FOR $J = 1 TO UBOUND($AARRAY, $UBOUND_COLUMNS) - 1
					$STEMP &= $SDELIMITER & $AARRAY[$I][$J]
				NEXT
				IF NOT FILEWRITE($HFILEOPEN, $STEMP & @CRLF) THEN
					$IERROR = 3
					$IRETURN = 0
					EXITLOOP
				ENDIF
			NEXT
	ENDSWITCH
	IF ISSTRING($SFILEPATH) THEN FILECLOSE($HFILEOPEN)
	RETURN SETERROR($IERROR, 0, $IRETURN)
ENDFUNC
FUNC _FILEWRITELOG($SLOGPATH, $SLOGMSG, $IFLAG = -1)
	LOCAL $IOPENMODE = $FO_APPEND
	LOCAL $SMSG = @YEAR & "-" & @MON & "-" & @MDAY & " " & @HOUR & ":" & @MIN & ":" & @SEC & " : " & $SLOGMSG
	IF $IFLAG = DEFAULT THEN $IFLAG = -1
	IF $IFLAG <> -1 THEN
		$IOPENMODE = $FO_OVERWRITE
		$SMSG &= @CRLF & FILEREAD($SLOGPATH)
	ENDIF
	LOCAL $HFILEOPEN = $SLOGPATH
	IF ISSTRING($SLOGPATH) THEN $HFILEOPEN = FILEOPEN($SLOGPATH, $IOPENMODE)
	IF $HFILEOPEN = -1 THEN RETURN SETERROR(1, 0, 0)
	LOCAL $IRETURN = FILEWRITELINE($HFILEOPEN, $SMSG)
	IF ISSTRING($SLOGPATH) THEN $IRETURN = FILECLOSE($HFILEOPEN)
	IF $IRETURN <= 0 THEN RETURN SETERROR(2, $IRETURN, 0)
	RETURN $IRETURN
ENDFUNC
FUNC _FILEWRITETOLINE($SFILEPATH, $ILINE, $STEXT, $BOVERWRITE = FALSE, $BFILL = FALSE)
	IF $BOVERWRITE = DEFAULT THEN $BOVERWRITE = FALSE
	IF $BFILL = DEFAULT THEN $BFILL = FALSE
	IF NOT FILEEXISTS($SFILEPATH) THEN RETURN SETERROR(2, 0, 0)
	IF $ILINE <= 0 THEN RETURN SETERROR(4, 0, 0)
	IF NOT(ISBOOL($BOVERWRITE) OR $BOVERWRITE = 0 OR $BOVERWRITE = 1) THEN RETURN SETERROR(5, 0, 0)
	IF NOT ISSTRING($STEXT) THEN
		$STEXT = STRING($STEXT)
		IF $STEXT = "" THEN RETURN SETERROR(6, 0, 0)
	ENDIF
	IF NOT ISBOOL($BFILL) THEN RETURN SETERROR(7, 0, 0)
	LOCAL $AARRAY = FILEREADTOARRAY($SFILEPATH)
	IF @ERROR THEN LOCAL $AARRAY[0]
	LOCAL $IUBOUND = UBOUND($AARRAY) - 1
	IF $BFILL THEN
		IF $IUBOUND < $ILINE THEN
			REDIM $AARRAY[$ILINE]
			$IUBOUND = $ILINE - 1
		ENDIF
	ELSE
		IF($IUBOUND + 1) < $ILINE THEN RETURN SETERROR(1, 0, 0)
	ENDIF
	$AARRAY[$ILINE - 1] = ($BOVERWRITE ? $STEXT : $STEXT & @CRLF & $AARRAY[$ILINE - 1])
	LOCAL $SDATA = ""
	FOR $I = 0 TO $IUBOUND
		$SDATA &= $AARRAY[$I] & @CRLF
	NEXT
	$SDATA = STRINGTRIMRIGHT($SDATA, STRINGLEN(@CRLF))
	LOCAL $HFILEOPEN = FILEOPEN($SFILEPATH, FILEGETENCODING($SFILEPATH) + $FO_OVERWRITE)
	IF $HFILEOPEN = -1 THEN RETURN SETERROR(3, 0, 0)
	FILEWRITE($HFILEOPEN, $SDATA)
	FILECLOSE($HFILEOPEN)
	RETURN 1
ENDFUNC
FUNC _PATHFULL($SRELATIVEPATH, $SBASEPATH = @WORKINGDIR)
	IF NOT $SRELATIVEPATH OR $SRELATIVEPATH = "." THEN RETURN $SBASEPATH
	LOCAL $SFULLPATH = STRINGREPLACE($SRELATIVEPATH, "/", "\")
	LOCAL CONST $SFULLPATHCONST = $SFULLPATH
	LOCAL $SPATH
	LOCAL $BROOTONLY = STRINGLEFT($SFULLPATH, 1) = "\" AND STRINGMID($SFULLPATH, 2, 1) <> "\"
	IF $SBASEPATH = DEFAULT THEN $SBASEPATH = @WORKINGDIR
	FOR $I = 1 TO 2
		$SPATH = STRINGLEFT($SFULLPATH, 2)
		IF $SPATH = "\\" THEN
			$SFULLPATH = STRINGTRIMLEFT($SFULLPATH, 2)
			LOCAL $NSERVERLEN = STRINGINSTR($SFULLPATH, "\") - 1
			$SPATH = "\\" & STRINGLEFT($SFULLPATH, $NSERVERLEN)
			$SFULLPATH = STRINGTRIMLEFT($SFULLPATH, $NSERVERLEN)
			EXITLOOP
		ELSEIF STRINGRIGHT($SPATH, 1) = ":" THEN
			$SFULLPATH = STRINGTRIMLEFT($SFULLPATH, 2)
			EXITLOOP
		ELSE
			$SFULLPATH = $SBASEPATH & "\" & $SFULLPATH
		ENDIF
	NEXT
	IF STRINGLEFT($SFULLPATH, 1) <> "\" THEN
		IF STRINGLEFT($SFULLPATHCONST, 2) = STRINGLEFT($SBASEPATH, 2) THEN
			$SFULLPATH = $SBASEPATH & "\" & $SFULLPATH
		ELSE
			$SFULLPATH = "\" & $SFULLPATH
		ENDIF
	ENDIF
	LOCAL $ATEMP = STRINGSPLIT($SFULLPATH, "\")
	LOCAL $APATHPARTS[$ATEMP[0]], $J = 0
	FOR $I = 2 TO $ATEMP[0]
		IF $ATEMP[$I] = ".." THEN
			IF $J THEN $J -= 1
		ELSEIF NOT($ATEMP[$I] = "" AND $I <> $ATEMP[0]) AND $ATEMP[$I] <> "." THEN
			$APATHPARTS[$J] = $ATEMP[$I]
			$J += 1
		ENDIF
	NEXT
	$SFULLPATH = $SPATH
	IF NOT $BROOTONLY THEN
		FOR $I = 0 TO $J - 1
			$SFULLPATH &= "\" & $APATHPARTS[$I]
		NEXT
	ELSE
		$SFULLPATH &= $SFULLPATHCONST
		IF STRINGINSTR($SFULLPATH, "..") THEN $SFULLPATH = _PATHFULL($SFULLPATH)
	ENDIF
	DO
		$SFULLPATH = STRINGREPLACE($SFULLPATH, ".\", "\")
	UNTIL @EXTENDED = 0
	RETURN $SFULLPATH
ENDFUNC
FUNC _PATHGETRELATIVE($SFROM, $STO)
	IF STRINGRIGHT($SFROM, 1) <> "\" THEN $SFROM &= "\"
	IF STRINGRIGHT($STO, 1) <> "\" THEN $STO &= "\"
	IF $SFROM = $STO THEN RETURN SETERROR(1, 0, STRINGTRIMRIGHT($STO, 1))
	LOCAL $ASFROM = STRINGSPLIT($SFROM, "\")
	LOCAL $ASTO = STRINGSPLIT($STO, "\")
	IF $ASFROM[1] <> $ASTO[1] THEN RETURN SETERROR(2, 0, STRINGTRIMRIGHT($STO, 1))
	LOCAL $I = 2
	LOCAL $IDIFF = 1
	WHILE 1
		IF $ASFROM[$I] <> $ASTO[$I] THEN
			$IDIFF = $I
			EXITLOOP
		ENDIF
		$I += 1
	WEND
	$I = 1
	LOCAL $SRELPATH = ""
	FOR $J = 1 TO $ASTO[0]
		IF $I >= $IDIFF THEN
			$SRELPATH &= "\" & $ASTO[$I]
		ENDIF
		$I += 1
	NEXT
	$SRELPATH = STRINGTRIMLEFT($SRELPATH, 1)
	$I = 1
	FOR $J = 1 TO $ASFROM[0]
		IF $I > $IDIFF THEN
			$SRELPATH = "..\" & $SRELPATH
		ENDIF
		$I += 1
	NEXT
	IF STRINGRIGHT($SRELPATH, 1) == "\" THEN $SRELPATH = STRINGTRIMRIGHT($SRELPATH, 1)
	RETURN $SRELPATH
ENDFUNC
FUNC _PATHMAKE($SDRIVE, $SDIR, $SFILENAME, $SEXTENSION)
	IF STRINGLEN($SDRIVE) THEN
		IF NOT(STRINGLEFT($SDRIVE, 2) = "\\") THEN $SDRIVE = STRINGLEFT($SDRIVE, 1) & ":"
	ENDIF
	IF STRINGLEN($SDIR) THEN
		IF NOT(STRINGRIGHT($SDIR, 1) = "\") AND NOT(STRINGRIGHT($SDIR, 1) = "/") THEN $SDIR = $SDIR & "\"
	ELSE
		$SDIR = "\"
	ENDIF
	IF STRINGLEN($SDIR) THEN
		IF NOT(STRINGLEFT($SDIR, 1) = "\") AND NOT(STRINGLEFT($SDIR, 1) = "/") THEN $SDIR = "\" & $SDIR
	ENDIF
	IF STRINGLEN($SEXTENSION) THEN
		IF NOT(STRINGLEFT($SEXTENSION, 1) = ".") THEN $SEXTENSION = "." & $SEXTENSION
	ENDIF
	RETURN $SDRIVE & $SDIR & $SFILENAME & $SEXTENSION
ENDFUNC
FUNC _PATHSPLIT($SFILEPATH, BYREF $SDRIVE, BYREF $SDIR, BYREF $SFILENAME, BYREF $SEXTENSION)
	LOCAL $AARRAY = STRINGREGEXP($SFILEPATH, "^\h*((?:\\\\\?\\)*(\\\\[^\?\/\\]+|[A-Za-z]:)?(.*[\/\\]\h*)?((?:[^\.\/\\]|(?(?=\.[^\/\\]*\.)\.))*)?([^\/\\]*))$", $STR_REGEXPARRAYMATCH)
	IF @ERROR THEN
		REDIM $AARRAY[5]
		$AARRAY[$PATH_ORIGINAL] = $SFILEPATH
	ENDIF
	$SDRIVE = $AARRAY[$PATH_DRIVE]
	IF STRINGLEFT($AARRAY[$PATH_DIRECTORY], 1) == "/" THEN
		$SDIR = STRINGREGEXPREPLACE($AARRAY[$PATH_DIRECTORY], "\h*[\/\\]+\h*", "\/")
	ELSE
		$SDIR = STRINGREGEXPREPLACE($AARRAY[$PATH_DIRECTORY], "\h*[\/\\]+\h*", "\\")
	ENDIF
	$AARRAY[$PATH_DIRECTORY] = $SDIR
	$SFILENAME = $AARRAY[$PATH_FILENAME]
	$SEXTENSION = $AARRAY[$PATH_EXTENSION]
	RETURN $AARRAY
ENDFUNC
FUNC _REPLACESTRINGINFILE($SFILEPATH, $SSEARCHSTRING, $SREPLACESTRING, $ICASESENSITIVE = 0, $IOCCURANCE = 1)
	IF STRINGINSTR(FILEGETATTRIB($SFILEPATH), "R") THEN RETURN SETERROR(1, 0, -1)
	LOCAL $HFILEOPEN = FILEOPEN($SFILEPATH, $FO_READ)
	IF $HFILEOPEN = -1 THEN RETURN SETERROR(2, 0, -1)
	LOCAL $SFILEREAD = FILEREAD($HFILEOPEN)
	FILECLOSE($HFILEOPEN)
	IF $ICASESENSITIVE = DEFAULT THEN $ICASESENSITIVE = 0
	IF $IOCCURANCE = DEFAULT THEN $IOCCURANCE = 1
	$SFILEREAD = STRINGREPLACE($SFILEREAD, $SSEARCHSTRING, $SREPLACESTRING, 1 - $IOCCURANCE, $ICASESENSITIVE)
	LOCAL $IRETURN = @EXTENDED
	IF $IRETURN THEN
		LOCAL $IFILEENCODING = FILEGETENCODING($SFILEPATH)
		$HFILEOPEN = FILEOPEN($SFILEPATH, $IFILEENCODING + $FO_OVERWRITE)
		IF $HFILEOPEN = -1 THEN RETURN SETERROR(3, 0, -1)
		FILEWRITE($HFILEOPEN, $SFILEREAD)
		FILECLOSE($HFILEOPEN)
	ENDIF
	RETURN $IRETURN
ENDFUNC
FUNC _TEMPFILE($SDIRECTORYNAME = @TEMPDIR, $SFILEPREFIX = "~", $SFILEEXTENSION = ".tmp", $IRANDOMLENGTH = 7)
	IF $IRANDOMLENGTH = DEFAULT OR $IRANDOMLENGTH <= 0 THEN $IRANDOMLENGTH = 7
	IF $SDIRECTORYNAME = DEFAULT OR(NOT FILEEXISTS($SDIRECTORYNAME)) THEN $SDIRECTORYNAME = @TEMPDIR
	IF $SFILEEXTENSION = DEFAULT THEN $SFILEEXTENSION = ".tmp"
	IF $SFILEPREFIX = DEFAULT THEN $SFILEPREFIX = "~"
	IF NOT FILEEXISTS($SDIRECTORYNAME) THEN $SDIRECTORYNAME = @SCRIPTDIR
	$SDIRECTORYNAME = STRINGREGEXPREPLACE($SDIRECTORYNAME, "[\\/]+$", "")
	$SFILEEXTENSION = STRINGREGEXPREPLACE($SFILEEXTENSION, "^\.+", "")
	$SFILEPREFIX = STRINGREGEXPREPLACE($SFILEPREFIX, '[\\/:*?"<>|]', "")
	LOCAL $STEMPNAME = ""
	DO
		$STEMPNAME = ""
		WHILE STRINGLEN($STEMPNAME) < $IRANDOMLENGTH
			$STEMPNAME &= CHR(RANDOM(97, 122, 1))
		WEND
		$STEMPNAME = $SDIRECTORYNAME & "\" & $SFILEPREFIX & $STEMPNAME & "." & $SFILEEXTENSION
	UNTIL NOT FILEEXISTS($STEMPNAME)
	RETURN $STEMPNAME
ENDFUNC
GLOBAL CONST $TRAY_ITEM_EXIT = 3
GLOBAL CONST $TRAY_ITEM_PAUSE = 4
GLOBAL CONST $TRAY_ITEM_FIRST = 7
GLOBAL CONST $TRAY_CHECKED = 1
GLOBAL CONST $TRAY_UNCHECKED = 4
GLOBAL CONST $TRAY_ENABLE = 64
GLOBAL CONST $TRAY_DISABLE = 128
GLOBAL CONST $TRAY_FOCUS = 256
GLOBAL CONST $TRAY_DEFAULT = 512
GLOBAL CONST $TRAY_EVENT_NONE = 0
GLOBAL CONST $TRAY_EVENT_SHOWICON = -3
GLOBAL CONST $TRAY_EVENT_HIDEICON = -4
GLOBAL CONST $TRAY_EVENT_FLASHICON = -5
GLOBAL CONST $TRAY_EVENT_NOFLASHICON = -6
GLOBAL CONST $TRAY_EVENT_PRIMARYDOWN = -7
GLOBAL CONST $TRAY_EVENT_PRIMARYUP = -8
GLOBAL CONST $TRAY_EVENT_SECONDARYDOWN = -9
GLOBAL CONST $TRAY_EVENT_SECONDARYUP = -10
GLOBAL CONST $TRAY_EVENT_MOUSEOVER = -11
GLOBAL CONST $TRAY_EVENT_MOUSEOUT = -12
GLOBAL CONST $TRAY_EVENT_PRIMARYDOUBLE = -13
GLOBAL CONST $TRAY_EVENT_SECONDARYDOUBLE = -14
GLOBAL CONST $TIP_ICONNONE = 0
GLOBAL CONST $TIP_ICONASTERISK = 1
GLOBAL CONST $TIP_ICONEXCLAMATION = 2
GLOBAL CONST $TIP_ICONHAND = 3
GLOBAL CONST $TIP_NOSOUND = 16
GLOBAL CONST $TRAY_ITEM_NORMAL = 0
GLOBAL CONST $TRAY_ITEM_RADIO = 1
GLOBAL CONST $TRAY_CLICK_SHOW = 0
GLOBAL CONST $TRAY_CLICK_PRIMARYDOWN = 1
GLOBAL CONST $TRAY_CLICK_PRIMARYUP = 2
GLOBAL CONST $TRAY_DBLCLICK_PRIMARY = 4
GLOBAL CONST $TRAY_CLICK_SECONDARYDOWN = 8
GLOBAL CONST $TRAY_CLICK_SECONDARYUP = 16
GLOBAL CONST $TRAY_DBLCLICK_SECONDARY = 32
GLOBAL CONST $TRAY_CLICK_HOVERING = 64
GLOBAL CONST $TRAY_ICONSTATE_SHOW = 1
GLOBAL CONST $TRAY_ICONSTATE_HIDE = 2
GLOBAL CONST $TRAY_ICONSTATE_FLASH = 4
GLOBAL CONST $TRAY_ICONSTATE_STOPFLASH = 8
GLOBAL CONST $TRAY_ICONSTATE_RESET = 16
GLOBAL CONST $BACKUP_ALTERNATE_DATA = 4
GLOBAL CONST $BACKUP_DATA = 1
GLOBAL CONST $BACKUP_EA_DATA = 2
GLOBAL CONST $BACKUP_LINK = 5
GLOBAL CONST $BACKUP_OBJECT_ID = 7
GLOBAL CONST $BACKUP_PROPERTY_DATA = 6
GLOBAL CONST $BACKUP_REPARSE_DATA = 8
GLOBAL CONST $BACKUP_SECURITY_DATA = 3
GLOBAL CONST $BACKUP_SPARSE_BLOCK = 9
GLOBAL CONST $BACKUP_TXFS_DATA = 10
GLOBAL CONST $COPY_FILE_ALLOW_DECRYPTED_DESTINATION = 8
GLOBAL CONST $COPY_FILE_COPY_SYMLINK = 2048
GLOBAL CONST $COPY_FILE_FAIL_IF_EXISTS = 1
GLOBAL CONST $COPY_FILE_NO_BUFFERING = 4096
GLOBAL CONST $COPY_FILE_OPEN_SOURCE_FOR_WRITE = 4
GLOBAL CONST $COPY_FILE_RESTARTABLE = 2
GLOBAL CONST $MOVE_FILE_COPY_ALLOWED = 2
GLOBAL CONST $MOVE_FILE_CREATE_HARDLINK = 16
GLOBAL CONST $MOVE_FILE_DELAY_UNTIL_REBOOT = 4
GLOBAL CONST $MOVE_FILE_FAIL_IF_NOT_TRACKABLE = 32
GLOBAL CONST $MOVE_FILE_REPLACE_EXISTING = 1
GLOBAL CONST $MOVE_FILE_WRITE_THROUGH = 8
GLOBAL CONST $PROGRESS_CONTINUE = 0
GLOBAL CONST $PROGRESS_CANCEL = 1
GLOBAL CONST $PROGRESS_STOP = 2
GLOBAL CONST $PROGRESS_QUIET = 3
GLOBAL CONST $FILE_APPEND_DATA = 4
GLOBAL CONST $FILE_DELETE_CHILD = 64
GLOBAL CONST $FILE_EXECUTE = 32
GLOBAL CONST $FILE_READ_ATTRIBUTES = 128
GLOBAL CONST $FILE_READ_DATA = 1
GLOBAL CONST $FILE_READ_EA = 8
GLOBAL CONST $FILE_WRITE_ATTRIBUTES = 256
GLOBAL CONST $FILE_WRITE_DATA = 2
GLOBAL CONST $FILE_WRITE_EA = 16
GLOBAL CONST $FILE_ADD_FILE = $FILE_WRITE_DATA
GLOBAL CONST $FILE_ADD_SUBDIRECTORY = $FILE_APPEND_DATA
GLOBAL CONST $FILE_CREATE_PIPE_INSTANCE = $FILE_APPEND_DATA
GLOBAL CONST $FILE_LIST_DIRECTORY = $FILE_READ_DATA
GLOBAL CONST $FILE_TRAVERSE = $FILE_EXECUTE
GLOBAL CONST $FILE_ALL_ACCESS = 2032127
GLOBAL CONST $FILE_FLAG_BACKUP_SEMANTICS = 33554432
GLOBAL CONST $FILE_FLAG_DELETE_ON_CLOSE = 67108864
GLOBAL CONST $FILE_FLAG_NO_BUFFERING = 536870912
GLOBAL CONST $FILE_FLAG_OPEN_NO_RECALL = 1048576
GLOBAL CONST $FILE_FLAG_OPEN_REPARSE_POINT = 2097152
GLOBAL CONST $FILE_FLAG_OVERLAPPED = 1073741824
GLOBAL CONST $FILE_FLAG_POSIX_SEMANTICS = 1048576
GLOBAL CONST $FILE_FLAG_RANDOM_ACCESS = 268435456
GLOBAL CONST $FILE_FLAG_SEQUENTIAL_SCAN = 134217728
GLOBAL CONST $FILE_FLAG_WRITE_THROUGH = -2147483648
GLOBAL CONST $SECURITY_ANONYMOUS = 0
GLOBAL CONST $SECURITY_CONTEXT_TRACKING = 262144
GLOBAL CONST $SECURITY_DELEGATION = 196608
GLOBAL CONST $SECURITY_EFFECTIVE_ONLY = 524288
GLOBAL CONST $SECURITY_IDENTIFICATION = 65536
GLOBAL CONST $SECURITY_IMPERSONATION = 131072
GLOBAL CONST $SEC_COMMIT = 134217728
GLOBAL CONST $SEC_IMAGE = 16777216
GLOBAL CONST $SEC_LARGE_PAGES = -2147483648
GLOBAL CONST $SEC_NOCACHE = 268435456
GLOBAL CONST $SEC_RESERVE = 67108864
GLOBAL CONST $SEC_WRITECOMBINE = 1073741824
GLOBAL CONST $SECTION_EXTEND_SIZE = 16
GLOBAL CONST $SECTION_MAP_EXECUTE = 8
GLOBAL CONST $SECTION_MAP_READ = 4
GLOBAL CONST $SECTION_MAP_WRITE = 2
GLOBAL CONST $SECTION_QUERY = 1
GLOBAL CONST $SECTION_ALL_ACCESS = 2031647
GLOBAL CONST $FILE_MAP_COPY = 1
GLOBAL CONST $FILE_MAP_EXECUTE = 32
GLOBAL CONST $FILE_MAP_READ = 4
GLOBAL CONST $FILE_MAP_WRITE = 2
GLOBAL CONST $FILE_MAP_ALL_ACCESS = $SECTION_ALL_ACCESS
GLOBAL CONST $DDD_EXACT_MATCH_ON_REMOVE = 4
GLOBAL CONST $DDD_NO_BROADCAST_SYSTEM = 8
GLOBAL CONST $DDD_RAW_TARGET_PATH = 1
GLOBAL CONST $DDD_REMOVE_DEFINITION = 2
GLOBAL CONST $FSCTL_ALLOW_EXTENDED_DASD_IO = 589955
GLOBAL CONST $FSCTL_CREATE_OR_GET_OBJECT_ID = 590016
GLOBAL CONST $FSCTL_CREATE_USN_JOURNAL = 590055
GLOBAL CONST $FSCTL_DELETE_OBJECT_ID = 589984
GLOBAL CONST $FSCTL_DELETE_REPARSE_POINT = 589996
GLOBAL CONST $FSCTL_DELETE_USN_JOURNAL = 590072
GLOBAL CONST $FSCTL_DISMOUNT_VOLUME = 589856
GLOBAL CONST $FSCTL_DUMP_PROPERTY_DATA = 589975
GLOBAL CONST $FSCTL_ENABLE_UPGRADE = 622800
GLOBAL CONST $FSCTL_ENCRYPTION_FSCTL_IO = 590043
GLOBAL CONST $FSCTL_ENUM_USN_DATA = 590003
GLOBAL CONST $FSCTL_EXTEND_VOLUME = 590064
GLOBAL CONST $FSCTL_FILESYSTEM_GET_STATISTICS = 589920
GLOBAL CONST $FSCTL_FIND_FILES_BY_SID = 589967
GLOBAL CONST $FSCTL_GET_COMPRESSION = 589884
GLOBAL CONST $FSCTL_GET_NTFS_FILE_RECORD = 589928
GLOBAL CONST $FSCTL_GET_NTFS_VOLUME_DATA = 589924
GLOBAL CONST $FSCTL_GET_OBJECT_ID = 589980
GLOBAL CONST $FSCTL_GET_REPARSE_POINT = 589992
GLOBAL CONST $FSCTL_GET_RETRIEVAL_POINTERS = 589939
GLOBAL CONST $FSCTL_GET_VOLUME_BITMAP = 589935
GLOBAL CONST $FSCTL_HSM_DATA = 639251
GLOBAL CONST $FSCTL_HSM_MSG = 639240
GLOBAL CONST $FSCTL_INVALIDATE_VOLUMES = 589908
GLOBAL CONST $FSCTL_IS_PATHNAME_VALID = 589868
GLOBAL CONST $FSCTL_IS_VOLUME_DIRTY = 589944
GLOBAL CONST $FSCTL_IS_VOLUME_MOUNTED = 589864
GLOBAL CONST $FSCTL_LOCK_VOLUME = 589848
GLOBAL CONST $FSCTL_MARK_AS_SYSTEM_HIVE = 589903
GLOBAL CONST $FSCTL_MARK_HANDLE = 590076
GLOBAL CONST $FSCTL_MARK_VOLUME_DIRTY = 589872
GLOBAL CONST $FSCTL_MOVE_FILE = 589940
GLOBAL CONST $FSCTL_OPBATCH_ACK_CLOSE_PENDING = 589840
GLOBAL CONST $FSCTL_OPLOCK_BREAK_ACK_NO_2 = 589904
GLOBAL CONST $FSCTL_OPLOCK_BREAK_ACKNOWLEDGE = 589836
GLOBAL CONST $FSCTL_OPLOCK_BREAK_NOTIFY = 589844
GLOBAL CONST $FSCTL_QUERY_ALLOCATED_RANGES = 606415
GLOBAL CONST $FSCTL_QUERY_FAT_BPB = 589912
GLOBAL CONST $FSCTL_QUERY_RETRIEVAL_POINTERS = 589883
GLOBAL CONST $FSCTL_QUERY_USN_JOURNAL = 590068
GLOBAL CONST $FSCTL_READ_FILE_USN_DATA = 590059
GLOBAL CONST $FSCTL_READ_PROPERTY_DATA = 589959
GLOBAL CONST $FSCTL_READ_RAW_ENCRYPTED = 590051
GLOBAL CONST $FSCTL_READ_USN_JOURNAL = 590011
GLOBAL CONST $FSCTL_RECALL_FILE = 590103
GLOBAL CONST $FSCTL_REQUEST_BATCH_OPLOCK = 589832
GLOBAL CONST $FSCTL_REQUEST_FILTER_OPLOCK = 589916
GLOBAL CONST $FSCTL_REQUEST_OPLOCK_LEVEL_1 = 589824
GLOBAL CONST $FSCTL_REQUEST_OPLOCK_LEVEL_2 = 589828
GLOBAL CONST $FSCTL_SECURITY_ID_CHECK = 606391
GLOBAL CONST $FSCTL_SET_COMPRESSION = 639040
GLOBAL CONST $FSCTL_SET_ENCRYPTION = 590039
GLOBAL CONST $FSCTL_SET_OBJECT_ID = 589976
GLOBAL CONST $FSCTL_SET_OBJECT_ID_EXTENDED = 590012
GLOBAL CONST $FSCTL_SET_REPARSE_POINT = 589988
GLOBAL CONST $FSCTL_SET_SPARSE = 590020
GLOBAL CONST $FSCTL_SET_ZERO_DATA = 622792
GLOBAL CONST $FSCTL_SIS_COPYFILE = 590080
GLOBAL CONST $FSCTL_SIS_LINK_FILES = 639236
GLOBAL CONST $FSCTL_UNLOCK_VOLUME = 589852
GLOBAL CONST $FSCTL_WRITE_PROPERTY_DATA = 589963
GLOBAL CONST $FSCTL_WRITE_RAW_ENCRYPTED = 590047
GLOBAL CONST $FSCTL_WRITE_USN_CLOSE_RECORD = 590063
GLOBAL CONST $IOCTL_AACS_END_SESSION = 3363020
GLOBAL CONST $IOCTL_AACS_GENERATE_BINDING_NONCE = 3395824
GLOBAL CONST $IOCTL_AACS_GET_CERTIFICATE = 3363028
GLOBAL CONST $IOCTL_AACS_GET_CHALLENGE_KEY = 3363032
GLOBAL CONST $IOCTL_AACS_READ_BINDING_NONCE = 3363052
GLOBAL CONST $IOCTL_AACS_READ_MEDIA_ID = 3363048
GLOBAL CONST $IOCTL_AACS_READ_MEDIA_KEY_BLOCK = 3363012
GLOBAL CONST $IOCTL_AACS_READ_MEDIA_KEY_BLOCK_SIZE = 3363008
GLOBAL CONST $IOCTL_AACS_READ_SERIAL_NUMBER = 3363044
GLOBAL CONST $IOCTL_AACS_READ_VOLUME_ID = 3363040
GLOBAL CONST $IOCTL_AACS_SEND_CERTIFICATE = 3363024
GLOBAL CONST $IOCTL_AACS_SEND_CHALLENGE_KEY = 3363036
GLOBAL CONST $IOCTL_AACS_START_SESSION = 3363016
GLOBAL CONST $IOCTL_ATA_PASS_THROUGH = 315436
GLOBAL CONST $IOCTL_ATA_PASS_THROUGH_DIRECT = 315440
GLOBAL CONST $IOCTL_CDROM_CHECK_VERIFY = 149504
GLOBAL CONST $IOCTL_CDROM_DISK_TYPE = 131136
GLOBAL CONST $IOCTL_CDROM_EJECT_MEDIA = 149512
GLOBAL CONST $IOCTL_CDROM_FIND_NEW_DEVICES = 149528
GLOBAL CONST $IOCTL_CDROM_GET_CONFIGURATION = 147544
GLOBAL CONST $IOCTL_CDROM_GET_CONTROL = 147508
GLOBAL CONST $IOCTL_CDROM_GET_DRIVE_GEOMETRY = 147532
GLOBAL CONST $IOCTL_CDROM_GET_DRIVE_GEOMETRY_EX = 147536
GLOBAL CONST $IOCTL_CDROM_GET_LAST_SESSION = 147512
GLOBAL CONST $IOCTL_CDROM_GET_VOLUME = 147476
GLOBAL CONST $IOCTL_CDROM_LOAD_MEDIA = 149516
GLOBAL CONST $IOCTL_CDROM_MEDIA_REMOVAL = 149508
GLOBAL CONST $IOCTL_CDROM_PAUSE_AUDIO = 147468
GLOBAL CONST $IOCTL_CDROM_PLAY_AUDIO_MSF = 147480
GLOBAL CONST $IOCTL_CDROM_RAW_READ = 147518
GLOBAL CONST $IOCTL_CDROM_READ_Q_CHANNEL = 147500
GLOBAL CONST $IOCTL_CDROM_READ_TOC = 147456
GLOBAL CONST $IOCTL_CDROM_READ_TOC_EX = 147540
GLOBAL CONST $IOCTL_CDROM_RELEASE = 149524
GLOBAL CONST $IOCTL_CDROM_RESERVE = 149520
GLOBAL CONST $IOCTL_CDROM_RESUME_AUDIO = 147472
GLOBAL CONST $IOCTL_CDROM_SEEK_AUDIO_MSF = 147460
GLOBAL CONST $IOCTL_CDROM_SET_VOLUME = 147496
GLOBAL CONST $IOCTL_CDROM_STOP_AUDIO = 147464
GLOBAL CONST $IOCTL_CDROM_UNLOAD_DRIVER = 151560
GLOBAL CONST $IOCTL_DISK_CHECK_VERIFY = 477184
GLOBAL CONST $IOCTL_DISK_CONTROLLER_NUMBER = 458820
GLOBAL CONST $IOCTL_DISK_CREATE_DISK = 507992
GLOBAL CONST $IOCTL_DISK_DELETE_DRIVE_LAYOUT = 508160
GLOBAL CONST $IOCTL_DISK_EJECT_MEDIA = 477192
GLOBAL CONST $IOCTL_DISK_FIND_NEW_DEVICES = 477208
GLOBAL CONST $IOCTL_DISK_FORMAT_TRACKS = 507928
GLOBAL CONST $IOCTL_DISK_FORMAT_TRACKS_EX = 507948
GLOBAL CONST $IOCTL_DISK_GET_CACHE_INFORMATION = 475348
GLOBAL CONST $IOCTL_DISK_GET_DRIVE_GEOMETRY = 458752
GLOBAL CONST $IOCTL_DISK_GET_DRIVE_GEOMETRY_EX = 458912
GLOBAL CONST $IOCTL_DISK_GET_DRIVE_LAYOUT = 475148
GLOBAL CONST $IOCTL_DISK_GET_DRIVE_LAYOUT_EX = 458832
GLOBAL CONST $IOCTL_DISK_GET_LENGTH_INFO = 475228
GLOBAL CONST $IOCTL_DISK_GET_MEDIA_TYPES = 461824
GLOBAL CONST $IOCTL_DISK_GET_PARTITION_INFO = 475140
GLOBAL CONST $IOCTL_DISK_GET_PARTITION_INFO_EX = 458824
GLOBAL CONST $IOCTL_DISK_GET_WRITE_CACHE_STATE = 475356
GLOBAL CONST $IOCTL_DISK_GROW_PARTITION = 508112
GLOBAL CONST $IOCTL_DISK_HISTOGRAM_DATA = 458804
GLOBAL CONST $IOCTL_DISK_HISTOGRAM_RESET = 458808
GLOBAL CONST $IOCTL_DISK_HISTOGRAM_STRUCTURE = 458800
GLOBAL CONST $IOCTL_DISK_INTERNAL_CLEAR_VERIFY = 459783
GLOBAL CONST $IOCTL_DISK_INTERNAL_SET_NOTIFY = 459784
GLOBAL CONST $IOCTL_DISK_INTERNAL_SET_VERIFY = 459779
GLOBAL CONST $IOCTL_DISK_IS_WRITABLE = 458788
GLOBAL CONST $IOCTL_DISK_LOAD_MEDIA = 477196
GLOBAL CONST $IOCTL_DISK_LOGGING = 458792
GLOBAL CONST $IOCTL_DISK_MEDIA_REMOVAL = 477188
GLOBAL CONST $IOCTL_DISK_PERFORMANCE = 458784
GLOBAL CONST $IOCTL_DISK_PERFORMANCE_OFF = 458848
GLOBAL CONST $IOCTL_DISK_REASSIGN_BLOCKS = 507932
GLOBAL CONST $IOCTL_DISK_RELEASE = 477204
GLOBAL CONST $IOCTL_DISK_REQUEST_DATA = 458816
GLOBAL CONST $IOCTL_DISK_REQUEST_STRUCTURE = 458812
GLOBAL CONST $IOCTL_DISK_RESERVE = 477200
GLOBAL CONST $IOCTL_DISK_SET_CACHE_INFORMATION = 508120
GLOBAL CONST $IOCTL_DISK_SET_DRIVE_LAYOUT = 507920
GLOBAL CONST $IOCTL_DISK_SET_DRIVE_LAYOUT_EX = 507988
GLOBAL CONST $IOCTL_DISK_SET_PARTITION_INFO = 507912
GLOBAL CONST $IOCTL_DISK_SET_PARTITION_INFO_EX = 507980
GLOBAL CONST $IOCTL_DISK_UPDATE_DRIVE_SIZE = 508104
GLOBAL CONST $IOCTL_DISK_UPDATE_PROPERTIES = 459072
GLOBAL CONST $IOCTL_DISK_VERIFY = 458772
GLOBAL CONST $IOCTL_DVD_END_SESSION = 3362828
GLOBAL CONST $IOCTL_DVD_GET_REGION = 3362836
GLOBAL CONST $IOCTL_DVD_READ_KEY = 3362820
GLOBAL CONST $IOCTL_DVD_READ_STRUCTURE = 3363136
GLOBAL CONST $IOCTL_DVD_SEND_KEY = 3362824
GLOBAL CONST $IOCTL_DVD_SEND_KEY2 = 3395608
GLOBAL CONST $IOCTL_DVD_SET_READ_AHEAD = 3362832
GLOBAL CONST $IOCTL_DVD_START_SESSION = 3362816
GLOBAL CONST $IOCTL_MOUNTDEV_LINK_CREATED = 5046288
GLOBAL CONST $IOCTL_MOUNTDEV_LINK_DELETED = 5046292
GLOBAL CONST $IOCTL_MOUNTDEV_QUERY_STABLE_GUID = 5046296
GLOBAL CONST $IOCTL_MOUNTDEV_QUERY_SUGGESTED_LINK_NAME = 5046284
GLOBAL CONST $IOCTL_MOUNTDEV_QUERY_UNIQUE_ID = 5046272
GLOBAL CONST $IOCTL_MOUNTDEV_UNIQUE_ID_CHANGE_NOTIFY = 5046276
GLOBAL CONST $IOCTL_MOUNTMGR_AUTO_DL_ASSIGNMENTS = 7192596
GLOBAL CONST $IOCTL_MOUNTMGR_CHANGE_NOTIFY = 7159840
GLOBAL CONST $IOCTL_MOUNTMGR_CHECK_UNPROCESSED_VOLUMES = 7159848
GLOBAL CONST $IOCTL_MOUNTMGR_CREATE_POINT = 7192576
GLOBAL CONST $IOCTL_MOUNTMGR_DELETE_POINTS = 7192580
GLOBAL CONST $IOCTL_MOUNTMGR_DELETE_POINTS_DBONLY = 7192588
GLOBAL CONST $IOCTL_MOUNTMGR_KEEP_LINKS_WHEN_OFFLINE = 7192612
GLOBAL CONST $IOCTL_MOUNTMGR_NEXT_DRIVE_LETTER = 7192592
GLOBAL CONST $IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATH = 7143472
GLOBAL CONST $IOCTL_MOUNTMGR_QUERY_DOS_VOLUME_PATHS = 7143476
GLOBAL CONST $IOCTL_MOUNTMGR_QUERY_POINTS = 7143432
GLOBAL CONST $IOCTL_MOUNTMGR_VOLUME_ARRIVAL_NOTIFICATION = 7159852
GLOBAL CONST $IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_CREATED = 7192600
GLOBAL CONST $IOCTL_MOUNTMGR_VOLUME_MOUNT_POINT_DELETED = 7192604
GLOBAL CONST $IOCTL_SCSI_GET_INQUIRY_DATA = 266252
GLOBAL CONST $IOCTL_SCSI_GET_CAPABILITIES = 266256
GLOBAL CONST $IOCTL_SCSI_GET_ADDRESS = 266264
GLOBAL CONST $IOCTL_SCSI_MINIPORT = 315400
GLOBAL CONST $IOCTL_SCSI_PASS_THROUGH = 315396
GLOBAL CONST $IOCTL_SCSI_PASS_THROUGH_DIRECT = 315412
GLOBAL CONST $IOCTL_SCSI_RESCAN_BUS = 266268
GLOBAL CONST $IOCTL_STORAGE_BREAK_RESERVATION = 2969620
GLOBAL CONST $IOCTL_STORAGE_CHECK_VERIFY = 2967552
GLOBAL CONST $IOCTL_STORAGE_CHECK_VERIFY2 = 2951168
GLOBAL CONST $IOCTL_STORAGE_EJECT_MEDIA = 2967560
GLOBAL CONST $IOCTL_STORAGE_EJECTION_CONTROL = 2951488
GLOBAL CONST $IOCTL_STORAGE_FIND_NEW_DEVICES = 2967576
GLOBAL CONST $IOCTL_STORAGE_GET_DEVICE_NUMBER = 2953344
GLOBAL CONST $IOCTL_STORAGE_GET_HOTPLUG_INFO = 2952212
GLOBAL CONST $IOCTL_STORAGE_GET_MEDIA_SERIAL_NUMBER = 2952208
GLOBAL CONST $IOCTL_STORAGE_GET_MEDIA_TYPES = 2952192
GLOBAL CONST $IOCTL_STORAGE_GET_MEDIA_TYPES_EX = 2952196
GLOBAL CONST $IOCTL_STORAGE_LOAD_MEDIA = 2967564
GLOBAL CONST $IOCTL_STORAGE_LOAD_MEDIA2 = 2951180
GLOBAL CONST $IOCTL_STORAGE_MANAGE_DATA_SET_ATTRIBUTES = 2987012
GLOBAL CONST $IOCTL_STORAGE_MCN_CONTROL = 2951492
GLOBAL CONST $IOCTL_STORAGE_MEDIA_REMOVAL = 2967556
GLOBAL CONST $IOCTL_STORAGE_PERSISTENT_RESERVE_IN = 2969624
GLOBAL CONST $IOCTL_STORAGE_PERSISTENT_RESERVE_OUT = 2969628
GLOBAL CONST $IOCTL_STORAGE_PREDICT_FAILURE = 2953472
GLOBAL CONST $IOCTL_STORAGE_QUERY_PROPERTY = 2954240
GLOBAL CONST $IOCTL_STORAGE_RELEASE = 2967572
GLOBAL CONST $IOCTL_STORAGE_RESERVE = 2967568
GLOBAL CONST $IOCTL_STORAGE_RESET_BUS = 2969600
GLOBAL CONST $IOCTL_STORAGE_RESET_DEVICE = 2969604
GLOBAL CONST $IOCTL_STORAGE_SET_HOTPLUG_INFO = 3001368
GLOBAL CONST $IOCTL_STORAGE_SET_READ_AHEAD = 2966528
GLOBAL CONST $IOCTL_VOLUME_GET_GPT_ATTRIBUTES = 5636152
GLOBAL CONST $IOCTL_VOLUME_GET_VOLUME_DISK_EXTENTS = 5636096
GLOBAL CONST $IOCTL_VOLUME_IS_CLUSTERED = 5636144
GLOBAL CONST $IOCTL_VOLUME_IS_IO_CAPABLE = 5636116
GLOBAL CONST $IOCTL_VOLUME_IS_OFFLINE = 5636112
GLOBAL CONST $IOCTL_VOLUME_IS_PARTITION = 5636136
GLOBAL CONST $IOCTL_VOLUME_LOGICAL_TO_PHYSICAL = 5636128
GLOBAL CONST $IOCTL_VOLUME_OFFLINE = 5685260
GLOBAL CONST $IOCTL_VOLUME_ONLINE = 5685256
GLOBAL CONST $IOCTL_VOLUME_PHYSICAL_TO_LOGICAL = 5636132
GLOBAL CONST $IOCTL_VOLUME_QUERY_FAILOVER_SET = 5636120
GLOBAL CONST $IOCTL_VOLUME_QUERY_VOLUME_NUMBER = 5636124
GLOBAL CONST $IOCTL_VOLUME_READ_PLEX = 5652526
GLOBAL CONST $IOCTL_VOLUME_SET_GPT_ATTRIBUTES = 5636148
GLOBAL CONST $IOCTL_VOLUME_SUPPORTS_ONLINE_OFFLINE = 5636100
GLOBAL CONST $SMART_GET_VERSION = 475264
GLOBAL CONST $SMART_RCV_DRIVE_DATA = 508040
GLOBAL CONST $SMART_SEND_DRIVE_COMMAND = 508036
GLOBAL CONST $FILE_ENCRYPTABLE = 0
GLOBAL CONST $FILE_IS_ENCRYPTED = 1
GLOBAL CONST $FILE_READ_ONLY = 8
GLOBAL CONST $FILE_ROOT_DIR = 3
GLOBAL CONST $FILE_SYSTEM_ATTR = 2
GLOBAL CONST $FILE_SYSTEM_DIR = 4
GLOBAL CONST $FILE_SYSTEM_NOT_SUPPORT = 6
GLOBAL CONST $FILE_UNKNOWN = 5
GLOBAL CONST $FILE_USER_DISALLOWED = 7
GLOBAL CONST $SCS_32BIT_BINARY = 0
GLOBAL CONST $SCS_64BIT_BINARY = 6
GLOBAL CONST $SCS_DOS_BINARY = 1
GLOBAL CONST $SCS_OS216_BINARY = 5
GLOBAL CONST $SCS_PIF_BINARY = 3
GLOBAL CONST $SCS_POSIX_BINARY = 4
GLOBAL CONST $SCS_WOW_BINARY = 2
GLOBAL CONST $DRIVE_BUS_TYPE_UNKNOWN = 0
GLOBAL CONST $DRIVE_BUS_TYPE_SCSI = 1
GLOBAL CONST $DRIVE_BUS_TYPE_ATAPI = 2
GLOBAL CONST $DRIVE_BUS_TYPE_ATA = 3
GLOBAL CONST $DRIVE_BUS_TYPE_1394 = 4
GLOBAL CONST $DRIVE_BUS_TYPE_SSA = 5
GLOBAL CONST $DRIVE_BUS_TYPE_FIBRE = 6
GLOBAL CONST $DRIVE_BUS_TYPE_USB = 7
GLOBAL CONST $DRIVE_BUS_TYPE_RAID = 8
GLOBAL CONST $DRIVE_BUS_TYPE_ISCSI = 9
GLOBAL CONST $DRIVE_BUS_TYPE_SAS = 10
GLOBAL CONST $DRIVE_BUS_TYPE_SATA = 11
GLOBAL CONST $DRIVE_BUS_TYPE_SD = 12
GLOBAL CONST $DRIVE_BUS_TYPE_MMC = 13
GLOBAL CONST $DRIVE_UNKNOWN = 0
GLOBAL CONST $DRIVE_NO_ROOT_DIR = 1
GLOBAL CONST $DRIVE_REMOVABLE = 2
GLOBAL CONST $DRIVE_FIXED = 3
GLOBAL CONST $DRIVE_REMOTE = 4
GLOBAL CONST $DRIVE_CDROM = 5
GLOBAL CONST $DRIVE_RAMDISK = 6
GLOBAL CONST $FILE_TYPE_CHAR = 2
GLOBAL CONST $FILE_TYPE_DISK = 1
GLOBAL CONST $FILE_TYPE_PIPE = 3
GLOBAL CONST $FILE_TYPE_REMOTE = 32768
GLOBAL CONST $FILE_TYPE_UNKNOWN = 0
GLOBAL CONST $FILE_NAME_NORMALIZED = 0
GLOBAL CONST $FILE_NAME_OPENED = 8
GLOBAL CONST $VOLUME_NAME_DOS = 0
GLOBAL CONST $VOLUME_NAME_GUID = 1
GLOBAL CONST $VOLUME_NAME_NONE = 4
GLOBAL CONST $VOLUME_NAME_NT = 2
GLOBAL CONST $IMAGE_FILE_MACHINE_UNKNOWN = 0
GLOBAL CONST $IMAGE_FILE_MACHINE_AM33 = 467
GLOBAL CONST $IMAGE_FILE_MACHINE_AMD64 = 34404
GLOBAL CONST $IMAGE_FILE_MACHINE_ARM = 448
GLOBAL CONST $IMAGE_FILE_MACHINE_EBC = 3772
GLOBAL CONST $IMAGE_FILE_MACHINE_I386 = 332
GLOBAL CONST $IMAGE_FILE_MACHINE_IA64 = 512
GLOBAL CONST $IMAGE_FILE_MACHINE_M32R = 36929
GLOBAL CONST $IMAGE_FILE_MACHINE_MIPS16 = 614
GLOBAL CONST $IMAGE_FILE_MACHINE_MIPSFPU = 870
GLOBAL CONST $IMAGE_FILE_MACHINE_MIPSFPU16 = 1126
GLOBAL CONST $IMAGE_FILE_MACHINE_POWERPC = 496
GLOBAL CONST $IMAGE_FILE_MACHINE_POWERPCFP = 497
GLOBAL CONST $IMAGE_FILE_MACHINE_R4000 = 358
GLOBAL CONST $IMAGE_FILE_MACHINE_SH3 = 418
GLOBAL CONST $IMAGE_FILE_MACHINE_SH3DSP = 419
GLOBAL CONST $IMAGE_FILE_MACHINE_SH4 = 422
GLOBAL CONST $IMAGE_FILE_MACHINE_SH5 = 424
GLOBAL CONST $IMAGE_FILE_MACHINE_THUMB = 450
GLOBAL CONST $IMAGE_FILE_MACHINE_WCEMIPSV2 = 361
GLOBAL CONST $FILE_CASE_PRESERVED_NAMES = 2
GLOBAL CONST $FILE_CASE_SENSITIVE_SEARCH = 1
GLOBAL CONST $FILE_FILE_COMPRESSION = 16
GLOBAL CONST $FILE_NAMED_STREAMS = 262144
GLOBAL CONST $FILE_PERSISTENT_ACLS = 8
GLOBAL CONST $FILE_READ_ONLY_VOLUME = 524288
GLOBAL CONST $FILE_SEQUENTIAL_WRITE_ONCE = 1048576
GLOBAL CONST $FILE_SUPPORTS_ENCRYPTION = 131072
GLOBAL CONST $FILE_SUPPORTS_EXTENDED_ATTRIBUTES = 8388608
GLOBAL CONST $FILE_SUPPORTS_HARD_LINKS = 4194304
GLOBAL CONST $FILE_SUPPORTS_OBJECT_IDS = 65536
GLOBAL CONST $FILE_SUPPORTS_OPEN_BY_FILE_ID = 16777216
GLOBAL CONST $FILE_SUPPORTS_REPARSE_POINTS = 128
GLOBAL CONST $FILE_SUPPORTS_SPARSE_FILES = 64
GLOBAL CONST $FILE_SUPPORTS_TRANSACTIONS = 2097152
GLOBAL CONST $FILE_SUPPORTS_USN_JOURNAL = 33554432
GLOBAL CONST $FILE_UNICODE_ON_DISK = 4
GLOBAL CONST $FILE_VOLUME_IS_COMPRESSED = 32768
GLOBAL CONST $FILE_VOLUME_QUOTAS = 32
GLOBAL CONST $FILE_DEVICE_8042_PORT = 39
GLOBAL CONST $FILE_DEVICE_ACPI = 50
GLOBAL CONST $FILE_DEVICE_BATTERY = 41
GLOBAL CONST $FILE_DEVICE_BEEP = 1
GLOBAL CONST $FILE_DEVICE_BUS_EXTENDER = 42
GLOBAL CONST $FILE_DEVICE_CD_ROM = 2
GLOBAL CONST $FILE_DEVICE_CD_ROM_FILE_SYSTEM = 3
GLOBAL CONST $FILE_DEVICE_CHANGER = 48
GLOBAL CONST $FILE_DEVICE_CONTROLLER = 4
GLOBAL CONST $FILE_DEVICE_DATALINK = 5
GLOBAL CONST $FILE_DEVICE_DFS = 6
GLOBAL CONST $FILE_DEVICE_DFS_FILE_SYSTEM = 53
GLOBAL CONST $FILE_DEVICE_DFS_VOLUME = 54
GLOBAL CONST $FILE_DEVICE_DISK = 7
GLOBAL CONST $FILE_DEVICE_DISK_FILE_SYSTEM = 8
GLOBAL CONST $FILE_DEVICE_DVD = 51
GLOBAL CONST $FILE_DEVICE_FILE_SYSTEM = 9
GLOBAL CONST $FILE_DEVICE_FIPS = 58
GLOBAL CONST $FILE_DEVICE_FULLSCREEN_VIDEO = 52
GLOBAL CONST $FILE_DEVICE_INPORT_PORT = 10
GLOBAL CONST $FILE_DEVICE_KEYBOARD = 11
GLOBAL CONST $FILE_DEVICE_KS = 47
GLOBAL CONST $FILE_DEVICE_KSEC = 57
GLOBAL CONST $FILE_DEVICE_MAILSLOT = 12
GLOBAL CONST $FILE_DEVICE_MASS_STORAGE = 45
GLOBAL CONST $FILE_DEVICE_MIDI_IN = 13
GLOBAL CONST $FILE_DEVICE_MIDI_OUT = 14
GLOBAL CONST $FILE_DEVICE_MODEM = 43
GLOBAL CONST $FILE_DEVICE_MOUSE = 15
GLOBAL CONST $FILE_DEVICE_MULTI_UNC_PROVIDER = 16
GLOBAL CONST $FILE_DEVICE_NAMED_PIPE = 17
GLOBAL CONST $FILE_DEVICE_NETWORK = 18
GLOBAL CONST $FILE_DEVICE_NETWORK_BROWSER = 19
GLOBAL CONST $FILE_DEVICE_NETWORK_FILE_SYSTEM = 20
GLOBAL CONST $FILE_DEVICE_NETWORK_REDIRECTOR = 40
GLOBAL CONST $FILE_DEVICE_NULL = 21
GLOBAL CONST $FILE_DEVICE_PARALLEL_PORT = 22
GLOBAL CONST $FILE_DEVICE_PHYSICAL_NETCARD = 23
GLOBAL CONST $FILE_DEVICE_PRINTER = 24
GLOBAL CONST $FILE_DEVICE_SCANNER = 25
GLOBAL CONST $FILE_DEVICE_SCREEN = 28
GLOBAL CONST $FILE_DEVICE_SERENUM = 55
GLOBAL CONST $FILE_DEVICE_SERIAL_MOUSE_PORT = 26
GLOBAL CONST $FILE_DEVICE_SERIAL_PORT = 27
GLOBAL CONST $FILE_DEVICE_SMARTCARD = 49
GLOBAL CONST $FILE_DEVICE_SMB = 46
GLOBAL CONST $FILE_DEVICE_SOUND = 29
GLOBAL CONST $FILE_DEVICE_STREAMS = 30
GLOBAL CONST $FILE_DEVICE_TAPE = 31
GLOBAL CONST $FILE_DEVICE_TAPE_FILE_SYSTEM = 32
GLOBAL CONST $FILE_DEVICE_TERMSRV = 56
GLOBAL CONST $FILE_DEVICE_TRANSPORT = 33
GLOBAL CONST $FILE_DEVICE_UNKNOWN = 34
GLOBAL CONST $FILE_DEVICE_VDM = 44
GLOBAL CONST $FILE_DEVICE_VIDEO = 35
GLOBAL CONST $FILE_DEVICE_VIRTUAL_DISK = 36
GLOBAL CONST $FILE_DEVICE_WAVE_IN = 37
GLOBAL CONST $FILE_DEVICE_WAVE_OUT = 38
GLOBAL CONST $FILE_ANY_ACCESS = 0
GLOBAL CONST $FILE_SPECIAL_ACCESS = $FILE_ANY_ACCESS
GLOBAL CONST $FILE_READ_ACCESS = 1
GLOBAL CONST $FILE_WRITE_ACCESS = 2
GLOBAL CONST $METHOD_BUFFERED = 0
GLOBAL CONST $METHOD_IN_DIRECT = 1
GLOBAL CONST $METHOD_OUT_DIRECT = 2
GLOBAL CONST $METHOD_NEITHER = 3
GLOBAL CONST $FILE_NOTIFY_CHANGE_FILE_NAME = 1
GLOBAL CONST $FILE_NOTIFY_CHANGE_DIR_NAME = 2
GLOBAL CONST $FILE_NOTIFY_CHANGE_ATTRIBUTES = 4
GLOBAL CONST $FILE_NOTIFY_CHANGE_SIZE = 8
GLOBAL CONST $FILE_NOTIFY_CHANGE_LAST_WRITE = 16
GLOBAL CONST $FILE_NOTIFY_CHANGE_LAST_ACCESS = 32
GLOBAL CONST $FILE_NOTIFY_CHANGE_CREATION = 64
GLOBAL CONST $FILE_NOTIFY_CHANGE_SECURITY = 256
GLOBAL CONST $FILE_ACTION_ADDED = 1
GLOBAL CONST $FILE_ACTION_REMOVED = 2
GLOBAL CONST $FILE_ACTION_MODIFIED = 3
GLOBAL CONST $FILE_ACTION_RENAMED_OLD_NAME = 4
GLOBAL CONST $FILE_ACTION_RENAMED_NEW_NAME = 5
GLOBAL CONST $REPLACEFILE_WRITE_THROUGH = 1
GLOBAL CONST $REPLACEFILE_IGNORE_MERGE_ERRORS = 2
GLOBAL CONST $REPLACEFILE_IGNORE_ACL_ERRORS = 4
GLOBAL CONST $BASE_SEARCH_PATH_ENABLE_SAFE_SEARCHMODE = 1
GLOBAL CONST $BASE_SEARCH_PATH_DISABLE_SAFE_SEARCHMODE = 65536
GLOBAL CONST $BASE_SEARCH_PATH_PERMANENT = 32768
GLOBAL CONST $URL_SCHEME_INVALID = -1
GLOBAL CONST $URL_SCHEME_UNKNOWN = 0
GLOBAL CONST $URL_SCHEME_FTP = 1
GLOBAL CONST $URL_SCHEME_HTTP = 2
GLOBAL CONST $URL_SCHEME_GOPHER = 3
GLOBAL CONST $URL_SCHEME_MAILTO = 4
GLOBAL CONST $URL_SCHEME_NEWS = 5
GLOBAL CONST $URL_SCHEME_NNTP = 6
GLOBAL CONST $URL_SCHEME_TELNET = 7
GLOBAL CONST $URL_SCHEME_WAIS = 8
GLOBAL CONST $URL_SCHEME_FILE = 9
GLOBAL CONST $URL_SCHEME_MK = 10
GLOBAL CONST $URL_SCHEME_HTTPS = 11
GLOBAL CONST $URL_SCHEME_SHELL = 12
GLOBAL CONST $URL_SCHEME_SNEWS = 13
GLOBAL CONST $URL_SCHEME_LOCAL = 14
GLOBAL CONST $URL_SCHEME_JAVASCRIPT = 15
GLOBAL CONST $URL_SCHEME_VBSCRIPT = 16
GLOBAL CONST $URL_SCHEME_ABOUT = 17
GLOBAL CONST $URL_SCHEME_RES = 18
GLOBAL CONST $URL_SCHEME_MSSHELLROOTED = 19
GLOBAL CONST $URL_SCHEME_MSSHELLIDLIST = 20
GLOBAL CONST $URL_SCHEME_MSHELP = 21
GLOBAL CONST $URL_SCHEME_MSSHELLDEVICE = 22
GLOBAL CONST $URL_SCHEME_WILDCARD = 23
GLOBAL CONST $URL_SCHEME_SEARCH_MS = 24
GLOBAL CONST $URL_SCHEME_SEARCH = 25
GLOBAL CONST $URL_SCHEME_KNOWNFOLDER = 26
GLOBAL CONST $GCT_INVALID = 0
GLOBAL CONST $GCT_LFNCHAR = 1
GLOBAL CONST $GCT_SEPARATOR = 8
GLOBAL CONST $GCT_SHORTCHAR = 2
GLOBAL CONST $GCT_WILD = 4
GLOBAL CONST $URL_APPLY_DEFAULT = 1
GLOBAL CONST $URL_APPLY_GUESSSCHEME = 2
GLOBAL CONST $URL_APPLY_GUESSFILE = 4
GLOBAL CONST $URL_APPLY_FORCEAPPLY = 8
GLOBAL CONST $URL_DONT_SIMPLIFY = 134217728
GLOBAL CONST $URL_ESCAPE_AS_UTF8 = 262144
GLOBAL CONST $URL_ESCAPE_PERCENT = 4096
GLOBAL CONST $URL_ESCAPE_SPACES_ONLY = 67108864
GLOBAL CONST $URL_ESCAPE_UNSAFE = 536870912
GLOBAL CONST $URL_NO_META = 134217728
GLOBAL CONST $URL_PLUGGABLE_PROTOCOL = 1073741824
GLOBAL CONST $URL_UNESCAPE = 268435456
GLOBAL CONST $URL_PART_HOSTNAME = 2
GLOBAL CONST $URL_PART_PASSWORD = 4
GLOBAL CONST $URL_PART_PORT = 5
GLOBAL CONST $URL_PART_QUERY = 6
GLOBAL CONST $URL_PART_SCHEME = 1
GLOBAL CONST $URL_PART_USERNAME = 3
GLOBAL CONST $URLIS_APPLIABLE = 4
GLOBAL CONST $URLIS_DIRECTORY = 5
GLOBAL CONST $URLIS_FILEURL = 3
GLOBAL CONST $URLIS_HASQUERY = 6
GLOBAL CONST $URLIS_NOHISTORY = 2
GLOBAL CONST $URLIS_OPAQUE = 1
GLOBAL CONST $URLIS_URL = 0
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_COMMANDLINETOARGV($SCMD)
		LOCAL $ARESULT[1] = [0]
		$SCMD = STRINGSTRIPWS($SCMD, $STR_STRIPLEADING + $STR_STRIPTRAILING)
		IF NOT $SCMD THEN
			RETURN $ARESULT
		ENDIF
		LOCAL $ARET = DLLCALL("shell32.dll", "ptr", "CommandLineToArgvW", "wstr", $SCMD, "int*", 0)
		IF @ERROR OR NOT $ARET[0] OR(NOT $ARET[2]) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TPTR = DLLSTRUCTCREATE("ptr[" & $ARET[2] & "]", $ARET[0])
		DIM $ARESULT[$ARET[2] + 1] = [$ARET[2]]
		FOR $I = 1 TO $ARET[2]
			$ARESULT[$I] = _WINAPI_GETSTRING(DLLSTRUCTGETDATA($TPTR, 1, $I))
		NEXT
		DLLCALL("kernel32.dll", "handle", "LocalFree", "handle", $ARET[0])
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_ISNAMEINEXPRESSION($SSTRING, $SPATTERN, $BCASESENSITIVE = FALSE)
		IF NOT $BCASESENSITIVE THEN $SPATTERN = STRINGUPPER($SPATTERN)
		LOCAL $TUS1 = __US($SPATTERN)
		LOCAL $TUS2 = __US($SSTRING)
		LOCAL $ARET = DLLCALL("ntdll.dll", "boolean", "RtlIsNameInExpression", "struct*", $TUS1, "struct*", $TUS2, "boolean", NOT $BCASESENSITIVE, "ptr", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PARSEURL($SURL)
		LOCAL $TAGPARSEDURL = "dword Size;ptr Protocol;uint cchProtocol;ptr Suffix;uint cchSuffix;uint Scheme"
		LOCAL $TPURL = DLLSTRUCTCREATE($TAGPARSEDURL)
		DLLSTRUCTSETDATA($TPURL, 1, DLLSTRUCTGETSIZE($TPURL))
		LOCAL $TURL = DLLSTRUCTCREATE("wchar[4096]")
		DLLSTRUCTSETDATA($TURL, 1, $SURL)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "long", "ParseURLW", "struct*", $TURL, "struct*", $TPURL)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		LOCAL $ARESULT[3]
		$ARESULT[0] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & DLLSTRUCTGETDATA($TPURL, 3) & "]", DLLSTRUCTGETDATA($TPURL, 2)), 1)
		$ARESULT[1] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & DLLSTRUCTGETDATA($TPURL, 5) & "]", DLLSTRUCTGETDATA($TPURL, 4)), 1)
		$ARESULT[2] = DLLSTRUCTGETDATA($TPURL, 6)
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_PARSEUSERNAME($SUSER)
		IF NOT __DLL("credui.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $ARET = DLLCALL("credui.dll", "dword", "CredUIParseUserNameW", "wstr", $SUSER, "wstr", "", "ulong", 4096, "wstr", "", "ulong", 4096)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		SWITCH $ARET[0]
			CASE 0
			CASE 1315
				IF STRINGSTRIPWS($SUSER, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
					$ARET[2] = $SUSER
					$ARET[4] = ""
				ELSE
					CONTINUECASE
				ENDIF
			CASE ELSE
				RETURN SETERROR(10, $ARET[0], 0)
		ENDSWITCH
		LOCAL $ARESULT[2]
		$ARESULT[0] = $ARET[4]
		$ARESULT[1] = $ARET[2]
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_PATHADDBACKSLASH($SFILEPATH)
		LOCAL $TPATH = DLLSTRUCTCREATE("wchar[260]")
		DLLSTRUCTSETDATA($TPATH, 1, $SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "ptr", "PathAddBackslashW", "struct*", $TPATH)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN DLLSTRUCTGETDATA($TPATH, 1)
	ENDFUNC
	FUNC _WINAPI_PATHADDEXTENSION($SFILEPATH, $SEXT = "")
		LOCAL $TPATH = DLLSTRUCTCREATE("wchar[260]")
		DLLSTRUCTSETDATA($TPATH, 1, $SFILEPATH)
		LOCAL $STYPEOFEXT = "wstr"
		IF NOT STRINGSTRIPWS($SEXT, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFEXT = "ptr"
			$SEXT = 0
		ENDIF
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathAddExtensionW", "struct*", $TPATH, $STYPEOFEXT, $SEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN SETEXTENDED($ARET[0], DLLSTRUCTGETDATA($TPATH, 1))
	ENDFUNC
	FUNC _WINAPI_PATHAPPEND($SFILEPATH, $SMORE)
		LOCAL $TPATH = DLLSTRUCTCREATE("wchar[260]")
		DLLSTRUCTSETDATA($TPATH, 1, $SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathAppendW", "struct*", $TPATH, "wstr", $SMORE)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN DLLSTRUCTGETDATA($TPATH, 1)
	ENDFUNC
	FUNC _WINAPI_PATHBUILDROOT($IDRIVE)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "ptr", "PathBuildRootW", "wstr", "", "int", $IDRIVE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_PATHCANONICALIZE($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathCanonicalizeW", "wstr", "", "wstr", $SFILEPATH)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, $SFILEPATH)
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_PATHCOMMONPREFIX($SPATH1, $SPATH2)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "int", "PathCommonPrefixW", "wstr", $SPATH1, "wstr", $SPATH2, "wstr", "")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN SETEXTENDED($ARET[0], $ARET[3])
	ENDFUNC
	FUNC _WINAPI_PATHCOMPACTPATH($HWND, $SFILEPATH, $IWIDTH = 0)
		IF $IWIDTH < 1 THEN
			LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
			DLLCALL("user32.dll", "bool", "GetClientRect", "hwnd", $HWND, "struct*", $TRECT)
			$IWIDTH += DLLSTRUCTGETDATA($TRECT, "Right") - DLLSTRUCTGETDATA($TRECT, "Left")
		ENDIF
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "GetDC", "hwnd", $HWND)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, $SFILEPATH)
		LOCAL $HDC = $ARET[0]
		LOCAL CONST $WM_GETFONT = 49
		$ARET = DLLCALL("user32.dll", "ptr", "SendMessage", "hwnd", $HWND, "uint", $WM_GETFONT, "wparam", 0, "lparam", 0)
		LOCAL $HBACK = DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDC, "handle", $ARET[0])
		LOCAL $IERROR = 0
		$ARET = DLLCALL("shlwapi.dll", "bool", "PathCompactPathW", "handle", $HDC, "wstr", $SFILEPATH, "int", $IWIDTH)
		IF @ERROR OR NOT $ARET[0] THEN $IERROR = @ERROR + 10
		DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDC, "handle", $HBACK[0])
		DLLCALL("user32.dll", "int", "ReleaseDC", "hwnd", $HWND, "handle", $HDC)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, $SFILEPATH)
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_PATHCOMPACTPATHEX($SFILEPATH, $IMAX)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathCompactPathExW", "wstr", "", "wstr", $SFILEPATH, "uint", $IMAX + 1, "dword", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, $SFILEPATH)
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_PATHCREATEFROMURL($SURL)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "long", "PathCreateFromUrlW", "wstr", $SURL, "wstr", "", "dword*", 4096, "dword", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_PATHFINDEXTENSION($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "wstr", "PathFindExtensionW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHFINDFILENAME($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "wstr", "PathFindFileNameW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, $SFILEPATH)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHFINDNEXTCOMPONENT($SFILEPATH)
		LOCAL $TPATH = DLLSTRUCTCREATE("wchar[" & (STRINGLEN($SFILEPATH) + 1) & "]")
		DLLSTRUCTSETDATA($TPATH, 1, $SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "ptr", "PathFindNextComponentW", "struct*", $TPATH)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN _WINAPI_GETSTRING($ARET[0])
	ENDFUNC
	FUNC _WINAPI_PATHFINDONPATH(CONST $SFILEPATH, $AEXTRAPATHS = "", CONST $SPATHDELIMITER = @LF)
		LOCAL $IEXTRACOUNT = 0
		IF ISSTRING($AEXTRAPATHS) THEN
			IF STRINGLEN($AEXTRAPATHS) THEN
				$AEXTRAPATHS = STRINGSPLIT($AEXTRAPATHS, $SPATHDELIMITER, $STR_ENTIRESPLIT + $STR_NOCOUNT)
				$IEXTRACOUNT = UBOUND($AEXTRAPATHS, $UBOUND_ROWS)
			ENDIF
		ELSEIF ISARRAY($AEXTRAPATHS) THEN
			$IEXTRACOUNT = UBOUND($AEXTRAPATHS)
		ENDIF
		LOCAL $TPATHS, $TPATHPTRS
		IF $IEXTRACOUNT THEN
			LOCAL $TAGSTRUCT = ""
			FOR $PATH IN $AEXTRAPATHS
				$TAGSTRUCT &= "wchar[" & STRINGLEN($PATH) + 1 & "];"
			NEXT
			$TPATHS = DLLSTRUCTCREATE($TAGSTRUCT)
			$TPATHPTRS = DLLSTRUCTCREATE("ptr[" & $IEXTRACOUNT + 1 & "]")
			FOR $I = 1 TO $IEXTRACOUNT
				DLLSTRUCTSETDATA($TPATHS, $I, $AEXTRAPATHS[$I - 1])
				DLLSTRUCTSETDATA($TPATHPTRS, 1, DLLSTRUCTGETPTR($TPATHS, $I), $I)
			NEXT
			DLLSTRUCTSETDATA($TPATHPTRS, 1, PTR(0), $IEXTRACOUNT + 1)
		ENDIF
		LOCAL $ARESULT = DLLCALL("shlwapi.dll", "bool", "PathFindOnPathW", "wstr", $SFILEPATH, "struct*", $TPATHPTRS)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, $SFILEPATH)
		RETURN $ARESULT[1]
	ENDFUNC
	FUNC _WINAPI_PATHGETARGS($SFILEPATH)
		LOCAL $TPATH = DLLSTRUCTCREATE("wchar[" & (STRINGLEN($SFILEPATH) + 1) & "]")
		DLLSTRUCTSETDATA($TPATH, 1, $SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "ptr", "PathGetArgsW", "struct*", $TPATH)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN _WINAPI_GETSTRING($ARET[0])
	ENDFUNC
	FUNC _WINAPI_PATHGETCHARTYPE($SCHAR)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "uint", "PathGetCharTypeW", "word", ASCW($SCHAR))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHGETDRIVENUMBER($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "int", "PathGetDriveNumberW", "wstr", $SFILEPATH)
		IF @ERROR OR($ARET[0] = -1) THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN CHR($ARET[0] + 65) & ":"
	ENDFUNC
	FUNC _WINAPI_PATHISCONTENTTYPE($SFILEPATH, $STYPE)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathIsContentTypeW", "wstr", $SFILEPATH, "wstr", $STYPE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHISEXE($SFILEPATH)
		LOCAL $ARET = DLLCALL("shell32.dll", "bool", "PathIsExe", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHISFILESPEC($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathIsFileSpecW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHISLFNFILESPEC($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathIsLFNFileSpecW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHISRELATIVE($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathIsRelativeW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHISROOT($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathIsRootW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHISSAMEROOT($SPATH1, $SPATH2)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathIsSameRootW", "wstr", $SPATH1, "wstr", $SPATH2)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHISSYSTEMFOLDER($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathIsSystemFolderW", "wstr", $SFILEPATH, "dword", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHISUNC($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathIsUNCW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHISUNCSERVER($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathIsUNCServerW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHISUNCSERVERSHARE($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathIsUNCServerShareW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHMAKESYSTEMFOLDER($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathMakeSystemFolderW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHMATCHSPEC($SFILEPATH, $SSPEC)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathMatchSpecW", "wstr", $SFILEPATH, "wstr", $SSPEC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHPARSEICONLOCATION($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "int", "PathParseIconLocationW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARESULT[2]
		$ARESULT[0] = $ARET[1]
		$ARESULT[1] = $ARET[0]
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_PATHRELATIVEPATHTO($SPATHFROM, $BDIRFROM, $SPATHTO, $BDIRTO)
		IF $BDIRFROM THEN
			$BDIRFROM = 16
		ENDIF
		IF $BDIRTO THEN
			$BDIRTO = 16
		ENDIF
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathRelativePathToW", "wstr", "", "wstr", $SPATHFROM, "dword", $BDIRFROM, "wstr", $SPATHTO, "dword", $BDIRTO)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_PATHREMOVEARGS($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "none", "PathRemoveArgsW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_PATHREMOVEBACKSLASH($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "ptr", "PathRemoveBackslashW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_PATHREMOVEEXTENSION($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "none", "PathRemoveExtensionW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_PATHREMOVEFILESPEC($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathRemoveFileSpecW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN SETEXTENDED($ARET[0], $ARET[1])
	ENDFUNC
	FUNC _WINAPI_PATHRENAMEEXTENSION($SFILEPATH, $SEXT)
		LOCAL $TPATH = DLLSTRUCTCREATE("wchar[260]")
		DLLSTRUCTSETDATA($TPATH, 1, $SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathRenameExtensionW", "struct*", $TPATH, "wstr", $SEXT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN DLLSTRUCTGETDATA($TPATH, 1)
	ENDFUNC
	FUNC _WINAPI_PATHSEARCHANDQUALIFY($SFILEPATH, $BEXISTS = FALSE)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathSearchAndQualifyW", "wstr", $SFILEPATH, "wstr", "", "int", 4096)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		IF $BEXISTS AND NOT FILEEXISTS($ARET[2]) THEN RETURN SETERROR(20, 0, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_PATHSKIPROOT($SFILEPATH)
		LOCAL $TPATH = DLLSTRUCTCREATE("wchar[" & (STRINGLEN($SFILEPATH) + 1) & "]")
		DLLSTRUCTSETDATA($TPATH, 1, $SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "ptr", "PathSkipRootW", "struct*", $TPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF NOT $ARET[0] THEN RETURN $SFILEPATH
		RETURN _WINAPI_GETSTRING($ARET[0])
	ENDFUNC
	FUNC _WINAPI_PATHSTRIPPATH($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "none", "PathStripPathW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_PATHSTRIPTOROOT($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathStripToRootW", "wstr", $SFILEPATH)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_PATHUNDECORATE($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "none", "PathUndecorateW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_PATHUNEXPANDENVSTRINGS($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathUnExpandEnvStringsW", "wstr", $SFILEPATH, "wstr", "", "uint", 4096)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_PATHUNMAKESYSTEMFOLDER($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathUnmakeSystemFolderW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHUNQUOTESPACES($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "none", "PathUnquoteSpacesW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_PATHYETANOTHERMAKEUNIQUENAME($SFILEPATH)
		LOCAL $ARET = DLLCALL("shell32.dll", "int", "PathYetAnotherMakeUniqueName", "wstr", "", "wstr", $SFILEPATH, "ptr", 0, "ptr", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_SHELLGETIMAGELIST($BSMALL = FALSE)
		LOCAL $PLARGE, $PSMALL, $TPTR = DLLSTRUCTCREATE("ptr")
		IF $BSMALL THEN
			$PLARGE = 0
			$PSMALL = DLLSTRUCTGETPTR($TPTR)
		ELSE
			$PLARGE = DLLSTRUCTGETPTR($TPTR)
			$PSMALL = 0
		ENDIF
		LOCAL $ARET = DLLCALL("shell32.dll", "int", "Shell_GetImageLists", "ptr", $PLARGE, "ptr", $PSMALL)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TPTR, 1)
	ENDFUNC
	FUNC _WINAPI_URLAPPLYSCHEME($SURL, $IFLAGS = 1)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "long", "UrlApplySchemeW", "wstr", $SURL, "wstr", "", "dword*", 4096, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_URLCANONICALIZE($SURL, $IFLAGS)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "long", "UrlCanonicalizeW", "wstr", $SURL, "wstr", "", "dword*", 4096, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_URLCOMBINE($SURL, $SPART, $IFLAGS = 0)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "long", "UrlCombineW", "wstr", $SURL, "wstr", $SPART, "wstr", "", "dword*", 4096, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_URLCOMPARE($SURL1, $SURL2, $BIGNORESLASH = FALSE)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "int", "UrlCompareW", "wstr", $SURL1, "wstr", $SURL2, "bool", $BIGNORESLASH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_URLCREATEFROMPATH($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "long", "UrlCreateFromPathW", "wstr", $SFILEPATH, "wstr", "", "dword*", 4096, "dword", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] < 0 OR $ARET[0] > 1 THEN
			RETURN SETERROR(10, $ARET[0], "")
		ENDIF
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_URLFIXUP($SURL)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "long", "UrlFixupW", "wstr", $SURL, "wstr", "", "dword", 4096)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_URLGETPART($SURL, $IPART)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "long", "UrlGetPartW", "wstr", $SURL, "wstr", "", "dword*", 4096, "dword", $IPART, "dword", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_URLHASH($SURL, $ILENGTH = 32)
		IF $ILENGTH <= 0 OR $ILENGTH > 256 THEN RETURN SETERROR(256, 0, 0)
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[" & $ILENGTH & "]")
		LOCAL $ARET = DLLCALL("shlwapi.dll", "long", "UrlHashW", "wstr", $SURL, "struct*", $TDATA, "dword", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN DLLSTRUCTGETDATA($TDATA, 1)
	ENDFUNC
	FUNC _WINAPI_URLIS($SURL, $ITYPE = 0)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "UrlIsW", "wstr", $SURL, "uint", $ITYPE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __US($SSTRING, $ILENGTH = 0)
		IF $ILENGTH THEN
			$SSTRING = STRINGLEFT($SSTRING, $ILENGTH)
		ELSE
			$ILENGTH = STRINGLEN($SSTRING)
		ENDIF
		LOCAL $TUS = DLLSTRUCTCREATE("ushort;ushort;ptr;wchar[" & ($ILENGTH + 1) & "]")
		DLLSTRUCTSETDATA($TUS, 1, 2 * STRINGLEN($SSTRING))
		DLLSTRUCTSETDATA($TUS, 2, 2 * $ILENGTH)
		DLLSTRUCTSETDATA($TUS, 3, DLLSTRUCTGETPTR($TUS, 4))
		DLLSTRUCTSETDATA($TUS, 4, $SSTRING)
		RETURN $TUS
	ENDFUNC
#EndRegion Internal Functions
#Region Global Variables and Constants
	GLOBAL $__G_IHEAPSIZE = 8388608
	GLOBAL CONST $TAGFILEINFO = "uint64 CreationTime;uint64 LastAccessTime;uint64 LastWriteTime;uint64 ChangeTime;dword Attributes"
	GLOBAL CONST $TAGFILE_ID_DESCRIPTOR = "dword Size;uint Type;" & $TAGGUID
	GLOBAL CONST $TAGWIN32_FIND_STREAM_DATA = "int64 StreamSize;wchar StreamName[296]"
	GLOBAL CONST $TAGWIN32_STREAM_ID = "dword StreamId;dword StreamAttributes;int64 Size;dword StreamNameSize;wchar StreamName[1]"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_BACKUPREAD($HFILE, $PBUFFER, $ILENGTH, BYREF $IBYTES, BYREF $PCONTEXT, $BSECURITY = FALSE)
		$IBYTES = 0
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "BackupRead", "handle", $HFILE, "struct*", $PBUFFER, "dword", $ILENGTH, "dword*", 0, "bool", 0, "bool", $BSECURITY, "ptr*", $PCONTEXT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IBYTES = $ARET[4]
		$PCONTEXT = $ARET[7]
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_BACKUPREADABORT(BYREF $PCONTEXT)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "BackupRead", "handle", 0, "ptr", 0, "dword", 0, "dword*", 0, "bool", 1, "bool", 0, "ptr*", $PCONTEXT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$PCONTEXT = $ARET[7]
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_BACKUPSEEK($HFILE, $ISEEK, BYREF $IBYTES, BYREF $PCONTEXT)
		$IBYTES = 0
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "BackupSeek", "handle", $HFILE, "dword", _WINAPI_LODWORD($ISEEK), "dword", _WINAPI_HIDWORD($ISEEK), "dword*", 0, "dword*", 0, "ptr*", $PCONTEXT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IBYTES = __WINAPI_MAKEQWORD($ARET[4], $ARET[5])
		$PCONTEXT = $ARET[6]
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_BACKUPWRITE($HFILE, $PBUFFER, $ILENGTH, BYREF $IBYTES, BYREF $PCONTEXT, $BSECURITY = FALSE)
		$IBYTES = 0
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "BackupWrite", "handle", $HFILE, "struct*", $PBUFFER, "dword", $ILENGTH, "dword*", 0, "bool", 0, "bool", $BSECURITY, "ptr*", $PCONTEXT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IBYTES = $ARET[4]
		$PCONTEXT = $ARET[7]
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_BACKUPWRITEABORT(BYREF $PCONTEXT)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "BackupWrite", "handle", 0, "ptr", 0, "dword", 0, "dword*", 0, "bool", 1, "bool", 0, "ptr*", $PCONTEXT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$PCONTEXT = $ARET[7]
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_COPYFILEEX($SEXISTINGFILE, $SNEWFILE, $IFLAGS = 0, $PPROGRESSPROC = 0, $PDATA = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "CopyFileExW", "wstr", $SEXISTINGFILE, "wstr", $SNEWFILE, "ptr", $PPROGRESSPROC, "struct*", $PDATA, "bool*", 0, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEDIRECTORY($SDIR, $TSECURITY = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "CreateDirectoryW", "wstr", $SDIR, "struct*", $TSECURITY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEDIRECTORYEX($SNEWDIR, $STEMPLATEDIR, $TSECURITY = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "CreateDirectoryExW", "wstr", $STEMPLATEDIR, "wstr", $SNEWDIR, "struct*", $TSECURITY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEFILEEX($SFILEPATH, $ICREATION, $IACCESS = 0, $ISHARE = 0, $IFLAGSANDATTRIBUTES = 0, $TSECURITY = 0, $HTEMPLATE = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "CreateFileW", "wstr", $SFILEPATH, "dword", $IACCESS, "dword", $ISHARE, "struct*", $TSECURITY, "dword", $ICREATION, "dword", $IFLAGSANDATTRIBUTES, "handle", $HTEMPLATE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] = PTR(-1) THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEFILEMAPPING($HFILE, $ISIZE = 0, $SNAME = "", $IPROTECT = 4, $TSECURITY = 0)
		LOCAL $STYPEOFNAME = "wstr"
		IF NOT STRINGSTRIPWS($SNAME, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFNAME = "ptr"
			$SNAME = 0
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "CreateFileMappingW", "handle", $HFILE, "struct*", $TSECURITY, "dword", $IPROTECT, "dword", _WINAPI_HIDWORD($ISIZE), "dword", _WINAPI_LODWORD($ISIZE), $STYPEOFNAME, $SNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN SETEXTENDED(_WINAPI_GETLASTERROR(), $ARET[0])
	ENDFUNC
	FUNC _WINAPI_CREATEHARDLINK($SNEWFILE, $SEXISTINGFILE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "CreateHardLinkW", "wstr", $SNEWFILE, "wstr", $SEXISTINGFILE, "ptr", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEOBJECTID($SFILEPATH)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TFOID = DLLSTRUCTCREATE("byte[16];byte[48]")
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 590016, "ptr", 0, "dword", 0, "struct*", $TFOID, "dword", DLLSTRUCTGETSIZE($TFOID), "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $TGUID = DLLSTRUCTCREATE($TAGGUID)
		_WINAPI_MOVEMEMORY($TGUID, $TFOID, 16)
		RETURN $TGUID
	ENDFUNC
	FUNC _WINAPI_CREATESYMBOLICLINK($SSYMLINK, $STARGET, $BDIRECTORY = FALSE)
		IF $BDIRECTORY THEN
			$BDIRECTORY = 1
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "boolean", "CreateSymbolicLinkW", "wstr", $SSYMLINK, "wstr", $STARGET, "dword", $BDIRECTORY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DECRYPTFILE($SFILEPATH)
		LOCAL $ARET = DLLCALL("advapi32.dll", "bool", "DecryptFileW", "wstr", $SFILEPATH, "dword", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DEFINEDOSDEVICE($SDEVICE, $IFLAGS, $SFILEPATH = "")
		LOCAL $STYPEOFPATH = "wstr"
		IF NOT STRINGSTRIPWS($SFILEPATH, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFPATH = "ptr"
			$SFILEPATH = 0
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DefineDosDeviceW", "dword", $IFLAGS, "wstr", $SDEVICE, $STYPEOFPATH, $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DELETEFILE($SFILEPATH)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeleteFileW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DELETEOBJECTID($SFILEPATH)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, $GENERIC_WRITE, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 589984, "ptr", 0, "dword", 0, "ptr", 0, "dword", 0, "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DELETEVOLUMEMOUNTPOINT($SMOUNTEDPATH)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeleteVolumeMountPointW", "wstr", $SMOUNTEDPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DEVICEIOCONTROL($HDEVICE, $ICONTROLCODE, $PINBUFFER = 0, $IINBUFFERSIZE = 0, $POUTBUFFER = 0, $IOUTBUFFERSIZE = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HDEVICE, "dword", $ICONTROLCODE, "struct*", $PINBUFFER, "dword", $IINBUFFERSIZE, "struct*", $POUTBUFFER, "dword", $IOUTBUFFERSIZE, "dword*", 0, "ptr", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN SETEXTENDED($ARET[7], $ARET[0])
	ENDFUNC
	FUNC _WINAPI_DUPLICATEENCRYPTIONINFOFILE($SSRCFILEPATH, $SDESTFILEPATH, $ICREATION = 2, $IATTRIBUTES = 0, $TSECURITY = 0)
		LOCAL $ARET = DLLCALL("advapi32.dll", "dword", "DuplicateEncryptionInfoFile", "wstr", $SSRCFILEPATH, "wstr", $SDESTFILEPATH, "dword", $ICREATION, "dword", $IATTRIBUTES, "struct*", $TSECURITY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_EJECTMEDIA($SDRIVE)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 2967560, "ptr", 0, "dword", 0, "ptr", 0, "dword", 0, "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_ENCRYPTFILE($SFILEPATH)
		LOCAL $ARET = DLLCALL("advapi32.dll", "bool", "EncryptFileW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ENCRYPTIONDISABLE($SDIR, $BDISABLE)
		LOCAL $ARET = DLLCALL("advapi32.dll", "bool", "EncryptionDisable", "wstr", $SDIR, "bool", $BDISABLE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ENUMFILES($SDIR, $IFLAG = 0, $STEMPLATE = "", $BEXCLUDE = FALSE)
		LOCAL $ARET = 0, $IERROR = 0
		LOCAL $ADATA[501][7] = [[0]]
		LOCAL $HDIR = _WINAPI_CREATEFILEEX($SDIR, $OPEN_EXISTING, 1, $FILE_SHARE_ANY, $FILE_FLAG_BACKUP_SEMANTICS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $PBUFFER = __HEAPALLOC($__G_IHEAPSIZE)
		IF @ERROR THEN
			$IERROR = @ERROR
		ELSE
			LOCAL $TIOSB = DLLSTRUCTCREATE("ptr;ulong_ptr")
			$ARET = DLLCALL("ntdll.dll", "uint", "ZwQueryDirectoryFile", "handle", $HDIR, "ptr", 0, "ptr", 0, "ptr", 0, "struct*", $TIOSB, "struct*", $PBUFFER, "ulong", 8388608, "uint", 1, "boolean", 0, "ptr", 0, "boolean", 1)
			IF @ERROR OR $ARET[0] THEN
				$IERROR = @ERROR + 40
			ENDIF
		ENDIF
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HDIR)
		IF $IERROR THEN
			__HEAPFREE($PBUFFER, 1)
			IF ISARRAY($ARET) THEN
				RETURN SETERROR(10, $ARET[0], 0)
			ELSE
				RETURN SETERROR($IERROR, 0, 0)
			ENDIF
		ENDIF
		LOCAL $TFDI, $IATTRIB, $STARGET, $ILENGTH = 0, $IOFFSET = 0
		DO
			$ILENGTH += $IOFFSET
			$TFDI = DLLSTRUCTCREATE("ulong;ulong;int64;int64;int64;int64;int64;int64;ulong;ulong;wchar[" & (DLLSTRUCTGETDATA(DLLSTRUCTCREATE("ulong", $PBUFFER + $ILENGTH + 60), 1) / 2) & "]", $PBUFFER + $ILENGTH)
			$STARGET = DLLSTRUCTGETDATA($TFDI, 11)
			$IATTRIB = DLLSTRUCTGETDATA($TFDI, 9)
			$IOFFSET = DLLSTRUCTGETDATA($TFDI, 1)
			SWITCH $STARGET
				CASE ".", ".."
					CONTINUELOOP
				CASE ELSE
					SWITCH $IFLAG
						CASE 1, 2
							IF BITAND($IATTRIB, 16) THEN
								IF $IFLAG = 1 THEN
									CONTINUELOOP
								ENDIF
							ELSE
								IF $IFLAG = 2 THEN
									CONTINUELOOP
								ENDIF
							ENDIF
					ENDSWITCH
					IF $STEMPLATE THEN
						$ARET = DLLCALL("shlwapi.dll", "int", "PathMatchSpecW", "wstr", $STARGET, "wstr", $STEMPLATE)
						IF @ERROR OR($ARET[0] AND $BEXCLUDE) OR(NOT $ARET[0] AND NOT $BEXCLUDE) THEN
							CONTINUELOOP
						ENDIF
					ENDIF
			ENDSWITCH
			__INC($ADATA, 500)
			$ADATA[$ADATA[0][0]][0] = $STARGET
			$ADATA[$ADATA[0][0]][1] = DLLSTRUCTGETDATA($TFDI, 3)
			$ADATA[$ADATA[0][0]][2] = DLLSTRUCTGETDATA($TFDI, 4)
			$ADATA[$ADATA[0][0]][3] = DLLSTRUCTGETDATA($TFDI, 5)
			$ADATA[$ADATA[0][0]][4] = DLLSTRUCTGETDATA($TFDI, 7)
			$ADATA[$ADATA[0][0]][5] = DLLSTRUCTGETDATA($TFDI, 8)
			$ADATA[$ADATA[0][0]][6] = $IATTRIB
		UNTIL NOT $IOFFSET
		__HEAPFREE($PBUFFER)
		__INC($ADATA, -1)
		RETURN $ADATA
	ENDFUNC
	FUNC _WINAPI_ENUMFILESTREAMS($SFILEPATH)
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[32768]")
		LOCAL $PDATA = DLLSTRUCTGETPTR($TDATA)
		LOCAL $ADATA[101][2] = [[0]]
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $IERROR = 0
		LOCAL $TIOSB = DLLSTRUCTCREATE("ptr;ulong_ptr")
		LOCAL $ARET = DLLCALL("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $HFILE, "struct*", $TIOSB, "ptr", $PDATA, "ulong", 32768, "uint", 22)
		IF @ERROR THEN $IERROR = @ERROR
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HFILE)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		LOCAL $TFSI, $ILENGTH = 0, $IOFFSET = 0
		DO
			$ILENGTH += $IOFFSET
			$TFSI = DLLSTRUCTCREATE("ulong;ulong;int64;int64;wchar[" & (DLLSTRUCTGETDATA(DLLSTRUCTCREATE("ulong", $PDATA + $ILENGTH + 4), 1) / 2) & "]", $PDATA + $ILENGTH)
			__INC($ADATA)
			$ADATA[$ADATA[0][0]][0] = DLLSTRUCTGETDATA($TFSI, 5)
			$ADATA[$ADATA[0][0]][1] = DLLSTRUCTGETDATA($TFSI, 3)
			$IOFFSET = DLLSTRUCTGETDATA($TFSI, 1)
		UNTIL NOT $IOFFSET
		__INC($ADATA, -1)
		RETURN $ADATA
	ENDFUNC
	FUNC _WINAPI_ENUMHARDLINKS($SFILEPATH)
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[32768]")
		LOCAL $PDATA = DLLSTRUCTGETPTR($TDATA)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $IERROR = 0
		LOCAL $TIOSB = DLLSTRUCTCREATE("ptr;ulong_ptr")
		LOCAL $ARET = DLLCALL("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $HFILE, "struct*", $TIOSB, "ptr", $PDATA, "ulong", 32768, "uint", 46)
		IF @ERROR OR $ARET[0] THEN
			$IERROR = @ERROR + 10
			DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HFILE)
			IF $ARET THEN RETURN SETERROR($IERROR, 0, 0)
			IF $ARET[0] THEN RETURN SETERROR(10, $IERROR, 0)
		ENDIF
		LOCAL $ICOUNT = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("ulong;ulong", $PDATA), 2)
		LOCAL $ADATA[$ICOUNT + 1] = [$ICOUNT]
		LOCAL $TFLEI, $HPATH, $SPATH, $ILENGTH = 8
		FOR $I = 1 TO $ICOUNT
			$TFLEI = DLLSTRUCTCREATE("ulong;int64;ulong;wchar[" & (DLLSTRUCTGETDATA(DLLSTRUCTCREATE("ulong", $PDATA + $ILENGTH + 16), 1)) & "]", $PDATA + $ILENGTH)
			$IERROR = 0
			DO
				$HPATH = _WINAPI_OPENFILEBYID($HFILE, DLLSTRUCTGETDATA($TFLEI, 2), 1048704, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
				IF @ERROR THEN
					$IERROR = @ERROR + 100
					EXITLOOP
				ENDIF
				$SPATH = _WINAPI_GETFINALPATHNAMEBYHANDLEEX($HPATH)
				IF @ERROR THEN
					$IERROR = @ERROR + 200
					EXITLOOP
				ENDIF
			UNTIL 1
			IF $HPATH THEN
				DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPATH)
			ENDIF
			IF $IERROR THEN EXITLOOP
			$ADATA[$I] = _WINAPI_PATHAPPEND($SPATH, DLLSTRUCTGETDATA($TFLEI, 4))
			$ILENGTH += DLLSTRUCTGETDATA($TFLEI, 1)
		NEXT
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HFILE)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ADATA
	ENDFUNC
	FUNC _WINAPI_FILEENCRYPTIONSTATUS($SFILEPATH)
		LOCAL $ARET = DLLCALL("advapi32.dll", "bool", "FileEncryptionStatusW", "wstr", $SFILEPATH, "dword*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, -1)
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_FILEEXISTS($SFILEPATH)
		IF NOT FILEEXISTS($SFILEPATH) THEN RETURN 0
		IF _WINAPI_PATHISDIRECTORY($SFILEPATH) THEN RETURN SETEXTENDED(1, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_FILEINUSE($SFILEPATH)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, $GENERIC_READ)
		IF @ERROR THEN
			IF @EXTENDED = 32 THEN RETURN 1
			RETURN SETERROR(@ERROR, @EXTENDED, 0)
		ENDIF
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HFILE)
		RETURN 0
	ENDFUNC
	FUNC _WINAPI_FINDCLOSE($HSEARCH)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "FindClose", "handle", $HSEARCH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FINDCLOSECHANGENOTIFICATION($HCHANGE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "FindCloseChangeNotification", "handle", $HCHANGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FINDFIRSTCHANGENOTIFICATION($SDIRECTORY, $IFLAGS, $BSUBTREE = FALSE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "FindFirstChangeNotificationW", "wstr", $SDIRECTORY, "bool", $BSUBTREE, "dword", $IFLAGS)
		IF @ERROR OR($ARET[0] = PTR(-1)) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FINDFIRSTFILE($SFILEPATH, $TDATA)
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "FindFirstFileW", "wstr", $SFILEPATH, "struct*", $TDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] = PTR(-1) THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FINDFIRSTFILENAME($SFILEPATH, BYREF $SLINK)
		$SLINK = ""
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "FindFirstFileNameW", "wstr", $SFILEPATH, "dword", 0, "dword*", 4096, "wstr", "")
		IF @ERROR OR($ARET[0] = PTR(-1)) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		$SLINK = $ARET[4]
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FINDFIRSTSTREAM($SFILEPATH, $TDATA)
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "FindFirstStreamW", "wstr", $SFILEPATH, "uint", 0, "struct*", $TDATA, "dword", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] = PTR(-1) THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FINDNEXTCHANGENOTIFICATION($HCHANGE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "FindNextChangeNotification", "handle", $HCHANGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FINDNEXTFILE($HSEARCH, $TDATA)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "FindNextFileW", "handle", $HSEARCH, "struct*", $TDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		IF NOT $ARET[0] THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FINDNEXTFILENAME($HSEARCH, BYREF $SLINK)
		$SLINK = ""
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "FindNextFileNameW", "handle", $HSEARCH, "dword*", 4096, "wstr", "")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		IF NOT $ARET[0] THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), 0)
		$SLINK = $ARET[3]
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FINDNEXTSTREAM($HSEARCH, $TDATA)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "FindNextStreamW", "handle", $HSEARCH, "struct*", $TDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		IF NOT $ARET[0] THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FLUSHFILEBUFFERS($HFILE)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "FlushFileBuffers", "handle", $HFILE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_FLUSHVIEWOFFILE($PADDRESS, $IBYTES = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "FlushViewOfFile", "struct*", $PADDRESS, "dword", $IBYTES)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETBINARYTYPE($SFILEPATH)
		LOCAL $ARET = DLLCALL("kernel32.dll", "int", "GetBinaryTypeW", "wstr", $SFILEPATH, "dword*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF NOT $ARET[0] THEN $ARET[2] = 0
		RETURN SETEXTENDED($ARET[2], $ARET[0])
	ENDFUNC
	FUNC _WINAPI_GETCDTYPE($SDRIVE)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TAGSCSI_PASS_THROUGH = "struct;ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16];endstruct"
		LOCAL $TSPT = DLLSTRUCTCREATE($TAGSCSI_PASS_THROUGH & ";byte Hdr[8]")
		LOCAL $TCDB = DLLSTRUCTCREATE("byte;byte;byte[2];byte[3];byte[2];byte;byte[2];byte[4]", DLLSTRUCTGETPTR($TSPT, "Cdb"))
		LOCAL $THDR = DLLSTRUCTCREATE("byte[4];byte;byte;byte[2]", DLLSTRUCTGETPTR($TSPT, "Hdr"))
		LOCAL $ISIZE = DLLSTRUCTGETPTR($TSPT, "Hdr") - DLLSTRUCTGETPTR($TSPT)
		DLLSTRUCTSETDATA($TSPT, "Length", $ISIZE)
		DLLSTRUCTSETDATA($TSPT, "ScsiStatus", 0)
		DLLSTRUCTSETDATA($TSPT, "PathId", 0)
		DLLSTRUCTSETDATA($TSPT, "TargetId", 0)
		DLLSTRUCTSETDATA($TSPT, "Lun", 0)
		DLLSTRUCTSETDATA($TSPT, "CdbLength", 12)
		DLLSTRUCTSETDATA($TSPT, "SenseInfoLength", 0)
		DLLSTRUCTSETDATA($TSPT, "DataIn", 1)
		DLLSTRUCTSETDATA($TSPT, "DataTransferLength", 8)
		DLLSTRUCTSETDATA($TSPT, "TimeOutValue", 86400)
		DLLSTRUCTSETDATA($TSPT, "DataBufferOffset", $ISIZE)
		DLLSTRUCTSETDATA($TSPT, "SenseInfoOffset", 0)
		DLLSTRUCTSETDATA($TCDB, 1, 70)
		DLLSTRUCTSETDATA($TCDB, 2, 0)
		DLLSTRUCTSETDATA($TCDB, 3, 0, 1)
		DLLSTRUCTSETDATA($TCDB, 3, 0, 2)
		DLLSTRUCTSETDATA($TCDB, 5, 0, 1)
		DLLSTRUCTSETDATA($TCDB, 5, 8, 2)
		DLLSTRUCTSETDATA($TCDB, 6, 0)
		DLLSTRUCTSETDATA($TCDB, 7, 0, 1)
		DLLSTRUCTSETDATA($TCDB, 7, 0, 2)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 315396, "struct*", $TSPT, "dword", $ISIZE, "struct*", $TSPT, "dword", DLLSTRUCTGETSIZE($TSPT), "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN BITOR(BITSHIFT(DLLSTRUCTGETDATA($THDR, 4, 1), -8), DLLSTRUCTGETDATA($THDR, 4, 2))
	ENDFUNC
	FUNC _WINAPI_GETCOMPRESSEDFILESIZE($SFILEPATH)
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "GetCompressedFileSizeW", "wstr", $SFILEPATH, "dword*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] = -1 THEN
			LOCAL $ILASTERROR = _WINAPI_GETLASTERROR()
			IF $ARET[2] = 0 THEN RETURN SETERROR(10, $ILASTERROR, 0)
			IF $ILASTERROR THEN RETURN SETERROR(11, $ILASTERROR, 0)
		ENDIF
		RETURN __WINAPI_MAKEQWORD($ARET[0], $ARET[2])
	ENDFUNC
	FUNC _WINAPI_GETCOMPRESSION($SFILEPATH)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 589884, "ptr", 0, "dword", 0, "ushort*", 0, "dword", 2, "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARET[5]
	ENDFUNC
	FUNC _WINAPI_GETCURRENTDIRECTORY()
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "GetCurrentDirectoryW", "dword", 4096, "wstr", "")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN SETEXTENDED($ARET[0], $ARET[2])
	ENDFUNC
	FUNC _WINAPI_GETDISKFREESPACEEX($SDRIVE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetDiskFreeSpaceEx", "str", $SDRIVE, "int64*", 0, "int64*", 0, "int64*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARESULT[3]
		FOR $I = 0 TO 2
			$ARESULT[$I] = $ARET[$I + 2]
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETDRIVEBUSTYPE($SDRIVE)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, -1)
		LOCAL $TAGSTORAGE_PROPERTY_QUERY = "ulong PropertyId;ulong QueryType;byte AdditionalParameters[1]"
		LOCAL $TSPQ = DLLSTRUCTCREATE($TAGSTORAGE_PROPERTY_QUERY)
		LOCAL $TSDD = DLLSTRUCTCREATE("ulong Version;ulong Size;byte DeviceType;byte DeviceTypeModifier;byte RemovableMedia;byte CommandQueueing;ulong VendorIdOffset;ulong ProductIdOffset;ulong ProductRevisionOffset;ulong SerialNumberOffset;ulong BusType;ulong RawPropertiesLength;byte RawDeviceProperties[1]")
		DLLSTRUCTSETDATA($TSPQ, "PropertyId", 0)
		DLLSTRUCTSETDATA($TSPQ, "QueryType", 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 2954240, "struct*", $TSPQ, "dword", DLLSTRUCTGETSIZE($TSPQ), "struct*", $TSDD, "dword", DLLSTRUCTGETSIZE($TSDD), "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN DLLSTRUCTGETDATA($TSDD, "BusType")
	ENDFUNC
	FUNC _WINAPI_GETDRIVEGEOMETRYEX($IDRIVE)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\PhysicalDrive" & $IDRIVE, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TDGEX = DLLSTRUCTCREATE("uint64;dword;dword;dword;dword;uint64")
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 458912, "ptr", 0, "dword", 0, "struct*", $TDGEX, "dword", DLLSTRUCTGETSIZE($TDGEX), "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARESULT[6]
		FOR $I = 0 TO 5
			$ARESULT[$I] = DLLSTRUCTGETDATA($TDGEX, $I + 1)
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETDRIVENUMBER($SDRIVE)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TSDN = DLLSTRUCTCREATE("dword;ulong;ulong")
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 2953344, "ptr", 0, "dword", 0, "struct*", $TSDN, "dword", DLLSTRUCTGETSIZE($TSDN), "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARESULT[3]
		FOR $I = 0 TO 2
			$ARESULT[$I] = DLLSTRUCTGETDATA($TSDN, $I + 1)
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETDRIVETYPE($SDRIVE = "")
		LOCAL $ITYPEOFDRIVE = "str"
		IF NOT STRINGSTRIPWS($SDRIVE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$ITYPEOFDRIVE = "ptr"
			$SDRIVE = 0
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "uint", "GetDriveType", $ITYPEOFDRIVE, $SDRIVE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETFILEATTRIBUTES($SFILEPATH)
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "GetFileAttributesW", "wstr", $SFILEPATH)
		IF @ERROR OR($ARET[0] = 4294967295) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETFILEID($HFILE)
		LOCAL $TIOSB = DLLSTRUCTCREATE("ptr;ulong_ptr")
		LOCAL $ARET = DLLCALL("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $HFILE, "struct*", $TIOSB, "int64*", 0, "ulong", 8, "uint", 6)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_GETFILEINFORMATIONBYHANDLE($HFILE)
		LOCAL $TBHFI = DLLSTRUCTCREATE("dword;dword[2];dword[2];dword[2];dword;dword;dword;dword;dword;dword")
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetFileInformationByHandle", "handle", $HFILE, "struct*", $TBHFI)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARESULT[8]
		$ARESULT[0] = DLLSTRUCTGETDATA($TBHFI, 1)
		FOR $I = 1 TO 3
			IF DLLSTRUCTGETDATA($TBHFI, $I + 1) THEN
				$ARESULT[$I] = DLLSTRUCTCREATE($TAGFILETIME)
				_WINAPI_MOVEMEMORY($ARESULT[$I], DLLSTRUCTGETPTR($TBHFI, $I + 1), 8)
			ELSE
				$ARESULT[$I] = 0
			ENDIF
		NEXT
		$ARESULT[4] = DLLSTRUCTGETDATA($TBHFI, 5)
		$ARESULT[5] = __WINAPI_MAKEQWORD(DLLSTRUCTGETDATA($TBHFI, 7), DLLSTRUCTGETDATA($TBHFI, 6))
		$ARESULT[6] = DLLSTRUCTGETDATA($TBHFI, 8)
		$ARESULT[7] = __WINAPI_MAKEQWORD(DLLSTRUCTGETDATA($TBHFI, 9), DLLSTRUCTGETDATA($TBHFI, 10))
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETFILEINFORMATIONBYHANDLEEX($HFILE)
		LOCAL $TFI = DLLSTRUCTCREATE($TAGFILEINFO)
		LOCAL $TIOSB = DLLSTRUCTCREATE("ptr;ulong_ptr")
		LOCAL $ARET = DLLCALL("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $HFILE, "struct*", $TIOSB, "struct*", $TFI, "ulong", DLLSTRUCTGETSIZE($TFI), "uint", 4)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TFI
	ENDFUNC
	FUNC _WINAPI_GETFILEPOINTEREX($HFILE)
		LOCAL $TIOSB = DLLSTRUCTCREATE("ptr;ulong_ptr")
		LOCAL $ARET = DLLCALL("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $HFILE, "struct*", $TIOSB, "int64*", 0, "ulong", 8, "uint", 14)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_GETFILESIZEEX($HFILE)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "GetFileSizeEx", "handle", $HFILE, "int64*", 0)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARESULT[2]
	ENDFUNC
	FUNC _WINAPI_GETFILESIZEONDISK($SFILEPATH)
		LOCAL $ISIZE = FILEGETSIZE($SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetDiskFreeSpaceW", "wstr", _WINAPI_PATHSTRIPTOROOT(_WINAPI_GETFULLPATHNAME($SFILEPATH)), "dword*", 0, "dword*", 0, "dword*", 0, "dword*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN CEILING($ISIZE / ($ARET[2] * $ARET[3])) * ($ARET[2] * $ARET[3])
	ENDFUNC
	FUNC _WINAPI_GETFILETITLE($SFILEPATH)
		LOCAL $ARET = DLLCALL("comdlg32.dll", "short", "GetFileTitleW", "wstr", $SFILEPATH, "wstr", "", "word", 4096)
		IF @ERROR OR $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_GETFILETYPE($HFILE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "GetFileType", "handle", $HFILE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		LOCAL $ILASTERROR = _WINAPI_GETLASTERROR()
		IF NOT $ARET[0] AND $ILASTERROR THEN RETURN SETERROR(10, $ILASTERROR, -1)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETFINALPATHNAMEBYHANDLE($HFILE)
		LOCAL $TFNI = DLLSTRUCTCREATE("ulong;wchar[4096]")
		LOCAL $TIOSB = DLLSTRUCTCREATE("ptr;ulong_ptr")
		LOCAL $ARET = DLLCALL("ntdll.dll", "long", "ZwQueryInformationFile", "handle", $HFILE, "struct*", $TIOSB, "struct*", $TFNI, "ulong", DLLSTRUCTGETSIZE($TFNI), "uint", 9)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		LOCAL $ILENGTH = DLLSTRUCTGETDATA($TFNI, 1)
		IF NOT $ILENGTH THEN RETURN SETERROR(12, 0, "")
		RETURN DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & ($ILENGTH / 2) & "]", DLLSTRUCTGETPTR($TFNI, 2)), 1)
	ENDFUNC
	FUNC _WINAPI_GETFINALPATHNAMEBYHANDLEEX($HFILE, $IFLAGS = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "GetFinalPathNameByHandleW", "handle", $HFILE, "wstr", "", "dword", 4096, "dword", $IFLAGS)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_GETFULLPATHNAME($SFILEPATH)
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "GetFullPathNameW", "wstr", $SFILEPATH, "dword", 4096, "wstr", "", "ptr", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_GETLOGICALDRIVES()
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "GetLogicalDrives")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETOBJECTID($SFILEPATH)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TFOID = DLLSTRUCTCREATE("byte[16];byte[48]")
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 589980, "ptr", 0, "dword", 0, "struct*", $TFOID, "dword", DLLSTRUCTGETSIZE($TFOID), "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $TGUID = DLLSTRUCTCREATE($TAGGUID)
		_WINAPI_MOVEMEMORY($TGUID, $TFOID, 16)
		RETURN $TGUID
	ENDFUNC
	FUNC _WINAPI_GETOVERLAPPEDRESULT($HFILE, $TOVERLAPPED, BYREF $IBYTES, $BWAIT = FALSE)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "GetOverlappedResult", "handle", $HFILE, "struct*", $TOVERLAPPED, "dword*", 0, "bool", $BWAIT)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		$IBYTES = $ARESULT[3]
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETPETYPE($SFILEPATH)
		LOCAL $TDATA = DLLSTRUCTCREATE("ushort[2]")
		LOCAL $TUINT = DLLSTRUCTCREATE("uint", DLLSTRUCTGETPTR($TDATA))
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $IERROR = 0, $IVAL
		DO
			LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "ReadFile", "handle", $HFILE, "struct*", $TDATA, "dword", 2, "dword*", 0, "ptr", 0)
			IF @ERROR OR(NOT $ARET[0]) OR($ARET[4] <> 2) THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			$IVAL = DLLSTRUCTGETDATA($TDATA, 1, 1)
			IF $IVAL <> 23117 THEN
				$IERROR = 3
				EXITLOOP
			ENDIF
			IF NOT _WINAPI_SETFILEPOINTEREX($HFILE, 60) THEN
				$IERROR = @ERROR + 40
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("kernel32.dll", "bool", "ReadFile", "handle", $HFILE, "struct*", $TDATA, "dword", 4, "dword*", 0, "ptr", 0)
			IF @ERROR OR(NOT $ARET[0]) OR($ARET[4] <> 4) THEN
				$IERROR = @ERROR + 50
				EXITLOOP
			ENDIF
			IF NOT _WINAPI_SETFILEPOINTEREX($HFILE, DLLSTRUCTGETDATA($TUINT, 1)) THEN
				$IERROR = @ERROR + 60
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("kernel32.dll", "bool", "ReadFile", "handle", $HFILE, "struct*", $TDATA, "dword", 4, "dword*", 0, "ptr", 0)
			IF @ERROR OR(NOT $ARET[0]) OR($ARET[4] <> 4) THEN
				$IERROR = @ERROR + 70
				EXITLOOP
			ENDIF
			$IVAL = DLLSTRUCTGETDATA($TUINT, 1)
			IF $IVAL <> 17744 THEN
				$IERROR = 4
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("kernel32.dll", "bool", "ReadFile", "handle", $HFILE, "struct*", $TDATA, "dword", 2, "dword*", 0, "ptr", 0)
			IF @ERROR OR(NOT $ARET[0]) OR($ARET[4] <> 2) THEN
				$IERROR = @ERROR + 80
				EXITLOOP
			ENDIF
			$IVAL = DLLSTRUCTGETDATA($TDATA, 1, 1)
		UNTIL 1
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HFILE)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $IVAL
	ENDFUNC
	FUNC _WINAPI_GETPROFILESDIRECTORY()
		LOCAL $ARET = DLLCALL("userenv.dll", "bool", "GetProfilesDirectoryW", "wstr", "", "dword*", 4096)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_GETTEMPFILENAME($SFILEPATH, $SPREFIX = "")
		LOCAL $ARET = DLLCALL("kernel32.dll", "uint", "GetTempFileNameW", "wstr", $SFILEPATH, "wstr", $SPREFIX, "uint", 0, "wstr", "")
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARET[4]
	ENDFUNC
	FUNC _WINAPI_GETVOLUMEINFORMATION($SROOT = "")
		LOCAL $STYPEOFROOT = "wstr"
		IF NOT STRINGSTRIPWS($SROOT, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFROOT = "ptr"
			$SROOT = 0
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetVolumeInformationW", $STYPEOFROOT, $SROOT, "wstr", "", "dword", 4096, "dword*", 0, "dword*", 0, "dword*", 0, "wstr", "", "dword", 4096)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARESULT[5]
		FOR $I = 0 TO 4
			SWITCH $I
				CASE 0
					$ARESULT[$I] = $ARET[2]
				CASE ELSE
					$ARESULT[$I] = $ARET[$I + 3]
			ENDSWITCH
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETVOLUMEINFORMATIONBYHANDLE($HFILE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetVolumeInformationByHandleW", "handle", $HFILE, "wstr", "", "dword", 4096, "dword*", 0, "dword*", 0, "dword*", 0, "wstr", "", "dword", 4096)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARESULT[5]
		FOR $I = 0 TO 4
			SWITCH $I
				CASE 0
					$ARESULT[$I] = $ARET[2]
				CASE ELSE
					$ARESULT[$I] = $ARET[$I + 3]
			ENDSWITCH
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETVOLUMENAMEFORVOLUMEMOUNTPOINT($SMOUNTEDPATH)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetVolumeNameForVolumeMountPointW", "wstr", $SMOUNTEDPATH, "wstr", "", "dword", 80)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_IOCTL($IDEVICETYPE, $IFUNCTION, $IMETHOD, $IACCESS)
		RETURN BITOR(BITSHIFT($IDEVICETYPE, -16), BITSHIFT($IACCESS, -14), BITSHIFT($IFUNCTION, -2), $IMETHOD)
	ENDFUNC
	FUNC _WINAPI_ISDOOROPEN($SDRIVE)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, FALSE)
		LOCAL $TSPT = DLLSTRUCTCREATE("ushort Length;byte ScsiStatus;byte PathId;byte TargetId;byte Lun;byte CdbLength;byte SenseInfoLength;byte DataIn;byte Alignment[3];ulong DataTransferLength;ulong TimeOutValue;ulong_ptr DataBufferOffset;ulong SenseInfoOffset;byte Cdb[16]" & (@AUTOITX64 ? ";byte[4]" : "") & ";byte Hdr[8]")
		LOCAL $TCDB = DLLSTRUCTCREATE("byte;byte;byte[6];byte[2];byte;byte;byte[4]", DLLSTRUCTGETPTR($TSPT, "Cdb"))
		LOCAL $THDR = DLLSTRUCTCREATE("byte;byte;byte[3];byte;byte[2]", DLLSTRUCTGETPTR($TSPT, "Hdr"))
		LOCAL $ISIZE = DLLSTRUCTGETPTR($TSPT, "Hdr") - DLLSTRUCTGETPTR($TSPT)
		DLLSTRUCTSETDATA($TSPT, "Length", $ISIZE)
		DLLSTRUCTSETDATA($TSPT, "ScsiStatus", 0)
		DLLSTRUCTSETDATA($TSPT, "PathId", 0)
		DLLSTRUCTSETDATA($TSPT, "TargetId", 0)
		DLLSTRUCTSETDATA($TSPT, "Lun", 0)
		DLLSTRUCTSETDATA($TSPT, "CdbLength", 12)
		DLLSTRUCTSETDATA($TSPT, "SenseInfoLength", 0)
		DLLSTRUCTSETDATA($TSPT, "DataIn", 1)
		DLLSTRUCTSETDATA($TSPT, "DataTransferLength", 8)
		DLLSTRUCTSETDATA($TSPT, "TimeOutValue", 86400)
		DLLSTRUCTSETDATA($TSPT, "DataBufferOffset", $ISIZE)
		DLLSTRUCTSETDATA($TSPT, "SenseInfoOffset", 0)
		DLLSTRUCTSETDATA($TCDB, 1, 189)
		DLLSTRUCTSETDATA($TCDB, 2, 0)
		DLLSTRUCTSETDATA($TCDB, 4, 0, 1)
		DLLSTRUCTSETDATA($TCDB, 4, 8, 2)
		DLLSTRUCTSETDATA($TCDB, 5, 0)
		DLLSTRUCTSETDATA($TCDB, 6, 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 315396, "struct*", $TSPT, "dword", $ISIZE, "struct*", $TSPT, "dword", DLLSTRUCTGETSIZE($TSPT), "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN(BITAND(DLLSTRUCTGETDATA($THDR, 2), 16) = 16)
	ENDFUNC
	FUNC _WINAPI_ISPATHSHARED($SFILEPATH)
		IF NOT __DLL("ntshrui.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $ARET = DLLCALL("ntshrui.dll", "bool", "IsPathSharedW", "wstr", _WINAPI_PATHREMOVEBACKSLASH($SFILEPATH), "int", 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ISWRITABLE($SDRIVE)
		DRIVEGETFILESYSTEM($SDRIVE)
		IF @ERROR THEN RETURN SETERROR(40 + @ERROR, _WINAPI_GETLASTERROR(), 0)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 458788, "ptr", 0, "dword", 0, "ptr", 0, "dword", 0, "dword*", 0, "ptr", 0)
		LOCAL CONST $ERROR_WRITE_PROTECT = 19
		IF __CHECKERRORCLOSEHANDLE($ARET, $HFILE, 1) <> 10 AND @EXTENDED = $ERROR_WRITE_PROTECT THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_LOADMEDIA($SDRIVE)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, $GENERIC_READ, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, FALSE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 2967564, "ptr", 0, "dword", 0, "ptr", 0, "dword", 0, "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_LOCKDEVICE($SDRIVE, $BLOCK)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX("\\.\" & $SDRIVE, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, FALSE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 2967556, "boolean*", $BLOCK, "dword", 1, "ptr", 0, "dword", 0, "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_LOCKFILE($HFILE, $IOFFSET, $ILENGTH)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "LockFile", "handle", $HFILE, "dword", _WINAPI_LODWORD($IOFFSET), "dword", _WINAPI_HIDWORD($IOFFSET), "dword", _WINAPI_LODWORD($ILENGTH), "dword", _WINAPI_HIDWORD($ILENGTH))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_MAPVIEWOFFILE($HMAPPING, $IOFFSET = 0, $IBYTES = 0, $IACCESS = 6)
		LOCAL $ARET = DLLCALL("kernel32.dll", "ptr", "MapViewOfFile", "handle", $HMAPPING, "dword", $IACCESS, "dword", _WINAPI_HIDWORD($IOFFSET), "dword", _WINAPI_LODWORD($IOFFSET), "ulong_ptr", $IBYTES)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_MOVEFILEEX($SEXISTINGFILE, $SNEWFILE, $IFLAGS = 0, $PPROGRESSPROC = 0, $PDATA = 0)
		LOCAL $STYPEOFNEWFILE = "wstr"
		IF NOT STRINGSTRIPWS($SNEWFILE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFNEWFILE = "ptr"
			$SNEWFILE = 0
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "MoveFileWithProgressW", "wstr", $SEXISTINGFILE, $STYPEOFNEWFILE, $SNEWFILE, "ptr", $PPROGRESSPROC, "ptr", $PDATA, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_OPENFILEBYID($HFILE, $VID, $IACCESS = 0, $ISHARE = 0, $IFLAGS = 0)
		LOCAL $TFIDD = DLLSTRUCTCREATE("dword;uint;int64;int64")
		LOCAL $HOBJ, $ARET, $ITYPE, $IERROR = 0
		SELECT
			CASE ISSTRING($VID)
				$ARET = DLLCALL("ole32.dll", "long", "CLSIDFromString", "wstr", $VID, "ptr", DLLSTRUCTGETPTR($TFIDD, 3))
				IF @ERROR OR $ARET[0] THEN
					RETURN SETERROR(@ERROR + 30, 0, 0)
				ENDIF
				$ITYPE = 1
			CASE ISDLLSTRUCT($VID)
				IF NOT _WINAPI_MOVEMEMORY(DLLSTRUCTGETPTR($TFIDD, 3), DLLSTRUCTGETPTR($VID), 16) THEN
					RETURN SETERROR(@ERROR + 40, 0, 0)
				ENDIF
				$ITYPE = 1
			CASE ELSE
				DLLSTRUCTSETDATA($TFIDD, 3, $VID)
				$ITYPE = 0
		ENDSELECT
		DLLSTRUCTSETDATA($TFIDD, 1, DLLSTRUCTGETSIZE($TFIDD))
		DLLSTRUCTSETDATA($TFIDD, 2, $ITYPE)
		IF ISSTRING($HFILE) THEN
			$HOBJ = _WINAPI_CREATEFILEEX($HFILE, $OPEN_EXISTING, 0, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
			IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		ELSE
			$HOBJ = $HFILE
		ENDIF
		$ARET = DLLCALL("kernel32.dll", "handle", "OpenFileById", "handle", $HOBJ, "struct*", $TFIDD, "dword", $IACCESS, "dword", $ISHARE, "ptr", 0, "dword", $IFLAGS)
		IF @ERROR OR($ARET[0] = PTR(-1)) THEN $IERROR = @ERROR + 10
		IF ISSTRING($HFILE) THEN
			DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HOBJ)
		ENDIF
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_OPENFILEMAPPING($SNAME, $IACCESS = 6, $BINHERIT = FALSE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "OpenFileMappingW", "dword", $IACCESS, "bool", $BINHERIT, "wstr", $SNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PATHISDIRECTORYEMPTY($SFILEPATH)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "bool", "PathIsDirectoryEmptyW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_QUERYDOSDEVICE($SDEVICE)
		LOCAL $STYPEOFDEVICE = "wstr"
		IF NOT STRINGSTRIPWS($SDEVICE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFDEVICE = "ptr"
			$SDEVICE = 0
		ENDIF
		LOCAL $TDATA = DLLSTRUCTCREATE("wchar[16384]")
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "QueryDosDeviceW", $STYPEOFDEVICE, $SDEVICE, "struct*", $TDATA, "dword", 16384)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		LOCAL $ARESULT = _WINAPI_STRUCTTOARRAY($TDATA)
		IF ISSTRING($SDEVICE) THEN
			$ARESULT = $ARESULT[1]
		ENDIF
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_READDIRECTORYCHANGES($HDIRECTORY, $IFILTER, $PBUFFER, $ILENGTH, $BSUBTREE = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "ReadDirectoryChangesW", "handle", $HDIRECTORY, "struct*", $PBUFFER, "dword", $ILENGTH - MOD($ILENGTH, 4), "bool", $BSUBTREE, "dword", $IFILTER, "dword*", 0, "ptr", 0, "ptr", 0)
		IF @ERROR OR NOT $ARET[0] OR(NOT $ARET[6]) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		$PBUFFER = $ARET[2]
		LOCAL $ADATA[101][2] = [[0]]
		LOCAL $TFNI, $IBUFFER = 0, $IOFFSET = 0
		DO
			$IBUFFER += $IOFFSET
			$TFNI = DLLSTRUCTCREATE("dword NextEntryOffset;dword Action;dword FileNameLength;wchar FileName[" & (DLLSTRUCTGETDATA(DLLSTRUCTCREATE("dword FileNameLength", $PBUFFER + $IBUFFER + 8), 1) / 2) & "]", $PBUFFER + $IBUFFER)
			__INC($ADATA)
			$ADATA[$ADATA[0][0]][0] = DLLSTRUCTGETDATA($TFNI, "FileName")
			$ADATA[$ADATA[0][0]][1] = DLLSTRUCTGETDATA($TFNI, "Action")
			$IOFFSET = DLLSTRUCTGETDATA($TFNI, "NextEntryOffset")
		UNTIL NOT $IOFFSET
		__INC($ADATA, -1)
		RETURN $ADATA
	ENDFUNC
	FUNC _WINAPI_REMOVEDIRECTORY($SDIRPATH)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "RemoveDirectoryW", "wstr", $SDIRPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_REOPENFILE($HFILE, $IACCESS, $ISHARE, $IFLAGS = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "ReOpenFile", "handle", $HFILE, "dword", $IACCESS, "dword", $ISHARE, "dword", $IFLAGS)
		IF @ERROR OR($ARET[0] = PTR(-1)) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_REPLACEFILE($SREPLACEDFILE, $SREPLACEMENTFILE, $SBACKUPFILE = "", $IFLAGS = 0)
		LOCAL $STYPEOFBACKUPFILE = "wstr"
		IF NOT STRINGSTRIPWS($SBACKUPFILE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFBACKUPFILE = "ptr"
			$SBACKUPFILE = 0
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "ReplaceFileW", "wstr", $SREPLACEDFILE, "wstr", $SREPLACEMENTFILE, $STYPEOFBACKUPFILE, $SBACKUPFILE, "dword", $IFLAGS, "ptr", 0, "ptr", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SEARCHPATH($SFILEPATH, $SSEARCHPATH = "")
		LOCAL $STYPEOFPATH = "wstr"
		IF NOT STRINGSTRIPWS($SSEARCHPATH, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFPATH = "ptr"
			$SSEARCHPATH = 0
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "SearchPathW", $STYPEOFPATH, $SSEARCHPATH, "wstr", $SFILEPATH, "ptr", 0, "dword", 4096, "wstr", "", "ptr", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARET[5]
	ENDFUNC
	FUNC _WINAPI_SETCOMPRESSION($SFILEPATH, $ICOMPRESSION)
		LOCAL $HFILE = _WINAPI_CREATEFILEEX($SFILEPATH, $OPEN_EXISTING, $GENERIC_READWRITE, $FILE_SHARE_READWRITE, $FILE_FLAG_BACKUP_SEMANTICS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "DeviceIoControl", "handle", $HFILE, "dword", 639040, "ushort*", $ICOMPRESSION, "dword", 2, "ptr", 0, "dword", 0, "dword*", 0, "ptr", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HFILE) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SETCURRENTDIRECTORY($SDIR)
		LOCAL $ARET = DLLCALL("kernel32.dll", "int", "SetCurrentDirectoryW", "wstr", $SDIR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETENDOFFILE($HFILE)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "SetEndOfFile", "handle", $HFILE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETFILEATTRIBUTES($SFILEPATH, $IATTRIBUTES)
		LOCAL $ARET = DLLCALL("kernel32.dll", "int", "SetFileAttributesW", "wstr", $SFILEPATH, "dword", $IATTRIBUTES)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETFILEINFORMATIONBYHANDLEEX($HFILE, $TFILEINFO)
		LOCAL $ARET = DLLCALL("ntdll.dll", "long", "ZwSetInformationFile", "handle", $HFILE, "struct*", $TFILEINFO, "struct*", $TFILEINFO, "ulong", DLLSTRUCTGETSIZE($TFILEINFO), "uint", 4)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SETFILEPOINTER($HFILE, $IPOS, $IMETHOD = 0)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "INT", "SetFilePointer", "handle", $HFILE, "long", $IPOS, "ptr", 0, "long", $IMETHOD)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETFILEPOINTEREX($HFILE, $IPOS, $IMETHOD = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "SetFilePointerEx", "handle", $HFILE, "int64", $IPOS, "int64*", 0, "dword", $IMETHOD)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETFILESHORTNAME($HFILE, $SSHORTNAME)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "SetFileShortNameW", "handle", $HFILE, "wstr", $SSHORTNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETFILEVALIDDATA($HFILE, $ILENGTH)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "SetFileValidData", "handle", $HFILE, "int64", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETSEARCHPATHMODE($IFLAGS)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "SetSearchPathMode", "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETVOLUMEMOUNTPOINT($SFILEPATH, $SGUID)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "SetVolumeMountPointW", "wstr", $SFILEPATH, "wstr", $SGUID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SFCISFILEPROTECTED($SFILEPATH)
		IF NOT __DLL("sfc.dll") THEN RETURN SETERROR(103, 0, FALSE)
		LOCAL $ARET = DLLCALL("sfc.dll", "bool", "SfcIsFileProtected", "handle", 0, "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_UNLOCKFILE($HFILE, $IOFFSET, $ILENGTH)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "UnlockFile", "handle", $HFILE, "dword", _WINAPI_LODWORD($IOFFSET), "dword", _WINAPI_HIDWORD($IOFFSET), "dword", _WINAPI_LODWORD($ILENGTH), "dword", _WINAPI_HIDWORD($ILENGTH))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_UNMAPVIEWOFFILE($PADDRESS)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "UnmapViewOfFile", "ptr", $PADDRESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_WOW64ENABLEWOW64FSREDIRECTION($BENABLE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "boolean", "Wow64EnableWow64FsRedirection", "boolean", $BENABLE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __WINAPI_MAKEQWORD($ILODWORD, $IHIDWORD)
		LOCAL $TINT64 = DLLSTRUCTCREATE("uint64")
		LOCAL $TDWORDS = DLLSTRUCTCREATE("dword;dword", DLLSTRUCTGETPTR($TINT64))
		DLLSTRUCTSETDATA($TDWORDS, 1, $ILODWORD)
		DLLSTRUCTSETDATA($TDWORDS, 2, $IHIDWORD)
		RETURN DLLSTRUCTGETDATA($TINT64, 1)
	ENDFUNC
#EndRegion Internal Functions
GLOBAL CONST $HGDI_ERROR = PTR(-1)
GLOBAL CONST $INVALID_HANDLE_VALUE = PTR(-1)
GLOBAL CONST $CLR_INVALID = -1
GLOBAL CONST $MB_PRECOMPOSED = 1
GLOBAL CONST $MB_COMPOSITE = 2
GLOBAL CONST $MB_USEGLYPHCHARS = 4
GLOBAL CONST $ULW_ALPHA = 2
GLOBAL CONST $ULW_COLORKEY = 1
GLOBAL CONST $ULW_OPAQUE = 4
GLOBAL CONST $ULW_EX_NORESIZE = 8
GLOBAL CONST $WH_CALLWNDPROC = 4
GLOBAL CONST $WH_CALLWNDPROCRET = 12
GLOBAL CONST $WH_CBT = 5
GLOBAL CONST $WH_DEBUG = 9
GLOBAL CONST $WH_FOREGROUNDIDLE = 11
GLOBAL CONST $WH_GETMESSAGE = 3
GLOBAL CONST $WH_JOURNALPLAYBACK = 1
GLOBAL CONST $WH_JOURNALRECORD = 0
GLOBAL CONST $WH_KEYBOARD = 2
GLOBAL CONST $WH_KEYBOARD_LL = 13
GLOBAL CONST $WH_MOUSE = 7
GLOBAL CONST $WH_MOUSE_LL = 14
GLOBAL CONST $WH_MSGFILTER = -1
GLOBAL CONST $WH_SHELL = 10
GLOBAL CONST $WH_SYSMSGFILTER = 6
GLOBAL CONST $WPF_ASYNCWINDOWPLACEMENT = 4
GLOBAL CONST $WPF_RESTORETOMAXIMIZED = 2
GLOBAL CONST $WPF_SETMINPOSITION = 1
GLOBAL CONST $KF_EXTENDED = 256
GLOBAL CONST $KF_ALTDOWN = 8192
GLOBAL CONST $KF_UP = 32768
GLOBAL CONST $LLKHF_EXTENDED = BITSHIFT($KF_EXTENDED, 8)
GLOBAL CONST $LLKHF_INJECTED = 16
GLOBAL CONST $LLKHF_ALTDOWN = BITSHIFT($KF_ALTDOWN, 8)
GLOBAL CONST $LLKHF_UP = BITSHIFT($KF_UP, 8)
GLOBAL CONST $OFN_ALLOWMULTISELECT = 512
GLOBAL CONST $OFN_CREATEPROMPT = 8192
GLOBAL CONST $OFN_DONTADDTORECENT = 33554432
GLOBAL CONST $OFN_ENABLEHOOK = 32
GLOBAL CONST $OFN_ENABLEINCLUDENOTIFY = 4194304
GLOBAL CONST $OFN_ENABLESIZING = 8388608
GLOBAL CONST $OFN_ENABLETEMPLATE = 64
GLOBAL CONST $OFN_ENABLETEMPLATEHANDLE = 128
GLOBAL CONST $OFN_EXPLORER = 524288
GLOBAL CONST $OFN_EXTENSIONDIFFERENT = 1024
GLOBAL CONST $OFN_FILEMUSTEXIST = 4096
GLOBAL CONST $OFN_FORCESHOWHIDDEN = 268435456
GLOBAL CONST $OFN_HIDEREADONLY = 4
GLOBAL CONST $OFN_LONGNAMES = 2097152
GLOBAL CONST $OFN_NOCHANGEDIR = 8
GLOBAL CONST $OFN_NODEREFERENCELINKS = 1048576
GLOBAL CONST $OFN_NOLONGNAMES = 262144
GLOBAL CONST $OFN_NONETWORKBUTTON = 131072
GLOBAL CONST $OFN_NOREADONLYRETURN = 32768
GLOBAL CONST $OFN_NOTESTFILECREATE = 65536
GLOBAL CONST $OFN_NOVALIDATE = 256
GLOBAL CONST $OFN_OVERWRITEPROMPT = 2
GLOBAL CONST $OFN_PATHMUSTEXIST = 2048
GLOBAL CONST $OFN_READONLY = 1
GLOBAL CONST $OFN_SHAREAWARE = 16384
GLOBAL CONST $OFN_SHOWHELP = 16
GLOBAL CONST $OFN_EX_NOPLACESBAR = 1
GLOBAL CONST $STD_CUT = 0
GLOBAL CONST $STD_COPY = 1
GLOBAL CONST $STD_PASTE = 2
GLOBAL CONST $STD_UNDO = 3
GLOBAL CONST $STD_REDOW = 4
GLOBAL CONST $STD_DELETE = 5
GLOBAL CONST $STD_FILENEW = 6
GLOBAL CONST $STD_FILEOPEN = 7
GLOBAL CONST $STD_FILESAVE = 8
GLOBAL CONST $STD_PRINTPRE = 9
GLOBAL CONST $STD_PROPERTIES = 10
GLOBAL CONST $STD_HELP = 11
GLOBAL CONST $STD_FIND = 12
GLOBAL CONST $STD_REPLACE = 13
GLOBAL CONST $STD_PRINT = 14
GLOBAL CONST $KB_SENDSPECIAL = 0
GLOBAL CONST $KB_SENDRAW = 1
GLOBAL CONST $KB_CAPSOFF = 0
GLOBAL CONST $KB_CAPSON = 1
GLOBAL CONST $S_OK = 0
GLOBAL CONST $E_ABORT = -2147467260
GLOBAL CONST $E_ACCESSDENIED = -2147024891
GLOBAL CONST $E_FAIL = -2147467259
GLOBAL CONST $E_HANDLE = -2147024890
GLOBAL CONST $E_INVALIDARG = -2147024809
GLOBAL CONST $E_NOINTERFACE = -2147467262
GLOBAL CONST $E_NOTIMPL = -2147467263
GLOBAL CONST $E_OUTOFMEMORY = -2147024882
GLOBAL CONST $E_POINTER = -2147467261
GLOBAL CONST $E_UNEXPECTED = -2147418113
GLOBAL CONST $__DLG_WM_USER = 1024
GLOBAL CONST $BIF_BROWSEFILEJUNCTIONS = 65536
GLOBAL CONST $BIF_BROWSEFORCOMPUTER = 4096
GLOBAL CONST $BIF_BROWSEFORPRINTER = 8192
GLOBAL CONST $BIF_BROWSEINCLUDEFILES = 16384
GLOBAL CONST $BIF_BROWSEINCLUDEURLS = 128
GLOBAL CONST $BIF_DONTGOBELOWDOMAIN = 2
GLOBAL CONST $BIF_EDITBOX = 16
GLOBAL CONST $BIF_NEWDIALOGSTYLE = 64
GLOBAL CONST $BIF_NONEWFOLDERBUTTON = 512
GLOBAL CONST $BIF_NOTRANSLATETARGETS = 1024
GLOBAL CONST $BIF_RETURNFSANCESTORS = 8
GLOBAL CONST $BIF_RETURNONLYFSDIRS = 1
GLOBAL CONST $BIF_SHAREABLE = 32768
GLOBAL CONST $BIF_STATUSTEXT = 4
GLOBAL CONST $BIF_USENEWUI = BITOR($BIF_EDITBOX, $BIF_NEWDIALOGSTYLE)
GLOBAL CONST $BIF_UAHINT = 256
GLOBAL CONST $BIF_VALIDATE = 32
GLOBAL CONST $BFFM_INITIALIZED = 1
GLOBAL CONST $BFFM_IUNKNOWN = 5
GLOBAL CONST $BFFM_SELCHANGED = 2
GLOBAL CONST $BFFM_VALIDATEFAILED = 4
GLOBAL CONST $BFFM_SETSTATUSTEXTA = $__DLG_WM_USER + 100
GLOBAL CONST $BFFM_ENABLEOK = $__DLG_WM_USER + 101
GLOBAL CONST $BFFM_SETSELECTIONA = $__DLG_WM_USER + 102
GLOBAL CONST $BFFM_SETSELECTIONW = $__DLG_WM_USER + 103
GLOBAL CONST $BFFM_SETSTATUSTEXTW = $__DLG_WM_USER + 104
GLOBAL CONST $BFFM_SETOKTEXT = $__DLG_WM_USER + 105
GLOBAL CONST $BFFM_SETEXPANDED = $__DLG_WM_USER + 106
GLOBAL CONST $CDERR_DIALOGFAILURE = 65535
GLOBAL CONST $CDERR_FINDRESFAILURE = 6
GLOBAL CONST $CDERR_INITIALIZATION = 2
GLOBAL CONST $CDERR_LOADRESFAILURE = 7
GLOBAL CONST $CDERR_LOADSTRFAILURE = 5
GLOBAL CONST $CDERR_LOCKRESFAILURE = 8
GLOBAL CONST $CDERR_MEMALLOCFAILURE = 9
GLOBAL CONST $CDERR_MEMLOCKFAILURE = 10
GLOBAL CONST $CDERR_NOHINSTANCE = 4
GLOBAL CONST $CDERR_NOHOOK = 11
GLOBAL CONST $CDERR_NOTEMPLATE = 3
GLOBAL CONST $CDERR_REGISTERMSGFAIL = 12
GLOBAL CONST $CDERR_STRUCTSIZE = 1
GLOBAL CONST $PDERR_CREATEICFAILURE = 4106
GLOBAL CONST $PDERR_DEFAULTDIFFERENT = 4108
GLOBAL CONST $PDERR_DNDMMISMATCH = 4105
GLOBAL CONST $PDERR_GETDEVMODEFAIL = 4101
GLOBAL CONST $PDERR_INITFAILURE = 4102
GLOBAL CONST $PDERR_LOADDRVFAILURE = 4100
GLOBAL CONST $PDERR_NODEFAULTPRN = 4104
GLOBAL CONST $PDERR_NODEVICES = 4103
GLOBAL CONST $PDERR_PARSEFAILURE = 4098
GLOBAL CONST $PDERR_PRINTERNOTFOUND = 4107
GLOBAL CONST $PDERR_RETDEFFAILURE = 4099
GLOBAL CONST $PDERR_SETUPFAILURE = 4097
GLOBAL CONST $CFERR_MAXLESSTHANMIN = 8194
GLOBAL CONST $CFERR_NOFONTS = 8193
GLOBAL CONST $FNERR_BUFFERTOOSMALL = 12291
GLOBAL CONST $FNERR_INVALIDFILENAME = 12290
GLOBAL CONST $FNERR_SUBCLASSFAILURE = 12289
GLOBAL CONST $FRERR_BUFFERLENGTHZERO = 16385
GLOBAL CONST $FR_DIALOGTERM = 64
GLOBAL CONST $FR_DOWN = 1
GLOBAL CONST $FR_ENABLEHOOK = 256
GLOBAL CONST $FR_ENABLETEMPLATE = 512
GLOBAL CONST $FR_ENABLETEMPLATEHANDLE = 8192
GLOBAL CONST $FR_FINDNEXT = 8
GLOBAL CONST $FR_HIDEUPDOWN = 16384
GLOBAL CONST $FR_HIDEMATCHCASE = 32768
GLOBAL CONST $FR_HIDEWHOLEWORD = 65536
GLOBAL CONST $FR_MATCHCASE = 4
GLOBAL CONST $FR_NOMATCHCASE = 2048
GLOBAL CONST $FR_NOUPDOWN = 1024
GLOBAL CONST $FR_NOWHOLEWORD = 4096
GLOBAL CONST $FR_REPLACE = 16
GLOBAL CONST $FR_REPLACEALL = 32
GLOBAL CONST $FR_SHOWHELP = 128
GLOBAL CONST $FR_WHOLEWORD = 2
GLOBAL CONST $SHFMT_ID_DEFAULT = 65535
GLOBAL CONST $SHFMT_OPT_FULL = 0
GLOBAL CONST $SHFMT_OPT_QUICKFORMAT = 1
GLOBAL CONST $SHFMT_OPT_SYSONLY = 2
GLOBAL CONST $SHFMT_ERROR = -1
GLOBAL CONST $SHFMT_CANCEL = -2
GLOBAL CONST $SHFMT_NOFORMAT = -3
GLOBAL CONST $CDM_FIRST = $__DLG_WM_USER + 100
GLOBAL CONST $CDM_GETSPEC = $CDM_FIRST
GLOBAL CONST $CDM_GETFILEPATH = $CDM_FIRST + 1
GLOBAL CONST $CDM_GETFOLDERPATH = $CDM_FIRST + 2
GLOBAL CONST $CDM_GETFOLDERIDLIST = $CDM_FIRST + 3
GLOBAL CONST $CDM_SETCONTROLTEXT = $CDM_FIRST + 4
GLOBAL CONST $CDM_HIDECONTROL = $CDM_FIRST + 5
GLOBAL CONST $CDM_SETDEFEXT = $CDM_FIRST + 6
GLOBAL CONST $CDM_LAST = $__DLG_WM_USER + 200
GLOBAL CONST $CDN_FIRST = -601
GLOBAL CONST $CDN_INITDONE = $CDN_FIRST
GLOBAL CONST $CDN_SELCHANGE = $CDN_FIRST - 1
GLOBAL CONST $CDN_FOLDERCHANGE = $CDN_FIRST - 2
GLOBAL CONST $CDN_SHAREVIOLATION = $CDN_FIRST - 3
GLOBAL CONST $CDN_HELP = $CDN_FIRST - 4
GLOBAL CONST $CDN_FILEOK = $CDN_FIRST - 5
GLOBAL CONST $CDN_TYPECHANGE = $CDN_FIRST - 6
GLOBAL CONST $CDN_INCLUDEITEM = $CDN_FIRST - 7
GLOBAL CONST $CDN_LAST = -699
GLOBAL CONST $PSD_DEFAULTMINMARGINS = 0
GLOBAL CONST $PSD_DISABLEMARGINS = 16
GLOBAL CONST $PSD_DISABLEORIENTATION = 256
GLOBAL CONST $PSD_DISABLEPAGEPAINTING = 524288
GLOBAL CONST $PSD_DISABLEPAPER = 512
GLOBAL CONST $PSD_DISABLEPRINTER = 32
GLOBAL CONST $PSD_ENABLEPAGEPAINTHOOK = 262144
GLOBAL CONST $PSD_ENABLEPAGESETUPHOOK = 8192
GLOBAL CONST $PSD_ENABLEPAGESETUPTEMPLATE = 32768
GLOBAL CONST $PSD_ENABLEPAGESETUPTEMPLATEHANDLE = 131072
GLOBAL CONST $PSD_INHUNDREDTHSOFMILLIMETERS = 8
GLOBAL CONST $PSD_INTHOUSANDTHSOFINCHES = 4
GLOBAL CONST $PSD_MARGINS = 2
GLOBAL CONST $PSD_MINMARGINS = 1
GLOBAL CONST $PSD_NONETWORKBUTTON = 2097152
GLOBAL CONST $PSD_NOWARNING = 128
GLOBAL CONST $PSD_RETURNDEFAULT = 1024
GLOBAL CONST $PSD_SHOWHELP = 2048
GLOBAL CONST $WM_PSD_PAGESETUPDLG = $__DLG_WM_USER
GLOBAL CONST $WM_PSD_FULLPAGERECT = $__DLG_WM_USER + 1
GLOBAL CONST $WM_PSD_MINMARGINRECT = $__DLG_WM_USER + 2
GLOBAL CONST $WM_PSD_MARGINRECT = $__DLG_WM_USER + 3
GLOBAL CONST $WM_PSD_GREEKTEXTRECT = $__DLG_WM_USER + 4
GLOBAL CONST $WM_PSD_ENVSTAMPRECT = $__DLG_WM_USER + 5
GLOBAL CONST $WM_PSD_YAFULLPAGERECT = $__DLG_WM_USER + 6
GLOBAL CONST $PD_ALLPAGES = 0
GLOBAL CONST $PD_COLLATE = 16
GLOBAL CONST $PD_CURRENTPAGE = 4194304
GLOBAL CONST $PD_DISABLEPRINTTOFILE = 524288
GLOBAL CONST $PD_ENABLEPRINTHOOK = 4096
GLOBAL CONST $PD_ENABLEPRINTTEMPLATE = 16384
GLOBAL CONST $PD_ENABLEPRINTTEMPLATEHANDLE = 65536
GLOBAL CONST $PD_ENABLESETUPHOOK = 8192
GLOBAL CONST $PD_ENABLESETUPTEMPLATE = 32768
GLOBAL CONST $PD_ENABLESETUPTEMPLATEHANDLE = 131072
GLOBAL CONST $PD_EXCLUSIONFLAGS = 16777216
GLOBAL CONST $PD_HIDEPRINTTOFILE = 1048576
GLOBAL CONST $PD_NOCURRENTPAGE = 8388608
GLOBAL CONST $PD_NONETWORKBUTTON = 2097152
GLOBAL CONST $PD_NOPAGENUMS = 8
GLOBAL CONST $PD_NOSELECTION = 4
GLOBAL CONST $PD_NOWARNING = 128
GLOBAL CONST $PD_PAGENUMS = 2
GLOBAL CONST $PD_PRINTSETUP = 64
GLOBAL CONST $PD_PRINTTOFILE = 32
GLOBAL CONST $PD_RETURNDC = 256
GLOBAL CONST $PD_RETURNDEFAULT = 1024
GLOBAL CONST $PD_RETURNIC = 512
GLOBAL CONST $PD_SELECTION = 1
GLOBAL CONST $PD_SHOWHELP = 2048
GLOBAL CONST $PD_USEDEVMODECOPIES = 262144
GLOBAL CONST $PD_USEDEVMODECOPIESANDCOLLATE = $PD_USEDEVMODECOPIES
GLOBAL CONST $PD_USELARGETEMPLATE = 268435456
GLOBAL CONST $PD_RESULT_APPLY = 2
GLOBAL CONST $PD_RESULT_CANCEL = 0
GLOBAL CONST $PD_RESULT_PRINT = 1
GLOBAL CONST $EWX_LOGOFF = 0
GLOBAL CONST $EWX_POWEROFF = 8
GLOBAL CONST $EWX_REBOOT = 2
GLOBAL CONST $EWX_SHUTDOWN = 1
GLOBAL CONST $EWX_FORCE = 4
GLOBAL CONST $EWX_FORCEIFHUNG = 16
GLOBAL CONST $OAIF_ALLOW_REGISTRATION = 1
GLOBAL CONST $OAIF_REGISTER_EXT = 2
GLOBAL CONST $OAIF_EXEC = 4
GLOBAL CONST $OAIF_FORCE_REGISTRATION = 8
GLOBAL CONST $OAIF_HIDE_REGISTRATION = 32
GLOBAL CONST $OAIF_URL_PROTOCOL = 64
GLOBAL CONST $CREDUI_FLAGS_ALWAYS_SHOW_UI = 128
GLOBAL CONST $CREDUI_FLAGS_COMPLETE_USERNAME = 2048
GLOBAL CONST $CREDUI_FLAGS_DO_NOT_PERSIST = 2
GLOBAL CONST $CREDUI_FLAGS_EXCLUDE_CERTIFICATES = 8
GLOBAL CONST $CREDUI_FLAGS_EXPECT_CONFIRMATION = 131072
GLOBAL CONST $CREDUI_FLAGS_GENERIC_CREDENTIALS = 262144
GLOBAL CONST $CREDUI_FLAGS_INCORRECT_PASSWORD = 1
GLOBAL CONST $CREDUI_FLAGS_KEEP_USERNAME = 1048576
GLOBAL CONST $CREDUI_FLAGS_PASSWORD_ONLY_OK = 512
GLOBAL CONST $CREDUI_FLAGS_PERSIST = 4096
GLOBAL CONST $CREDUI_FLAGS_REQUEST_ADMINISTRATOR = 4
GLOBAL CONST $CREDUI_FLAGS_REQUIRE_CERTIFICATE = 16
GLOBAL CONST $CREDUI_FLAGS_REQUIRE_SMARTCARD = 256
GLOBAL CONST $CREDUI_FLAGS_SERVER_CREDENTIAL = 16384
GLOBAL CONST $CREDUI_FLAGS_SHOW_SAVE_CHECK_BOX = 64
GLOBAL CONST $CREDUI_FLAGS_USERNAME_TARGET_CREDENTIALS = 524288
GLOBAL CONST $CREDUI_FLAGS_VALIDATE_USERNAME = 1024
GLOBAL CONST $CREDUIWIN_AUTHPACKAGE_ONLY = 16
GLOBAL CONST $CREDUIWIN_CHECKBOX = 2
GLOBAL CONST $CREDUIWIN_ENUMERATE_ADMINS = 256
GLOBAL CONST $CREDUIWIN_ENUMERATE_CURRENT_USER = 512
GLOBAL CONST $CREDUIWIN_GENERIC = 1
GLOBAL CONST $CREDUIWIN_IN_CRED_ONLY = 32
GLOBAL CONST $CREDUIWIN_SECURE_PROMPT = 4096
GLOBAL CONST $CREDUIWIN_PACK_32_WOW = 268435456
GLOBAL CONST $CREDUIWIN_PREPROMPTING = 8192
GLOBAL CONST $DLLVER_PLATFORM_WINDOWS = 1
GLOBAL CONST $DLLVER_PLATFORM_NT = 2
GLOBAL CONST $SHCNE_ALLEVENTS = 2147483647
GLOBAL CONST $SHCNE_ASSOCCHANGED = 134217728
GLOBAL CONST $SHCNE_ATTRIBUTES = 2048
GLOBAL CONST $SHCNE_CREATE = 2
GLOBAL CONST $SHCNE_DELETE = 4
GLOBAL CONST $SHCNE_DRIVEADD = 256
GLOBAL CONST $SHCNE_DRIVEADDGUI = 65536
GLOBAL CONST $SHCNE_DRIVEREMOVED = 128
GLOBAL CONST $SHCNE_EXTENDED_EVENT = 67108864
GLOBAL CONST $SHCNE_FREESPACE = 262144
GLOBAL CONST $SHCNE_MEDIAINSERTED = 32
GLOBAL CONST $SHCNE_MEDIAREMOVED = 64
GLOBAL CONST $SHCNE_MKDIR = 8
GLOBAL CONST $SHCNE_NETSHARE = 512
GLOBAL CONST $SHCNE_NETUNSHARE = 1024
GLOBAL CONST $SHCNE_RENAMEFOLDER = 131072
GLOBAL CONST $SHCNE_RENAMEITEM = 1
GLOBAL CONST $SHCNE_RMDIR = 16
GLOBAL CONST $SHCNE_SERVERDISCONNECT = 16384
GLOBAL CONST $SHCNE_UPDATEDIR = 4096
GLOBAL CONST $SHCNE_UPDATEIMAGE = 32768
GLOBAL CONST $SHCNE_UPDATEITEM = 8192
GLOBAL CONST $SHCNE_DISKEVENTS = 145439
GLOBAL CONST $SHCNE_GLOBALEVENTS = 201687520
GLOBAL CONST $SHCNE_INTERRUPT = -2147483648
GLOBAL CONST $SHCNF_DWORD = 3
GLOBAL CONST $SHCNF_IDLIST = 0
GLOBAL CONST $SHCNF_PATH = 1
GLOBAL CONST $SHCNF_PRINTER = 2
GLOBAL CONST $SHCNF_FLUSH = 4096
GLOBAL CONST $SHCNF_FLUSHNOWAIT = 8192
GLOBAL CONST $SHCNF_NOTIFYRECURSIVE = 65536
GLOBAL CONST $SHCNRF_INTERRUPTLEVEL = 1
GLOBAL CONST $SHCNRF_SHELLLEVEL = 2
GLOBAL CONST $SHCNRF_RECURSIVEINTERRUPT = 4096
GLOBAL CONST $SHCNRF_NEWDELIVERY = 32768
GLOBAL CONST $SHERB_NOCONFIRMATION = 1
GLOBAL CONST $SHERB_NOPROGRESSUI = 2
GLOBAL CONST $SHERB_NOSOUND = 4
GLOBAL CONST $SHERB_NO_UI = BITOR($SHERB_NOCONFIRMATION, $SHERB_NOPROGRESSUI, $SHERB_NOSOUND)
GLOBAL CONST $SEE_MASK_DEFAULT = 0
GLOBAL CONST $SEE_MASK_CLASSNAME = 1
GLOBAL CONST $SEE_MASK_CLASSKEY = 3
GLOBAL CONST $SEE_MASK_IDLIST = 4
GLOBAL CONST $SEE_MASK_INVOKEIDLIST = 12
GLOBAL CONST $SEE_MASK_ICON = 16
GLOBAL CONST $SEE_MASK_HOTKEY = 32
GLOBAL CONST $SEE_MASK_NOCLOSEPROCESS = 64
GLOBAL CONST $SEE_MASK_CONNECTNETDRV = 128
GLOBAL CONST $SEE_MASK_NOASYNC = 256
GLOBAL CONST $SEE_MASK_FLAG_DDEWAIT = $SEE_MASK_NOASYNC
GLOBAL CONST $SEE_MASK_DOENVSUBST = 512
GLOBAL CONST $SEE_MASK_FLAG_NO_UI = 1024
GLOBAL CONST $SEE_MASK_UNICODE = 16384
GLOBAL CONST $SEE_MASK_NO_CONSOLE = 32768
GLOBAL CONST $SEE_MASK_ASYNCOK = 1048576
GLOBAL CONST $SEE_MASK_NOQUERYCLASSSTORE = 16777216
GLOBAL CONST $SEE_MASK_HMONITOR = 2097152
GLOBAL CONST $SEE_MASK_NOZONECHECKS = 8388608
GLOBAL CONST $SEE_MASK_WAITFORINPUTIDLE = 33554432
GLOBAL CONST $SEE_MASK_FLAG_LOG_USAGE = 67108864
GLOBAL CONST $SE_ERR_ACCESSDENIED = 5
GLOBAL CONST $SE_ERR_ASSOCINCOMPLETE = 27
GLOBAL CONST $SE_ERR_DDEBUSY = 30
GLOBAL CONST $SE_ERR_DDEFAIL = 29
GLOBAL CONST $SE_ERR_DDETIMEOUT = 28
GLOBAL CONST $SE_ERR_DLLNOTFOUND = 32
GLOBAL CONST $SE_ERR_FNF = 2
GLOBAL CONST $SE_ERR_NOASSOC = 31
GLOBAL CONST $SE_ERR_OOM = 8
GLOBAL CONST $SE_ERR_PNF = 3
GLOBAL CONST $SE_ERR_SHARE = 26
GLOBAL CONST $FO_COPY = 2
GLOBAL CONST $FO_DELETE = 3
GLOBAL CONST $FO_MOVE = 1
GLOBAL CONST $FO_RENAME = 4
GLOBAL CONST $FOF_ALLOWUNDO = 64
GLOBAL CONST $FOF_CONFIRMMOUSE = 2
GLOBAL CONST $FOF_FILESONLY = 128
GLOBAL CONST $FOF_MULTIDESTFILES = 1
GLOBAL CONST $FOF_NOCONFIRMATION = 16
GLOBAL CONST $FOF_NOCONFIRMMKDIR = 512
GLOBAL CONST $FOF_NO_CONNECTED_ELEMENTS = 8192
GLOBAL CONST $FOF_NOCOPYSECURITYATTRIBS = 2048
GLOBAL CONST $FOF_NOERRORUI = 1024
GLOBAL CONST $FOF_NORECURSEREPARSE = 32768
GLOBAL CONST $FOF_NORECURSION = 4096
GLOBAL CONST $FOF_RENAMEONCOLLISION = 8
GLOBAL CONST $FOF_SILENT = 4
GLOBAL CONST $FOF_SIMPLEPROGRESS = 256
GLOBAL CONST $FOF_WANTMAPPINGHANDLE = 32
GLOBAL CONST $FOF_WANTNUKEWARNING = 16384
GLOBAL CONST $FOF_NO_UI = BITOR($FOF_NOCONFIRMATION, $FOF_NOCONFIRMMKDIR, $FOF_NOERRORUI, $FOF_SILENT)
GLOBAL CONST $SHGFI_ADDOVERLAYS = 32
GLOBAL CONST $SHGFI_ATTR_SPECIFIED = 131072
GLOBAL CONST $SHGFI_ATTRIBUTES = 2048
GLOBAL CONST $SHGFI_DISPLAYNAME = 512
GLOBAL CONST $SHGFI_EXETYPE = 8192
GLOBAL CONST $SHGFI_ICON = 256
GLOBAL CONST $SHGFI_ICONLOCATION = 4096
GLOBAL CONST $SHGFI_LARGEICON = 0
GLOBAL CONST $SHGFI_LINKOVERLAY = 32768
GLOBAL CONST $SHGFI_OPENICON = 2
GLOBAL CONST $SHGFI_OVERLAYINDEX = 64
GLOBAL CONST $SHGFI_PIDL = 8
GLOBAL CONST $SHGFI_SELECTED = 65536
GLOBAL CONST $SHGFI_SHELLICONSIZE = 4
GLOBAL CONST $SHGFI_SMALLICON = 1
GLOBAL CONST $SHGFI_SYSICONINDEX = 16384
GLOBAL CONST $SHGFI_TYPENAME = 1024
GLOBAL CONST $SHGFI_USEFILEATTRIBUTES = 16
GLOBAL CONST $SFGAO_CANCOPY = 1
GLOBAL CONST $SFGAO_CANMOVE = 2
GLOBAL CONST $SFGAO_CANLINK = 4
GLOBAL CONST $SFGAO_STORAGE = 8
GLOBAL CONST $SFGAO_CANRENAME = 16
GLOBAL CONST $SFGAO_CANDELETE = 32
GLOBAL CONST $SFGAO_HASPROPSHEET = 64
GLOBAL CONST $SFGAO_DROPTARGET = 256
GLOBAL CONST $SFGAO_CAPABILITYMASK = BITOR($SFGAO_CANCOPY, $SFGAO_CANMOVE, $SFGAO_CANLINK, $SFGAO_CANRENAME, $SFGAO_CANDELETE, $SFGAO_HASPROPSHEET, $SFGAO_DROPTARGET)
GLOBAL CONST $SFGAO_SYSTEM = 4096
GLOBAL CONST $SFGAO_ENCRYPTED = 8192
GLOBAL CONST $SFGAO_ISSLOW = 16384
GLOBAL CONST $SFGAO_GHOSTED = 32768
GLOBAL CONST $SFGAO_LINK = 65536
GLOBAL CONST $SFGAO_SHARE = 131072
GLOBAL CONST $SFGAO_READONLY = 262144
GLOBAL CONST $SFGAO_HIDDEN = 524288
GLOBAL CONST $SFGAO_DISPLAYATTRMASK = BITOR($SFGAO_ISSLOW, $SFGAO_GHOSTED, $SFGAO_LINK, $SFGAO_SHARE, $SFGAO_READONLY, $SFGAO_HIDDEN)
GLOBAL CONST $SFGAO_NONENUMERATED = 1048576
GLOBAL CONST $SFGAO_NEWCONTENT = 2097152
GLOBAL CONST $SFGAO_STREAM = 4194304
GLOBAL CONST $SFGAO_STORAGEANCESTOR = 8388608
GLOBAL CONST $SFGAO_VALIDATE = 16777216
GLOBAL CONST $SFGAO_REMOVABLE = 33554432
GLOBAL CONST $SFGAO_COMPRESSED = 67108864
GLOBAL CONST $SFGAO_BROWSABLE = 134217728
GLOBAL CONST $SFGAO_FILESYSANCESTOR = 268435456
GLOBAL CONST $SFGAO_FOLDER = 536870912
GLOBAL CONST $SFGAO_FILESYSTEM = 1073741824
GLOBAL CONST $SFGAO_STORAGECAPMASK = BITOR($SFGAO_STORAGE, $SFGAO_LINK, $SFGAO_READONLY, $SFGAO_STREAM, $SFGAO_STORAGEANCESTOR, $SFGAO_FILESYSANCESTOR, $SFGAO_FOLDER, $SFGAO_FILESYSTEM)
GLOBAL CONST $SFGAO_HASSUBFOLDER = -2147483648
GLOBAL CONST $SFGAO_CONTENTSMASK = $SFGAO_HASSUBFOLDER
GLOBAL CONST $SFGAO_PKEYSFGAOMASK = BITOR($SFGAO_ISSLOW, $SFGAO_READONLY, $SFGAO_HASSUBFOLDER, $SFGAO_VALIDATE)
GLOBAL CONST $IDO_SHGIOI_DEFAULT = 268435452
GLOBAL CONST $IDO_SHGIOI_LINK = 268435454
GLOBAL CONST $IDO_SHGIOI_SHARE = 268435455
GLOBAL CONST $IDO_SHGIOI_SLOWFILE = 268435453
GLOBAL CONST $FCSM_VIEWID = 1
GLOBAL CONST $FCSM_WEBVIEWTEMPLATE = 2
GLOBAL CONST $FCSM_INFOTIP = 4
GLOBAL CONST $FCSM_CLSID = 8
GLOBAL CONST $FCSM_ICONFILE = 16
GLOBAL CONST $FCSM_LOGO = 32
GLOBAL CONST $FCSM_FLAGS = 64
GLOBAL CONST $FCS_READ = 1
GLOBAL CONST $FCS_FORCEWRITE = 2
GLOBAL CONST $FCS_WRITE = BITOR($FCS_READ, $FCS_FORCEWRITE)
GLOBAL CONST $SSF_AUTOCHECKSELECT = 8388608
GLOBAL CONST $SSF_DESKTOPHTML = 512
GLOBAL CONST $SSF_DONTPRETTYPATH = 2048
GLOBAL CONST $SSF_DOUBLECLICKINWEBVIEW = 128
GLOBAL CONST $SSF_HIDEICONS = 16384
GLOBAL CONST $SSF_ICONSONLY = 16777216
GLOBAL CONST $SSF_MAPNETDRVBUTTON = 4096
GLOBAL CONST $SSF_NOCONFIRMRECYCLE = 32768
GLOBAL CONST $SSF_NONETCRAWLING = 1048576
GLOBAL CONST $SSF_SEPPROCESS = 524288
GLOBAL CONST $SSF_SHOWALLOBJECTS = 1
GLOBAL CONST $SSF_SHOWCOMPCOLOR = 8
GLOBAL CONST $SSF_SHOWEXTENSIONS = 2
GLOBAL CONST $SSF_SHOWINFOTIP = 8192
GLOBAL CONST $SSF_SHOWSUPERHIDDEN = 262144
GLOBAL CONST $SSF_SHOWSYSFILES = 32
GLOBAL CONST $SSF_SHOWTYPEOVERLAY = 33554432
GLOBAL CONST $SSF_STARTPANELON = 2097152
GLOBAL CONST $SSF_WIN95CLASSIC = 1024
GLOBAL CONST $SSF_WEBVIEW = 131072
GLOBAL CONST $CSIDL_ADMINTOOLS = 48
GLOBAL CONST $CSIDL_ALTSTARTUP = 29
GLOBAL CONST $CSIDL_APPDATA = 26
GLOBAL CONST $CSIDL_BITBUCKET = 10
GLOBAL CONST $CSIDL_CDBURN_AREA = 59
GLOBAL CONST $CSIDL_COMMON_ADMINTOOLS = 47
GLOBAL CONST $CSIDL_COMMON_ALTSTARTUP = 30
GLOBAL CONST $CSIDL_COMMON_APPDATA = 35
GLOBAL CONST $CSIDL_COMMON_DESKTOPDIRECTORY = 25
GLOBAL CONST $CSIDL_COMMON_DOCUMENTS = 46
GLOBAL CONST $CSIDL_COMMON_FAVORITES = 31
GLOBAL CONST $CSIDL_COMMON_MUSIC = 53
GLOBAL CONST $CSIDL_COMMON_PICTURES = 54
GLOBAL CONST $CSIDL_COMMON_PROGRAMS = 23
GLOBAL CONST $CSIDL_COMMON_STARTMENU = 22
GLOBAL CONST $CSIDL_COMMON_STARTUP = 24
GLOBAL CONST $CSIDL_COMMON_TEMPLATES = 45
GLOBAL CONST $CSIDL_COMMON_VIDEO = 55
GLOBAL CONST $CSIDL_COMPUTERSNEARME = 61
GLOBAL CONST $CSIDL_CONNECTIONS = 49
GLOBAL CONST $CSIDL_CONTROLS = 3
GLOBAL CONST $CSIDL_COOKIES = 33
GLOBAL CONST $CSIDL_DESKTOP = 0
GLOBAL CONST $CSIDL_DESKTOPDIRECTORY = 16
GLOBAL CONST $CSIDL_DRIVES = 17
GLOBAL CONST $CSIDL_FAVORITES = 6
GLOBAL CONST $CSIDL_FONTS = 20
GLOBAL CONST $CSIDL_INTERNET_CACHE = 32
GLOBAL CONST $CSIDL_HISTORY = 34
GLOBAL CONST $CSIDL_LOCAL_APPDATA = 28
GLOBAL CONST $CSIDL_MYMUSIC = 13
GLOBAL CONST $CSIDL_MYPICTURES = 39
GLOBAL CONST $CSIDL_MYVIDEO = 14
GLOBAL CONST $CSIDL_NETHOOD = 19
GLOBAL CONST $CSIDL_PERSONAL = 5
GLOBAL CONST $CSIDL_PRINTERS = 4
GLOBAL CONST $CSIDL_PRINTHOOD = 27
GLOBAL CONST $CSIDL_PROFILE = 40
GLOBAL CONST $CSIDL_PROGRAM_FILES = 38
GLOBAL CONST $CSIDL_PROGRAM_FILES_COMMON = 43
GLOBAL CONST $CSIDL_PROGRAM_FILES_COMMONX86 = 44
GLOBAL CONST $CSIDL_PROGRAM_FILESX86 = 42
GLOBAL CONST $CSIDL_PROGRAMS = 2
GLOBAL CONST $CSIDL_RECENT = 8
GLOBAL CONST $CSIDL_SENDTO = 9
GLOBAL CONST $CSIDL_STARTMENU = 11
GLOBAL CONST $CSIDL_STARTUP = 7
GLOBAL CONST $CSIDL_SYSTEM = 37
GLOBAL CONST $CSIDL_SYSTEMX86 = 41
GLOBAL CONST $CSIDL_TEMPLATES = 21
GLOBAL CONST $CSIDL_WINDOWS = 36
GLOBAL CONST $SIID_DOCNOASSOC = 0
GLOBAL CONST $SIID_DOCASSOC = 1
GLOBAL CONST $SIID_APPLICATION = 2
GLOBAL CONST $SIID_FOLDER = 3
GLOBAL CONST $SIID_FOLDEROPEN = 4
GLOBAL CONST $SIID_DRIVE525 = 5
GLOBAL CONST $SIID_DRIVE35 = 6
GLOBAL CONST $SIID_DRIVEREMOVE = 7
GLOBAL CONST $SIID_DRIVEFIXED = 8
GLOBAL CONST $SIID_DRIVENET = 9
GLOBAL CONST $SIID_DRIVENETDISABLED = 10
GLOBAL CONST $SIID_DRIVECD = 11
GLOBAL CONST $SIID_DRIVERAM = 12
GLOBAL CONST $SIID_WORLD = 13
GLOBAL CONST $SIID_SERVER = 15
GLOBAL CONST $SIID_PRINTER = 16
GLOBAL CONST $SIID_MYNETWORK = 17
GLOBAL CONST $SIID_FIND = 22
GLOBAL CONST $SIID_HELP = 23
GLOBAL CONST $SIID_SHARE = 28
GLOBAL CONST $SIID_LINK = 29
GLOBAL CONST $SIID_SLOWFILE = 30
GLOBAL CONST $SIID_RECYCLER = 31
GLOBAL CONST $SIID_RECYCLERFULL = 32
GLOBAL CONST $SIID_MEDIACDAUDIO = 40
GLOBAL CONST $SIID_LOCK = 47
GLOBAL CONST $SIID_AUTOLIST = 49
GLOBAL CONST $SIID_PRINTERNET = 50
GLOBAL CONST $SIID_SERVERSHARE = 51
GLOBAL CONST $SIID_PRINTERFAX = 52
GLOBAL CONST $SIID_PRINTERFAXNET = 53
GLOBAL CONST $SIID_PRINTERFILE = 54
GLOBAL CONST $SIID_STACK = 55
GLOBAL CONST $SIID_MEDIASVCD = 56
GLOBAL CONST $SIID_STUFFEDFOLDER = 57
GLOBAL CONST $SIID_DRIVEUNKNOWN = 58
GLOBAL CONST $SIID_DRIVEDVD = 59
GLOBAL CONST $SIID_MEDIADVD = 60
GLOBAL CONST $SIID_MEDIADVDRAM = 61
GLOBAL CONST $SIID_MEDIADVDRW = 62
GLOBAL CONST $SIID_MEDIADVDR = 63
GLOBAL CONST $SIID_MEDIADVDROM = 64
GLOBAL CONST $SIID_MEDIACDAUDIOPLUS = 65
GLOBAL CONST $SIID_MEDIACDRW = 66
GLOBAL CONST $SIID_MEDIACDR = 67
GLOBAL CONST $SIID_MEDIACDBURN = 68
GLOBAL CONST $SIID_MEDIABLANKCD = 69
GLOBAL CONST $SIID_MEDIACDROM = 70
GLOBAL CONST $SIID_AUDIOFILES = 71
GLOBAL CONST $SIID_IMAGEFILES = 72
GLOBAL CONST $SIID_VIDEOFILES = 73
GLOBAL CONST $SIID_MIXEDFILES = 74
GLOBAL CONST $SIID_FOLDERBACK = 75
GLOBAL CONST $SIID_FOLDERFRONT = 76
GLOBAL CONST $SIID_SHIELD = 77
GLOBAL CONST $SIID_WARNING = 78
GLOBAL CONST $SIID_INFO = 79
GLOBAL CONST $SIID_ERROR = 80
GLOBAL CONST $SIID_KEY = 81
GLOBAL CONST $SIID_SOFTWARE = 82
GLOBAL CONST $SIID_RENAME = 83
GLOBAL CONST $SIID_DELETE = 84
GLOBAL CONST $SIID_MEDIAAUDIODVD = 85
GLOBAL CONST $SIID_MEDIAMOVIEDVD = 86
GLOBAL CONST $SIID_MEDIAENHANCEDCD = 87
GLOBAL CONST $SIID_MEDIAENHANCEDDVD = 88
GLOBAL CONST $SIID_MEDIAHDDVD = 89
GLOBAL CONST $SIID_MEDIABLURAY = 90
GLOBAL CONST $SIID_MEDIAVCD = 91
GLOBAL CONST $SIID_MEDIADVDPLUSR = 92
GLOBAL CONST $SIID_MEDIADVDPLUSRW = 93
GLOBAL CONST $SIID_DESKTOPPC = 94
GLOBAL CONST $SIID_MOBILEPC = 95
GLOBAL CONST $SIID_USERS = 96
GLOBAL CONST $SIID_MEDIASMARTMEDIA = 97
GLOBAL CONST $SIID_MEDIACOMPACTFLASH = 98
GLOBAL CONST $SIID_DEVICECELLPHONE = 99
GLOBAL CONST $SIID_DEVICECAMERA = 100
GLOBAL CONST $SIID_DEVICEVIDEOCAMERA = 101
GLOBAL CONST $SIID_DEVICEAUDIOPLAYER = 102
GLOBAL CONST $SIID_NETWORKCONNECT = 103
GLOBAL CONST $SIID_INTERNET = 104
GLOBAL CONST $SIID_ZIPFILE = 105
GLOBAL CONST $SIID_SETTINGS = 106
GLOBAL CONST $SIID_DRIVEHDDVD = 132
GLOBAL CONST $SIID_DRIVEBD = 133
GLOBAL CONST $SIID_MEDIAHDDVDROM = 134
GLOBAL CONST $SIID_MEDIAHDDVDR = 135
GLOBAL CONST $SIID_MEDIAHDDVDRAM = 136
GLOBAL CONST $SIID_MEDIABDROM = 137
GLOBAL CONST $SIID_MEDIABDR = 138
GLOBAL CONST $SIID_MEDIABDRE = 139
GLOBAL CONST $SIID_CLUSTEREDDRIVE = 140
GLOBAL CONST $SIID_MAX_ICONS = 174
GLOBAL CONST $SHGSI_ICONLOCATION = 0
GLOBAL CONST $SHGSI_ICON = $SHGFI_ICON
GLOBAL CONST $SHGSI_SYSICONINDEX = $SHGFI_SYSICONINDEX
GLOBAL CONST $SHGSI_LINKOVERLAY = $SHGFI_LINKOVERLAY
GLOBAL CONST $SHGSI_SELECTED = $SHGFI_SELECTED
GLOBAL CONST $SHGSI_LARGEICON = $SHGFI_LARGEICON
GLOBAL CONST $SHGSI_SMALLICON = $SHGFI_SMALLICON
GLOBAL CONST $SHGSI_SHELLICONSIZE = $SHGFI_SHELLICONSIZE
GLOBAL CONST $NIM_ADD = 0
GLOBAL CONST $NIM_MODIFY = 1
GLOBAL CONST $NIM_DELETE = 2
GLOBAL CONST $NIM_SETFOCUS = 3
GLOBAL CONST $NIM_SETVERSION = 4
GLOBAL CONST $NIF_MESSAGE = 1
GLOBAL CONST $NIF_ICON = 2
GLOBAL CONST $NIF_TIP = 4
GLOBAL CONST $NIF_STATE = 8
GLOBAL CONST $NIF_INFO = 16
GLOBAL CONST $NIF_GUID = 32
GLOBAL CONST $NIF_REALTIME = 64
GLOBAL CONST $NIF_SHOWTIP = 128
GLOBAL CONST $NIS_HIDDEN = 1
GLOBAL CONST $NIS_SHAREDICON = 2
GLOBAL CONST $NIIF_NONE = 0
GLOBAL CONST $NIIF_INFO = 1
GLOBAL CONST $NIIF_WARNING = 2
GLOBAL CONST $NIIF_ERROR = 3
GLOBAL CONST $NIIF_USER = 4
GLOBAL CONST $NIIF_NOSOUND = 16
GLOBAL CONST $NIIF_LARGE_ICON = 16
GLOBAL CONST $NIIF_RESPECT_QUIET_TIME = 128
GLOBAL CONST $NIIF_ICON_MASK = 15
GLOBAL CONST $SHOP_PRINTERNAME = 1
GLOBAL CONST $SHOP_FILEPATH = 2
GLOBAL CONST $SHOP_VOLUMEGUID = 4
GLOBAL CONST $OFASI_EDIT = 1
GLOBAL CONST $OFASI_OPENDESKTOP = 2
GLOBAL CONST $QUNS_NOT_PRESENT = 1
GLOBAL CONST $QUNS_BUSY = 2
GLOBAL CONST $QUNS_RUNNING_D3D_FULL_SCREEN = 3
GLOBAL CONST $QUNS_PRESENTATION_MODE = 4
GLOBAL CONST $QUNS_ACCEPTS_NOTIFICATIONS = 5
GLOBAL CONST $QUNS_QUIET_TIME = 6
GLOBAL CONST $REST_NORUN = 1
GLOBAL CONST $REST_NOCLOSE = 2
GLOBAL CONST $REST_NOSAVESET = 3
GLOBAL CONST $REST_NOFILEMENU = 4
GLOBAL CONST $REST_NOSETFOLDERS = 5
GLOBAL CONST $REST_NOSETTASKBAR = 6
GLOBAL CONST $REST_NODESKTOP = 7
GLOBAL CONST $REST_NOFIND = 8
GLOBAL CONST $REST_NODRIVES = 9
GLOBAL CONST $REST_NODRIVEAUTORUN = 10
GLOBAL CONST $REST_NODRIVETYPEAUTORUN = 11
GLOBAL CONST $REST_NONETHOOD = 12
GLOBAL CONST $REST_STARTBANNER = 13
GLOBAL CONST $REST_RESTRICTRUN = 14
GLOBAL CONST $REST_NOPRINTERTABS = 15
GLOBAL CONST $REST_NOPRINTERDELETE = 16
GLOBAL CONST $REST_NOPRINTERADD = 17
GLOBAL CONST $REST_NOSTARTMENUSUBFOLDERS = 18
GLOBAL CONST $REST_MYDOCSONNET = 19
GLOBAL CONST $REST_NOEXITTODOS = 20
GLOBAL CONST $REST_ENFORCESHELLEXTSECURITY = 21
GLOBAL CONST $REST_LINKRESOLVEIGNORELINKINFO = 22
GLOBAL CONST $REST_NOCOMMONGROUPS = 23
GLOBAL CONST $REST_SEPARATEDESKTOPPROCESS = 24
GLOBAL CONST $REST_NOWEB = 25
GLOBAL CONST $REST_NOTRAYCONTEXTMENU = 26
GLOBAL CONST $REST_NOVIEWCONTEXTMENU = 27
GLOBAL CONST $REST_NONETCONNECTDISCONNECT = 28
GLOBAL CONST $REST_STARTMENULOGOFF = 29
GLOBAL CONST $REST_NOSETTINGSASSIST = 30
GLOBAL CONST $REST_NOINTERNETICON = 31
GLOBAL CONST $REST_NORECENTDOCSHISTORY = 32
GLOBAL CONST $REST_NORECENTDOCSMENU = 33
GLOBAL CONST $REST_NOACTIVEDESKTOP = 34
GLOBAL CONST $REST_NOACTIVEDESKTOPCHANGES = 35
GLOBAL CONST $REST_NOFAVORITESMENU = 36
GLOBAL CONST $REST_CLEARRECENTDOCSONEXIT = 37
GLOBAL CONST $REST_CLASSICSHELL = 38
GLOBAL CONST $REST_NOCUSTOMIZEWEBVIEW = 39
GLOBAL CONST $REST_NOHTMLWALLPAPER = 40
GLOBAL CONST $REST_NOCHANGINGWALLPAPER = 41
GLOBAL CONST $REST_NODESKCOMP = 42
GLOBAL CONST $REST_NOADDDESKCOMP = 43
GLOBAL CONST $REST_NODELDESKCOMP = 44
GLOBAL CONST $REST_NOCLOSEDESKCOMP = 45
GLOBAL CONST $REST_NOCLOSE_DRAGDROPBAND = 46
GLOBAL CONST $REST_NOMOVINGBAND = 47
GLOBAL CONST $REST_NOEDITDESKCOMP = 48
GLOBAL CONST $REST_NORESOLVESEARCH = 49
GLOBAL CONST $REST_NORESOLVETRACK = 50
GLOBAL CONST $REST_FORCECOPYACLWITHFILE = 51
GLOBAL CONST $REST_NOLOGO3CHANNELNOTIFY = 52
GLOBAL CONST $REST_NOFORGETSOFTWAREUPDATE = 53
GLOBAL CONST $REST_NOSETACTIVEDESKTOP = 54
GLOBAL CONST $REST_NOUPDATEWINDOWS = 55
GLOBAL CONST $REST_NOCHANGESTARMENU = 56
GLOBAL CONST $REST_NOFOLDEROPTIONS = 57
GLOBAL CONST $REST_HASFINDCOMPUTERS = 58
GLOBAL CONST $REST_INTELLIMENUS = 59
GLOBAL CONST $REST_RUNDLGMEMCHECKBOX = 60
GLOBAL CONST $REST_ARP_SHOWPOSTSETUP = 61
GLOBAL CONST $REST_NOCSC = 62
GLOBAL CONST $REST_NOCONTROLPANEL = 63
GLOBAL CONST $REST_ENUMWORKGROUP = 64
GLOBAL CONST $REST_ARP_NOARP = 65
GLOBAL CONST $REST_ARP_NOREMOVEPAGE = 66
GLOBAL CONST $REST_ARP_NOADDPAGE = 67
GLOBAL CONST $REST_ARP_NOWINSETUPPAGE = 68
GLOBAL CONST $REST_GREYMSIADS = 69
GLOBAL CONST $REST_NOCHANGEMAPPEDDRIVELABEL = 70
GLOBAL CONST $REST_NOCHANGEMAPPEDDRIVECOMMENT = 71
GLOBAL CONST $REST_MAXRECENTDOCS = 72
GLOBAL CONST $REST_NONETWORKCONNECTIONS = 73
GLOBAL CONST $REST_FORCESTARTMENULOGOFF = 74
GLOBAL CONST $REST_NOWEBVIEW = 75
GLOBAL CONST $REST_NOCUSTOMIZETHISFOLDER = 76
GLOBAL CONST $REST_NOENCRYPTION = 77
GLOBAL CONST $REST_DONTSHOWSUPERHIDDEN = 78
GLOBAL CONST $REST_NOSHELLSEARCHBUTTON = 79
GLOBAL CONST $REST_NOHARDWARETAB = 80
GLOBAL CONST $REST_NORUNASINSTALLPROMPT = 81
GLOBAL CONST $REST_PROMPTRUNASINSTALLNETPATH = 82
GLOBAL CONST $REST_NOMANAGEMYCOMPUTERVERB = 83
GLOBAL CONST $REST_NORECENTDOCSNETHOOD = 84
GLOBAL CONST $REST_DISALLOWRUN = 85
GLOBAL CONST $REST_NOWELCOMESCREEN = 86
GLOBAL CONST $REST_RESTRICTCPL = 87
GLOBAL CONST $REST_DISALLOWCPL = 88
GLOBAL CONST $REST_NOSMBALLOONTIP = 89
GLOBAL CONST $REST_NOSMHELP = 90
GLOBAL CONST $REST_NOWINKEYS = 91
GLOBAL CONST $REST_NOENCRYPTONMOVE = 92
GLOBAL CONST $REST_NOLOCALMACHINERUN = 93
GLOBAL CONST $REST_NOCURRENTUSERRUN = 94
GLOBAL CONST $REST_NOLOCALMACHINERUNONCE = 95
GLOBAL CONST $REST_NOCURRENTUSERRUNONCE = 96
GLOBAL CONST $REST_FORCEACTIVEDESKTOPON = 97
GLOBAL CONST $REST_NOCOMPUTERSNEARME = 98
GLOBAL CONST $REST_NOVIEWONDRIVE = 99
GLOBAL CONST $REST_NONETCRAWL = 100
GLOBAL CONST $REST_NOSHAREDDOCUMENTS = 101
GLOBAL CONST $REST_NOSMMYDOCS = 102
GLOBAL CONST $REST_NOSMMYPICS = 103
GLOBAL CONST $REST_ALLOWBITBUCKDRIVES = 104
GLOBAL CONST $REST_NONLEGACYSHELLMODE = 105
GLOBAL CONST $REST_NOCONTROLPANELBARRICADE = 106
GLOBAL CONST $REST_NOSTARTPAGE = 107
GLOBAL CONST $REST_NOAUTOTRAYNOTIFY = 108
GLOBAL CONST $REST_NOTASKGROUPING = 109
GLOBAL CONST $REST_NOCDBURNING = 110
GLOBAL CONST $REST_MYCOMPNOPROP = 111
GLOBAL CONST $REST_MYDOCSNOPROP = 112
GLOBAL CONST $REST_NOSTARTPANEL = 113
GLOBAL CONST $REST_NODISPLAYAPPEARANCEPAGE = 114
GLOBAL CONST $REST_NOTHEMESTAB = 115
GLOBAL CONST $REST_NOVISUALSTYLECHOICE = 116
GLOBAL CONST $REST_NOSIZECHOICE = 117
GLOBAL CONST $REST_NOCOLORCHOICE = 118
GLOBAL CONST $REST_SETVISUALSTYLE = 119
GLOBAL CONST $REST_STARTRUNNOHOMEPATH = 120
GLOBAL CONST $REST_NOUSERNAMEINSTARTPANEL = 121
GLOBAL CONST $REST_NOMYCOMPUTERICON = 122
GLOBAL CONST $REST_NOSMNETWORKPLACES = 123
GLOBAL CONST $REST_NOSMPINNEDLIST = 124
GLOBAL CONST $REST_NOSMMYMUSIC = 125
GLOBAL CONST $REST_NOSMEJECTPC = 126
GLOBAL CONST $REST_NOSMMOREPROGRAMS = 127
GLOBAL CONST $REST_NOSMMFUPROGRAMS = 128
GLOBAL CONST $REST_NOTRAYITEMSDISPLAY = 129
GLOBAL CONST $REST_NOTOOLBARSONTASKBAR = 130
GLOBAL CONST $REST_NOSMCONFIGUREPROGRAMS = 131
GLOBAL CONST $REST_HIDECLOCK = 132
GLOBAL CONST $REST_NOLOWDISKSPACECHECKS = 133
GLOBAL CONST $REST_NOENTIRENETWORK = 134
GLOBAL CONST $REST_NODESKTOPCLEANUP = 135
GLOBAL CONST $REST_BITBUCKNUKEONDELETE = 136
GLOBAL CONST $REST_BITBUCKCONFIRMDELETE = 137
GLOBAL CONST $REST_BITBUCKNOPROP = 138
GLOBAL CONST $REST_NODISPBACKGROUND = 139
GLOBAL CONST $REST_NODISPSCREENSAVEPG = 140
GLOBAL CONST $REST_NODISPSETTINGSPG = 141
GLOBAL CONST $REST_NODISPSCREENSAVEPREVIEW = 142
GLOBAL CONST $REST_NODISPLAYCPL = 143
GLOBAL CONST $REST_HIDERUNASVERB = 144
GLOBAL CONST $REST_NOTHUMBNAILCACHE = 145
GLOBAL CONST $REST_NOSTRCMPLOGICAL = 146
GLOBAL CONST $REST_NOPUBLISHWIZARD = 147
GLOBAL CONST $REST_NOONLINEPRINTSWIZARD = 148
GLOBAL CONST $REST_NOWEBSERVICES = 149
GLOBAL CONST $REST_ALLOWUNHASHEDWEBVIEW = 150
GLOBAL CONST $REST_ALLOWLEGACYWEBVIEW = 151
GLOBAL CONST $REST_REVERTWEBVIEWSECURITY = 152
GLOBAL CONST $REST_INHERITCONSOLEHANDLES = 153
GLOBAL CONST $REST_SORTMAXITEMCOUNT = 154
GLOBAL CONST $REST_NOREMOTERECURSIVEEVENTS = 155
GLOBAL CONST $REST_NOREMOTECHANGENOTIFY = 156
GLOBAL CONST $REST_NOSIMPLENETIDLIST = 157
GLOBAL CONST $REST_NOENUMENTIRENETWORK = 158
GLOBAL CONST $REST_NODETAILSTHUMBNAILONNETWORK = 159
GLOBAL CONST $REST_NOINTERNETOPENWITH = 160
GLOBAL CONST $REST_ALLOWLEGACYLMZBEHAVIOR = 161
GLOBAL CONST $REST_DONTRETRYBADNETNAME = 162
GLOBAL CONST $REST_ALLOWFILECLSIDJUNCTIONS = 163
GLOBAL CONST $REST_NOUPNPINSTALL = 164
GLOBAL CONST $REST_ARP_DONTGROUPPATCHES = 165
GLOBAL CONST $REST_ARP_NOCHOOSEPROGRAMSPAGE = 166
GLOBAL CONST $REST_NODISCONNECT = 167
GLOBAL CONST $REST_NOSECURITY = 168
GLOBAL CONST $REST_NOFILEASSOCIATE = 169
GLOBAL CONST $REST_ALLOWCOMMENTTOGGLE = 170
GLOBAL CONST $REST_USEDESKTOPINICACHE = 171
GLOBAL CONST $GIL_DONTCACHE = 16
GLOBAL CONST $GIL_NOTFILENAME = 8
GLOBAL CONST $GIL_PERCLASS = 4
GLOBAL CONST $GIL_PERINSTANCE = 2
GLOBAL CONST $GIL_SIMULATEDOC = 1
GLOBAL CONST $GIL_SHIELD = 512
GLOBAL CONST $GIL_FORCENOSHIELD = 1024
GLOBAL CONST $FOLDERID_ADDNEWPROGRAMS = "{DE61D971-5EBC-4F02-A3A9-6C82895E5C04}"
GLOBAL CONST $FOLDERID_ADMINTOOLS = "{724EF170-A42D-4FEF-9F26-B60E846FBA4F}"
GLOBAL CONST $FOLDERID_APPUPDATES = "{A305CE99-F527-492B-8B1A-7E76FA98D6E4}"
GLOBAL CONST $FOLDERID_CDBURNING = "{9E52AB10-F80D-49DF-ACB8-4330F5687855}"
GLOBAL CONST $FOLDERID_CHANGEREMOVEPROGRAMS = "{DF7266AC-9274-4867-8D55-3BD661DE872D}"
GLOBAL CONST $FOLDERID_COMMONADMINTOOLS = "{D0384E7D-BAC3-4797-8F14-CBA229B392B5}"
GLOBAL CONST $FOLDERID_COMMONOEMLINKS = "{C1BAE2D0-10DF-4334-BEDD-7AA20B227A9D}"
GLOBAL CONST $FOLDERID_COMMONPROGRAMS = "{0139D44E-6AFE-49F2-8690-3DAFCAE6FFB8}"
GLOBAL CONST $FOLDERID_COMMONSTARTMENU = "{A4115719-D62E-491D-AA7C-E74B8BE3B067}"
GLOBAL CONST $FOLDERID_COMMONSTARTUP = "{82A5EA35-D9CD-47C5-9629-E15D2F714E6E}"
GLOBAL CONST $FOLDERID_COMMONTEMPLATES = "{B94237E7-57AC-4347-9151-B08C6C32D1F7}"
GLOBAL CONST $FOLDERID_COMPUTERFOLDER = "{0AC0837C-BBF8-452A-850D-79D08E667CA7}"
GLOBAL CONST $FOLDERID_CONFLICTFOLDER = "{4BFEFB45-347D-4006-A5BE-AC0CB0567192}"
GLOBAL CONST $FOLDERID_CONNECTIONSFOLDER = "{6F0CD92B-2E97-45D1-88FF-B0D186B8DEDD}"
GLOBAL CONST $FOLDERID_CONTACTS = "{56784854-C6CB-462B-8169-88E350ACB882}"
GLOBAL CONST $FOLDERID_CONTROLPANELFOLDER = "{82A74AEB-AEB4-465C-A014-D097EE346D63}"
GLOBAL CONST $FOLDERID_COOKIES = "{2B0F765D-C0E9-4171-908E-08A611B84FF6}"
GLOBAL CONST $FOLDERID_DESKTOP = "{B4BFCC3A-DB2C-424C-B029-7FE99A87C641}"
GLOBAL CONST $FOLDERID_DEVICEMETADATASTORE = "{5CE4A5E9-E4EB-479D-B89F-130C02886155}"
GLOBAL CONST $FOLDERID_DOCUMENTSLIBRARY = "{7B0DB17D-9CD2-4A93-9733-46CC89022E7C}"
GLOBAL CONST $FOLDERID_DOWNLOADS = "{374DE290-123F-4565-9164-39C4925E467B}"
GLOBAL CONST $FOLDERID_FAVORITES = "{1777F761-68AD-4D8A-87BD-30B759FA33DD}"
GLOBAL CONST $FOLDERID_FONTS = "{FD228CB7-AE11-4AE3-864C-16F3910AB8FE}"
GLOBAL CONST $FOLDERID_GAMES = "{CAC52C1A-B53D-4EDC-92D7-6B2E8AC19434}"
GLOBAL CONST $FOLDERID_GAMETASKS = "{054FAE61-4DD8-4787-80B6-090220C4B700}"
GLOBAL CONST $FOLDERID_HISTORY = "{D9DC8A3B-B784-432E-A781-5A1130A75963}"
GLOBAL CONST $FOLDERID_HOMEGROUP = "{52528A6B-B9E3-4ADD-B60D-588C2DBA842D}"
GLOBAL CONST $FOLDERID_IMPLICITAPPSHORTCUTS = "{BCB5256F-79F6-4CEE-B725-DC34E402FD46}"
GLOBAL CONST $FOLDERID_INTERNETCACHE = "{352481E8-33BE-4251-BA85-6007CAEDCF9D}"
GLOBAL CONST $FOLDERID_INTERNETFOLDER = "{4D9F7874-4E0C-4904-967B-40B0D20C3E4B}"
GLOBAL CONST $FOLDERID_LIBRARIES = "{1B3EA5DC-B587-4786-B4EF-BD1DC332AEAE}"
GLOBAL CONST $FOLDERID_LINKS = "{BFB9D5E0-C6A9-404C-B2B2-AE6DB6AF4968}"
GLOBAL CONST $FOLDERID_LOCALAPPDATA = "{F1B32785-6FBA-4FCF-9D55-7B8E7F157091}"
GLOBAL CONST $FOLDERID_LOCALAPPDATALOW = "{A520A1A4-1780-4FF6-BD18-167343C5AF16}"
GLOBAL CONST $FOLDERID_LOCALIZEDRESOURCESDIR = "{2A00375E-224C-49DE-B8D1-440DF7EF3DDC}"
GLOBAL CONST $FOLDERID_MUSIC = "{4BD8D571-6D19-48D3-BE97-422220080E43}"
GLOBAL CONST $FOLDERID_MUSICLIBRARY = "{2112AB0A-C86A-4FFE-A368-0DE96E47012E}"
GLOBAL CONST $FOLDERID_NETHOOD = "{C5ABBF53-E17F-4121-8900-86626FC2C973}"
GLOBAL CONST $FOLDERID_NETWORKFOLDER = "{D20BEEC4-5CA8-4905-AE3B-BF251EA09B53}"
GLOBAL CONST $FOLDERID_ORIGINALIMAGES = "{2C36C0AA-5812-4B87-BFD0-4CD0DFB19B39}"
GLOBAL CONST $FOLDERID_PHOTOALBUMS = "{69D2CF90-FC33-4FB7-9A0C-EBB0F0FCB43C}"
GLOBAL CONST $FOLDERID_PICTURESLIBRARY = "{A990AE9F-A03B-4E80-94BC-9912D7504104}"
GLOBAL CONST $FOLDERID_PICTURES = "{33E28130-4E1E-4676-835A-98395C3BC3BB}"
GLOBAL CONST $FOLDERID_PLAYLISTS = "{DE92C1C7-837F-4F69-A3BB-86E631204A23}"
GLOBAL CONST $FOLDERID_PRINTERSFOLDER = "{76FC4E2D-D6AD-4519-A663-37BD56068185}"
GLOBAL CONST $FOLDERID_PRINTHOOD = "{9274BD8D-CFD1-41C3-B35E-B13F55A758F4}"
GLOBAL CONST $FOLDERID_PROFILE = "{5E6C858F-0E22-4760-9AFE-EA3317B67173}"
GLOBAL CONST $FOLDERID_PROGRAMDATA = "{62AB5D82-FDC1-4DC3-A9DD-070D1D495D97}"
GLOBAL CONST $FOLDERID_PROGRAMFILES = "{905E63B6-C1BF-494E-B29C-65B732D3D21A}"
GLOBAL CONST $FOLDERID_PROGRAMFILESX64 = "{6D809377-6AF0-444B-8957-A3773F02200E}"
GLOBAL CONST $FOLDERID_PROGRAMFILESX86 = "{7C5A40EF-A0FB-4BFC-874A-C0F2E0B9FA8E}"
GLOBAL CONST $FOLDERID_PROGRAMFILESCOMMON = "{F7F1ED05-9F6D-47A2-AAAE-29D317C6F066}"
GLOBAL CONST $FOLDERID_PROGRAMFILESCOMMONX64 = "{6365D5A7-0F0D-45E5-87F6-0DA56B6A4F7D}"
GLOBAL CONST $FOLDERID_PROGRAMFILESCOMMONX86 = "{DE974D24-D9C6-4D3E-BF91-F4455120B917}"
GLOBAL CONST $FOLDERID_PROGRAMS = "{A77F5D77-2E2B-44C3-A6A2-ABA601054A51}"
GLOBAL CONST $FOLDERID_PUBLIC = "{DFDF76A2-C82A-4D63-906A-5644AC457385}"
GLOBAL CONST $FOLDERID_PUBLICDESKTOP = "{C4AA340D-F20F-4863-AFEF-F87EF2E6BA25}"
GLOBAL CONST $FOLDERID_PUBLICDOCUMENTS = "{ED4824AF-DCE4-45A8-81E2-FC7965083634}"
GLOBAL CONST $FOLDERID_PUBLICDOWNLOADS = "{3D644C9B-1FB8-4F30-9B45-F670235F79C0}"
GLOBAL CONST $FOLDERID_PUBLICGAMETASKS = "{DEBF2536-E1A8-4C59-B6A2-414586476AEA}"
GLOBAL CONST $FOLDERID_PUBLICLIBRARIES = "{48DAF80B-E6CF-4F4E-B800-0E69D84EE384}"
GLOBAL CONST $FOLDERID_PUBLICMUSIC = "{3214FAB5-9757-4298-BB61-92A9DEAA44FF}"
GLOBAL CONST $FOLDERID_PUBLICPICTURES = "{B6EBFB86-6907-413C-9AF7-4FC2ABF07CC5}"
GLOBAL CONST $FOLDERID_PUBLICRINGTONES = "{E555AB60-153B-4D17-9F04-A5FE99FC15EC}"
GLOBAL CONST $FOLDERID_PUBLICVIDEOS = "{2400183A-6185-49FB-A2D8-4A392A602BA3}"
GLOBAL CONST $FOLDERID_QUICKLAUNCH = "{52A4F021-7B75-48A9-9F6B-4B87A210BC8F}"
GLOBAL CONST $FOLDERID_RECENT = "{AE50C081-EBD2-438A-8655-8A092E34987A}"
GLOBAL CONST $FOLDERID_RECORDEDTVLIBRARY = "{1A6FDBA2-F42D-4358-A798-B74D745926C5}"
GLOBAL CONST $FOLDERID_RECYCLEBINFOLDER = "{B7534046-3ECB-4C18-BE4E-64CD4CB7D6AC}"
GLOBAL CONST $FOLDERID_RESOURCEDIR = "{8AD10C31-2ADB-4296-A8F7-E4701232C972}"
GLOBAL CONST $FOLDERID_RINGTONES = "{C870044B-F49E-4126-A9C3-B52A1FF411E8}"
GLOBAL CONST $FOLDERID_ROAMINGAPPDATA = "{3EB685DB-65F9-4CF6-A03A-E3EF65729F3D}"
GLOBAL CONST $FOLDERID_SAMPLEMUSIC = "{B250C668-F57D-4EE1-A63C-290EE7D1AA1F}"
GLOBAL CONST $FOLDERID_SAMPLEPICTURES = "{C4900540-2379-4C75-844B-64E6FAF8716B}"
GLOBAL CONST $FOLDERID_SAMPLEPLAYLISTS = "{15CA69B3-30EE-49C1-ACE1-6B5EC372AFB5}"
GLOBAL CONST $FOLDERID_SAMPLEVIDEOS = "{859EAD94-2E85-48AD-A71A-0969CB56A6CD}"
GLOBAL CONST $FOLDERID_SAVEDGAMES = "{4C5C32FF-BB9D-43B0-B5B4-2D72E54EAAA4}"
GLOBAL CONST $FOLDERID_SAVEDSEARCHES = "{7D1D3A04-DEBB-4115-95CF-2F29DA2920DA}"
GLOBAL CONST $FOLDERID_SEARCH_CSC = "{EE32E446-31CA-4ABA-814F-A5EBD2FD6D5E}"
GLOBAL CONST $FOLDERID_SEARCH_MAPI = "{98EC0E18-2098-4D44-8644-66979315A281}"
GLOBAL CONST $FOLDERID_SEARCHHOME = "{190337D1-B8CA-4121-A639-6D472D16972A}"
GLOBAL CONST $FOLDERID_SENDTO = "{8983036C-27C0-404B-8F08-102D10DCFD74}"
GLOBAL CONST $FOLDERID_SIDEBARDEFAULTPARTS = "{7B396E54-9EC5-4300-BE0A-2482EBAE1A26}"
GLOBAL CONST $FOLDERID_SIDEBARPARTS = "{A75D362E-50FC-4FB7-AC2C-A8BEAA314493}"
GLOBAL CONST $FOLDERID_STARTMENU = "{625B53C3-AB48-4EC1-BA1F-A1EF4146FC19}"
GLOBAL CONST $FOLDERID_STARTUP = "{B97D20BB-F46A-4C97-BA10-5E3608430854}"
GLOBAL CONST $FOLDERID_SYNCMANAGERFOLDER = "{43668BF8-C14E-49B2-97C9-747784D784B7}"
GLOBAL CONST $FOLDERID_SYNCRESULTSFOLDER = "{289A9A43-BE44-4057-A41B-587A76D7E7F9}"
GLOBAL CONST $FOLDERID_SYNCSETUPFOLDER = "{0F214138-B1D3-4A90-BBA9-27CBC0C5389A}"
GLOBAL CONST $FOLDERID_SYSTEM = "{1AC14E77-02E7-4E5D-B744-2EB1AE5198B7}"
GLOBAL CONST $FOLDERID_SYSTEMX86 = "{D65231B0-B2F1-4857-A4CE-A8E7C6EA7D27}"
GLOBAL CONST $FOLDERID_TEMPLATES = "{A63293E8-664E-48DB-A079-DF759E0509F7}"
GLOBAL CONST $FOLDERID_USERPINNED = "{9E3995AB-1F9C-4F13-B827-48B24B6C7174}"
GLOBAL CONST $FOLDERID_USERPROFILES = "{0762D272-C50A-4BB0-A382-697DCD729B80}"
GLOBAL CONST $FOLDERID_USERPROGRAMFILES = "{5CD7AEE2-2219-4A67-B85D-6C9CE15660CB}"
GLOBAL CONST $FOLDERID_USERPROGRAMFILESCOMMON = "{BCBD3057-CA5C-4622-B42D-BC56DB0AE516}"
GLOBAL CONST $FOLDERID_USERSFILES = "{F3CE0F7C-4901-4ACC-8648-D5D44B04EF8F}"
GLOBAL CONST $FOLDERID_USERSLIBRARIES = "{A302545D-DEFF-464B-ABE8-61C8648D939B}"
GLOBAL CONST $FOLDERID_VIDEOS = "{18989B1D-99B5-455B-841C-AB7C74E4DDFC}"
GLOBAL CONST $FOLDERID_VIDEOSLIBRARY = "{491E922F-5643-4AF4-A7EB-4E7A138D8174}"
GLOBAL CONST $FOLDERID_WINDOWS = "{F38BF404-1D43-42F2-9305-67DE0B28FC23}"
GLOBAL CONST $KF_FLAG_ALIAS_ONLY = -2147483648
GLOBAL CONST $KF_FLAG_CREATE = 32768
GLOBAL CONST $KF_FLAG_DONT_VERIFY = 16384
GLOBAL CONST $KF_FLAG_DONT_UNEXPAND = 8192
GLOBAL CONST $KF_FLAG_NO_ALIAS = 4096
GLOBAL CONST $KF_FLAG_INIT = 2048
GLOBAL CONST $KF_FLAG_DEFAULT_PATH = 1024
GLOBAL CONST $KF_FLAG_NO_APPCONTAINER_REDIRECTION = 65536
GLOBAL CONST $KF_FLAG_NOT_PARENT_RELATIVE = 512
GLOBAL CONST $KF_FLAG_SIMPLE_IDLIST = 256
GLOBAL CONST $KLF_ACTIVATE = 1
GLOBAL CONST $KLF_NOTELLSHELL = 128
GLOBAL CONST $KLF_REORDER = 8
GLOBAL CONST $KLF_REPLACELANG = 16
GLOBAL CONST $KLF_RESET = 1073741824
GLOBAL CONST $KLF_SETFORPROCESS = 256
GLOBAL CONST $KLF_SHIFTLOCK = 65536
GLOBAL CONST $KLF_SUBSTITUTE_OK = 2
GLOBAL CONST $HKL_NEXT = 1
GLOBAL CONST $HKL_PREV = 0
GLOBAL CONST $AW_ACTIVATE = 131072
GLOBAL CONST $AW_BLEND = 524288
GLOBAL CONST $AW_CENTER = 16
GLOBAL CONST $AW_HIDE = 65536
GLOBAL CONST $AW_HOR_NEGATIVE = 2
GLOBAL CONST $AW_HOR_POSITIVE = 1
GLOBAL CONST $AW_SLIDE = 262144
GLOBAL CONST $AW_VER_NEGATIVE = 8
GLOBAL CONST $AW_VER_POSITIVE = 4
GLOBAL CONST $BSF_ALLOWSFW = 128
GLOBAL CONST $BSF_FLUSHDISK = 4
GLOBAL CONST $BSF_FORCEIFHUNG = 32
GLOBAL CONST $BSF_IGNORECURRENTTASK = 2
GLOBAL CONST $BSF_NOHANG = 8
GLOBAL CONST $BSF_NOTIMEOUTIFNOTHUNG = 64
GLOBAL CONST $BSF_POSTMESSAGE = 16
GLOBAL CONST $BSF_QUERY = 1
GLOBAL CONST $BSF_SENDNOTIFYMESSAGE = 256
GLOBAL CONST $BSM_ALLCOMPONENTS = 0
GLOBAL CONST $BSM_ALLDESKTOPS = 8
GLOBAL CONST $BSM_APPLICATIONS = 16
GLOBAL CONST $BSM_INSTALLABLEDRIVERS = 4
GLOBAL CONST $BSM_NETDRIVER = 2
GLOBAL CONST $BSM_VXDS = 1
GLOBAL CONST $MDITILE_HORIZONTAL = 1
GLOBAL CONST $MDITILE_SKIPDISABLED = 2
GLOBAL CONST $MDITILE_VERTICAL = 0
GLOBAL CONST $MDITILE_ZORDER = 4
GLOBAL CONST $MSGFLT_ALLOW = 1
GLOBAL CONST $MSGFLT_DISALLOW = 2
GLOBAL CONST $MSGFLT_RESET = 0
GLOBAL CONST $MSGFLTINFO_ALLOWED_HIGHER = 3
GLOBAL CONST $MSGFLTINFO_ALREADYALLOWED_FORWND = 1
GLOBAL CONST $MSGFLTINFO_ALREADYDISALLOWED_FORWND = 2
GLOBAL CONST $MSGFLTINFO_NONE = 0
GLOBAL CONST $CWP_ALL = 0
GLOBAL CONST $CWP_SKIPINVISIBLE = 1
GLOBAL CONST $CWP_SKIPDISABLED = 2
GLOBAL CONST $CWP_SKIPTRANSPARENT = 4
GLOBAL CONST $COMPRESSION_FORMAT_NONE = 0
GLOBAL CONST $COMPRESSION_FORMAT_DEFAULT = 1
GLOBAL CONST $COMPRESSION_FORMAT_LZNT1 = 2
GLOBAL CONST $COMPRESSION_FORMAT_XPRESS = 3
GLOBAL CONST $COMPRESSION_FORMAT_XPRESS_HUFF = 4
GLOBAL CONST $COMPRESSION_ENGINE_STANDARD = 0
GLOBAL CONST $COMPRESSION_ENGINE_MAXIMUM = 256
GLOBAL CONST $COMPRESSION_ENGINE_HIBER = 512
GLOBAL CONST $WINSTA_ACCESSCLIPBOARD = 4
GLOBAL CONST $WINSTA_ACCESSGLOBALATOMS = 32
GLOBAL CONST $WINSTA_CREATEDESKTOP = 8
GLOBAL CONST $WINSTA_ENUMDESKTOPS = 1
GLOBAL CONST $WINSTA_ENUMERATE = 256
GLOBAL CONST $WINSTA_EXITWINDOWS = 64
GLOBAL CONST $WINSTA_READATTRIBUTES = 2
GLOBAL CONST $WINSTA_READSCREEN = 512
GLOBAL CONST $WINSTA_WRITEATTRIBUTES = 16
GLOBAL CONST $WINSTA_ALL_ACCESS = BITOR($WINSTA_ACCESSCLIPBOARD, $WINSTA_ACCESSGLOBALATOMS, $WINSTA_CREATEDESKTOP, $WINSTA_ENUMDESKTOPS, $WINSTA_ENUMERATE, $WINSTA_EXITWINDOWS, $WINSTA_READATTRIBUTES, $WINSTA_READSCREEN, $WINSTA_WRITEATTRIBUTES)
GLOBAL CONST $CWF_CREATE_ONLY = 1
GLOBAL CONST $GCL_CBCLSEXTRA = -20
GLOBAL CONST $GCL_CBWNDEXTRA = -18
GLOBAL CONST $GCL_HBRBACKGROUND = -10
GLOBAL CONST $GCL_HCURSOR = -12
GLOBAL CONST $GCL_HICON = -14
GLOBAL CONST $GCL_HICONSM = -34
GLOBAL CONST $GCL_HMODULE = -16
GLOBAL CONST $GCL_MENUNAME = -8
GLOBAL CONST $GCL_STYLE = -26
GLOBAL CONST $GCL_WNDPROC = -24
GLOBAL CONST $DOCKINFO_DOCKED = 2
GLOBAL CONST $DOCKINFO_UNDOCKED = 1
GLOBAL CONST $DOCKINFO_USER_SUPPLIED = 4
GLOBAL CONST $DOCKINFO_USER_DOCKED = 5
GLOBAL CONST $DOCKINFO_USER_UNDOCKED = 6
GLOBAL CONST $GUI_CARETBLINKING = 1
GLOBAL CONST $GUI_INMENUMODE = 4
GLOBAL CONST $GUI_INMOVESIZE = 2
GLOBAL CONST $GUI_POPUPMENUMODE = 16
GLOBAL CONST $GUI_SYSTEMMENUMODE = 8
GLOBAL CONST $HANDLE_FLAG_INHERIT = 1
GLOBAL CONST $HANDLE_FLAG_PROTECT_FROM_CLOSE = 2
GLOBAL CONST $GET_MODULE_HANDLE_EX_FLAG_FROM_ADDRESS = 4
GLOBAL CONST $GET_MODULE_HANDLE_EX_FLAG_PIN = 1
GLOBAL CONST $GET_MODULE_HANDLE_EX_FLAG_UNCHANGED_REFCOUNT = 2
GLOBAL CONST $GET_MODULE_HANDLE_EX_FLAG_DEFAULT = 0
GLOBAL CONST $PROCESSOR_ARCHITECTURE_AMD64 = 9
GLOBAL CONST $PROCESSOR_ARCHITECTURE_IA64 = 6
GLOBAL CONST $PROCESSOR_ARCHITECTURE_INTEL = 0
GLOBAL CONST $PROCESSOR_ARCHITECTURE_UNKNOWN = 65535
GLOBAL CONST $PROCESSOR_INTEL_386 = 386
GLOBAL CONST $PROCESSOR_INTEL_486 = 486
GLOBAL CONST $PROCESSOR_INTEL_PENTIUM = 586
GLOBAL CONST $PROCESSOR_INTEL_IA64 = 2200
GLOBAL CONST $PROCESSOR_AMD_X8664 = 8664
GLOBAL CONST $UOI_FLAGS = 1
GLOBAL CONST $UOI_HEAPSIZE = 5
GLOBAL CONST $UOI_IO = 6
GLOBAL CONST $UOI_NAME = 2
GLOBAL CONST $UOI_TYPE = 3
GLOBAL CONST $UOI_USER_SID = 4
GLOBAL CONST $DF_ALLOWOTHERACCOUNTHOOK = 1
GLOBAL CONST $WSF_VISIBLE = 1
GLOBAL CONST $VER_SUITE_BACKOFFICE = 4
GLOBAL CONST $VER_SUITE_BLADE = 1024
GLOBAL CONST $VER_SUITE_COMPUTE_SERVER = 16384
GLOBAL CONST $VER_SUITE_DATACENTER = 128
GLOBAL CONST $VER_SUITE_ENTERPRISE = 2
GLOBAL CONST $VER_SUITE_EMBEDDEDNT = 64
GLOBAL CONST $VER_SUITE_PERSONAL = 512
GLOBAL CONST $VER_SUITE_SINGLEUSERTS = 256
GLOBAL CONST $VER_SUITE_SMALLBUSINESS = 1
GLOBAL CONST $VER_SUITE_SMALLBUSINESS_RESTRICTED = 32
GLOBAL CONST $VER_SUITE_STORAGE_SERVER = 8192
GLOBAL CONST $VER_SUITE_TERMINAL = 16
GLOBAL CONST $VER_SUITE_WH_SERVER = 32768
GLOBAL CONST $VER_NT_DOMAIN_CONTROLLER = 2
GLOBAL CONST $VER_NT_SERVER = 3
GLOBAL CONST $VER_NT_WORKSTATION = 1
GLOBAL CONST $WDA_MONITOR = 1
GLOBAL CONST $WDA_NONE = 0
GLOBAL CONST $PF_3DNOW_INSTRUCTIONS_AVAILABLE = 7
GLOBAL CONST $PF_CHANNELS_ENABLED = 16
GLOBAL CONST $PF_COMPARE_EXCHANGE_DOUBLE = 2
GLOBAL CONST $PF_COMPARE_EXCHANGE128 = 14
GLOBAL CONST $PF_COMPARE64_EXCHANGE128 = 15
GLOBAL CONST $PF_FLOATING_POINT_EMULATED = 1
GLOBAL CONST $PF_FLOATING_POINT_PRECISION_ERRATA = 0
GLOBAL CONST $PF_MMX_INSTRUCTIONS_AVAILABLE = 3
GLOBAL CONST $PF_NX_ENABLED = 12
GLOBAL CONST $PF_PAE_ENABLED = 9
GLOBAL CONST $PF_RDTSC_INSTRUCTION_AVAILABLE = 8
GLOBAL CONST $PF_SSE3_INSTRUCTIONS_AVAILABLE = 13
GLOBAL CONST $PF_XMMI_INSTRUCTIONS_AVAILABLE = 6
GLOBAL CONST $PF_XMMI64_INSTRUCTIONS_AVAILABLE = 10
GLOBAL CONST $PF_XSAVE_ENABLED = 17
GLOBAL CONST $KEYEVENTF_EXTENDEDKEY = 1
GLOBAL CONST $KEYEVENTF_KEYUP = 2
GLOBAL CONST $LIM_SMALL = 0
GLOBAL CONST $LIM_LARGE = 1
GLOBAL CONST $MAPVK_VK_TO_CHAR = 2
GLOBAL CONST $MAPVK_VK_TO_VSC = 0
GLOBAL CONST $MAPVK_VK_TO_VSC_EX = 4
GLOBAL CONST $MAPVK_VSC_TO_VK = 1
GLOBAL CONST $MAPVK_VSC_TO_VK_EX = 3
GLOBAL CONST $MOD_ALT = 1
GLOBAL CONST $MOD_CONTROL = 2
GLOBAL CONST $MOD_NOREPEAT = 16384
GLOBAL CONST $MOD_SHIFT = 4
GLOBAL CONST $MOD_WIN = 8
GLOBAL CONST $GUID_ACDC_POWER_SOURCE = "{5D3E9A59-E9D5-4B00-A6BD-FF34FF516548}"
GLOBAL CONST $GUID_BATTERY_PERCENTAGE_REMAINING = "{A7AD8041-B45A-4CAE-87A3-EECBB468A9E1}"
GLOBAL CONST $GUID_IDLE_BACKGROUND_TASK = "{515C31D8-F734-163D-A0FD-11A08C91E8F1}"
GLOBAL CONST $GUID_MONITOR_POWER_ON = "{02731015-4510-4526-99E6-E5A17EBD1AEA}"
GLOBAL CONST $GUID_POWERSCHEME_PERSONALITY = "{245D8541-3943-4422-B025-13A784F679B7}"
GLOBAL CONST $GUID_SYSTEM_AWAYMODE = "{98A7F580-01F7-48AA-9C0F-44352C29E5C0}"
GLOBAL CONST $GUID_MIN_POWER_SAVINGS = "{8C5E7FDA-E8BF-4A96-9A85-A6E23A8C635C}"
GLOBAL CONST $GUID_MAX_POWER_SAVINGS = "{A1841308-3541-4FAB-BC81-F71556F20B4A}"
GLOBAL CONST $GUID_TYPICAL_POWER_SAVINGS = "{381B4222-F694-41F0-9685-FF5BB260DF2E}"
GLOBAL CONST $HSHELL_WINDOWCREATED = 1
GLOBAL CONST $HSHELL_WINDOWDESTROYED = 2
GLOBAL CONST $HSHELL_ACTIVATESHELLWINDOW = 3
GLOBAL CONST $HSHELL_WINDOWACTIVATED = 4
GLOBAL CONST $HSHELL_GETMINRECT = 5
GLOBAL CONST $HSHELL_REDRAW = 6
GLOBAL CONST $HSHELL_TASKMAN = 7
GLOBAL CONST $HSHELL_LANGUAGE = 8
GLOBAL CONST $HSHELL_SYSMENU = 9
GLOBAL CONST $HSHELL_ENDTASK = 10
GLOBAL CONST $HSHELL_ACCESSIBILITYSTATE = 11
GLOBAL CONST $HSHELL_APPCOMMAND = 12
GLOBAL CONST $HSHELL_WINDOWREPLACED = 13
GLOBAL CONST $HSHELL_WINDOWREPLACING = 14
GLOBAL CONST $HSHELL_RUDEAPPACTIVATED = 32772
GLOBAL CONST $HSHELL_FLASH = 32774
GLOBAL CONST $HWND_BROADCAST = 65535
GLOBAL CONST $SMTO_BLOCK = 1
GLOBAL CONST $SMTO_NORMAL = 0
GLOBAL CONST $SMTO_ABORTIFHUNG = 2
GLOBAL CONST $SMTO_NOTIMEOUTIFNOTHUNG = 8
GLOBAL CONST $SMTO_ERRORONEXIT = 32
GLOBAL CONST $INPUTLANGCHANGE_BACKWARD = 4
GLOBAL CONST $INPUTLANGCHANGE_FORWARD = 2
GLOBAL CONST $INPUTLANGCHANGE_SYSCHARSET = 1
GLOBAL CONST $EVENT_MIN = 1
GLOBAL CONST $EVENT_SYSTEM_SOUND = 1
GLOBAL CONST $EVENT_SYSTEM_ALERT = 2
GLOBAL CONST $EVENT_SYSTEM_FOREGROUND = 3
GLOBAL CONST $EVENT_SYSTEM_MENUSTART = 4
GLOBAL CONST $EVENT_SYSTEM_MENUEND = 5
GLOBAL CONST $EVENT_SYSTEM_MENUPOPUPSTART = 6
GLOBAL CONST $EVENT_SYSTEM_MENUPOPUPEND = 7
GLOBAL CONST $EVENT_SYSTEM_CAPTURESTART = 8
GLOBAL CONST $EVENT_SYSTEM_CAPTUREEND = 9
GLOBAL CONST $EVENT_SYSTEM_MOVESIZESTART = 10
GLOBAL CONST $EVENT_SYSTEM_MOVESIZEEND = 11
GLOBAL CONST $EVENT_SYSTEM_CONTEXTHELPSTART = 12
GLOBAL CONST $EVENT_SYSTEM_CONTEXTHELPEND = 13
GLOBAL CONST $EVENT_SYSTEM_DRAGDROPSTART = 14
GLOBAL CONST $EVENT_SYSTEM_DRAGDROPEND = 15
GLOBAL CONST $EVENT_SYSTEM_DIALOGSTART = 16
GLOBAL CONST $EVENT_SYSTEM_DIALOGEND = 17
GLOBAL CONST $EVENT_SYSTEM_SCROLLINGSTART = 18
GLOBAL CONST $EVENT_SYSTEM_SCROLLINGEND = 19
GLOBAL CONST $EVENT_SYSTEM_SWITCHSTART = 20
GLOBAL CONST $EVENT_SYSTEM_SWITCHEND = 21
GLOBAL CONST $EVENT_SYSTEM_MINIMIZESTART = 22
GLOBAL CONST $EVENT_SYSTEM_MINIMIZEEND = 23
GLOBAL CONST $EVENT_SYSTEM_DESKTOPSWITCH = 32
GLOBAL CONST $EVENT_OBJECT_CREATE = 32768
GLOBAL CONST $EVENT_OBJECT_DESTROY = 32769
GLOBAL CONST $EVENT_OBJECT_SHOW = 32770
GLOBAL CONST $EVENT_OBJECT_HIDE = 32771
GLOBAL CONST $EVENT_OBJECT_REORDER = 32772
GLOBAL CONST $EVENT_OBJECT_FOCUS = 32773
GLOBAL CONST $EVENT_OBJECT_SELECTION = 32774
GLOBAL CONST $EVENT_OBJECT_SELECTIONADD = 32775
GLOBAL CONST $EVENT_OBJECT_SELECTIONREMOVE = 32776
GLOBAL CONST $EVENT_OBJECT_SELECTIONWITHIN = 32777
GLOBAL CONST $EVENT_OBJECT_STATECHANGE = 32778
GLOBAL CONST $EVENT_OBJECT_LOCATIONCHANGE = 32779
GLOBAL CONST $EVENT_OBJECT_NAMECHANGE = 32780
GLOBAL CONST $EVENT_OBJECT_DESCRIPTIONCHANGE = 32781
GLOBAL CONST $EVENT_OBJECT_VALUECHANGE = 32782
GLOBAL CONST $EVENT_OBJECT_PARENTCHANGE = 32783
GLOBAL CONST $EVENT_OBJECT_HELPCHANGE = 32784
GLOBAL CONST $EVENT_OBJECT_DEFACTIONCHANGE = 32785
GLOBAL CONST $EVENT_OBJECT_ACCELERATORCHANGE = 32786
GLOBAL CONST $EVENT_OBJECT_INVOKED = 32787
GLOBAL CONST $EVENT_OBJECT_TEXTSELECTIONCHANGED = 32788
GLOBAL CONST $EVENT_OBJECT_CONTENTSCROLLED = 32789
GLOBAL CONST $EVENT_MAX = 2147483647
GLOBAL CONST $WINEVENT_INCONTEXT = 4
GLOBAL CONST $WINEVENT_OUTOFCONTEXT = 0
GLOBAL CONST $WINEVENT_SKIPOWNPROCESS = 2
GLOBAL CONST $WINEVENT_SKIPOWNTHREAD = 1
GLOBAL CONST $TME_CANCEL = -2147483648
GLOBAL CONST $TME_HOVER = 1
GLOBAL CONST $TME_LEAVE = 2
GLOBAL CONST $TME_NONCLIENT = 16
GLOBAL CONST $TME_QUERY = 1073741824
GLOBAL CONST $DESKTOP_CREATEMENU = 4
GLOBAL CONST $DESKTOP_CREATEWINDOW = 2
GLOBAL CONST $DESKTOP_ENUMERATE = 64
GLOBAL CONST $DESKTOP_HOOKCONTROL = 8
GLOBAL CONST $DESKTOP_JOURNALPLAYBACK = 32
GLOBAL CONST $DESKTOP_JOURNALRECORD = 16
GLOBAL CONST $DESKTOP_READOBJECTS = 1
GLOBAL CONST $DESKTOP_SWITCHDESKTOP = 256
GLOBAL CONST $DESKTOP_WRITEOBJECTS = 128
GLOBAL CONST $DESKTOP_ALL_ACCESS = BITOR($DESKTOP_CREATEMENU, $DESKTOP_CREATEWINDOW, $DESKTOP_ENUMERATE, $DESKTOP_HOOKCONTROL, $DESKTOP_JOURNALPLAYBACK, $DESKTOP_JOURNALRECORD, $DESKTOP_READOBJECTS, $DESKTOP_SWITCHDESKTOP, $DESKTOP_WRITEOBJECTS)
GLOBAL CONST $RIDEV_APPKEYS = 1024
GLOBAL CONST $RIDEV_CAPTUREMOUSE = 512
GLOBAL CONST $RIDEV_DEVNOTIFY = 8192
GLOBAL CONST $RIDEV_EXCLUDE = 16
GLOBAL CONST $RIDEV_EXINPUTSINK = 4096
GLOBAL CONST $RIDEV_INPUTSINK = 256
GLOBAL CONST $RIDEV_NOHOTKEYS = 512
GLOBAL CONST $RIDEV_NOLEGACY = 48
GLOBAL CONST $RIDEV_PAGEONLY = 32
GLOBAL CONST $RIDEV_REMOVE = 1
GLOBAL CONST $RID_HEADER = 268435461
GLOBAL CONST $RID_INPUT = 268435459
GLOBAL CONST $RIM_TYPEHID = 2
GLOBAL CONST $RIM_TYPEKEYBOARD = 1
GLOBAL CONST $RIM_TYPEMOUSE = 0
GLOBAL CONST $RIDI_DEVICENAME = 536870919
GLOBAL CONST $RIDI_DEVICEINFO = 536870923
GLOBAL CONST $RIDI_PREPARSEDDATA = 536870917
GLOBAL CONST $MOUSE_ATTRIBUTES_CHANGED = 4
GLOBAL CONST $MOUSE_MOVE_ABSOLUTE = 1
GLOBAL CONST $MOUSE_MOVE_RELATIVE = 0
GLOBAL CONST $MOUSE_VIRTUAL_DESKTOP = 2
GLOBAL CONST $RI_MOUSE_LEFT_BUTTON_DOWN = 1
GLOBAL CONST $RI_MOUSE_LEFT_BUTTON_UP = 2
GLOBAL CONST $RI_MOUSE_MIDDLE_BUTTON_DOWN = 16
GLOBAL CONST $RI_MOUSE_MIDDLE_BUTTON_UP = 32
GLOBAL CONST $RI_MOUSE_RIGHT_BUTTON_DOWN = 4
GLOBAL CONST $RI_MOUSE_RIGHT_BUTTON_UP = 8
GLOBAL CONST $RI_MOUSE_BUTTON_1_DOWN = $RI_MOUSE_LEFT_BUTTON_DOWN
GLOBAL CONST $RI_MOUSE_BUTTON_1_UP = $RI_MOUSE_LEFT_BUTTON_UP
GLOBAL CONST $RI_MOUSE_BUTTON_2_DOWN = $RI_MOUSE_RIGHT_BUTTON_DOWN
GLOBAL CONST $RI_MOUSE_BUTTON_2_UP = $RI_MOUSE_RIGHT_BUTTON_UP
GLOBAL CONST $RI_MOUSE_BUTTON_3_DOWN = $RI_MOUSE_MIDDLE_BUTTON_DOWN
GLOBAL CONST $RI_MOUSE_BUTTON_3_UP = $RI_MOUSE_MIDDLE_BUTTON_UP
GLOBAL CONST $RI_MOUSE_BUTTON_4_DOWN = 64
GLOBAL CONST $RI_MOUSE_BUTTON_4_UP = 128
GLOBAL CONST $RI_MOUSE_BUTTON_5_DOWN = 256
GLOBAL CONST $RI_MOUSE_BUTTON_5_UP = 512
GLOBAL CONST $RI_MOUSE_WHEEL = 1024
GLOBAL CONST $RI_KEY_BREAK = 1
GLOBAL CONST $RI_KEY_E0 = 2
GLOBAL CONST $RI_KEY_E1 = 4
GLOBAL CONST $RI_KEY_MAKE = 0
GLOBAL CONST $FLASHW_CAPTION = 1
GLOBAL CONST $FLASHW_TRAY = 2
GLOBAL CONST $FLASHW_TIMER = 4
GLOBAL CONST $FLASHW_TIMERNOFG = 12
GLOBAL CONST $TAGUPDATELAYEREDWINDOWINFO = "dword Size;hwnd hDstDC;long DstX;long DstY;long cX;long cY;hwnd hSrcDC;long SrcX;long SrcY;dword crKey;byte BlendOp;byte BlendFlags;byte Alpha;byte AlphaFormat;dword Flags;long DirtyLeft;long DirtyTop;long DirtyRight;long DirtyBottom"
GLOBAL CONST $TAGWINDOWINFO = "dword Size;struct;long rWindow[4];endstruct;struct;long rClient[4];endstruct;dword Style;dword ExStyle;dword WindowStatus;uint cxWindowBorders;uint cyWindowBorders;word atomWindowType;word CreatorVersion"
GLOBAL CONST $TAGWNDCLASS = "uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName"
GLOBAL CONST $TAGWNDCLASSEX = "uint Size;uint Style;ptr hWndProc;int ClsExtra;int WndExtra;ptr hInstance;ptr hIcon;ptr hCursor;ptr hBackground;ptr MenuName;ptr ClassName;ptr hIconSm"
GLOBAL CONST $TAGFLASHWINFO = "uint Size;hwnd hWnd;dword Flags;uint Count;dword TimeOut"
FUNC _WINAPI_ADJUSTWINDOWRECTEX(BYREF $TRECT, $ISTYLE, $IEXSTYLE = 0, $BMENU = FALSE)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "AdjustWindowRectEx", "struct*", $TRECT, "dword", $ISTYLE, "bool", $BMENU, "dword", $IEXSTYLE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_ANIMATEWINDOW($HWND, $IFLAGS, $IDURATION = 1000)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "AnimateWindow", "hwnd", $HWND, "dword", $IDURATION, "dword", $IFLAGS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_BEGINDEFERWINDOWPOS($IAMOUNT = 1)
	LOCAL $ARET = DLLCALL("user32.dll", "handle", "BeginDeferWindowPos", "int", $IAMOUNT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_BRINGWINDOWTOTOP($HWND)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "BringWindowToTop", "hwnd", $HWND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_BROADCASTSYSTEMMESSAGE($IMSG, $WPARAM = 0, $LPARAM = 0, $IFLAGS = 0, $IRECIPIENTS = 0)
	LOCAL $ARET = DLLCALL("user32.dll", "long", "BroadcastSystemMessageW", "dword", $IFLAGS, "dword*", $IRECIPIENTS, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)
	IF @ERROR OR($ARET[0] = -1) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	RETURN SETEXTENDED($ARET[2], $ARET[0])
ENDFUNC
FUNC _WINAPI_CALLWINDOWPROC($PPREVWNDFUNC, $HWND, $IMSG, $WPARAM, $LPARAM)
	LOCAL $ARESULT = DLLCALL("user32.dll", "lresult", "CallWindowProc", "ptr", $PPREVWNDFUNC, "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_CALLWINDOWPROCW($PPREVWNDPROC, $HWND, $IMSG, $WPARAM, $LPARAM)
	LOCAL $ARET = DLLCALL("user32.dll", "lresult", "CallWindowProcW", "ptr", $PPREVWNDPROC, "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_CASCADEWINDOWS($AWNDS, $TRECT = 0, $HPARENT = 0, $IFLAGS = 0, $ISTART = 0, $IEND = -1)
	IF __CHECKERRORARRAYBOUNDS($AWNDS, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	LOCAL $ICOUNT = $IEND - $ISTART + 1
	LOCAL $TWNDS = DLLSTRUCTCREATE("hwnd[" & $ICOUNT & "]")
	$ICOUNT = 1
	FOR $I = $ISTART TO $IEND
		DLLSTRUCTSETDATA($TWNDS, 1, $AWNDS[$I], $ICOUNT)
		$ICOUNT += 1
	NEXT
	LOCAL $ARET = DLLCALL("user32.dll", "word", "CascadeWindows", "hwnd", $HPARENT, "uint", $IFLAGS, "struct*", $TRECT, "uint", $ICOUNT - 1, "struct*", $TWNDS)
	IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_CHANGEWINDOWMESSAGEFILTEREX($HWND, $IMSG, $IACTION)
	LOCAL $TCFS, $ARET
	IF $HWND AND($__WINVER > 1536) THEN
		LOCAL CONST $TAGCHANGEFILTERSTRUCT = "dword cbSize; dword ExtStatus"
		$TCFS = DLLSTRUCTCREATE($TAGCHANGEFILTERSTRUCT)
		DLLSTRUCTSETDATA($TCFS, 1, DLLSTRUCTGETSIZE($TCFS))
		$ARET = DLLCALL("user32.dll", "bool", "ChangeWindowMessageFilterEx", "hwnd", $HWND, "uint", $IMSG, "dword", $IACTION, "struct*", $TCFS)
	ELSE
		$TCFS = 0
		$ARET = DLLCALL("user32.dll", "bool", "ChangeWindowMessageFilter", "uint", $IMSG, "dword", $IACTION)
	ENDIF
	IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN SETEXTENDED(DLLSTRUCTGETDATA($TCFS, 2), 1)
ENDFUNC
FUNC _WINAPI_CHILDWINDOWFROMPOINTEX($HWND, $TPOINT, $IFLAGS = 0)
	LOCAL $ARET = DLLCALL("user32.dll", "hwnd", "ChildWindowFromPointEx", "hwnd", $HWND, "struct", $TPOINT, "uint", $IFLAGS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_CLOSEWINDOW($HWND)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "CloseWindow", "hwnd", $HWND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_DEFERWINDOWPOS($HINFO, $HWND, $HAFTER, $IX, $IY, $IWIDTH, $IHEIGHT, $IFLAGS)
	LOCAL $ARET = DLLCALL("user32.dll", "handle", "DeferWindowPos", "handle", $HINFO, "hwnd", $HWND, "hwnd", $HAFTER, "int", $IX, "int", $IY, "int", $IWIDTH, "int", $IHEIGHT, "uint", $IFLAGS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_DEFWINDOWPROC($HWND, $IMSG, $WPARAM, $LPARAM)
	LOCAL $ARESULT = DLLCALL("user32.dll", "lresult", "DefWindowProc", "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_DEFWINDOWPROCW($HWND, $IMSG, $WPARAM, $LPARAM)
	LOCAL $ARET = DLLCALL("user32.dll", "lresult", "DefWindowProcW", "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_DEREGISTERSHELLHOOKWINDOW($HWND)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "DeregisterShellHookWindow", "hwnd", $HWND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_DRAGACCEPTFILES($HWND, $BACCEPT = TRUE)
	DLLCALL("shell32.dll", "none", "DragAcceptFiles", "hwnd", $HWND, "bool", $BACCEPT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN 1
ENDFUNC
FUNC _WINAPI_DRAGFINISH($HDROP)
	DLLCALL("shell32.dll", "none", "DragFinish", "handle", $HDROP)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN 1
ENDFUNC
FUNC _WINAPI_DRAGQUERYFILEEX($HDROP, $IFLAG = 0)
	LOCAL $ARET = DLLCALL("shell32.dll", "uint", "DragQueryFileW", "handle", $HDROP, "uint", -1, "ptr", 0, "uint", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF NOT $ARET[0] THEN RETURN SETERROR(10, 0, 0)
	LOCAL $ICOUNT = $ARET[0]
	LOCAL $ARESULT[$ICOUNT + 1]
	FOR $I = 0 TO $ICOUNT - 1
		$ARET = DLLCALL("shell32.dll", "uint", "DragQueryFileW", "handle", $HDROP, "uint", $I, "wstr", "", "uint", 4096)
		IF NOT $ARET[0] THEN RETURN SETERROR(11, 0, 0)
		IF $IFLAG THEN
			LOCAL $BDIR = _WINAPI_PATHISDIRECTORY($ARET[3])
			IF(($IFLAG = 1) AND $BDIR) OR(($IFLAG = 2) AND NOT $BDIR) THEN
				CONTINUELOOP
			ENDIF
		ENDIF
		$ARESULT[$I + 1] = $ARET[3]
		$ARESULT[0] += 1
	NEXT
	IF NOT $ARESULT[0] THEN RETURN SETERROR(12, 0, 0)
	__INC($ARESULT, -1)
	RETURN $ARESULT
ENDFUNC
FUNC _WINAPI_DRAGQUERYPOINT($HDROP)
	LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
	LOCAL $ARET = DLLCALL("shell32.dll", "bool", "DragQueryPoint", "handle", $HDROP, "struct*", $TPOINT)
	IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $TPOINT
ENDFUNC
FUNC _WINAPI_ENDDEFERWINDOWPOS($HINFO)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "EndDeferWindowPos", "handle", $HINFO)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_ENUMCHILDWINDOWS($HWND, $BVISIBLE = TRUE)
	IF NOT _WINAPI_GETWINDOW($HWND, 5) THEN RETURN SETERROR(2, 0, 0)
	LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumWindowsProc", "bool", "hwnd;lparam")
	DIM $__G_VENUM[101][2] = [[0]]
	DLLCALL("user32.dll", "bool", "EnumChildWindows", "hwnd", $HWND, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "lparam", $BVISIBLE)
	IF @ERROR OR NOT $__G_VENUM[0][0] THEN
		$__G_VENUM = @ERROR + 10
	ENDIF
	DLLCALLBACKFREE($HENUMPROC)
	IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
	__INC($__G_VENUM, -1)
	RETURN $__G_VENUM
ENDFUNC
FUNC _WINAPI_FINDWINDOW($SCLASSNAME, $SWINDOWNAME)
	LOCAL $ARESULT = DLLCALL("user32.dll", "hwnd", "FindWindowW", "wstr", $SCLASSNAME, "wstr", $SWINDOWNAME)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_FLASHWINDOW($HWND, $BINVERT = TRUE)
	LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "FlashWindow", "hwnd", $HWND, "bool", $BINVERT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_FLASHWINDOWEX($HWND, $IFLAGS = 3, $ICOUNT = 3, $ITIMEOUT = 0)
	LOCAL $TFLASH = DLLSTRUCTCREATE($TAGFLASHWINFO)
	LOCAL $IFLASH = DLLSTRUCTGETSIZE($TFLASH)
	LOCAL $IMODE = 0
	IF BITAND($IFLAGS, 1) <> 0 THEN $IMODE = BITOR($IMODE, $FLASHW_CAPTION)
	IF BITAND($IFLAGS, 2) <> 0 THEN $IMODE = BITOR($IMODE, $FLASHW_TRAY)
	IF BITAND($IFLAGS, 4) <> 0 THEN $IMODE = BITOR($IMODE, $FLASHW_TIMER)
	IF BITAND($IFLAGS, 8) <> 0 THEN $IMODE = BITOR($IMODE, $FLASHW_TIMERNOFG)
	DLLSTRUCTSETDATA($TFLASH, "Size", $IFLASH)
	DLLSTRUCTSETDATA($TFLASH, "hWnd", $HWND)
	DLLSTRUCTSETDATA($TFLASH, "Flags", $IMODE)
	DLLSTRUCTSETDATA($TFLASH, "Count", $ICOUNT)
	DLLSTRUCTSETDATA($TFLASH, "Timeout", $ITIMEOUT)
	LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "FlashWindowEx", "struct*", $TFLASH)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_GETANCESTOR($HWND, $IFLAGS = 1)
	LOCAL $ARESULT = DLLCALL("user32.dll", "hwnd", "GetAncestor", "hwnd", $HWND, "uint", $IFLAGS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_GETCLASSINFOEX($SCLASS, $HINSTANCE = 0)
	LOCAL $STYPEOFCLASS = "ptr"
	IF ISSTRING($SCLASS) THEN
		$STYPEOFCLASS = "wstr"
	ENDIF
	LOCAL $TWNDCLASSEX = DLLSTRUCTCREATE($TAGWNDCLASSEX)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetClassInfoExW", "handle", $HINSTANCE, $STYPEOFCLASS, $SCLASS, "struct*", $TWNDCLASSEX)
	IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $TWNDCLASSEX
ENDFUNC
FUNC _WINAPI_GETCLASSLONGEX($HWND, $IINDEX)
	LOCAL $ARET
	IF @AUTOITX64 THEN
		$ARET = DLLCALL("user32.dll", "ulong_ptr", "GetClassLongPtrW", "hwnd", $HWND, "int", $IINDEX)
	ELSE
		$ARET = DLLCALL("user32.dll", "dword", "GetClassLongW", "hwnd", $HWND, "int", $IINDEX)
	ENDIF
	IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_GETCLIENTHEIGHT($HWND)
	LOCAL $TRECT = _WINAPI_GETCLIENTRECT($HWND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN DLLSTRUCTGETDATA($TRECT, "Bottom") - DLLSTRUCTGETDATA($TRECT, "Top")
ENDFUNC
FUNC _WINAPI_GETCLIENTWIDTH($HWND)
	LOCAL $TRECT = _WINAPI_GETCLIENTRECT($HWND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN DLLSTRUCTGETDATA($TRECT, "Right") - DLLSTRUCTGETDATA($TRECT, "Left")
ENDFUNC
FUNC _WINAPI_GETDLGITEM($HWND, $IITEMID)
	LOCAL $ARESULT = DLLCALL("user32.dll", "hwnd", "GetDlgItem", "hwnd", $HWND, "int", $IITEMID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_GETFOREGROUNDWINDOW()
	LOCAL $ARESULT = DLLCALL("user32.dll", "hwnd", "GetForegroundWindow")
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_GETGUITHREADINFO($ITHREADID)
	LOCAL CONST $TAGGUITHREADINFO = "dword Size;dword Flags;hwnd hWndActive;hwnd hWndFocus;hwnd hWndCapture;hwnd hWndMenuOwner;hwnd hWndMoveSize;hwnd hWndCaret;struct rcCaret;long left;long top;long right;long bottom;endstruct"
	LOCAL $TGTI = DLLSTRUCTCREATE($TAGGUITHREADINFO)
	DLLSTRUCTSETDATA($TGTI, 1, DLLSTRUCTGETSIZE($TGTI))
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetGUIThreadInfo", "dword", $ITHREADID, "struct*", $TGTI)
	IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	LOCAL $ARESULT[11]
	FOR $I = 0 TO 10
		$ARESULT[$I] = DLLSTRUCTGETDATA($TGTI, $I + 2)
	NEXT
	FOR $I = 9 TO 10
		$ARESULT[$I] -= $ARESULT[$I - 2]
	NEXT
	RETURN $ARESULT
ENDFUNC
FUNC _WINAPI_GETLASTACTIVEPOPUP($HWND)
	LOCAL $ARET = DLLCALL("user32.dll", "hwnd", "GetLastActivePopup", "hwnd", $HWND)
	IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	IF $ARET[0] = $HWND THEN RETURN SETERROR(1, 0, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_GETLAYEREDWINDOWATTRIBUTES($HWND, BYREF $ITRANSCOLOR, BYREF $ITRANSGUI, $BCOLORREF = FALSE)
	$ITRANSCOLOR = -1
	$ITRANSGUI = -1
	LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "GetLayeredWindowAttributes", "hwnd", $HWND, "INT*", $ITRANSCOLOR, "byte*", $ITRANSGUI, "dword*", 0)
	IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	IF NOT $BCOLORREF THEN
		$ARESULT[2] = INT(BINARYMID($ARESULT[2], 3, 1) & BINARYMID($ARESULT[2], 2, 1) & BINARYMID($ARESULT[2], 1, 1))
	ENDIF
	$ITRANSCOLOR = $ARESULT[2]
	$ITRANSGUI = $ARESULT[3]
	RETURN $ARESULT[4]
ENDFUNC
FUNC _WINAPI_GETMESSAGEEXTRAINFO()
	LOCAL $ARET = DLLCALL("user32.dll", "lparam", "GetMessageExtraInfo")
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_GETSHELLWINDOW()
	LOCAL $ARET = DLLCALL("user32.dll", "hwnd", "GetShellWindow")
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_GETTOPWINDOW($HWND)
	LOCAL $ARET = DLLCALL("user32.dll", "hwnd", "GetTopWindow", "hwnd", $HWND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_GETWINDOWDISPLAYAFFINITY($HWND)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetWindowDisplayAffinity", "hwnd", $HWND, "dword*", 0)
	IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $ARET[2]
ENDFUNC
FUNC _WINAPI_GETWINDOWINFO($HWND)
	LOCAL $TWINDOWINFO = DLLSTRUCTCREATE($TAGWINDOWINFO)
	DLLSTRUCTSETDATA($TWINDOWINFO, "Size", DLLSTRUCTGETSIZE($TWINDOWINFO))
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetWindowInfo", "hwnd", $HWND, "struct*", $TWINDOWINFO)
	IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $TWINDOWINFO
ENDFUNC
FUNC _WINAPI_GETWINDOWPLACEMENT($HWND)
	LOCAL $TWINDOWPLACEMENT = DLLSTRUCTCREATE($TAGWINDOWPLACEMENT)
	DLLSTRUCTSETDATA($TWINDOWPLACEMENT, "length", DLLSTRUCTGETSIZE($TWINDOWPLACEMENT))
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetWindowPlacement", "hwnd", $HWND, "struct*", $TWINDOWPLACEMENT)
	IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	RETURN $TWINDOWPLACEMENT
ENDFUNC
FUNC _WINAPI_ISCHILD($HWND, $HWNDPARENT)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "IsChild", "hwnd", $HWNDPARENT, "hwnd", $HWND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_ISHUNGAPPWINDOW($HWND)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "IsHungAppWindow", "hwnd", $HWND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_ISICONIC($HWND)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "IsIconic", "hwnd", $HWND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_ISWINDOWUNICODE($HWND)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "IsWindowUnicode", "hwnd", $HWND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_ISZOOMED($HWND)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "IsZoomed", "hwnd", $HWND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_KILLTIMER($HWND, $ITIMERID)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "KillTimer", "hwnd", $HWND, "uint_ptr", $ITIMERID)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_OPENICON($HWND)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "OpenIcon", "hwnd", $HWND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_POSTMESSAGE($HWND, $IMSG, $WPARAM, $LPARAM)
	LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "PostMessage", "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_REGISTERCLASS($TWNDCLASS)
	LOCAL $ARET = DLLCALL("user32.dll", "word", "RegisterClassW", "struct*", $TWNDCLASS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_REGISTERCLASSEX($TWNDCLASSEX)
	LOCAL $ARET = DLLCALL("user32.dll", "word", "RegisterClassExW", "struct*", $TWNDCLASSEX)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_REGISTERSHELLHOOKWINDOW($HWND)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "RegisterShellHookWindow", "hwnd", $HWND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_REGISTERWINDOWMESSAGE($SMESSAGE)
	LOCAL $ARESULT = DLLCALL("user32.dll", "uint", "RegisterWindowMessageW", "wstr", $SMESSAGE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_SENDMESSAGETIMEOUT($HWND, $IMSG, $WPARAM = 0, $LPARAM = 0, $ITIMEOUT = 1000, $IFLAGS = 0)
	LOCAL $ARET = DLLCALL("user32.dll", "lresult", "SendMessageTimeoutW", "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM, "uint", $IFLAGS, "uint", $ITIMEOUT, "dword_ptr*", 0)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
	IF NOT $ARET[0] THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), -1)
	RETURN $ARET[7]
ENDFUNC
FUNC _WINAPI_SETCLASSLONGEX($HWND, $IINDEX, $INEWLONG)
	LOCAL $ARET
	IF @AUTOITX64 THEN
		$ARET = DLLCALL("user32.dll", "ulong_ptr", "SetClassLongPtrW", "hwnd", $HWND, "int", $IINDEX, "long_ptr", $INEWLONG)
	ELSE
		$ARET = DLLCALL("user32.dll", "dword", "SetClassLongW", "hwnd", $HWND, "int", $IINDEX, "long", $INEWLONG)
	ENDIF
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_SETFOREGROUNDWINDOW($HWND)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "SetForegroundWindow", "hwnd", $HWND)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_SETLAYEREDWINDOWATTRIBUTES($HWND, $ITRANSCOLOR, $ITRANSGUI = 255, $IFLAGS = 3, $BCOLORREF = FALSE)
	IF $IFLAGS = DEFAULT OR $IFLAGS = "" OR $IFLAGS < 0 THEN $IFLAGS = 3
	IF NOT $BCOLORREF THEN
		$ITRANSCOLOR = INT(BINARYMID($ITRANSCOLOR, 3, 1) & BINARYMID($ITRANSCOLOR, 2, 1) & BINARYMID($ITRANSCOLOR, 1, 1))
	ENDIF
	LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "SetLayeredWindowAttributes", "hwnd", $HWND, "INT", $ITRANSCOLOR, "byte", $ITRANSGUI, "dword", $IFLAGS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_SETMESSAGEEXTRAINFO($LPARAM)
	LOCAL $ARET = DLLCALL("user32.dll", "lparam", "SetMessageExtraInfo", "lparam", $LPARAM)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_SETSYSCOLORS($VELEMENTS, $VCOLORS)
	LOCAL $BISEARRAY = ISARRAY($VELEMENTS), $BISCARRAY = ISARRAY($VCOLORS)
	LOCAL $IELEMENTNUM
	IF NOT $BISCARRAY AND NOT $BISEARRAY THEN
		$IELEMENTNUM = 1
	ELSEIF $BISCARRAY OR $BISEARRAY THEN
		IF NOT $BISCARRAY OR NOT $BISEARRAY THEN RETURN SETERROR(-1, -1, FALSE)
		IF UBOUND($VELEMENTS) <> UBOUND($VCOLORS) THEN RETURN SETERROR(-1, -1, FALSE)
		$IELEMENTNUM = UBOUND($VELEMENTS)
	ENDIF
	LOCAL $TELEMENTS = DLLSTRUCTCREATE("int Element[" & $IELEMENTNUM & "]")
	LOCAL $TCOLORS = DLLSTRUCTCREATE("INT NewColor[" & $IELEMENTNUM & "]")
	IF NOT $BISEARRAY THEN
		DLLSTRUCTSETDATA($TELEMENTS, "Element", $VELEMENTS, 1)
	ELSE
		FOR $X = 0 TO $IELEMENTNUM - 1
			DLLSTRUCTSETDATA($TELEMENTS, "Element", $VELEMENTS[$X], $X + 1)
		NEXT
	ENDIF
	IF NOT $BISCARRAY THEN
		DLLSTRUCTSETDATA($TCOLORS, "NewColor", $VCOLORS, 1)
	ELSE
		FOR $X = 0 TO $IELEMENTNUM - 1
			DLLSTRUCTSETDATA($TCOLORS, "NewColor", $VCOLORS[$X], $X + 1)
		NEXT
	ENDIF
	LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "SetSysColors", "int", $IELEMENTNUM, "struct*", $TELEMENTS, "struct*", $TCOLORS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_SETTIMER($HWND, $ITIMERID, $IELAPSE, $PTIMERFUNC)
	LOCAL $ARET = DLLCALL("user32.dll", "uint_ptr", "SetTimer", "hwnd", $HWND, "uint_ptr", $ITIMERID, "uint", $IELAPSE, "ptr", $PTIMERFUNC)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_SETWINDOWDISPLAYAFFINITY($HWND, $IAFFINITY)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "SetWindowDisplayAffinity", "hwnd", $HWND, "dword", $IAFFINITY)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_SETWINDOWLONG($HWND, $IINDEX, $IVALUE)
	_WINAPI_SETLASTERROR(0)
	LOCAL $SFUNCNAME = "SetWindowLongW"
	IF @AUTOITX64 THEN $SFUNCNAME = "SetWindowLongPtrW"
	LOCAL $ARESULT = DLLCALL("user32.dll", "long_ptr", $SFUNCNAME, "hwnd", $HWND, "int", $IINDEX, "long_ptr", $IVALUE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_SETWINDOWPLACEMENT($HWND, $TWINDOWPLACEMENT)
	LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "SetWindowPlacement", "hwnd", $HWND, "struct*", $TWINDOWPLACEMENT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_SHOWOWNEDPOPUPS($HWND, $BSHOW)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "ShowOwnedPopups", "hwnd", $HWND, "bool", $BSHOW)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_SWITCHTOTHISWINDOW($HWND, $BALTTAB = FALSE)
	DLLCALL("user32.dll", "none", "SwitchToThisWindow", "hwnd", $HWND, "bool", $BALTTAB)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN 1
ENDFUNC
FUNC _WINAPI_TILEWINDOWS($AWNDS, $TRECT = 0, $HPARENT = 0, $IFLAGS = 0, $ISTART = 0, $IEND = -1)
	IF __CHECKERRORARRAYBOUNDS($AWNDS, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
	LOCAL $ICOUNT = $IEND - $ISTART + 1
	LOCAL $TWNDS = DLLSTRUCTCREATE("hwnd[" & $ICOUNT & "]")
	$ICOUNT = 1
	FOR $I = $ISTART TO $IEND
		DLLSTRUCTSETDATA($TWNDS, 1, $AWNDS[$I], $ICOUNT)
		$ICOUNT += 1
	NEXT
	LOCAL $ARET = DLLCALL("user32.dll", "word", "TileWindows", "hwnd", $HPARENT, "uint", $IFLAGS, "struct*", $TRECT, "uint", $ICOUNT - 1, "struct*", $TWNDS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_UNREGISTERCLASS($SCLASS, $HINSTANCE = 0)
	LOCAL $STYPEOFCLASS = "ptr"
	IF ISSTRING($SCLASS) THEN
		$STYPEOFCLASS = "wstr"
	ENDIF
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "UnregisterClassW", $STYPEOFCLASS, $SCLASS, "handle", $HINSTANCE)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_UPDATELAYEREDWINDOW($HWND, $HDESTDC, $TPTDEST, $TSIZE, $HSRCDC, $TPTSRCE, $IRGB, $TBLEND, $IFLAGS)
	LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $HWND, "handle", $HDESTDC, "struct*", $TPTDEST, "struct*", $TSIZE, "handle", $HSRCDC, "struct*", $TPTSRCE, "dword", $IRGB, "struct*", $TBLEND, "dword", $IFLAGS)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARESULT[0]
ENDFUNC
FUNC _WINAPI_UPDATELAYEREDWINDOWEX($HWND, $IX, $IY, $HBITMAP, $IOPACITY = 255, $BDELETE = FALSE)
	LOCAL $ARET = DLLCALL("user32.dll", "handle", "GetDC", "hwnd", $HWND)
	LOCAL $HDC = $ARET[0]
	$ARET = DLLCALL("gdi32.dll", "handle", "CreateCompatibleDC", "handle", $HDC)
	LOCAL $HDESTDC = $ARET[0]
	$ARET = DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDESTDC, "handle", $HBITMAP)
	LOCAL $HDESTSV = $ARET[0]
	LOCAL $TPOINT
	IF($IX = -1) AND($IY = -1) THEN
		$TPOINT = DLLSTRUCTCREATE("int;int")
	ELSE
		$TPOINT = DLLSTRUCTCREATE("int;int;int;int")
		DLLSTRUCTSETDATA($TPOINT, 3, $IX)
		DLLSTRUCTSETDATA($TPOINT, 4, $IY)
	ENDIF
	DLLSTRUCTSETDATA($TPOINT, 1, 0)
	DLLSTRUCTSETDATA($TPOINT, 2, 0)
	LOCAL $TBLENDFUNCTION = DLLSTRUCTCREATE($TAGBLENDFUNCTION)
	DLLSTRUCTSETDATA($TBLENDFUNCTION, 1, 0)
	DLLSTRUCTSETDATA($TBLENDFUNCTION, 2, 0)
	DLLSTRUCTSETDATA($TBLENDFUNCTION, 3, $IOPACITY)
	DLLSTRUCTSETDATA($TBLENDFUNCTION, 4, 1)
	LOCAL CONST $TAGBITMAP = "struct;long bmType;long bmWidth;long bmHeight;long bmWidthBytes;ushort bmPlanes;ushort bmBitsPixel;ptr bmBits;endstruct"
	LOCAL $TOBJ = DLLSTRUCTCREATE($TAGBITMAP)
	DLLCALL("gdi32.dll", "int", "GetObject", "handle", $HBITMAP, "int", DLLSTRUCTGETSIZE($TOBJ), "struct*", $TOBJ)
	LOCAL $TSIZE = DLLSTRUCTCREATE($TAGSIZE, DLLSTRUCTGETPTR($TOBJ, "bmWidth"))
	$ARET = DLLCALL("user32.dll", "bool", "UpdateLayeredWindow", "hwnd", $HWND, "handle", $HDC, "ptr", DLLSTRUCTGETPTR($TPOINT, 3), "struct*", $TSIZE, "handle", $HDESTDC, "struct*", $TPOINT, "dword", 0, "struct*", $TBLENDFUNCTION, "dword", 2)
	LOCAL $IERROR = @ERROR
	DLLCALL("user32.dll", "bool", "ReleaseDC", "hwnd", $HWND, "handle", $HDC)
	DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDESTDC, "handle", $HDESTSV)
	DLLCALL("gdi32.dll", "bool", "DeleteDC", "handle", $HDESTDC)
	IF $IERROR THEN RETURN SETERROR($IERROR, 0, FALSE)
	IF $BDELETE THEN
		DLLCALL("gdi32.dll", "bool", "DeleteObject", "handle", $HBITMAP)
	ENDIF
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_UPDATELAYEREDWINDOWINDIRECT($HWND, $TULWINFO)
	LOCAL $ARET = DLLCALL("user32.dll", "bool", "UpdateLayeredWindowIndirect", "hwnd", $HWND, "struct*", $TULWINFO)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
	RETURN $ARET[0]
ENDFUNC
FUNC _WINAPI_WINDOWFROMPOINT(BYREF $TPOINT)
	LOCAL $ARESULT = DLLCALL("user32.dll", "hwnd", "WindowFromPoint", "struct", $TPOINT)
	IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
	RETURN $ARESULT[0]
ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __ENUMDEFAULTPROC($PDATA, $LPARAM)
		#forceref $LPARAM
		LOCAL $ILENGTH = _WINAPI_STRLEN($PDATA)
		__INC($__G_VENUM)
		IF $ILENGTH THEN
			$__G_VENUM[$__G_VENUM[0]] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & ($ILENGTH + 1) & "]", $PDATA), 1)
		ELSE
			$__G_VENUM[$__G_VENUM[0]] = ""
		ENDIF
		RETURN 1
	ENDFUNC
#EndRegion Internal Functions
#Region Global Variables and Constants
	GLOBAL CONST $TAGOSVERSIONINFOEX = $TAGOSVERSIONINFO & ";ushort ServicePackMajor;ushort ServicePackMinor;ushort SuiteMask;byte ProductType;byte Reserved"
	GLOBAL CONST $TAGRAWINPUTDEVICE = "struct;ushort UsagePage;ushort Usage;dword Flags;hwnd hTarget;endstruct"
	GLOBAL CONST $TAGRAWINPUTHEADER = "struct;dword Type;dword Size;handle hDevice;wparam wParam;endstruct"
	GLOBAL CONST $TAGRAWMOUSE = "ushort Flags;ushort Alignment;ushort ButtonFlags;ushort ButtonData;ulong RawButtons;long LastX;long LastY;ulong ExtraInformation;"
	GLOBAL CONST $TAGRAWKEYBOARD = "ushort MakeCode;ushort Flags;ushort Reserved;ushort VKey;uint Message;ulong ExtraInformation;"
	GLOBAL CONST $TAGRAWHID = "dword SizeHid;dword Count;"
	GLOBAL CONST $TAGRAWINPUTMOUSE = $TAGRAWINPUTHEADER & ";" & $TAGRAWMOUSE
	GLOBAL CONST $TAGRAWINPUTKEYBOARD = $TAGRAWINPUTHEADER & ";" & $TAGRAWKEYBOARD
	GLOBAL CONST $TAGRAWINPUTHID = $TAGRAWINPUTHEADER & ";" & $TAGRAWHID
	GLOBAL CONST $TAGRID_DEVICE_INFO_MOUSE = "struct;dword Id;dword NumberOfButtons;dword SampleRate;int HasHorizontalWheel;endstruc"
	GLOBAL CONST $TAGRID_DEVICE_INFO_KEYBOARD = "struct;dword KbType;dword KbSubType;dword KeyboardMode;dword NumberOfFunctionKeys;dword NumberOfIndicators;dword NumberOfKeysTotal;endstruc"
	GLOBAL CONST $TAGRID_DEVICE_INFO_HID = "struct;dword VendorId;dword ProductId;dword VersionNumber;ushort UsagePage;ushort Usage;endstruc"
	GLOBAL CONST $TAGRID_INFO_MOUSE = "dword Size;dword Type;" & $TAGRID_DEVICE_INFO_MOUSE & ";dword Unused[2];"
	GLOBAL CONST $TAGRID_INFO_KEYBOARD = "dword Size;dword Type;" & $TAGRID_DEVICE_INFO_KEYBOARD
	GLOBAL CONST $TAGRID_INFO_HID = "dword Size;dword Type;" & $TAGRID_DEVICE_INFO_HID & ";dword Unused[2]"
	GLOBAL CONST $TAGUSEROBJECTFLAGS = "int Inherit;int Reserved;dword Flags"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_ACTIVATEKEYBOARDLAYOUT($HLOCALE, $IFLAG = 0)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "ActivateKeyboardLayout", "handle", $HLOCALE, "uint", $IFLAG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ADDCLIPBOARDFORMATLISTENER($HWND)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "AddClipboardFormatListener", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CALLNEXTHOOKEX($HHOOK, $ICODE, $WPARAM, $LPARAM)
		LOCAL $ARESULT = DLLCALL("user32.dll", "lresult", "CallNextHookEx", "handle", $HHOOK, "int", $ICODE, "wparam", $WPARAM, "lparam", $LPARAM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_CLOSEDESKTOP($HDESKTOP)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "CloseDesktop", "handle", $HDESKTOP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CLOSEWINDOWSTATION($HSTATION)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "CloseWindowStation", "handle", $HSTATION)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_COMPRESSBUFFER($PUNCOMPRESSEDBUFFER, $IUNCOMPRESSEDSIZE, $PCOMPRESSEDBUFFER, $ICOMPRESSEDSIZE, $IFORMATANDENGINE = 2)
		LOCAL $ARET, $PWORKSPACE = 0, $IERROR = 0
		DO
			$ARET = DLLCALL("ntdll.dll", "uint", "RtlGetCompressionWorkSpaceSize", "ushort", $IFORMATANDENGINE, "ulong*", 0, "ulong*", 0)
			IF @ERROR OR $ARET[0] THEN
				$IERROR = @ERROR + 20
				EXITLOOP
			ENDIF
			$PWORKSPACE = __HEAPALLOC($ARET[2])
			IF @ERROR THEN
				$IERROR = @ERROR + 100
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("ntdll.dll", "uint", "RtlCompressBuffer", "ushort", $IFORMATANDENGINE, "struct*", $PUNCOMPRESSEDBUFFER, "ulong", $IUNCOMPRESSEDSIZE, "struct*", $PCOMPRESSEDBUFFER, "ulong", $ICOMPRESSEDSIZE, "ulong", 4096, "ulong*", 0, "ptr", $PWORKSPACE)
			IF @ERROR OR $ARET[0] OR NOT $ARET[7] THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
		UNTIL 1
		__HEAPFREE($PWORKSPACE)
		IF $IERROR THEN
			IF ISARRAY($ARET) THEN
				RETURN SETERROR(10, $ARET[0], 0)
			ELSE
				RETURN SETERROR($IERROR, 0, 0)
			ENDIF
		ENDIF
		RETURN $ARET[7]
	ENDFUNC
	FUNC _WINAPI_COMPUTECRC32($PMEMORY, $ILENGTH)
		IF _WINAPI_ISBADREADPTR($PMEMORY, $ILENGTH) THEN RETURN SETERROR(1, @EXTENDED, 0)
		LOCAL $ARET = DLLCALL("ntdll.dll", "dword", "RtlComputeCrc32", "dword", 0, "struct*", $PMEMORY, "int", $ILENGTH)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEDESKTOP($SNAME, $IACCESS = 2, $IFLAGS = 0, $IHEAP = 0, $TSECURITY = 0)
		LOCAL $ARET
		IF $IHEAP THEN
			$ARET = DLLCALL("user32.dll", "handle", "CreateDesktopExW", "wstr", $SNAME, "ptr", 0, "ptr", 0, "dword", $IFLAGS, "dword", $IACCESS, "struct*", $TSECURITY, "ulong", $IHEAP, "ptr", 0)
		ELSE
			$ARET = DLLCALL("user32.dll", "handle", "CreateDesktopW", "wstr", $SNAME, "ptr", 0, "ptr", 0, "dword", $IFLAGS, "dword", $IACCESS, "struct*", $TSECURITY)
		ENDIF
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEWINDOWSTATION($SNAME = "", $IACCESS = 0, $IFLAGS = 0, $TSECURITY = 0)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "CreateWindowStationW", "wstr", $SNAME, "dword", $IFLAGS, "dword", $IACCESS, "struct*", $TSECURITY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DECOMPRESSBUFFER($PUNCOMPRESSEDBUFFER, $IUNCOMPRESSEDSIZE, $PCOMPRESSEDBUFFER, $ICOMPRESSEDSIZE, $IFORMAT = 2)
		LOCAL $ARET = DLLCALL("ntdll.dll", "long", "RtlDecompressBuffer", "ushort", $IFORMAT, "struct*", $PUNCOMPRESSEDBUFFER, "ulong", $IUNCOMPRESSEDSIZE, "struct*", $PCOMPRESSEDBUFFER, "ulong", $ICOMPRESSEDSIZE, "ulong*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[6]
	ENDFUNC
	FUNC _WINAPI_DEFRAWINPUTPROC($PARAWINPUT, $IINPUT)
		LOCAL $ARET = DLLCALL("user32.dll", "lresult", "DefRawInputProc", "ptr", $PARAWINPUT, "int", $IINPUT, "uint", DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGRAWINPUTHEADER)))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_ENUMDESKTOPS($HSTATION)
		IF STRINGCOMPARE(_WINAPI_GETUSEROBJECTINFORMATION($HSTATION, 3), "WindowStation") THEN RETURN SETERROR(1, 0, 0)
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumDefaultProc", "bool", "ptr;lparam")
		DIM $__G_VENUM[101] = [0]
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "EnumDesktopsW", "handle", $HSTATION, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "lparam", 0)
		IF @ERROR OR NOT $ARET[0] OR NOT $__G_VENUM[0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_ENUMDESKTOPWINDOWS($HDESKTOP, $BVISIBLE = TRUE)
		IF STRINGCOMPARE(_WINAPI_GETUSEROBJECTINFORMATION($HDESKTOP, 3), "Desktop") THEN RETURN SETERROR(1, 0, 0)
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumWindowsProc", "bool", "hwnd;lparam")
		DIM $__G_VENUM[101][2] = [[0]]
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "EnumDesktopWindows", "handle", $HDESKTOP, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "lparam", $BVISIBLE)
		IF @ERROR OR NOT $ARET[0] OR NOT $__G_VENUM[0][0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_ENUMPAGEFILES()
		LOCAL $AINFO = _WINAPI_GETSYSTEMINFO()
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumPageFilesProc", "bool", "lparam;ptr;ptr")
		DIM $__G_VENUM[101][4] = [[0]]
		LOCAL $ARET = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EnumPageFilesW", "ptr", DLLCALLBACKGETPTR($HENUMPROC), "lparam", $AINFO[1])
		IF @ERROR OR NOT $ARET[0] OR NOT $__G_VENUM[0][0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_ENUMRAWINPUTDEVICES()
		LOCAL CONST $TAGRAWINPUTDEVICELIST = "struct;handle hDevice;dword Type;endstruct"
		LOCAL $TRIDL, $ILENGTH = DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGRAWINPUTDEVICELIST))
		LOCAL $ARET = DLLCALL("user32.dll", "uint", "GetRawInputDeviceList", "ptr", 0, "uint*", 0, "uint", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		IF($ARET[0] = 4294967295) OR(NOT $ARET[2]) THEN RETURN SETERROR(10, -1, 0)
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[" & ($ARET[2] * $ILENGTH) & "]")
		LOCAL $PDATA = DLLSTRUCTGETPTR($TDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, 0, 0)
		$ARET = DLLCALL("user32.dll", "uint", "GetRawInputDeviceList", "ptr", $PDATA, "uint*", $ARET[2], "uint", $ILENGTH)
		IF($ARET[0] = 4294967295) OR(NOT $ARET[0]) THEN RETURN SETERROR(1, -1, 0)
		LOCAL $ARESULT[$ARET[2] + 1][2] = [[$ARET[2]]]
		FOR $I = 1 TO $ARET[2]
			$TRIDL = DLLSTRUCTCREATE("ptr;dword", $PDATA + $ILENGTH * ($I - 1))
			FOR $J = 0 TO 1
				$ARESULT[$I][$J] = DLLSTRUCTGETDATA($TRIDL, $J + 1)
			NEXT
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_ENUMWINDOWSTATIONS()
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumDefaultProc", "bool", "ptr;lparam")
		DIM $__G_VENUM[101] = [0]
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "EnumWindowStationsW", "ptr", DLLCALLBACKGETPTR($HENUMPROC), "lparam", 0)
		IF @ERROR OR NOT $ARET[0] OR NOT $__G_VENUM[0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_EXPANDENVIRONMENTSTRINGS($SSTRING)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $SSTRING, "wstr", "", "dword", 4096)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARESULT[2]
	ENDFUNC
	FUNC _WINAPI_GETACTIVEWINDOW()
		LOCAL $ARET = DLLCALL("user32.dll", "hwnd", "GetActiveWindow")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETASYNCKEYSTATE($IKEY)
		LOCAL $ARESULT = DLLCALL("user32.dll", "short", "GetAsyncKeyState", "int", $IKEY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETCLIPBOARDSEQUENCENUMBER()
		LOCAL $ARET = DLLCALL("user32.dll", "dword", "GetClipboardSequenceNumber")
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETCURRENTHWPROFILE()
		LOCAL $TAGHW_PROFILE_INFO = "dword DockInfo;wchar szHwProfileGuid[39];wchar szHwProfileName[80]"
		LOCAL $THWPI = DLLSTRUCTCREATE($TAGHW_PROFILE_INFO)
		LOCAL $ARET = DLLCALL("advapi32.dll", "bool", "GetCurrentHwProfileW", "struct*", $THWPI)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARESULT[3]
		FOR $I = 0 TO 2
			$ARESULT[$I] = DLLSTRUCTGETDATA($THWPI, $I + 1)
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETDEFAULTPRINTER()
		LOCAL $ARET = DLLCALL("winspool.drv", "bool", "GetDefaultPrinterW", "wstr", "", "dword*", 2048)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF NOT $ARET[0] THEN RETURN SETERROR(10, _WINAPI_GETLASTERROR(), "")
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_GETDLLDIRECTORY()
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "GetDllDirectoryW", "dword", 4096, "wstr", "")
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_GETEFFECTIVECLIENTRECT($HWND, $ACTRL, $ISTART = 0, $IEND = -1)
		IF NOT ISARRAY($ACTRL) THEN
			LOCAL $ICTRL = $ACTRL
			DIM $ACTRL[1] = [$ICTRL]
			$ISTART = 0
			$IEND = 0
		ENDIF
		IF __CHECKERRORARRAYBOUNDS($ACTRL, $ISTART, $IEND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ICOUNT = $IEND - $ISTART + 1
		LOCAL $TCTRL = DLLSTRUCTCREATE("uint64[" & ($ICOUNT + 2) & "]")
		$ICOUNT = 2
		FOR $I = $ISTART TO $IEND
			IF ISHWND($ACTRL[$I]) THEN
				$ACTRL[$I] = _WINAPI_GETDLGCTRLID($ACTRL[$I])
			ENDIF
			DLLSTRUCTSETDATA($TCTRL, 1, _WINAPI_MAKEQWORD(1, $ACTRL[$I]), $ICOUNT)
			$ICOUNT += 1
		NEXT
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		DLLCALL("comctl32.dll", "none", "GetEffectiveClientRect", "hwnd", $HWND, "struct*", $TRECT, "struct*", $TCTRL)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_GETHANDLEINFORMATION($HOBJECT)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetHandleInformation", "handle", $HOBJECT, "dword*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_GETIDLETIME()
		LOCAL $TLASTINPUTINFO = DLLSTRUCTCREATE("uint;dword")
		DLLSTRUCTSETDATA($TLASTINPUTINFO, 1, DLLSTRUCTGETSIZE($TLASTINPUTINFO))
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetLastInputInfo", "struct*", $TLASTINPUTINFO)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN _WINAPI_GETTICKCOUNT() - DLLSTRUCTGETDATA($TLASTINPUTINFO, 2)
	ENDFUNC
	FUNC _WINAPI_GETKEYBOARDLAYOUT($HWND)
		LOCAL $ARET = DLLCALL("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $HWND, "ptr", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		$ARET = DLLCALL("user32.dll", "handle", "GetKeyboardLayout", "dword", $ARET[0])
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETKEYBOARDLAYOUTLIST()
		LOCAL $ARET = DLLCALL("user32.dll", "uint", "GetKeyboardLayoutList", "int", 0, "ptr", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TDATA = DLLSTRUCTCREATE("handle[" & $ARET[0] & "]")
		$ARET = DLLCALL("user32.dll", "uint", "GetKeyboardLayoutList", "int", $ARET[0], "struct*", $TDATA)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ALIST[$ARET[0] + 1] = [$ARET[0]]
		FOR $I = 1 TO $ALIST[0]
			$ALIST[$I] = DLLSTRUCTGETDATA($TDATA, 1, $I)
		NEXT
		RETURN $ALIST
	ENDFUNC
	FUNC _WINAPI_GETKEYBOARDSTATE()
		LOCAL $TDATA = DLLSTRUCTCREATE("byte[256]")
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetKeyboardState", "struct*", $TDATA)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TDATA
	ENDFUNC
	FUNC _WINAPI_GETKEYBOARDTYPE($ITYPE)
		LOCAL $ARET = DLLCALL("user32.dll", "int", "GetKeyboardType", "int", $ITYPE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETKEYNAMETEXT($LPARAM)
		LOCAL $ARET = DLLCALL("user32.dll", "int", "GetKeyNameTextW", "long", $LPARAM, "wstr", "", "int", 128)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_GETKEYSTATE($VKEY)
		LOCAL $ARET = DLLCALL("user32.dll", "short", "GetKeyState", "int", $VKEY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETMODULEHANDLEEX($SMODULE, $IFLAGS = 0)
		LOCAL $STYPEOFMODULE = "ptr"
		IF ISSTRING($SMODULE) THEN
			IF STRINGSTRIPWS($SMODULE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
				$STYPEOFMODULE = "wstr"
			ELSE
				$SMODULE = 0
			ENDIF
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetModuleHandleExW", "dword", $IFLAGS, $STYPEOFMODULE, $SMODULE, "ptr*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_GETMUILANGUAGE()
		LOCAL $ARET = DLLCALL("comctl32.dll", "word", "GetMUILanguage")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETPERFORMANCEINFO()
		LOCAL $TPI = DLLSTRUCTCREATE("dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;dword;dword;dword")
		LOCAL $ARET = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "GetPerformanceInfo", "struct*", $TPI, "dword", DLLSTRUCTGETSIZE($TPI))
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARESULT[13]
		FOR $I = 0 TO 12
			$ARESULT[$I] = DLLSTRUCTGETDATA($TPI, $I + 2)
		NEXT
		FOR $I = 0 TO 8
			$ARESULT[$I] *= $ARESULT[9]
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETPROCADDRESS($HMODULE, $VNAME)
		LOCAL $STYPE = "str"
		IF ISNUMBER($VNAME) THEN $STYPE = "word"
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "ptr", "GetProcAddress", "handle", $HMODULE, $STYPE, $VNAME)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETPHYSICALLYINSTALLEDSYSTEMMEMORY()
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetPhysicallyInstalledSystemMemory", "uint64*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_GETPROCESSSHUTDOWNPARAMETERS()
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetProcessShutdownParameters", "dword*", 0, "dword*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN SETEXTENDED(NUMBER(NOT $ARET[2]), $ARET[1])
	ENDFUNC
	FUNC _WINAPI_GETPROCESSWINDOWSTATION()
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "GetProcessWindowStation")
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETPWRCAPABILITIES()
		IF NOT __DLL("powrprof.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $TSPC = DLLSTRUCTCREATE("byte[18];byte[3];byte;byte[8];byte[2];ulong[6];ulong[5]")
		LOCAL $ARET = DLLCALL("powrprof.dll", "boolean", "GetPwrCapabilities", "struct*", $TSPC)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARESULT[25]
		FOR $I = 0 TO 17
			$ARESULT[$I] = DLLSTRUCTGETDATA($TSPC, 1, $I + 1)
		NEXT
		$ARESULT[18] = DLLSTRUCTGETDATA($TSPC, 3)
		FOR $I = 19 TO 20
			$ARESULT[$I] = DLLSTRUCTGETDATA($TSPC, 5, $I - 18)
		NEXT
		FOR $I = 21 TO 24
			$ARESULT[$I] = DLLSTRUCTGETDATA($TSPC, 7, $I - 20)
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETRAWINPUTBUFFER($PBUFFER, $ILENGTH)
		LOCAL $ARET = DLLCALL("user32.dll", "uint", "GetRawInputBuffer", "struct*", $PBUFFER, "uint*", $ILENGTH, "uint", DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGRAWINPUTHEADER)))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF($ARET[0] = 4294967295) OR(NOT $ARET[1]) THEN RETURN SETERROR(10, -1, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETRAWINPUTBUFFERLENGTH()
		LOCAL $ARET = DLLCALL("user32.dll", "uint", "GetRawInputBuffer", "ptr", 0, "uint*", 0, "uint", DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGRAWINPUTHEADER)))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] = 4294967295 THEN RETURN SETERROR(10, -1, 0)
		RETURN $ARET[2] * 8
	ENDFUNC
	FUNC _WINAPI_GETRAWINPUTDATA($HRAWINPUT, $PBUFFER, $ILENGTH, $IFLAG)
		LOCAL $ARET = DLLCALL("user32.dll", "uint", "GetRawInputData", "handle", $HRAWINPUT, "uint", $IFLAG, "struct*", $PBUFFER, "uint*", $ILENGTH, "uint", DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGRAWINPUTHEADER)))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] = 4294967295 THEN RETURN SETERROR(10, -1, 0)
		RETURN($ARET[3] ? $ARET[0] : $ARET[4])
	ENDFUNC
	FUNC _WINAPI_GETRAWINPUTDEVICEINFO($HDEVICE, $PBUFFER, $ILENGTH, $IFLAG)
		LOCAL $ARET = DLLCALL("user32.dll", "uint", "GetRawInputDeviceInfoW", "handle", $HDEVICE, "uint", $IFLAG, "struct*", $PBUFFER, "uint*", $ILENGTH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] = 4294967295 THEN RETURN SETERROR(10, -1, 0)
		RETURN($ARET[3] ? $ARET[0] : $ARET[4])
	ENDFUNC
	FUNC _WINAPI_GETREGISTEREDRAWINPUTDEVICES($PBUFFER, $ILENGTH)
		LOCAL $ILENGTHRAW = DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGRAWINPUTDEVICE))
		LOCAL $ARET = DLLCALL("user32.dll", "uint", "GetRegisteredRawInputDevices", "struct*", $PBUFFER, "uint*", FLOOR($ILENGTH / $ILENGTHRAW), "uint", $ILENGTHRAW)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] = 4294967295 THEN
			LOCAL $ILASTERROR = _WINAPI_GETLASTERROR()
			IF $ILASTERROR = 122 THEN RETURN SETEXTENDED($ILASTERROR, $ARET[2] * $ILENGTHRAW)
			RETURN SETERROR(10, $ILASTERROR, 0)
		ENDIF
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETSTARTUPINFO()
		LOCAL $TSI = DLLSTRUCTCREATE($TAGSTARTUPINFO)
		DLLCALL("kernel32.dll", "none", "GetStartupInfoW", "struct*", $TSI)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $TSI
	ENDFUNC
	FUNC _WINAPI_GETSYSTEMDEPPOLICY()
		LOCAL $ARET = DLLCALL("kernel32.dll", "uint", "GetSystemDEPPolicy")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETSYSTEMINFO()
		LOCAL $SPROC
		IF _WINAPI_ISWOW64PROCESS() THEN
			$SPROC = "GetNativeSystemInfo"
		ELSE
			$SPROC = "GetSystemInfo"
		ENDIF
		LOCAL CONST $TAGSYSTEMINFO = "struct;word ProcessorArchitecture;word Reserved; endstruct;dword PageSize;" & "ptr MinimumApplicationAddress;ptr MaximumApplicationAddress;dword_ptr ActiveProcessorMask;dword NumberOfProcessors;" & "dword ProcessorType;dword AllocationGranularity;word ProcessorLevel;word ProcessorRevision"
		LOCAL $TSYSTEMINFO = DLLSTRUCTCREATE($TAGSYSTEMINFO)
		DLLCALL("kernel32.dll", "none", $SPROC, "struct*", $TSYSTEMINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARESULT[10]
		$ARESULT[0] = DLLSTRUCTGETDATA($TSYSTEMINFO, 1)
		FOR $I = 1 TO 9
			$ARESULT[$I] = DLLSTRUCTGETDATA($TSYSTEMINFO, $I + 2)
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETSYSTEMPOWERSTATUS()
		LOCAL $TAGSYSTEM_POWER_STATUS = "byte ACLineStatus;byte BatteryFlag;byte BatteryLifePercent;byte Reserved1;" & "int BatteryLifeTime;int BatteryFullLifeTime"
		LOCAL $TSYSTEM_POWER_STATUS = DLLSTRUCTCREATE($TAGSYSTEM_POWER_STATUS)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetSystemPowerStatus", "struct*", $TSYSTEM_POWER_STATUS)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARESULT[5]
		$ARESULT[0] = DLLSTRUCTGETDATA($TSYSTEM_POWER_STATUS, 1)
		$ARESULT[1] = DLLSTRUCTGETDATA($TSYSTEM_POWER_STATUS, 2)
		$ARESULT[2] = DLLSTRUCTGETDATA($TSYSTEM_POWER_STATUS, 3)
		$ARESULT[3] = DLLSTRUCTGETDATA($TSYSTEM_POWER_STATUS, 5)
		$ARESULT[4] = DLLSTRUCTGETDATA($TSYSTEM_POWER_STATUS, 6)
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETSYSTEMTIMES()
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetSystemTimes", "uint64*", 0, "uint64*", 0, "uint64*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARESULT[3]
		FOR $I = 0 TO 2
			$ARESULT[$I] = $ARET[$I + 1]
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETSYSTEMWOW64DIRECTORY()
		LOCAL $ARET = DLLCALL("kernel32.dll", "uint", "GetSystemWow64DirectoryW", "wstr", "", "uint", 4096)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, _WINAPI_GETLASTERROR(), "")
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_GETTICKCOUNT()
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "GetTickCount")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETTICKCOUNT64()
		LOCAL $ARET = DLLCALL("kernel32.dll", "uint64", "GetTickCount64")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETUSEROBJECTINFORMATION($HOBJECT, $IINDEX)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetUserObjectInformationW", "handle", $HOBJECT, "int", $IINDEX, "ptr", 0, "dword", 0, "dword*", 0)
		IF @ERROR OR NOT $ARET[5] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TDATA
		SWITCH $IINDEX
			CASE 1
				$TDATA = DLLSTRUCTCREATE($TAGUSEROBJECTFLAGS)
			CASE 5, 6
				$TDATA = DLLSTRUCTCREATE("uint")
			CASE 2, 3
				$TDATA = DLLSTRUCTCREATE("wchar[" & $ARET[5] & "]")
			CASE 4
				$TDATA = DLLSTRUCTCREATE("byte[" & $ARET[5] & "]")
			CASE ELSE
				RETURN SETERROR(20, 0, 0)
		ENDSWITCH
		$ARET = DLLCALL("user32.dll", "bool", "GetUserObjectInformationW", "handle", $HOBJECT, "int", $IINDEX, "struct*", $TDATA, "dword", DLLSTRUCTGETSIZE($TDATA), "dword*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 30, @EXTENDED, 0)
		SWITCH $IINDEX
			CASE 1, 4
				RETURN $TDATA
			CASE ELSE
				RETURN DLLSTRUCTGETDATA($TDATA, 1)
		ENDSWITCH
	ENDFUNC
	FUNC _WINAPI_GETVERSION()
		RETURN NUMBER(BITAND(BITSHIFT($__WINVER, 8), 255) & "." & BITAND($__WINVER, 255), $NUMBER_DOUBLE)
	ENDFUNC
	FUNC _WINAPI_GETVERSIONEX()
		LOCAL $TOSVERSIONINFOEX = DLLSTRUCTCREATE($TAGOSVERSIONINFOEX)
		DLLSTRUCTSETDATA($TOSVERSIONINFOEX, "OSVersionInfoSize", DLLSTRUCTGETSIZE($TOSVERSIONINFOEX))
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetVersionExW", "struct*", $TOSVERSIONINFOEX)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TOSVERSIONINFOEX
	ENDFUNC
	FUNC _WINAPI_GETWORKAREA()
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("user32.dll", "int", "SystemParametersInfo", "uint", 48, "uint", 0, "struct*", $TRECT, "uint", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_INITMUILANGUAGE($ILANGUAGE)
		DLLCALL("comctl32.dll", "none", "InitMUILanguage", "word", $ILANGUAGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_ISLOADKBLAYOUT($ILANGUAGE)
		LOCAL $ALAYOUT = _WINAPI_GETKEYBOARDLAYOUTLIST()
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		FOR $I = 1 TO $ALAYOUT[0]
			IF $ALAYOUT[$I] = $ILANGUAGE THEN RETURN TRUE
		NEXT
		RETURN FALSE
	ENDFUNC
	FUNC _WINAPI_ISPROCESSORFEATUREPRESENT($IFEATURE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "IsProcessorFeaturePresent", "dword", $IFEATURE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ISWINDOWENABLED($HWND)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "IsWindowEnabled", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_KEYBD_EVENT($VKEY, $IFLAGS, $ISCANCODE = 0, $IEXTRAINFO = 0)
		DLLCALL("user32.dll", "none", "keybd_event", "byte", $VKEY, "byte", $ISCANCODE, "dword", $IFLAGS, "ulong_ptr", $IEXTRAINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_LOADKEYBOARDLAYOUT($ILANGUAGE, $IFLAG = 0)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "LoadKeyboardLayoutW", "wstr", HEX($ILANGUAGE, 8), "uint", $IFLAG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_LOCKWORKSTATION()
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "LockWorkStation")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_MAPVIRTUALKEY($ICODE, $ITYPE, $HLOCALE = 0)
		LOCAL $ARET = DLLCALL("user32.dll", "INT", "MapVirtualKeyExW", "uint", $ICODE, "uint", $ITYPE, "uint_ptr", $HLOCALE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_MOUSE_EVENT($IFLAGS, $IX = 0, $IY = 0, $IDATA = 0, $IEXTRAINFO = 0)
		DLLCALL("user32.dll", "none", "mouse_event", "dword", $IFLAGS, "dword", $IX, "dword", $IY, "dword", $IDATA, "ulong_ptr", $IEXTRAINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED)
	ENDFUNC
	FUNC _WINAPI_OPENDESKTOP($SNAME, $IACCESS = 0, $IFLAGS = 0, $BINHERIT = FALSE)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "OpenDesktopW", "wstr", $SNAME, "dword", $IFLAGS, "bool", $BINHERIT, "dword", $IACCESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_OPENINPUTDESKTOP($IACCESS = 0, $IFLAGS = 0, $BINHERIT = FALSE)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "OpenInputDesktop", "dword", $IFLAGS, "bool", $BINHERIT, "dword", $IACCESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_OPENWINDOWSTATION($SNAME, $IACCESS = 0, $BINHERIT = FALSE)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "OpenWindowStationW", "wstr", $SNAME, "bool", $BINHERIT, "dword", $IACCESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_QUERYPERFORMANCECOUNTER()
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "QueryPerformanceCounter", "int64*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_QUERYPERFORMANCEFREQUENCY()
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "QueryPerformanceFrequency", "int64*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_REGISTERHOTKEY($HWND, $IID, $IMODIFIERS, $VKEY)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "RegisterHotKey", "hwnd", $HWND, "int", $IID, "uint", $IMODIFIERS, "uint", $VKEY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_REGISTERPOWERSETTINGNOTIFICATION($HWND, $SGUID)
		LOCAL $TGUID = DLLSTRUCTCREATE($TAGGUID)
		LOCAL $ARET = DLLCALL("ole32.dll", "long", "CLSIDFromString", "wstr", $SGUID, "struct*", $TGUID)
		IF @ERROR OR $ARET[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		$ARET = DLLCALL("user32.dll", "handle", "RegisterPowerSettingNotification", "handle", $HWND, "struct*", $TGUID, "dword", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_REGISTERRAWINPUTDEVICES($PADEVICE, $ICOUNT = 1)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "RegisterRawInputDevices", "struct*", $PADEVICE, "uint", $ICOUNT, "uint", DLLSTRUCTGETSIZE(DLLSTRUCTCREATE($TAGRAWINPUTDEVICE)) * $ICOUNT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_RELEASECAPTURE()
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "ReleaseCapture")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_REMOVECLIPBOARDFORMATLISTENER($HWND)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "RemoveClipboardFormatListener", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETACTIVEWINDOW($HWND)
		LOCAL $ARET = DLLCALL("user32.dll", "int", "SetActiveWindow", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETCAPTURE($HWND)
		LOCAL $ARESULT = DLLCALL("user32.dll", "hwnd", "SetCapture", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETDEFAULTPRINTER($SPRINTER)
		LOCAL $ARESULT = DLLCALL("winspool.drv", "bool", "SetDefaultPrinterW", "wstr", $SPRINTER)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETDLLDIRECTORY($SDIRPATH = DEFAULT)
		LOCAL $STYPEOFPATH = "wstr"
		IF $SDIRPATH = DEFAULT THEN
			$STYPEOFPATH = "ptr"
			$SDIRPATH = 0
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "SetDllDirectoryW", $STYPEOFPATH, $SDIRPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETKEYBOARDLAYOUT($HWND, $ILANGUAGE, $IFLAGS = 0)
		IF NOT _WINAPI_ISWINDOW($HWND) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $HLOCALE = 0
		IF $ILANGUAGE THEN
			$HLOCALE = _WINAPI_LOADKEYBOARDLAYOUT($ILANGUAGE)
			IF NOT $HLOCALE THEN RETURN SETERROR(10, 0, 0)
		ENDIF
		LOCAL CONST $WM_INPUTLANGCHANGEREQUEST = 80
		DLLCALL("user32.dll", "none", "SendMessage", "hwnd", $HWND, "uint", $WM_INPUTLANGCHANGEREQUEST, "uint", $IFLAGS, "uint_ptr", $HLOCALE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SETKEYBOARDSTATE(BYREF $TSTATE)
		LOCAL $ARET = DLLCALL("user32.dll", "int", "SetKeyboardState", "struct*", $TSTATE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETPROCESSSHUTDOWNPARAMETERS($ILEVEL, $BDIALOG = FALSE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "SetProcessShutdownParameters", "dword", $ILEVEL, "dword", NOT $BDIALOG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETPROCESSWINDOWSTATION($HSTATION)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "SetProcessWindowStation", "handle", $HSTATION)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETUSEROBJECTINFORMATION($HOBJECT, $IINDEX, BYREF $TDATA)
		IF $IINDEX <> 1 THEN RETURN SETERROR(10, 0, FALSE)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "SetUserObjectInformationW", "handle", $HOBJECT, "int", 1, "struct*", $TDATA, "dword", DLLSTRUCTGETSIZE($TDATA))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETWINDOWSHOOKEX($IHOOK, $PPROC, $HDLL, $ITHREADID = 0)
		LOCAL $ARESULT = DLLCALL("user32.dll", "handle", "SetWindowsHookEx", "int", $IHOOK, "ptr", $PPROC, "handle", $HDLL, "dword", $ITHREADID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETWINEVENTHOOK($IEVENTMIN, $IEVENTMAX, $PEVENTPROC, $IPID = 0, $ITHREADID = 0, $IFLAGS = 0)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "SetWinEventHook", "uint", $IEVENTMIN, "uint", $IEVENTMAX, "ptr", 0, "ptr", $PEVENTPROC, "dword", $IPID, "dword", $ITHREADID, "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SHUTDOWNBLOCKREASONCREATE($HWND, $STEXT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "ShutdownBlockReasonCreate", "hwnd", $HWND, "wstr", $STEXT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SHUTDOWNBLOCKREASONDESTROY($HWND)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "ShutdownBlockReasonDestroy", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SHUTDOWNBLOCKREASONQUERY($HWND)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "ShutdownBlockReasonQuery", "hwnd", $HWND, "wstr", "", "dword*", 4096)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_SWITCHDESKTOP($HDESKTOP)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "SwitchDesktop", "handle", $HDESKTOP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SYSTEMPARAMETERSINFO($IACTION, $IPARAM = 0, $VPARAM = 0, $IWININI = 0)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "SystemParametersInfoW", "uint", $IACTION, "uint", $IPARAM, "struct*", $VPARAM, "uint", $IWININI)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_TRACKMOUSEEVENT($HWND, $IFLAGS, $ITIME = -1)
		LOCAL $TTME = DLLSTRUCTCREATE("dword;dword;hwnd;dword")
		DLLSTRUCTSETDATA($TTME, 1, DLLSTRUCTGETSIZE($TTME))
		DLLSTRUCTSETDATA($TTME, 2, $IFLAGS)
		DLLSTRUCTSETDATA($TTME, 3, $HWND)
		DLLSTRUCTSETDATA($TTME, 4, $ITIME)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "TrackMouseEvent", "struct*", $TTME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_UNHOOKWINDOWSHOOKEX($HHOOK)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "UnhookWindowsHookEx", "handle", $HHOOK)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_UNHOOKWINEVENT($HEVENTHOOK)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "UnhookWinEvent", "handle", $HEVENTHOOK)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_UNLOADKEYBOARDLAYOUT($HLOCALE)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "UnloadKeyboardLayout", "handle", $HLOCALE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_UNREGISTERHOTKEY($HWND, $IID)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "UnregisterHotKey", "hwnd", $HWND, "int", $IID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_UNREGISTERPOWERSETTINGNOTIFICATION($HNOTIFY)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "UnregisterPowerSettingNotification", "handle", $HNOTIFY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC __ENUMPAGEFILESPROC($ISIZE, $PINFO, $PFILE)
		LOCAL $TEPFI = DLLSTRUCTCREATE("dword;dword;ulong_ptr;ulong_ptr;ulong_ptr", $PINFO)
		__INC($__G_VENUM)
		$__G_VENUM[$__G_VENUM[0][0]][0] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & (_WINAPI_STRLEN($PFILE) + 1) & "]", $PFILE), 1)
		FOR $I = 1 TO 3
			$__G_VENUM[$__G_VENUM[0][0]][$I] = DLLSTRUCTGETDATA($TEPFI, $I + 2) * $ISIZE
		NEXT
		RETURN 1
	ENDFUNC
#EndRegion Public Functions
#Region Global Variables and Constants
	GLOBAL CONST $TAGNOTIFYICONDATA = "struct;dword Size;hwnd hWnd;uint ID;uint Flags;uint CallbackMessage;ptr hIcon;wchar Tip[128];dword State;dword StateMask;wchar Info[256];uint Version;wchar InfoTitle[64];dword InfoFlags;endstruct"
	GLOBAL CONST $TAGNOTIFYICONDATA_V3 = $TAGNOTIFYICONDATA & ";" & $TAGGUID
	GLOBAL CONST $TAGNOTIFYICONDATA_V4 = $TAGNOTIFYICONDATA_V3 & ";ptr hBalloonIcon;"
	GLOBAL CONST $TAGSHELLEXECUTEINFO = "dword Size;ulong Mask;hwnd hWnd;ptr Verb;ptr File;ptr Parameters;ptr Directory;int Show;ulong_ptr hInstApp;ptr IDList;ptr Class;ulong_ptr hKeyClass;dword HotKey;ptr hMonitor;ptr hProcess"
	GLOBAL CONST $TAGSHFILEINFO = "ptr hIcon;int iIcon;dword Attributes;wchar DisplayName[260];wchar TypeName[80]"
	GLOBAL CONST $TAGSHFILEOPSTRUCT = "hwnd hWnd;uint Func;ptr From;ptr To;dword Flags;int fAnyOperationsAborted;ptr hNameMappings;ptr ProgressTitle"
	GLOBAL CONST $TAGSHFOLDERCUSTOMSETTINGS = "dword Size;dword Mask;ptr GUID;ptr WebViewTemplate;dword SizeWVT;ptr WebViewTemplateVersion;ptr InfoTip;dword SizeIT;ptr CLSID;dword Flags;ptr IconFile;dword SizeIF;int IconIndex;ptr Logo;dword SizeL"
	GLOBAL CONST $TAGSHSTOCKICONINFO = "dword Size;ptr hIcon;int SysImageIndex;int iIcon;wchar Path[260]"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_DEFSUBCLASSPROC($HWND, $IMSG, $WPARAM, $LPARAM)
		LOCAL $ARET = DLLCALL("comctl32.dll", "lresult", "DefSubclassProc", "hwnd", $HWND, "uint", $IMSG, "wparam", $WPARAM, "lparam", $LPARAM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DLLGETVERSION($SFILEPATH)
		LOCAL $TVERSION = DLLSTRUCTCREATE("dword[5]")
		DLLSTRUCTSETDATA($TVERSION, 1, DLLSTRUCTGETSIZE($TVERSION), 1)
		LOCAL $ARET = DLLCALL($SFILEPATH, "uint", "DllGetVersion", "struct*", $TVERSION)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		LOCAL $ARESULT[4]
		FOR $I = 0 TO 3
			$ARESULT[$I] = DLLSTRUCTGETDATA($TVERSION, 1, $I + 2)
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_FINDEXECUTABLE($SFILENAME, $SDIRECTORY = "")
		LOCAL $ARESULT = DLLCALL("shell32.dll", "INT", "FindExecutableW", "wstr", $SFILENAME, "wstr", $SDIRECTORY, "wstr", "")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARESULT[0] <= 32 THEN RETURN SETERROR(10, $ARESULT[0], "")
		RETURN SETEXTENDED($ARESULT[0], $ARESULT[3])
	ENDFUNC
	FUNC _WINAPI_GETALLUSERSPROFILEDIRECTORY()
		LOCAL $ARET = DLLCALL("userenv.dll", "bool", "GetAllUsersProfileDirectoryW", "wstr", "", "dword*", 4096)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_GETDEFAULTUSERPROFILEDIRECTORY()
		LOCAL $ARET = DLLCALL("userenv.dll", "bool", "GetDefaultUserProfileDirectoryW", "wstr", "", "dword*", 4096)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_GETWINDOWSUBCLASS($HWND, $PSUBCLASSPROC, $IDSUBCLASS)
		LOCAL $ARET = DLLCALL("comctl32.dll", "bool", "GetWindowSubclass", "hwnd", $HWND, "ptr", $PSUBCLASSPROC, "uint_ptr", $IDSUBCLASS, "dword_ptr*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ARET[4]
	ENDFUNC
	FUNC _WINAPI_REMOVEWINDOWSUBCLASS($HWND, $PSUBCLASSPROC, $IDSUBCLASS)
		LOCAL $ARET = DLLCALL("comctl32.dll", "bool", "RemoveWindowSubclass", "hwnd", $HWND, "ptr", $PSUBCLASSPROC, "uint_ptr", $IDSUBCLASS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETCURRENTPROCESSEXPLICITAPPUSERMODELID($SAPPID)
		LOCAL $ARET = DLLCALL("shell32.dll", "long", "SetCurrentProcessExplicitAppUserModelID", "wstr", $SAPPID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SETWINDOWSUBCLASS($HWND, $PSUBCLASSPROC, $IDSUBCLASS, $PDATA = 0)
		LOCAL $ARET = DLLCALL("comctl32.dll", "bool", "SetWindowSubclass", "hwnd", $HWND, "ptr", $PSUBCLASSPROC, "uint_ptr", $IDSUBCLASS, "dword_ptr", $PDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SHELLADDTORECENTDOCS($SFILEPATH)
		LOCAL $STYPEOFFILE = "wstr"
		IF STRINGSTRIPWS($SFILEPATH, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$SFILEPATH = _WINAPI_PATHSEARCHANDQUALIFY($SFILEPATH, 1)
			IF NOT $SFILEPATH THEN
				RETURN SETERROR(1, 0, 0)
			ENDIF
		ELSE
			$STYPEOFFILE = "ptr"
			$SFILEPATH = 0
		ENDIF
		DLLCALL("shell32.dll", "none", "SHAddToRecentDocs", "uint", 3, $STYPEOFFILE, $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLCHANGENOTIFY($IEVENT, $IFLAGS, $IITEM1 = 0, $IITEM2 = 0)
		LOCAL $STYPEOFITEM1 = "dword_ptr", $STYPEOFITEM2 = "dword_ptr"
		IF ISSTRING($IITEM1) THEN
			$STYPEOFITEM1 = "wstr"
		ENDIF
		IF ISSTRING($IITEM2) THEN
			$STYPEOFITEM2 = "wstr"
		ENDIF
		DLLCALL("shell32.dll", "none", "SHChangeNotify", "long", $IEVENT, "uint", $IFLAGS, $STYPEOFITEM1, $IITEM1, $STYPEOFITEM2, $IITEM2)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLCHANGENOTIFYDEREGISTER($IID)
		LOCAL $ARET = DLLCALL("shell32.dll", "bool", "SHChangeNotifyDeregister", "ulong", $IID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SHELLCHANGENOTIFYREGISTER($HWND, $IMSG, $IEVENTS, $ISOURCES, $APATHS, $BRECURSIVE = FALSE)
		LOCAL $IPATH = $APATHS, $TAGSTRUCT = ""
		IF ISARRAY($APATHS) THEN
			IF UBOUND($APATHS, $UBOUND_COLUMNS) THEN RETURN SETERROR(1, 0, 0)
		ELSE
			DIM $APATHS[1] = [$IPATH]
		ENDIF
		FOR $I = 0 TO UBOUND($APATHS) - 1
			IF NOT _WINAPI_PATHISDIRECTORY($APATHS[$I]) THEN RETURN SETERROR(2, 0, 0)
		NEXT
		FOR $I = 0 TO UBOUND($APATHS) - 1
			$TAGSTRUCT &= "ptr;int;"
		NEXT
		LOCAL $TENTRY = DLLSTRUCTCREATE($TAGSTRUCT)
		FOR $I = 0 TO UBOUND($APATHS) - 1
			$APATHS[$I] = _WINAPI_SHELLILCREATEFROMPATH(_WINAPI_PATHSEARCHANDQUALIFY($APATHS[$I]))
			DLLSTRUCTSETDATA($TENTRY, 2 * $I + 1, $APATHS[$I])
			DLLSTRUCTSETDATA($TENTRY, 2 * $I + 2, $BRECURSIVE)
		NEXT
		LOCAL $IERROR = 0
		LOCAL $ARET = DLLCALL("shell32.dll", "ulong", "SHChangeNotifyRegister", "hwnd", $HWND, "int", $ISOURCES, "long", $IEVENTS, "uint", $IMSG, "int", UBOUND($APATHS), "struct*", $TENTRY)
		IF @ERROR OR NOT $ARET[0] THEN $IERROR = @ERROR + 10
		FOR $I = 0 TO UBOUND($APATHS) - 1
			_WINAPI_COTASKMEMFREE($APATHS[$I])
		NEXT
		RETURN SETERROR($IERROR, 0, $ARET[0])
	ENDFUNC
	FUNC _WINAPI_SHELLCREATEDIRECTORY($SFILEPATH, $HPARENT = 0, $TSECURITY = 0)
		LOCAL $ARET = DLLCALL("shell32.dll", "int", "SHCreateDirectoryExW", "hwnd", $HPARENT, "wstr", $SFILEPATH, "struct*", $TSECURITY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLEMPTYRECYCLEBIN($SROOT = "", $IFLAGS = 0, $HPARENT = 0)
		LOCAL $ARET = DLLCALL("shell32.dll", "long", "SHEmptyRecycleBinW", "hwnd", $HPARENT, "wstr", $SROOT, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLEXECUTE($SFILEPATH, $SARGS = "", $SDIR = "", $SVERB = "", $ISHOW = 1, $HPARENT = 0)
		LOCAL $STYPEOFARGS = "wstr", $STYPEOFDIR = "wstr", $STYPEOFVERB = "wstr"
		IF NOT STRINGSTRIPWS($SARGS, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFARGS = "ptr"
			$SARGS = 0
		ENDIF
		IF NOT STRINGSTRIPWS($SDIR, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFDIR = "ptr"
			$SDIR = 0
		ENDIF
		IF NOT STRINGSTRIPWS($SVERB, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFVERB = "ptr"
			$SVERB = 0
		ENDIF
		LOCAL $ARET = DLLCALL("shell32.dll", "ULONG_PTR", "ShellExecuteW", "hwnd", $HPARENT, $STYPEOFVERB, $SVERB, "wstr", $SFILEPATH, $STYPEOFARGS, $SARGS, $STYPEOFDIR, $SDIR, "int", $ISHOW)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		IF $ARET[0] <= 32 THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SHELLEXECUTEEX(BYREF $TSHEXINFO)
		LOCAL $ARET = DLLCALL("shell32.dll", "bool", "ShellExecuteExW", "struct*", $TSHEXINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SHELLEXTRACTASSOCIATEDICON($SFILEPATH, $BSMALL = FALSE)
		LOCAL $IFLAGS = 256
		IF NOT _WINAPI_PATHISDIRECTORY($SFILEPATH) THEN
			$IFLAGS = BITOR($IFLAGS, 16)
		ENDIF
		IF $BSMALL THEN
			$IFLAGS = BITOR($IFLAGS, 1)
		ENDIF
		LOCAL $TSHFILEINFO = DLLSTRUCTCREATE($TAGSHFILEINFO)
		IF NOT _WINAPI_SHELLGETFILEINFO($SFILEPATH, $IFLAGS, 0, $TSHFILEINFO) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN DLLSTRUCTGETDATA($TSHFILEINFO, "hIcon")
	ENDFUNC
	FUNC _WINAPI_SHELLEXTRACTICON($SICON, $IINDEX, $IWIDTH, $IHEIGHT)
		LOCAL $ARET = DLLCALL("shell32.dll", "int", "SHExtractIconsW", "wstr", $SICON, "int", $IINDEX, "int", $IWIDTH, "int", $IHEIGHT, "ptr*", 0, "ptr*", 0, "int", 1, "int", 0)
		IF @ERROR OR NOT $ARET[0] OR NOT $ARET[5] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[5]
	ENDFUNC
	FUNC _WINAPI_SHELLFILEOPERATION($SFROM, $STO, $IFUNC, $IFLAGS, $STITLE = "", $HPARENT = 0)
		LOCAL $IDATA
		IF NOT ISARRAY($SFROM) THEN
			$IDATA = $SFROM
			DIM $SFROM[1] = [$IDATA]
		ENDIF
		LOCAL $TFROM = _WINAPI_ARRAYTOSTRUCT($SFROM)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		IF NOT ISARRAY($STO) THEN
			$IDATA = $STO
			DIM $STO[1] = [$IDATA]
		ENDIF
		LOCAL $TTO = _WINAPI_ARRAYTOSTRUCT($STO)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 30, @EXTENDED, 0)
		LOCAL $TSHFILEOPSTRUCT = DLLSTRUCTCREATE($TAGSHFILEOPSTRUCT)
		DLLSTRUCTSETDATA($TSHFILEOPSTRUCT, "hWnd", $HPARENT)
		DLLSTRUCTSETDATA($TSHFILEOPSTRUCT, "Func", $IFUNC)
		DLLSTRUCTSETDATA($TSHFILEOPSTRUCT, "From", DLLSTRUCTGETPTR($TFROM))
		DLLSTRUCTSETDATA($TSHFILEOPSTRUCT, "To", DLLSTRUCTGETPTR($TTO))
		DLLSTRUCTSETDATA($TSHFILEOPSTRUCT, "Flags", $IFLAGS)
		DLLSTRUCTSETDATA($TSHFILEOPSTRUCT, "ProgressTitle", $STITLE)
		LOCAL $ARET = DLLCALL("shell32.dll", "int", "SHFileOperationW", "struct*", $TSHFILEOPSTRUCT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TSHFILEOPSTRUCT
	ENDFUNC
	FUNC _WINAPI_SHELLFLUSHSFCACHE()
		DLLCALL("shell32.dll", "none", "SHFlushSFCache")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLGETFILEINFO($SFILEPATH, $IFLAGS, $IATTRIBUTES, BYREF $TSHFILEINFO)
		LOCAL $ARET = DLLCALL("shell32.dll", "dword_ptr", "SHGetFileInfoW", "wstr", $SFILEPATH, "dword", $IATTRIBUTES, "struct*", $TSHFILEINFO, "uint", DLLSTRUCTGETSIZE($TSHFILEINFO), "uint", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SHELLGETICONOVERLAYINDEX($SICON, $IINDEX)
		LOCAL $STYPEOFICON = "wstr"
		IF NOT STRINGSTRIPWS($SICON, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFICON = "ptr"
			$SICON = 0
		ENDIF
		LOCAL $ARET = DLLCALL("shell32.dll", "int", "SHGetIconOverlayIndexW", $STYPEOFICON, $SICON, "int", $IINDEX)
		IF @ERROR OR($ARET[0] = -1) THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SHELLGETKNOWNFOLDERIDLIST($SGUID, $IFLAGS = 0, $HTOKEN = 0)
		LOCAL $TGUID = DLLSTRUCTCREATE($TAGGUID)
		LOCAL $ARET = DLLCALL("ole32.dll", "uint", "CLSIDFromString", "wstr", $SGUID, "struct*", $TGUID)
		IF @ERROR OR $ARET[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		$ARET = DLLCALL("shell32.dll", "uint", "SHGetKnownFolderIDList", "struct*", $TGUID, "dword", $IFLAGS, "handle", $HTOKEN, "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[4]
	ENDFUNC
	FUNC _WINAPI_SHELLGETKNOWNFOLDERPATH($SGUID, $IFLAGS = 0, $HTOKEN = 0)
		LOCAL $TGUID = DLLSTRUCTCREATE($TAGGUID)
		LOCAL $ARET = DLLCALL("ole32.dll", "long", "CLSIDFromString", "wstr", $SGUID, "struct*", $TGUID)
		IF @ERROR OR $ARET[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		$ARET = DLLCALL("shell32.dll", "long", "SHGetKnownFolderPath", "struct*", $TGUID, "dword", $IFLAGS, "handle", $HTOKEN, "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		LOCAL $SPATH = _WINAPI_GETSTRING($ARET[4])
		_WINAPI_COTASKMEMFREE($ARET[4])
		RETURN $SPATH
	ENDFUNC
	FUNC _WINAPI_SHELLGETLOCALIZEDNAME($SFILEPATH)
		LOCAL $ARET = DLLCALL("shell32.dll", "long", "SHGetLocalizedName", "wstr", $SFILEPATH, "wstr", "", "uint*", 0, "int*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		LOCAL $ARESULT[2]
		LOCAL $ARET1 = DLLCALL("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $ARET[2], "wstr", "", "dword", 4096)
		$ARESULT[0] = $ARET1[2]
		$ARESULT[1] = $ARET[4]
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_SHELLGETPATHFROMIDLIST($PPIDL)
		LOCAL $ARET = DLLCALL("shell32.dll", "bool", "SHGetPathFromIDListW", "struct*", $PPIDL, "wstr", "")
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_SHELLGETSETFOLDERCUSTOMSETTINGS($SFILEPATH, $IFLAG, BYREF $TSHFCS)
		LOCAL $SPROC = "SHGetSetFolderCustomSettings"
		IF $__WINVER < 1536 THEN $SPROC &= "W"
		LOCAL $ARET = DLLCALL("shell32.dll", "long", $SPROC, "struct*", $TSHFCS, "wstr", $SFILEPATH, "dword", $IFLAG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLGETSETTINGS($IFLAGS)
		LOCAL $TSHELLSTATE = DLLSTRUCTCREATE("uint[8]")
		DLLCALL("shell32.dll", "none", "SHGetSetSettings", "struct*", $TSHELLSTATE, "dword", $IFLAGS, "bool", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $IVAL1 = DLLSTRUCTGETDATA($TSHELLSTATE, 1, 1)
		LOCAL $IVAL2 = DLLSTRUCTGETDATA($TSHELLSTATE, 1, 8)
		LOCAL $IRESULT = 0
		LOCAL $AOPT[20][2] = [[1, 1], [2, 2], [4, 32768], [8, 32], [16, 8], [32, 128], [64, 512], [128, 1024], [256, 2048], [1024, 4096], [2048, 8192], [4096, 16384], [8192, 131072], [32768, 262144], [65536, 1048576], [1, 524288], [2, 2097152], [8, 8388608], [16, 16777216], [32, 33554432]]
		FOR $I = 0 TO 14
			IF BITAND($IVAL1, $AOPT[$I][0]) THEN
				$IRESULT += $AOPT[$I][1]
			ENDIF
		NEXT
		FOR $I = 15 TO 19
			IF BITAND($IVAL2, $AOPT[$I][0]) THEN
				$IRESULT += $AOPT[$I][1]
			ENDIF
		NEXT
		RETURN $IRESULT
	ENDFUNC
	FUNC _WINAPI_SHELLGETSPECIALFOLDERLOCATION($ICSIDL)
		LOCAL $ARET = DLLCALL("shell32.dll", "long", "SHGetSpecialFolderLocation", "hwnd", 0, "int", $ICSIDL, "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_SHELLGETSPECIALFOLDERPATH($ICSIDL, $BCREATE = FALSE)
		LOCAL $ARET = DLLCALL("shell32.dll", "bool", "SHGetSpecialFolderPathW", "hwnd", 0, "wstr", "", "int", $ICSIDL, "bool", $BCREATE)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_SHELLGETSTOCKICONINFO($ISIID, $IFLAGS)
		LOCAL $TSHSTOCKICONINFO = DLLSTRUCTCREATE($TAGSHSTOCKICONINFO)
		DLLSTRUCTSETDATA($TSHSTOCKICONINFO, "Size", DLLSTRUCTGETSIZE($TSHSTOCKICONINFO))
		LOCAL $ARET = DLLCALL("shell32.dll", "long", "SHGetStockIconInfo", "int", $ISIID, "uint", $IFLAGS, "struct*", $TSHSTOCKICONINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TSHSTOCKICONINFO
	ENDFUNC
	FUNC _WINAPI_SHELLILCREATEFROMPATH($SFILEPATH)
		LOCAL $ARET = DLLCALL("shell32.dll", "long", "SHILCreateFromPath", "wstr", $SFILEPATH, "ptr*", 0, "dword*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_SHELLNOTIFYICON($IMESSAGE, BYREF $TNOTIFYICONDATA)
		LOCAL $ARET = DLLCALL("shell32.dll", "bool", "Shell_NotifyIconW", "dword", $IMESSAGE, "struct*", $TNOTIFYICONDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SHELLNOTIFYICONGETRECT($HWND, $IID, $TGUID = 0)
		LOCAL $TNII = DLLSTRUCTCREATE("dword;hwnd;uint;" & $TAGGUID)
		DLLSTRUCTSETDATA($TNII, 1, DLLSTRUCTGETSIZE($TNII))
		DLLSTRUCTSETDATA($TNII, 2, $HWND)
		DLLSTRUCTSETDATA($TNII, 3, $IID)
		IF ISDLLSTRUCT($TGUID) THEN
			IF NOT _WINAPI_MOVEMEMORY(DLLSTRUCTGETPTR($TNII, 4), $TGUID, 16) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		ENDIF
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("shell32.dll", "long", "Shell_NotifyIconGetRect", "struct*", $TNII, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_SHELLOBJECTPROPERTIES($SFILEPATH, $ITYPE = 2, $SPROPERTY = "", $HPARENT = 0)
		LOCAL $STYPEOFPROPERTY = "wstr"
		IF NOT STRINGSTRIPWS($SPROPERTY, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFPROPERTY = "ptr"
			$SPROPERTY = 0
		ENDIF
		LOCAL $ARET = DLLCALL("shell32.dll", "bool", "SHObjectProperties", "hwnd", $HPARENT, "dword", $ITYPE, "wstr", $SFILEPATH, $STYPEOFPROPERTY, $SPROPERTY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SHELLOPENFOLDERANDSELECTITEMS($SFILEPATH, $ANAMES = 0, $ISTART = 0, $IEND = -1, $IFLAGS = 0)
		LOCAL $PPIDL, $ARET, $TPTR = 0, $ICOUNT = 0, $IOBJ = 0, $IERROR = 0
		$SFILEPATH = _WINAPI_PATHREMOVEBACKSLASH(_WINAPI_PATHSEARCHANDQUALIFY($SFILEPATH))
		IF ISARRAY($ANAMES) THEN
			IF $SFILEPATH AND NOT _WINAPI_PATHISDIRECTORY($SFILEPATH) THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		ENDIF
		$PPIDL = _WINAPI_SHELLILCREATEFROMPATH($SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 30, @EXTENDED, 0)
		IF NOT __CHECKERRORARRAYBOUNDS($ANAMES, $ISTART, $IEND) THEN
			$TPTR = DLLSTRUCTCREATE("ptr[" & ($IEND - $ISTART + 1) & "]")
			FOR $I = $ISTART TO $IEND
				$ICOUNT += 1
				IF $ANAMES[$I] THEN
					DLLSTRUCTSETDATA($TPTR, 1, _WINAPI_SHELLILCREATEFROMPATH($SFILEPATH & "\" & $ANAMES[$I]), $ICOUNT)
				ELSE
					DLLSTRUCTSETDATA($TPTR, 1, 0, $ICOUNT)
				ENDIF
			NEXT
		ENDIF
		IF _WINAPI_COINITIALIZE() THEN $IOBJ = 1
		$ARET = DLLCALL("shell32.dll", "long", "SHOpenFolderAndSelectItems", "ptr", $PPIDL, "uint", $ICOUNT, "struct*", $TPTR, "dword", $IFLAGS)
		IF @ERROR THEN
			$IERROR = @ERROR + 10
		ELSE
			IF $ARET[0] THEN $IERROR = 10
		ENDIF
		IF $IOBJ THEN _WINAPI_COUNINITIALIZE()
		_WINAPI_COTASKMEMFREE($PPIDL)
		FOR $I = 1 TO $ICOUNT
			$PPIDL = DLLSTRUCTGETDATA($TPTR, $I)
			IF $PPIDL THEN
				_WINAPI_COTASKMEMFREE($PPIDL)
			ENDIF
		NEXT
		IF $IERROR = 10 THEN RETURN SETERROR(10, $ARET[0], 0)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLQUERYRECYCLEBIN($SROOT = "")
		LOCAL $TSHQRBI = DLLSTRUCTCREATE("align 4;dword_ptr;int64;int64")
		DLLSTRUCTSETDATA($TSHQRBI, 1, DLLSTRUCTGETSIZE($TSHQRBI))
		LOCAL $ARET = DLLCALL("shell32.dll", "long", "SHQueryRecycleBinW", "wstr", $SROOT, "struct*", $TSHQRBI)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		LOCAL $ARESULT[2]
		$ARESULT[0] = DLLSTRUCTGETDATA($TSHQRBI, 2)
		$ARESULT[1] = DLLSTRUCTGETDATA($TSHQRBI, 3)
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_SHELLQUERYUSERNOTIFICATIONSTATE()
		LOCAL $ARET = DLLCALL("shell32.dll", "long", "SHQueryUserNotificationState", "uint*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_SHELLREMOVELOCALIZEDNAME($SFILEPATH)
		LOCAL $ARET = DLLCALL("shell32.dll", "long", "SHRemoveLocalizedName", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLRESTRICTED($IRESTRICTION)
		LOCAL $ARET = DLLCALL("shell32.dll", "dword", "SHRestricted", "uint", $IRESTRICTION)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SHELLSETKNOWNFOLDERPATH($SGUID, $SFILEPATH, $IFLAGS = 0, $HTOKEN = 0)
		LOCAL $TGUID = DLLSTRUCTCREATE($TAGGUID)
		LOCAL $ARET = DLLCALL("ole32.dll", "long", "CLSIDFromString", "wstr", $SGUID, "struct*", $TGUID)
		IF @ERROR OR $ARET[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		$ARET = DLLCALL("shell32.dll", "long", "SHSetKnownFolderPath", "struct*", $TGUID, "dword", $IFLAGS, "handle", $HTOKEN, "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLSETLOCALIZEDNAME($SFILEPATH, $SMODULE, $IRESID)
		LOCAL $ARET = DLLCALL("shell32.dll", "long", "SHSetLocalizedName", "wstr", $SFILEPATH, "wstr", $SMODULE, "int", $IRESID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLSETSETTINGS($IFLAGS, $BSET)
		LOCAL $IVAL1 = 0, $IVAL2 = 0
		LOCAL $AOPT[20][2] = [[1, 1], [2, 2], [4, 32768], [8, 32], [16, 8], [32, 128], [64, 512], [128, 1024], [256, 2048], [1024, 4096], [2048, 8192], [4096, 16384], [8192, 131072], [32768, 262144], [65536, 1048576], [1, 524288], [2, 2097152], [8, 8388608], [16, 16777216], [32, 33554432]]
		IF $BSET THEN
			FOR $I = 0 TO 14
				IF BITAND($IFLAGS, $AOPT[$I][1]) THEN
					$IVAL1 += $AOPT[$I][0]
				ENDIF
			NEXT
			FOR $I = 15 TO 19
				IF BITAND($IFLAGS, $AOPT[$I][1]) THEN
					$IVAL2 += $AOPT[$I][0]
				ENDIF
			NEXT
		ENDIF
		LOCAL $TSHELLSTATE = DLLSTRUCTCREATE("uint[8]")
		DLLSTRUCTSETDATA($TSHELLSTATE, 1, $IVAL1, 1)
		DLLSTRUCTSETDATA($TSHELLSTATE, 1, $IVAL2, 8)
		DLLCALL("shell32.dll", "none", "SHGetSetSettings", "struct*", $TSHELLSTATE, "dword", $IFLAGS, "bool", 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLUPDATEIMAGE($SICON, $IINDEX, $IIMAGE, $IFLAGS = 0)
		DLLCALL("shell32.dll", "none", "SHUpdateImageW", "wstr", $SICON, "int", $IINDEX, "uint", $IFLAGS, "int", $IIMAGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
#EndRegion Public Functions
#Region Global Variables and Constants
	GLOBAL $__G_PFRBUFFER = 0, $__G_IFRBUFFERSIZE = 16385
	GLOBAL CONST $TAGDEVNAMES = "ushort DriverOffset;ushort DeviceOffset;ushort OutputOffset;ushort Default"
	GLOBAL CONST $TAGFINDREPLACE = "dword Size;hwnd hOwner;ptr hInstance;dword Flags;ptr FindWhat;ptr ReplaceWith;ushort FindWhatLen;ushort ReplaceWithLen;lparam lParam;ptr Hook;ptr TemplateName"
	GLOBAL CONST $TAGMSGBOXPARAMS = "uint Size;hwnd hOwner;ptr hInstance;int_ptr Text;int_ptr Caption;dword Style;int_ptr Icon;dword_ptr ContextHelpId;ptr MsgBoxCallback;dword LanguageId"
	GLOBAL CONST $TAGPAGESETUPDLG = "dword Size;hwnd hOwner;ptr hDevMode;ptr hDevNames;dword Flags;long PaperWidth;long PaperHeight;long MarginMinLeft;long MarginMinTop;long MarginMinRight;long MarginMinBottom;long MarginLeft;long MarginTop;long MarginRight;long MarginBottom;ptr hInstance;lparam lParam;ptr PageSetupHook;ptr PagePaintHook;ptr PageSetupTemplateName;ptr hPageSetupTemplate"
	GLOBAL CONST $TAGPRINTDLG = (@AUTOITX64 ? "" : "align 2;") & "dword Size;hwnd hOwner;handle hDevMode;handle hDevNames;handle hDC;dword Flags;word FromPage;word ToPage;word MinPage;word MaxPage;word Copies;handle hInstance;lparam lParam;ptr PrintHook;ptr SetupHook;ptr PrintTemplateName;ptr SetupTemplateName;handle hPrintTemplate;handle hSetupTemplate"
	GLOBAL CONST $TAGPRINTDLGEX = "dword Size;hwnd hOwner;handle hDevMode;handle hDevNames;handle hDC;dword Flags;dword Flags2;dword ExclusionFlags;dword NumPageRanges;dword MaxPageRanges;ptr PageRanges;dword MinPage;dword MaxPage;dword Copies;handle hInstance;ptr PrintTemplateName;lparam lParam;dword NumPropertyPages;ptr hPropertyPages;dword StartPage;dword ResultAction"
	GLOBAL CONST $TAGPRINTPAGERANGE = "dword FromPage;dword ToPage"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_BROWSEFORFOLDERDLG($SROOT = "", $STEXT = "", $IFLAGS = 0, $PBROWSEPROC = 0, $LPARAM = 0, $HPARENT = 0)
		LOCAL CONST $TAGBROWSEINFO = "hwnd hwndOwner;ptr pidlRoot;ptr pszDisplayName; ptr lpszTitle;uint ulFlags;ptr lpfn;lparam lParam;int iImage"
		LOCAL $TBROWSEINFO = DLLSTRUCTCREATE($TAGBROWSEINFO & ";wchar[" & (STRINGLEN($STEXT) + 1) & "];wchar[260]")
		LOCAL $PPIDL = 0, $SRESULT = ""
		IF STRINGSTRIPWS($SROOT, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			LOCAL $SPATH = _WINAPI_PATHSEARCHANDQUALIFY($SROOT, 1)
			IF @ERROR THEN
				$SPATH = $SROOT
			ENDIF
			$PPIDL = _WINAPI_SHELLILCREATEFROMPATH($SPATH)
			IF @ERROR THEN
			ENDIF
		ENDIF
		DLLSTRUCTSETDATA($TBROWSEINFO, 1, $HPARENT)
		DLLSTRUCTSETDATA($TBROWSEINFO, 2, $PPIDL)
		DLLSTRUCTSETDATA($TBROWSEINFO, 3, DLLSTRUCTGETPTR($TBROWSEINFO, 10))
		DLLSTRUCTSETDATA($TBROWSEINFO, 4, DLLSTRUCTGETPTR($TBROWSEINFO, 9))
		DLLSTRUCTSETDATA($TBROWSEINFO, 5, $IFLAGS)
		DLLSTRUCTSETDATA($TBROWSEINFO, 6, $PBROWSEPROC)
		DLLSTRUCTSETDATA($TBROWSEINFO, 7, $LPARAM)
		DLLSTRUCTSETDATA($TBROWSEINFO, 8, 0)
		DLLSTRUCTSETDATA($TBROWSEINFO, 9, $STEXT)
		LOCAL $ARET = DLLCALL("shell32.dll", "ptr", "SHBrowseForFolderW", "struct*", $TBROWSEINFO)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		$SRESULT = _WINAPI_SHELLGETPATHFROMIDLIST($ARET[0])
		_WINAPI_COTASKMEMFREE($ARET[0])
		IF $PPIDL THEN
			_WINAPI_COTASKMEMFREE($PPIDL)
		ENDIF
		IF NOT $SRESULT THEN RETURN SETERROR(10, 0, "")
		RETURN $SRESULT
	ENDFUNC
	FUNC _WINAPI_COMMDLGEXTENDEDERROR()
		LOCAL CONST $CDERR_DIALOGFAILURE = 65535
		LOCAL CONST $CDERR_FINDRESFAILURE = 6
		LOCAL CONST $CDERR_INITIALIZATION = 2
		LOCAL CONST $CDERR_LOADRESFAILURE = 7
		LOCAL CONST $CDERR_LOADSTRFAILURE = 5
		LOCAL CONST $CDERR_LOCKRESFAILURE = 8
		LOCAL CONST $CDERR_MEMALLOCFAILURE = 9
		LOCAL CONST $CDERR_MEMLOCKFAILURE = 10
		LOCAL CONST $CDERR_NOHINSTANCE = 4
		LOCAL CONST $CDERR_NOHOOK = 11
		LOCAL CONST $CDERR_NOTEMPLATE = 3
		LOCAL CONST $CDERR_REGISTERMSGFAIL = 12
		LOCAL CONST $CDERR_STRUCTSIZE = 1
		LOCAL CONST $FNERR_BUFFERTOOSMALL = 12291
		LOCAL CONST $FNERR_INVALIDFILENAME = 12290
		LOCAL CONST $FNERR_SUBCLASSFAILURE = 12289
		LOCAL $ARESULT = DLLCALL("comdlg32.dll", "dword", "CommDlgExtendedError")
		IF NOT @ERROR THEN
			SWITCH $ARESULT[0]
				CASE $CDERR_DIALOGFAILURE
					RETURN SETERROR($ARESULT[0], 0, "The dialog box could not be created." & @LF & "The common dialog box function's call to the DialogBox function failed." & @LF & "For example, this error occurs if the common dialog box call specifies an invalid window handle.")
				CASE $CDERR_FINDRESFAILURE
					RETURN SETERROR($ARESULT[0], 0, "The common dialog box function failed to find a specified resource.")
				CASE $CDERR_INITIALIZATION
					RETURN SETERROR($ARESULT[0], 0, "The common dialog box function failed during initialization." & @LF & "This error often occurs when sufficient memory is not available.")
				CASE $CDERR_LOADRESFAILURE
					RETURN SETERROR($ARESULT[0], 0, "The common dialog box function failed to load a specified resource.")
				CASE $CDERR_LOADSTRFAILURE
					RETURN SETERROR($ARESULT[0], 0, "The common dialog box function failed to load a specified string.")
				CASE $CDERR_LOCKRESFAILURE
					RETURN SETERROR($ARESULT[0], 0, "The common dialog box function failed to lock a specified resource.")
				CASE $CDERR_MEMALLOCFAILURE
					RETURN SETERROR($ARESULT[0], 0, "The common dialog box function was unable to allocate memory for internal structures.")
				CASE $CDERR_MEMLOCKFAILURE
					RETURN SETERROR($ARESULT[0], 0, "The common dialog box function was unable to lock the memory associated with a handle.")
				CASE $CDERR_NOHINSTANCE
					RETURN SETERROR($ARESULT[0], 0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a corresponding instance handle.")
				CASE $CDERR_NOHOOK
					RETURN SETERROR($ARESULT[0], 0, "The ENABLEHOOK flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a pointer to a corresponding hook procedure.")
				CASE $CDERR_NOTEMPLATE
					RETURN SETERROR($ARESULT[0], 0, "The ENABLETEMPLATE flag was set in the Flags member of the initialization structure for the corresponding common dialog box," & @LF & "but you failed to provide a corresponding template.")
				CASE $CDERR_REGISTERMSGFAIL
					RETURN SETERROR($ARESULT[0], 0, "The RegisterWindowMessage function returned an error code when it was called by the common dialog box function.")
				CASE $CDERR_STRUCTSIZE
					RETURN SETERROR($ARESULT[0], 0, "The lStructSize member of the initialization structure for the corresponding common dialog box is invalid")
				CASE $FNERR_BUFFERTOOSMALL
					RETURN SETERROR($ARESULT[0], 0, "The buffer pointed to by the lpstrFile member of the OPENFILENAME structure is too small for the file name specified by the user." & @LF & "The first two bytes of the lpstrFile buffer contain an integer value specifying the size, in TCHARs, required to receive the full name.")
				CASE $FNERR_INVALIDFILENAME
					RETURN SETERROR($ARESULT[0], 0, "A file name is invalid.")
				CASE $FNERR_SUBCLASSFAILURE
					RETURN SETERROR($ARESULT[0], 0, "An attempt to subclass a list box failed because sufficient memory was not available.")
			ENDSWITCH
		ENDIF
		RETURN SETERROR(@ERROR, @EXTENDED, "0x" & HEX($ARESULT[0]))
	ENDFUNC
	FUNC _WINAPI_COMMDLGEXTENDEDERROREX()
		LOCAL $ARET = DLLCALL("comdlg32.dll", "dword", "CommDlgExtendedError")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CONFIRMCREDENTIALS($STARGET, $BCONFIRM)
		IF NOT __DLL("credui.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $ARET = DLLCALL("credui.dll", "dword", "CredUIConfirmCredentialsW", "wstr", $STARGET, "bool", $BCONFIRM)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_FINDTEXTDLG($HOWNER, $SFINDWHAT = "", $IFLAGS = 0, $PFINDPROC = 0, $LPARAM = 0)
		$__G_PFRBUFFER = __HEAPREALLOC($__G_PFRBUFFER, 2 * $__G_IFRBUFFERSIZE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		DLLSTRUCTSETDATA(DLLSTRUCTCREATE("wchar[" & $__G_IFRBUFFERSIZE & "]", $__G_PFRBUFFER), 1, STRINGLEFT($SFINDWHAT, $__G_IFRBUFFERSIZE - 1))
		LOCAL $TFR = DLLSTRUCTCREATE($TAGFINDREPLACE)
		DLLSTRUCTSETDATA($TFR, "Size", DLLSTRUCTGETSIZE($TFR))
		DLLSTRUCTSETDATA($TFR, "hOwner", $HOWNER)
		DLLSTRUCTSETDATA($TFR, "hInstance", 0)
		DLLSTRUCTSETDATA($TFR, "Flags", $IFLAGS)
		DLLSTRUCTSETDATA($TFR, "FindWhat", $__G_PFRBUFFER)
		DLLSTRUCTSETDATA($TFR, "ReplaceWith", 0)
		DLLSTRUCTSETDATA($TFR, "FindWhatLen", $__G_IFRBUFFERSIZE * 2)
		DLLSTRUCTSETDATA($TFR, "ReplaceWithLen", 0)
		DLLSTRUCTSETDATA($TFR, "lParam", $LPARAM)
		DLLSTRUCTSETDATA($TFR, "Hook", $PFINDPROC)
		DLLSTRUCTSETDATA($TFR, "TemplateName", 0)
		LOCAL $ARET = DLLCALL("comdlg32.dll", "hwnd", "FindTextW", "struct*", $TFR)
		IF @ERROR OR NOT $ARET[0] THEN
			LOCAL $IERROR = @ERROR + 30
			__HEAPFREE($__G_PFRBUFFER)
			IF ISARRAY($ARET) THEN
				RETURN SETERROR(10, _WINAPI_COMMDLGEXTENDEDERROREX(), 0)
			ELSE
				RETURN SETERROR($IERROR, @EXTENDED, 0)
			ENDIF
		ENDIF
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FLUSHFRBUFFER()
		IF NOT __HEAPFREE($__G_PFRBUFFER, 1) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_FORMATDRIVEDLG($SDRIVE, $IOPTION = 0, $HPARENT = 0)
		IF NOT ISSTRING($SDRIVE) THEN RETURN SETERROR(10, 0, 0)
		$SDRIVE = STRINGLEFT(STRINGUPPER(STRINGSTRIPWS($SDRIVE, $STR_STRIPLEADING)), 1)
		IF NOT $SDRIVE THEN RETURN SETERROR(11, 0, 0)
		$SDRIVE = ASC($SDRIVE) - 65
		IF($SDRIVE < 0) OR($SDRIVE > 25) THEN RETURN SETERROR(12, 0, 0)
		LOCAL $ARET = DLLCALL("shell32.dll", "dword", "SHFormatDrive", "hwnd", $HPARENT, "uint", $SDRIVE, "uint", 65535, "uint", $IOPTION)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] < 0 THEN RETURN SETERROR($ARET[0], 0, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETCONNECTEDDLG($IDLG, $IFLAGS = 0, $HPARENT = 0)
		IF NOT __DLL("connect.dll") THEN RETURN SETERROR(103, 0, 0)
		SWITCH $IDLG
			CASE 0
				$IDLG = "GetNetworkConnected"
			CASE 1
				$IDLG = "GetInternetConnected"
			CASE 2
				$IDLG = "GetVPNConnected"
			CASE ELSE
				RETURN SETERROR(1, 0, 0)
		ENDSWITCH
		LOCAL $SSTR = ""
		IF BITAND($IFLAGS, 1) THEN
			$SSTR &= "-SkipInternetDetection "
		ENDIF
		IF BITAND($IFLAGS, 2) THEN
			$SSTR &= "-SkipExistingConnections "
		ENDIF
		IF BITAND($IFLAGS, 4) THEN
			$SSTR &= "-HideFinishPage "
		ENDIF
		LOCAL $ARET = DLLCALL("connect.dll", "long", $IDLG, "hwnd", $HPARENT, "dword", 0, "dword", 0, "dword", 0, "handle", 0, "wstr", STRINGSTRIPWS($SSTR, $STR_STRIPTRAILING))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF NOT($ARET[0] = 0 OR $ARET[0] = 1) THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN NUMBER(NOT $ARET[0])
	ENDFUNC
	FUNC _WINAPI_GETFRBUFFER()
		RETURN $__G_IFRBUFFERSIZE - 1
	ENDFUNC
	FUNC _WINAPI_GETOPENFILENAME($STITLE = "", $SFILTER = "All files (*.*)", $SINITALDIR = ".", $SDEFAULTFILE = "", $SDEFAULTEXT = "", $IFILTERINDEX = 1, $IFLAGS = 0, $IFLAGSEX = 0, $HWNDOWNER = 0)
		LOCAL $VRESULT = __OFNDLG(0, $STITLE, $SINITALDIR, $SFILTER, $IFILTERINDEX, $SDEFAULTFILE, $SDEFAULTEXT, $IFLAGS, $IFLAGSEX, 0, 0, $HWNDOWNER)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF BITAND($IFLAGS, $OFN_ALLOWMULTISELECT) THEN
			RETURN __WINAPI_PARSEMULTISELECTFILEDIALOGPATH($VRESULT)
		ELSE
			RETURN __WINAPI_PARSEFILEDIALOGPATH($VRESULT)
		ENDIF
	ENDFUNC
	FUNC _WINAPI_GETSAVEFILENAME($STITLE = "", $SFILTER = "All files (*.*)", $SINITALDIR = ".", $SDEFAULTFILE = "", $SDEFAULTEXT = "", $IFILTERINDEX = 1, $IFLAGS = 0, $IFLAGSEX = 0, $HWNDOWNER = 0)
		LOCAL $SRETURN = __OFNDLG(1, $STITLE, $SINITALDIR, $SFILTER, $IFILTERINDEX, $SDEFAULTFILE, $SDEFAULTEXT, $IFLAGS, $IFLAGSEX, 0, 0, $HWNDOWNER)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN __WINAPI_PARSEFILEDIALOGPATH($SRETURN)
	ENDFUNC
	FUNC _WINAPI_MESSAGEBOXCHECK($ITYPE, $STITLE, $STEXT, $SREGVAL, $IDEFAULT = -1, $HPARENT = 0)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "int", "SHMessageBoxCheckW", "hwnd", $HPARENT, "wstr", $STEXT, "wstr", $STITLE, "uint", $ITYPE, "int", $IDEFAULT, "wstr", $SREGVAL)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_MESSAGEBOXINDIRECT($TMSGBOXPARAMS)
		LOCAL $ARET = DLLCALL("user32.dll", "int", "MessageBoxIndirectW", "struct*", $TMSGBOXPARAMS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_OPENFILEDLG($STITLE = "", $SINITDIR = "", $SFILTERS = "", $IDEFAULTFILTER = 0, $SDEFAULTFILEPATH = "", $SDEFAULTEXT = "", $IFLAGS = 0, $IFLAGSEX = 0, $POFNPROC = 0, $PDATA = 0, $HPARENT = 0)
		LOCAL $SRESULT = __OFNDLG(0, $STITLE, $SINITDIR, $SFILTERS, $IDEFAULTFILTER, $SDEFAULTFILEPATH, $SDEFAULTEXT, $IFLAGS, $IFLAGSEX, $POFNPROC, $PDATA, $HPARENT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $SRESULT
	ENDFUNC
	FUNC _WINAPI_PAGESETUPDLG(BYREF $TPAGESETUPDLG)
		LOCAL $ARET = DLLCALL("comdlg32.dll", "int", "PageSetupDlgW", "struct*", $TPAGESETUPDLG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF NOT $ARET[0] THEN RETURN SETERROR(10, _WINAPI_COMMDLGEXTENDEDERROREX(), 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PICKICONDLG($SICON = "", $IINDEX = 0, $HPARENT = 0)
		LOCAL $ARET = DLLCALL("shell32.dll", "int", "PickIconDlg", "hwnd", $HPARENT, "wstr", $SICON, "int", 4096, "int*", $IINDEX)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARESULT[2]
		LOCAL $ARES = DLLCALL("kernel32.dll", "dword", "ExpandEnvironmentStringsW", "wstr", $ARET[2], "wstr", "", "dword", 4096)
		$ARESULT[0] = $ARES[2]
		$ARESULT[1] = $ARET[4]
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_PRINTDLG(BYREF $TPRINTDLG)
		LOCAL $ARET = DLLCALL("comdlg32.dll", "long", "PrintDlgW", "struct*", $TPRINTDLG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF NOT $ARET[0] THEN RETURN SETERROR(10, _WINAPI_COMMDLGEXTENDEDERROREX(), 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_PRINTDLGEX(BYREF $TPRINTDLGEX)
		LOCAL $TPDEX = DLLSTRUCTCREATE($TAGPRINTDLGEX, DLLSTRUCTGETPTR($TPRINTDLGEX))
		LOCAL $ARET = DLLCALL("comdlg32.dll", "long", "PrintDlgExW", "struct*", $TPDEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN SETEXTENDED(DLLSTRUCTGETDATA($TPDEX, "ResultAction"), 1)
	ENDFUNC
	FUNC _WINAPI_REPLACETEXTDLG($HOWNER, $SFINDWHAT = "", $SREPLACEWITH = "", $IFLAGS = 0, $PREPLACEPROC = 0, $LPARAM = 0)
		$__G_PFRBUFFER = __HEAPREALLOC($__G_PFRBUFFER, 4 * $__G_IFRBUFFERSIZE)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 100, @EXTENDED, 0)
		LOCAL $TBUFF = DLLSTRUCTCREATE("wchar[" & $__G_IFRBUFFERSIZE & "];wchar[" & $__G_IFRBUFFERSIZE & "]", $__G_PFRBUFFER)
		DLLSTRUCTSETDATA($TBUFF, 1, STRINGLEFT($SFINDWHAT, $__G_IFRBUFFERSIZE - 1))
		DLLSTRUCTSETDATA($TBUFF, 2, STRINGLEFT($SREPLACEWITH, $__G_IFRBUFFERSIZE - 1))
		LOCAL $TFR = DLLSTRUCTCREATE($TAGFINDREPLACE)
		DLLSTRUCTSETDATA($TFR, "Size", DLLSTRUCTGETSIZE($TFR))
		DLLSTRUCTSETDATA($TFR, "hOwner", $HOWNER)
		DLLSTRUCTSETDATA($TFR, "hInstance", 0)
		DLLSTRUCTSETDATA($TFR, "Flags", $IFLAGS)
		DLLSTRUCTSETDATA($TFR, "FindWhat", DLLSTRUCTGETPTR($TBUFF, 1))
		DLLSTRUCTSETDATA($TFR, "ReplaceWith", DLLSTRUCTGETPTR($TBUFF, 2))
		DLLSTRUCTSETDATA($TFR, "FindWhatLen", $__G_IFRBUFFERSIZE * 2)
		DLLSTRUCTSETDATA($TFR, "ReplaceWithLen", $__G_IFRBUFFERSIZE * 2)
		DLLSTRUCTSETDATA($TFR, "lParam", $LPARAM)
		DLLSTRUCTSETDATA($TFR, "Hook", $PREPLACEPROC)
		DLLSTRUCTSETDATA($TFR, "TemplateName", 0)
		LOCAL $ARET = DLLCALL("comdlg32.dll", "hwnd", "ReplaceTextW", "struct*", $TFR)
		IF @ERROR OR NOT $ARET[0] THEN
			LOCAL $IERROR = @ERROR
			__HEAPFREE($__G_PFRBUFFER)
			IF ISARRAY($ARET) THEN
				RETURN SETERROR(10, _WINAPI_COMMDLGEXTENDEDERROREX(), 0)
			ELSE
				RETURN SETERROR($IERROR, 0, 0)
			ENDIF
		ENDIF
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_RESTARTDLG($STEXT = "", $IFLAGS = 2, $HPARENT = 0)
		LOCAL $ARET = DLLCALL("shell32.dll", "int", "RestartDialog", "hwnd", $HPARENT, "wstr", $STEXT, "int", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SAVEFILEDLG($STITLE = "", $SINITDIR = "", $SFILTERS = "", $IDEFAULTFILTER = 0, $SDEFAULTFILEPATH = "", $SDEFAULTEXT = "", $IFLAGS = 0, $IFLAGSEX = 0, $POFNPROC = 0, $PDATA = 0, $HPARENT = 0)
		LOCAL $SRESULT = __OFNDLG(1, $STITLE, $SINITDIR, $SFILTERS, $IDEFAULTFILTER, $SDEFAULTFILEPATH, $SDEFAULTEXT, $IFLAGS, $IFLAGSEX, $POFNPROC, $PDATA, $HPARENT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $SRESULT
	ENDFUNC
	FUNC _WINAPI_SETFRBUFFER($ICHARS)
		$ICHARS = NUMBER($ICHARS)
		IF $ICHARS < 80 THEN
			$ICHARS = 80
		ENDIF
		$__G_IFRBUFFERSIZE = $ICHARS + 1
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLABOUTDLG($STITLE, $SNAME, $STEXT, $HICON = 0, $HPARENT = 0)
		LOCAL $ARET = DLLCALL("shell32.dll", "int", "ShellAboutW", "hwnd", $HPARENT, "wstr", $STITLE & "#" & $SNAME, "wstr", $STEXT, "handle", $HICON)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SHELLOPENWITHDLG($SFILEPATH, $IFLAGS = 0, $HPARENT = 0)
		LOCAL $TOPENASINFO = DLLSTRUCTCREATE("ptr;ptr;dword;wchar[" & (STRINGLEN($SFILEPATH) + 1) & "]")
		DLLSTRUCTSETDATA($TOPENASINFO, 1, DLLSTRUCTGETPTR($TOPENASINFO, 4))
		DLLSTRUCTSETDATA($TOPENASINFO, 2, 0)
		DLLSTRUCTSETDATA($TOPENASINFO, 3, $IFLAGS)
		DLLSTRUCTSETDATA($TOPENASINFO, 4, $SFILEPATH)
		LOCAL $ARET = DLLCALL("shell32.dll", "long", "SHOpenWithDialog", "hwnd", $HPARENT, "struct*", $TOPENASINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLSTARTNETCONNECTIONDLG($SREMOTE = "", $IFLAGS = 0, $HPARENT = 0)
		LOCAL $STYPEOFREMOTE = "wstr"
		IF NOT STRINGSTRIPWS($SREMOTE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFREMOTE = "ptr"
			$SREMOTE = 0
		ENDIF
		DLLCALL("shell32.dll", "long", "SHStartNetConnectionDialogW", "hwnd", $HPARENT, $STYPEOFREMOTE, $SREMOTE, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SHELLUSERAUTHENTICATIONDLG($SCAPTION, $SMESSAGE, $SUSER, $SPASSWORD, $STARGET, $IFLAGS = 0, $IERROR = 0, $BSAVE = FALSE, $HBITMAP = 0, $HPARENT = 0)
		IF NOT __DLL("credui.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $TINFO = DLLSTRUCTCREATE("dword;hwnd;ptr;ptr;ptr;wchar[" & (STRINGLEN($SMESSAGE) + 1) & "];wchar[" & (STRINGLEN($SCAPTION) + 1) & "]")
		DLLSTRUCTSETDATA($TINFO, 1, DLLSTRUCTGETPTR($TINFO, 6) - DLLSTRUCTGETPTR($TINFO))
		DLLSTRUCTSETDATA($TINFO, 2, $HPARENT)
		DLLSTRUCTSETDATA($TINFO, 3, DLLSTRUCTGETPTR($TINFO, 6))
		DLLSTRUCTSETDATA($TINFO, 4, DLLSTRUCTGETPTR($TINFO, 7))
		DLLSTRUCTSETDATA($TINFO, 5, $HBITMAP)
		DLLSTRUCTSETDATA($TINFO, 6, $SMESSAGE)
		DLLSTRUCTSETDATA($TINFO, 7, $SCAPTION)
		LOCAL $ARET = DLLCALL("credui.dll", "dword", "CredUIPromptForCredentialsW", "struct*", $TINFO, "wstr", $STARGET, "ptr", 0, "dword", $IERROR, "wstr", $SUSER, "ulong", 4096, "wstr", $SPASSWORD, "ulong", 4096, "bool*", $BSAVE, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		LOCAL $ARESULT[3]
		$ARESULT[0] = $ARET[5]
		$ARESULT[1] = $ARET[7]
		$ARESULT[2] = $ARET[9]
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_SHELLUSERAUTHENTICATIONDLGEX($SCAPTION, $SMESSAGE, $SUSER, $SPASSWORD, $IFLAGS = 0, $IAUTHERROR = 0, $BSAVE = FALSE, $IPACKAGE = 0, $HPARENT = 0)
		IF NOT __DLL("credui.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $TBLOB = 0, $ARET
		IF STRINGLEN($SUSER) THEN
			$ARET = DLLCALL("credui.dll", "bool", "CredPackAuthenticationBufferW", "dword", 1, "wstr", $SUSER, "wstr", $SPASSWORD, "ptr", 0, "dword*", 0)
			IF @ERROR OR NOT $ARET[5] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
			$TBLOB = DLLSTRUCTCREATE("byte[" & $ARET[5] & "]")
			$ARET = DLLCALL("credui.dll", "bool", "CredPackAuthenticationBufferW", "dword", 1, "wstr", $SUSER, "wstr", $SPASSWORD, "struct*", $TBLOB, "dword*", $ARET[5])
			IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		ENDIF
		LOCAL $TINFO = DLLSTRUCTCREATE("dword;hwnd;ptr;ptr;ptr;wchar[" & (STRINGLEN($SMESSAGE) + 1) & "];wchar[" & (STRINGLEN($SCAPTION) + 1) & "]")
		DLLSTRUCTSETDATA($TINFO, 1, DLLSTRUCTGETPTR($TINFO, 6) - DLLSTRUCTGETPTR($TINFO))
		DLLSTRUCTSETDATA($TINFO, 2, $HPARENT)
		DLLSTRUCTSETDATA($TINFO, 3, DLLSTRUCTGETPTR($TINFO, 6))
		DLLSTRUCTSETDATA($TINFO, 4, DLLSTRUCTGETPTR($TINFO, 7))
		DLLSTRUCTSETDATA($TINFO, 5, 0)
		DLLSTRUCTSETDATA($TINFO, 6, $SMESSAGE)
		DLLSTRUCTSETDATA($TINFO, 7, $SCAPTION)
		$ARET = DLLCALL("credui.dll", "dword", "CredUIPromptForWindowsCredentialsW", "struct*", $TINFO, "dword", $IAUTHERROR, "ulong*", $IPACKAGE, "struct*", $TBLOB, "ulong", DLLSTRUCTGETSIZE($TBLOB), "ptr*", 0, "ulong*", 0, "bool*", $BSAVE, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 30, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(30, $ARET[0], 0)
		LOCAL $ARESULT[4], $IERROR = 0
		$ARESULT[2] = $ARET[8]
		$ARESULT[3] = $ARET[3]
		LOCAL $PBLOB = $ARET[6]
		LOCAL $ISIZE = $ARET[7]
		$ARET = DLLCALL("credui.dll", "bool", "CredUnPackAuthenticationBufferW", "dword", 1, "ptr", $PBLOB, "dword", $ISIZE, "wstr", "", "dword*", 4096, "wstr", "", "dword*", 4096, "wstr", "", "dword*", 4096)
		IF NOT @ERROR AND $ARET[0] THEN
			$ARESULT[0] = $ARET[4]
			$ARESULT[1] = $ARET[8]
		ELSE
			$IERROR = @ERROR + 40
		ENDIF
		IF NOT _WINAPI_ZEROMEMORY($PBLOB, $ISIZE) THEN
		ENDIF
		_WINAPI_COTASKMEMFREE($PBLOB)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ARESULT
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __OFNDLG($IDLG, $STITLE, $SINITDIR, $SFILTERS, $IDEFFILTER, $SDEFFILE, $SDEFEXT, $IFLAGS, $IFLAGSEX, $POFNPROC, $PDATA, $HPARENT)
		LOCAL $TBUFFER = DLLSTRUCTCREATE("wchar[32768]")
		LOCAL $TFILTERS = 0, $TDEFEXT = 0, $TINITDIR = 0, $TTITLE = 0
		LOCAL $TOFN = DLLSTRUCTCREATE($TAGOPENFILENAME)
		DLLSTRUCTSETDATA($TOFN, "StructSize", DLLSTRUCTGETSIZE($TOFN))
		DLLSTRUCTSETDATA($TOFN, "hwndOwner", $HPARENT)
		DLLSTRUCTSETDATA($TOFN, 3, 0)
		LOCAL $ADATA = STRINGSPLIT($SFILTERS, "|")
		LOCAL $AFILTERS[$ADATA[0] * 2]
		LOCAL $ICOUNT = 0
		FOR $I = 1 TO $ADATA[0]
			$AFILTERS[$ICOUNT + 0] = STRINGSTRIPWS($ADATA[$I], $STR_STRIPLEADING + $STR_STRIPTRAILING)
			$AFILTERS[$ICOUNT + 1] = STRINGSTRIPWS(STRINGREGEXPREPLACE($ADATA[$I], ".*\((.*)\)", "\1"), $STR_STRIPALL)
			IF $AFILTERS[$ICOUNT + 1] THEN
				$ICOUNT += 2
			ENDIF
		NEXT
		IF $ICOUNT THEN
			$TFILTERS = _WINAPI_ARRAYTOSTRUCT($AFILTERS, 0, $ICOUNT - 1)
			IF @ERROR THEN
			ENDIF
		ENDIF
		DLLSTRUCTSETDATA($TOFN, "lpstrFilter", DLLSTRUCTGETPTR($TFILTERS))
		DLLSTRUCTSETDATA($TOFN, 5, 0)
		DLLSTRUCTSETDATA($TOFN, 6, 0)
		DLLSTRUCTSETDATA($TOFN, "nFilterIndex", $IDEFFILTER)
		$SDEFFILE = STRINGSTRIPWS($SDEFFILE, $STR_STRIPLEADING + $STR_STRIPTRAILING)
		IF $SDEFFILE THEN
			DLLSTRUCTSETDATA($TBUFFER, 1, $SDEFFILE)
		ENDIF
		DLLSTRUCTSETDATA($TOFN, "lpstrFile", DLLSTRUCTGETPTR($TBUFFER))
		DLLSTRUCTSETDATA($TOFN, "nMaxFile", 32768)
		DLLSTRUCTSETDATA($TOFN, 10, 0)
		DLLSTRUCTSETDATA($TOFN, 11, 0)
		$SINITDIR = STRINGSTRIPWS($SINITDIR, $STR_STRIPLEADING + $STR_STRIPTRAILING)
		IF $SINITDIR THEN
			$TINITDIR = DLLSTRUCTCREATE("wchar[" & (STRINGLEN($SINITDIR) + 1) & "]")
		ENDIF
		DLLSTRUCTSETDATA($TINITDIR, 1, $SINITDIR)
		DLLSTRUCTSETDATA($TOFN, "lpstrInitialDir", DLLSTRUCTGETPTR($TINITDIR))
		$STITLE = STRINGSTRIPWS($STITLE, $STR_STRIPLEADING + $STR_STRIPTRAILING)
		IF $STITLE THEN
			$TTITLE = DLLSTRUCTCREATE("wchar[" & (STRINGLEN($STITLE) + 1) & "]")
		ENDIF
		DLLSTRUCTSETDATA($TTITLE, 1, $STITLE)
		DLLSTRUCTSETDATA($TOFN, "lpstrTitle", DLLSTRUCTGETPTR($TTITLE))
		DLLSTRUCTSETDATA($TOFN, "Flags", $IFLAGS)
		DLLSTRUCTSETDATA($TOFN, 15, 0)
		DLLSTRUCTSETDATA($TOFN, 16, 0)
		$SDEFEXT = STRINGSTRIPWS($SDEFEXT, $STR_STRIPLEADING + $STR_STRIPTRAILING)
		IF $SDEFEXT THEN
			$TDEFEXT = DLLSTRUCTCREATE("wchar[" & (STRINGLEN($TDEFEXT) + 1) & "]")
		ENDIF
		DLLSTRUCTSETDATA($TDEFEXT, 1, STRINGREPLACE($SDEFEXT, ".", ""))
		DLLSTRUCTSETDATA($TOFN, "lpstrDefExt", DLLSTRUCTGETPTR($TDEFEXT))
		DLLSTRUCTSETDATA($TOFN, "lCustData", $PDATA)
		DLLSTRUCTSETDATA($TOFN, "lpfnHook", $POFNPROC)
		DLLSTRUCTSETDATA($TOFN, 20, 0)
		DLLSTRUCTSETDATA($TOFN, 21, 0)
		DLLSTRUCTSETDATA($TOFN, 22, 0)
		DLLSTRUCTSETDATA($TOFN, "FlagsEx", $IFLAGSEX)
		LOCAL $ARET
		SWITCH $IDLG
			CASE 0
				$ARET = DLLCALL("comdlg32.dll", "bool", "GetOpenFileNameW", "struct*", $TOFN)
			CASE 1
				$ARET = DLLCALL("comdlg32.dll", "bool", "GetSaveFileNameW", "struct*", $TOFN)
			CASE ELSE
		ENDSWITCH
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF NOT $ARET[0] THEN RETURN SETERROR(10, _WINAPI_COMMDLGEXTENDEDERROREX(), "")
		IF BITAND($IFLAGS, $OFN_ALLOWMULTISELECT) THEN
			IF BITAND($IFLAGS, $OFN_EXPLORER) THEN
				$ADATA = _WINAPI_STRUCTTOARRAY($TBUFFER)
				IF @ERROR THEN
					RETURN SETERROR(11, 0, "")
				ENDIF
			ELSE
				$ADATA = STRINGSPLIT(DLLSTRUCTGETDATA($TBUFFER, 1), " ")
			ENDIF
			SWITCH $ADATA[0]
				CASE 0
					RETURN SETERROR(12, 0, "")
				CASE 1
				CASE ELSE
					LOCAL $SPATH = $ADATA[1]
					FOR $I = 2 TO $ADATA[0]
						$ADATA[$I - 1] = _WINAPI_PATHAPPEND($SPATH, $ADATA[$I])
					NEXT
					REDIM $ADATA[$ADATA[0]]
					$ADATA[0] -= 1
			ENDSWITCH
		ELSE
			$ADATA = DLLSTRUCTGETDATA($TBUFFER, 1)
		ENDIF
		$__G_VEXT = $TOFN
		RETURN $ADATA
	ENDFUNC
	FUNC __WINAPI_PARSEMULTISELECTFILEDIALOGPATH($APATH)
		LOCAL $AFILES[UBOUND($APATH) + 1]
		$AFILES[0] = UBOUND($APATH)
		$AFILES[1] = STRINGMID($APATH[1], 1, STRINGINSTR($APATH[1], "\", $STR_NOCASESENSEBASIC, -1) - 1)
		FOR $I = 1 TO UBOUND($APATH) - 1
			$AFILES[$I + 1] = STRINGMID($APATH[$I], STRINGINSTR($APATH[$I], "\", $STR_NOCASESENSEBASIC, -1) + 1)
		NEXT
		RETURN $AFILES
	ENDFUNC
	FUNC __WINAPI_PARSEFILEDIALOGPATH($SPATH)
		LOCAL $AFILES[3]
		$AFILES[0] = 2
		$AFILES[1] = STRINGMID($SPATH, 1, STRINGINSTR($SPATH, "\", $STR_NOCASESENSEBASIC, -1) - 1)
		$AFILES[2] = STRINGMID($SPATH, STRINGINSTR($SPATH, "\", $STR_NOCASESENSEBASIC, -1) + 1)
		RETURN $AFILES
	ENDFUNC
#EndRegion Internal Functions
GLOBAL CONST $CREATE_BREAKAWAY_FROM_JOB = 16777216
GLOBAL CONST $CREATE_DEFAULT_ERROR_MODE = 67108864
GLOBAL CONST $CREATE_NEW_CONSOLE = 16
GLOBAL CONST $CREATE_NEW_PROCESS_GROUP = 512
GLOBAL CONST $CREATE_NO_WINDOW = 134217728
GLOBAL CONST $CREATE_PROTECTED_PROCESS = 262144
GLOBAL CONST $CREATE_PRESERVE_CODE_AUTHZ_LEVEL = 33554432
GLOBAL CONST $CREATE_SEPARATE_WOW_VDM = 2048
GLOBAL CONST $CREATE_SHARED_WOW_VDM = 4096
GLOBAL CONST $CREATE_SUSPENDED = 4
GLOBAL CONST $CREATE_UNICODE_ENVIRONMENT = 1024
GLOBAL CONST $LIST_MODULES_32BIT = 1
GLOBAL CONST $LIST_MODULES_64BIT = 2
GLOBAL CONST $LIST_MODULES_ALL = 3
GLOBAL CONST $LIST_MODULES_DEFAULT = 0
GLOBAL CONST $ABOVE_NORMAL_PRIORITY_CLASS = 32768
GLOBAL CONST $BELOW_NORMAL_PRIORITY_CLASS = 16384
GLOBAL CONST $HIGH_PRIORITY_CLASS = 128
GLOBAL CONST $IDLE_PRIORITY_CLASS = 64
GLOBAL CONST $NORMAL_PRIORITY_CLASS = 32
GLOBAL CONST $REALTIME_PRIORITY_CLASS = 256
GLOBAL CONST $PROCESS_MODE_BACKGROUND_BEGIN = 1048576
GLOBAL CONST $PROCESS_MODE_BACKGROUND_END = 2097152
GLOBAL CONST $MUTEX_MODIFY_STATE = 1
GLOBAL CONST $MUTEX_ALL_ACCESS = 2031617
GLOBAL CONST $JOB_OBJECT_ASSIGN_PROCESS = 1
GLOBAL CONST $JOB_OBJECT_QUERY = 4
GLOBAL CONST $JOB_OBJECT_SET_ATTRIBUTES = 2
GLOBAL CONST $JOB_OBJECT_SET_SECURITY_ATTRIBUTES = 16
GLOBAL CONST $JOB_OBJECT_TERMINATE = 8
GLOBAL CONST $JOB_OBJECT_ALL_ACCESS = 2031647
GLOBAL CONST $JOB_OBJECT_LIMIT_ACTIVE_PROCESS = 8
GLOBAL CONST $JOB_OBJECT_LIMIT_AFFINITY = 16
GLOBAL CONST $JOB_OBJECT_LIMIT_BREAKAWAY_OK = 2048
GLOBAL CONST $JOB_OBJECT_LIMIT_DIE_ON_UNHANDLED_EXCEPTION = 1024
GLOBAL CONST $JOB_OBJECT_LIMIT_JOB_MEMORY = 512
GLOBAL CONST $JOB_OBJECT_LIMIT_JOB_TIME = 4
GLOBAL CONST $JOB_OBJECT_LIMIT_KILL_ON_JOB_CLOSE = 8192
GLOBAL CONST $JOB_OBJECT_LIMIT_PRESERVE_JOB_TIME = 64
GLOBAL CONST $JOB_OBJECT_LIMIT_PRIORITY_CLASS = 32
GLOBAL CONST $JOB_OBJECT_LIMIT_PROCESS_MEMORY = 256
GLOBAL CONST $JOB_OBJECT_LIMIT_PROCESS_TIME = 2
GLOBAL CONST $JOB_OBJECT_LIMIT_SCHEDULING_CLASS = 128
GLOBAL CONST $JOB_OBJECT_LIMIT_SILENT_BREAKAWAY_OK = 4096
GLOBAL CONST $JOB_OBJECT_LIMIT_WORKINGSET = 1
GLOBAL CONST $JOB_OBJECT_UILIMIT_DESKTOP = 64
GLOBAL CONST $JOB_OBJECT_UILIMIT_DISPLAYSETTINGS = 16
GLOBAL CONST $JOB_OBJECT_UILIMIT_EXITWINDOWS = 128
GLOBAL CONST $JOB_OBJECT_UILIMIT_GLOBALATOMS = 32
GLOBAL CONST $JOB_OBJECT_UILIMIT_HANDLES = 1
GLOBAL CONST $JOB_OBJECT_UILIMIT_READCLIPBOARD = 2
GLOBAL CONST $JOB_OBJECT_UILIMIT_SYSTEMPARAMETERS = 8
GLOBAL CONST $JOB_OBJECT_UILIMIT_WRITECLIPBOARD = 4
GLOBAL CONST $JOB_OBJECT_SECURITY_FILTER_TOKENS = 8
GLOBAL CONST $JOB_OBJECT_SECURITY_NO_ADMIN = 1
GLOBAL CONST $JOB_OBJECT_SECURITY_ONLY_TOKEN = 4
GLOBAL CONST $JOB_OBJECT_SECURITY_RESTRICTED_TOKEN = 2
GLOBAL CONST $JOB_OBJECT_TERMINATE_AT_END_OF_JOB = 0
GLOBAL CONST $JOB_OBJECT_POST_AT_END_OF_JOB = 1
GLOBAL CONST $SEMAPHORE_MODIFY_STATE = 2
GLOBAL CONST $SEMAPHORE_QUERY_STATE = 1
GLOBAL CONST $SEMAPHORE_ALL_ACCESS = 2031619
GLOBAL CONST $ES_AWAYMODE_REQUIRED = 64
GLOBAL CONST $ES_CONTINUOUS = -2147483648
GLOBAL CONST $ES_DISPLAY_REQUIRED = 2
GLOBAL CONST $ES_SYSTEM_REQUIRED = 1
GLOBAL CONST $ES_USER_PRESENT = 4
#Region Global Variables and Constants
	GLOBAL CONST $TAGIO_COUNTERS = "struct;uint64 ReadOperationCount;uint64 WriteOperationCount;uint64 OtherOperationCount;uint64 ReadTransferCount;uint64 WriteTransferCount;uint64 OtherTransferCount;endstruct"
	GLOBAL CONST $TAGJOBOBJECT_ASSOCIATE_COMPLETION_PORT = "ulong_ptr CompletionKey;ptr CompletionPort"
	GLOBAL CONST $TAGJOBOBJECT_BASIC_ACCOUNTING_INFORMATION = "struct;int64 TotalUserTime;int64 TotalKernelTime;int64 ThisPeriodTotalUserTime;int64 ThisPeriodTotalKernelTime;dword TotalPageFaultCount;dword TotalProcesses;dword ActiveProcesses;dword TotalTerminatedProcesses;endstruct"
	GLOBAL CONST $TAGJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION = $TAGJOBOBJECT_BASIC_ACCOUNTING_INFORMATION & ";" & $TAGIO_COUNTERS
	GLOBAL CONST $TAGJOBOBJECT_BASIC_LIMIT_INFORMATION = "struct;int64 PerProcessUserTimeLimit;int64 PerJobUserTimeLimit;dword LimitFlags;ulong_ptr MinimumWorkingSetSize;ulong_ptr MaximumWorkingSetSize;dword ActiveProcessLimit;ulong_ptr Affinity;dword PriorityClass;dword SchedulingClass;endstruct"
	GLOBAL CONST $TAGJOBOBJECT_BASIC_PROCESS_ID_LIST = "dword NumberOfAssignedProcesses;dword NumberOfProcessIdsInList"
	GLOBAL CONST $TAGJOBOBJECT_BASIC_UI_RESTRICTIONS = "dword UIRestrictionsClass"
	GLOBAL CONST $TAGJOBOBJECT_END_OF_JOB_TIME_INFORMATION = "dword EndOfJobTimeAction"
	GLOBAL CONST $TAGJOBOBJECT_EXTENDED_LIMIT_INFORMATION = $TAGJOBOBJECT_BASIC_LIMIT_INFORMATION & ";" & $TAGIO_COUNTERS & ";ulong_ptr ProcessMemoryLimit;ulong_ptr JobMemoryLimit;ulong_ptr PeakProcessMemoryUsed;ulong_ptr PeakJobMemoryUsed"
	GLOBAL CONST $TAGJOBOBJECT_GROUP_INFORMATION = ""
	GLOBAL CONST $TAGJOBOBJECT_SECURITY_LIMIT_INFORMATION = "dword SecurityLimitFlags;ptr JobToken;ptr SidsToDisable;ptr PrivilegesToDelete;ptr RestrictedSids"
	GLOBAL CONST $TAGMODULEINFO = "ptr BaseOfDll;dword SizeOfImage;ptr EntryPoint"
	GLOBAL CONST $TAGPROCESSENTRY32 = "dword Size;dword Usage;dword ProcessID;ulong_ptr DefaultHeapID;dword ModuleID;dword Threads;dword ParentProcessID;long PriClassBase;dword Flags;wchar ExeFile[260]"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_ADJUSTTOKENPRIVILEGES($HTOKEN, $APRIVILEGES, $IATTRIBUTES, BYREF $AADJUST)
		$AADJUST = 0
		IF NOT $APRIVILEGES AND ISNUMBER($APRIVILEGES) THEN RETURN 0
		LOCAL $TTP1 = 0, $TTP2, $ICOUNT, $ARET, $BDISABLE = FALSE
		IF $APRIVILEGES = -1 THEN
			$TTP2 = DLLSTRUCTCREATE("dword")
			$ARET = DLLCALL("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $HTOKEN, "bool", 1, "ptr", 0, "dword", 0, "struct*", $TTP2, "dword*", 0)
			IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
			LOCAL $ILASTERROR = _WINAPI_GETLASTERROR()
			SWITCH $ILASTERROR
				CASE 122
					$TTP2 = DLLSTRUCTCREATE("dword;dword[" & ($ARET[6] / 4 - 1) & "]")
					IF @ERROR THEN
						CONTINUECASE
					ENDIF
				CASE ELSE
					RETURN SETERROR(10, $ILASTERROR, 0)
			ENDSWITCH
			$BDISABLE = TRUE
		ELSE
			LOCAL $APREV = 0
			IF NOT ISARRAY($APRIVILEGES) THEN
				DIM $APREV[1][2]
				$APREV[0][0] = $APRIVILEGES
				$APREV[0][1] = $IATTRIBUTES
			ELSE
				IF NOT UBOUND($APRIVILEGES, $UBOUND_COLUMNS) THEN
					$ICOUNT = UBOUND($APRIVILEGES)
					DIM $APREV[$ICOUNT][2]
					FOR $I = 0 TO $ICOUNT - 1
						$APREV[$I][0] = $APRIVILEGES[$I]
						$APREV[$I][1] = $IATTRIBUTES
					NEXT
				ENDIF
			ENDIF
			IF ISARRAY($APREV) THEN
				$APRIVILEGES = $APREV
			ENDIF
			LOCAL $TAGSTRUCT = "dword;dword[" & (3 * UBOUND($APRIVILEGES)) & "]"
			$TTP1 = DLLSTRUCTCREATE($TAGSTRUCT)
			$TTP2 = DLLSTRUCTCREATE($TAGSTRUCT)
			IF @ERROR THEN RETURN SETERROR(@ERROR + 20, 0, 0)
			DLLSTRUCTSETDATA($TTP1, 1, UBOUND($APRIVILEGES))
			FOR $I = 0 TO UBOUND($APRIVILEGES) - 1
				DLLSTRUCTSETDATA($TTP1, 2, $APRIVILEGES[$I][1], 3 * $I + 3)
				$ARET = DLLCALL("advapi32.dll", "bool", "LookupPrivilegeValueW", "ptr", 0, "wstr", $APRIVILEGES[$I][0], "ptr", DLLSTRUCTGETPTR($TTP1, 2) + 12 * $I)
				IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 100, @EXTENDED, 0)
			NEXT
		ENDIF
		$ARET = DLLCALL("advapi32.dll", "bool", "AdjustTokenPrivileges", "handle", $HTOKEN, "bool", $BDISABLE, "struct*", $TTP1, "dword", DLLSTRUCTGETSIZE($TTP2), "struct*", $TTP2, "dword*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 200, @EXTENDED, 0)
		LOCAL $IRESULT
		SWITCH _WINAPI_GETLASTERROR()
			CASE 1300
				$IRESULT = 1
			CASE ELSE
				$IRESULT = 0
		ENDSWITCH
		$ICOUNT = DLLSTRUCTGETDATA($TTP2, 1)
		IF $ICOUNT THEN
			LOCAL $TDATA = DLLSTRUCTCREATE("wchar[128]")
			DIM $APRIVILEGES[$ICOUNT][2]
			FOR $I = 0 TO $ICOUNT - 1
				$ARET = DLLCALL("advapi32.dll", "bool", "LookupPrivilegeNameW", "ptr", 0, "ptr", DLLSTRUCTGETPTR($TTP2, 2) + 12 * $I, "struct*", $TDATA, "dword*", 128)
				IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 300, @EXTENDED, 0)
				$APRIVILEGES[$I][1] = DLLSTRUCTGETDATA($TTP2, 2, 3 * $I + 3)
				$APRIVILEGES[$I][0] = DLLSTRUCTGETDATA($TDATA, 1)
			NEXT
			$AADJUST = $APRIVILEGES
		ENDIF
		RETURN SETEXTENDED($IRESULT, 1)
	ENDFUNC
	FUNC _WINAPI_ASSIGNPROCESSTOJOBOBJECT($HJOB, $HPROCESS)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "AssignProcessToJobObject", "handle", $HJOB, "handle", $HPROCESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ATTACHCONSOLE($IPID = -1)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "AttachConsole", "dword", $IPID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_ATTACHTHREADINPUT($IATTACH, $IATTACHTO, $BATTACH)
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "AttachThreadInput", "dword", $IATTACH, "dword", $IATTACHTO, "bool", $BATTACH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_CREATEEVENT($TATTRIBUTES = 0, $BMANUALRESET = TRUE, $BINITIALSTATE = TRUE, $SNAME = "")
		LOCAL $SNAMETYPE = "wstr"
		IF $SNAME = "" THEN
			$SNAME = 0
			$SNAMETYPE = "ptr"
		ENDIF
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "handle", "CreateEventW", "struct*", $TATTRIBUTES, "bool", $BMANUALRESET, "bool", $BINITIALSTATE, $SNAMETYPE, $SNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_CREATEJOBOBJECT($SNAME = "", $TSECURITY = 0)
		LOCAL $STYPEOFNAME = "wstr"
		IF NOT STRINGSTRIPWS($SNAME, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFNAME = "ptr"
			$SNAME = 0
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "CreateJobObjectW", "struct*", $TSECURITY, $STYPEOFNAME, $SNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEMUTEX($SMUTEX, $BINITIAL = TRUE, $TSECURITY = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "CreateMutexW", "struct*", $TSECURITY, "bool", $BINITIAL, "wstr", $SMUTEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATEPROCESS($SAPPNAME, $SCOMMAND, $TSECURITY, $TTHREAD, $BINHERIT, $IFLAGS, $PENVIRON, $SDIR, $TSTARTUPINFO, $TPROCESS)
		LOCAL $TCOMMAND = 0
		LOCAL $SAPPNAMETYPE = "wstr", $SDIRTYPE = "wstr"
		IF $SAPPNAME = "" THEN
			$SAPPNAMETYPE = "ptr"
			$SAPPNAME = 0
		ENDIF
		IF $SCOMMAND <> "" THEN
			$TCOMMAND = DLLSTRUCTCREATE("wchar Text[" & 260 + 1 & "]")
			DLLSTRUCTSETDATA($TCOMMAND, "Text", $SCOMMAND)
		ENDIF
		IF $SDIR = "" THEN
			$SDIRTYPE = "ptr"
			$SDIR = 0
		ENDIF
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "CreateProcessW", $SAPPNAMETYPE, $SAPPNAME, "struct*", $TCOMMAND, "struct*", $TSECURITY, "struct*", $TTHREAD, "bool", $BINHERIT, "dword", $IFLAGS, "struct*", $PENVIRON, $SDIRTYPE, $SDIR, "struct*", $TSTARTUPINFO, "struct*", $TPROCESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_CREATEPROCESSWITHTOKEN($SAPP, $SCMD, $IFLAGS, $TSTARTUPINFO, $TPROCESSINFO, $HTOKEN, $ILOGON = 0, $PENVIRONMENT = 0, $SDIR = "")
		LOCAL $STYPEOFAPP = "wstr", $STYPEOFCMD = "wstr", $STYPEOFDIR = "wstr"
		IF NOT STRINGSTRIPWS($SAPP, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFAPP = "ptr"
			$SAPP = 0
		ENDIF
		IF NOT STRINGSTRIPWS($SCMD, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFCMD = "ptr"
			$SCMD = 0
		ENDIF
		IF NOT STRINGSTRIPWS($SDIR, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STYPEOFDIR = "ptr"
			$SDIR = 0
		ENDIF
		LOCAL $ARET = DLLCALL("advapi32.dll", "bool", "CreateProcessWithTokenW", "handle", $HTOKEN, "dword", $ILOGON, $STYPEOFAPP, $SAPP, $STYPEOFCMD, $SCMD, "dword", $IFLAGS, "struct*", $PENVIRONMENT, $STYPEOFDIR, $SDIR, "struct*", $TSTARTUPINFO, "struct*", $TPROCESSINFO)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CREATESEMAPHORE($SSEMAPHORE, $IINITIAL, $IMAXIMUM, $TSECURITY = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "CreateSemaphoreW", "struct*", $TSECURITY, "long", $IINITIAL, "long", $IMAXIMUM, "wstr", $SSEMAPHORE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DUPLICATETOKENEX($HTOKEN, $IACCESS, $ILEVEL, $ITYPE = 1, $TSECURITY = 0)
		LOCAL $ARET = DLLCALL("advapi32.dll", "bool", "DuplicateTokenEx", "handle", $HTOKEN, "dword", $IACCESS, "struct*", $TSECURITY, "int", $ILEVEL, "int", $ITYPE, "handle*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[6]
	ENDFUNC
	FUNC _WINAPI_EMPTYWORKINGSET($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", (($__WINVER < 1536) ? 1280 : 4352), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ARET = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EmptyWorkingSet", "handle", $HPROCESS[0])
		IF __CHECKERRORCLOSEHANDLE($ARET, $HPROCESS[0]) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_ENUMCHILDPROCESS($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HSNAPSHOT = DLLCALL("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 2, "dword", 0)
		IF @ERROR OR($HSNAPSHOT[0] = PTR(-1)) THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TPROCESSENTRY32 = DLLSTRUCTCREATE($TAGPROCESSENTRY32)
		LOCAL $ARESULT[101][2] = [[0]]
		$HSNAPSHOT = $HSNAPSHOT[0]
		DLLSTRUCTSETDATA($TPROCESSENTRY32, "Size", DLLSTRUCTGETSIZE($TPROCESSENTRY32))
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "Process32FirstW", "handle", $HSNAPSHOT, "struct*", $TPROCESSENTRY32)
		LOCAL $IERROR = @ERROR
		WHILE(NOT @ERROR) AND($ARET[0])
			IF DLLSTRUCTGETDATA($TPROCESSENTRY32, "ParentProcessID") = $IPID THEN
				__INC($ARESULT)
				$ARESULT[$ARESULT[0][0]][0] = DLLSTRUCTGETDATA($TPROCESSENTRY32, "ProcessID")
				$ARESULT[$ARESULT[0][0]][1] = DLLSTRUCTGETDATA($TPROCESSENTRY32, "ExeFile")
			ENDIF
			$ARET = DLLCALL("kernel32.dll", "bool", "Process32NextW", "handle", $HSNAPSHOT, "struct*", $TPROCESSENTRY32)
			$IERROR = @ERROR
		WEND
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HSNAPSHOT)
		IF NOT $ARESULT[0][0] THEN RETURN SETERROR($IERROR + 20, 0, 0)
		__INC($ARESULT, -1)
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_ENUMDEVICEDRIVERS()
		LOCAL $ARET = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EnumDeviceDrivers", "ptr", 0, "dword", 0, "dword*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ISIZE
		IF @AUTOITX64 THEN
			$ISIZE = $ARET[3] / 8
		ELSE
			$ISIZE = $ARET[3] / 4
		ENDIF
		LOCAL $TDATA = DLLSTRUCTCREATE("ptr[" & $ISIZE & "]")
		$ARET = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EnumDeviceDrivers", "struct*", $TDATA, "dword", DLLSTRUCTGETSIZE($TDATA), "dword*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ARESULT[$ISIZE + 1] = [$ISIZE]
		FOR $I = 1 TO $ISIZE
			$ARESULT[$I] = DLLSTRUCTGETDATA($TDATA, 1, $I)
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_ENUMPROCESSHANDLES($IPID = 0, $ITYPE = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $ARESULT[101][4] = [[0]]
		LOCAL $TSHI = DLLSTRUCTCREATE("ulong;byte[4194304]")
		LOCAL $ARET = DLLCALL("ntdll.dll", "long", "ZwQuerySystemInformation", "uint", 16, "struct*", $TSHI, "ulong", DLLSTRUCTGETSIZE($TSHI), "ulong*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		LOCAL $PDATA = DLLSTRUCTGETPTR($TSHI, 2)
		LOCAL $THANDLE
		FOR $I = 1 TO DLLSTRUCTGETDATA($TSHI, 1)
			$THANDLE = DLLSTRUCTCREATE("align 4;ulong;byte;byte;ushort;ptr;ulong", $PDATA + (@AUTOITX64 ? (4 + ($I - 1) * 24) : (($I - 1) * 16)))
			IF(DLLSTRUCTGETDATA($THANDLE, 1) = $IPID) AND((NOT $ITYPE) OR($ITYPE = DLLSTRUCTGETDATA($THANDLE, 2))) THEN
				__INC($ARESULT)
				$ARESULT[$ARESULT[0][0]][0] = PTR(DLLSTRUCTGETDATA($THANDLE, 4))
				$ARESULT[$ARESULT[0][0]][1] = DLLSTRUCTGETDATA($THANDLE, 2)
				$ARESULT[$ARESULT[0][0]][2] = DLLSTRUCTGETDATA($THANDLE, 3)
				$ARESULT[$ARESULT[0][0]][3] = DLLSTRUCTGETDATA($THANDLE, 6)
			ENDIF
		NEXT
		IF NOT $ARESULT[0][0] THEN RETURN SETERROR(11, 0, 0)
		__INC($ARESULT, -1)
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_ENUMPROCESSMODULES($IPID = 0, $IFLAG = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", (($__WINVER < 1536) ? 1040 : 4112), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ICOUNT, $ARET, $IERROR = 0
		DO
			IF $__WINVER >= 1536 THEN
				$ARET = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EnumProcessModulesEx", "handle", $HPROCESS[0], "ptr", 0, "dword", 0, "dword*", 0, "dword", $IFLAG)
			ELSE
				$ARET = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EnumProcessModules", "handle", $HPROCESS[0], "ptr", 0, "dword", 0, "dword*", 0)
			ENDIF
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
			IF @AUTOITX64 THEN
				$ICOUNT = $ARET[4] / 8
			ELSE
				$ICOUNT = $ARET[4] / 4
			ENDIF
			LOCAL $TPTR = DLLSTRUCTCREATE("ptr[" & $ICOUNT & "]")
			IF @ERROR THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			IF $__WINVER >= 1536 THEN
				$ARET = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EnumProcessModulesEx", "handle", $HPROCESS[0], "struct*", $TPTR, "dword", DLLSTRUCTGETSIZE($TPTR), "dword*", 0, "dword", $IFLAG)
			ELSE
				$ARET = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "EnumProcessModules", "handle", $HPROCESS[0], "struct*", $TPTR, "dword", DLLSTRUCTGETSIZE($TPTR), "dword*", 0)
			ENDIF
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 40
				EXITLOOP
			ENDIF
			LOCAL $ARESULT[$ICOUNT + 1][2] = [[$ICOUNT]]
			FOR $I = 1 TO $ICOUNT
				$ARESULT[$I][0] = DLLSTRUCTGETDATA($TPTR, 1, $I)
				$ARESULT[$I][1] = _WINAPI_GETMODULEFILENAMEEX($HPROCESS[0], $ARESULT[$I][0])
			NEXT
		UNTIL 1
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS[0])
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_ENUMPROCESSTHREADS($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HSNAPSHOT = DLLCALL("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 4, "dword", 0)
		IF @ERROR OR NOT $HSNAPSHOT[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL CONST $TAGTHREADENTRY32 = "dword Size;dword Usage;dword ThreadID;dword OwnerProcessID;long BasePri;long DeltaPri;dword Flags"
		LOCAL $TTHREADENTRY32 = DLLSTRUCTCREATE($TAGTHREADENTRY32)
		LOCAL $ARESULT[101] = [0]
		$HSNAPSHOT = $HSNAPSHOT[0]
		DLLSTRUCTSETDATA($TTHREADENTRY32, "Size", DLLSTRUCTGETSIZE($TTHREADENTRY32))
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "Thread32First", "handle", $HSNAPSHOT, "struct*", $TTHREADENTRY32)
		WHILE NOT @ERROR AND $ARET[0]
			IF DLLSTRUCTGETDATA($TTHREADENTRY32, "OwnerProcessID") = $IPID THEN
				__INC($ARESULT)
				$ARESULT[$ARESULT[0]] = DLLSTRUCTGETDATA($TTHREADENTRY32, "ThreadID")
			ENDIF
			$ARET = DLLCALL("kernel32.dll", "bool", "Thread32Next", "handle", $HSNAPSHOT, "struct*", $TTHREADENTRY32)
		WEND
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HSNAPSHOT)
		IF NOT $ARESULT[0] THEN RETURN SETERROR(1, 0, 0)
		__INC($ARESULT, -1)
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_ENUMPROCESSWINDOWS($IPID = 0, $BVISIBLE = TRUE)
		LOCAL $ATHREADS = _WINAPI_ENUMPROCESSTHREADS($IPID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumWindowsProc", "bool", "hwnd;lparam")
		DIM $__G_VENUM[101][2] = [[0]]
		FOR $I = 1 TO $ATHREADS[0]
			DLLCALL("user32.dll", "bool", "EnumThreadWindows", "dword", $ATHREADS[$I], "ptr", DLLCALLBACKGETPTR($HENUMPROC), "lparam", $BVISIBLE)
			IF @ERROR THEN
				EXITLOOP
			ENDIF
		NEXT
		DLLCALLBACKFREE($HENUMPROC)
		IF NOT $__G_VENUM[0][0] THEN RETURN SETERROR(11, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_FATALAPPEXIT($SMESSAGE)
		DLLCALL("kernel32.dll", "none", "FatalAppExitW", "uint", 0, "wstr", $SMESSAGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED)
	ENDFUNC
	FUNC _WINAPI_GETCURRENTPROCESSEXPLICITAPPUSERMODELID()
		LOCAL $ARET = DLLCALL("shell32.dll", "long", "GetCurrentProcessExplicitAppUserModelID", "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		LOCAL $SID = _WINAPI_GETSTRING($ARET[1])
		_WINAPI_COTASKMEMFREE($ARET[1])
		RETURN $SID
	ENDFUNC
	FUNC _WINAPI_GETCURRENTPROCESSID()
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "dword", "GetCurrentProcessId")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETCURRENTTHREAD()
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "handle", "GetCurrentThread")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETCURRENTTHREADID()
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "dword", "GetCurrentThreadId")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETDEVICEDRIVERBASENAME($PDRIVER)
		LOCAL $ARET = DLLCALL(@SYSTEMDIR & "\psapi.dll", "dword", "GetDeviceDriverBaseNameW", "ptr", $PDRIVER, "wstr", "", "dword", 4096)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_GETDEVICEDRIVERFILENAME($PDRIVER)
		LOCAL $ARET = DLLCALL(@SYSTEMDIR & "\psapi.dll", "dword", "GetDeviceDriverFileNameW", "ptr", $PDRIVER, "wstr", "", "dword", 4096)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_GETEXITCODEPROCESS($HPROCESS)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetExitCodeProcess", "handle", $HPROCESS, "dword*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_GETGUIRESOURCES($IFLAG = 0, $HPROCESS = -1)
		IF $HPROCESS = -1 THEN $HPROCESS = _WINAPI_GETCURRENTPROCESS()
		LOCAL $ARESULT = DLLCALL("user32.dll", "dword", "GetGuiResources", "handle", $HPROCESS, "dword", $IFLAG)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_GETMODULEFILENAMEEX($HPROCESS, $HMODULE = 0)
		LOCAL $ARET = DLLCALL(@SYSTEMDIR & "\psapi.dll", "dword", "GetModuleFileNameExW", "handle", $HPROCESS, "handle", $HMODULE, "wstr", "", "int", 4096)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_GETMODULEINFORMATION($HPROCESS, $HMODULE = 0)
		LOCAL $TMODULEINFO = DLLSTRUCTCREATE($TAGMODULEINFO)
		LOCAL $ARET = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "GetModuleInformation", "handle", $HPROCESS, "handle", $HMODULE, "struct*", $TMODULEINFO, "dword", DLLSTRUCTGETSIZE($TMODULEINFO))
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TMODULEINFO
	ENDFUNC
	FUNC _WINAPI_GETPARENTPROCESS($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HSNAPSHOT = DLLCALL("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 2, "dword", 0)
		IF @ERROR OR NOT $HSNAPSHOT[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TPROCESSENTRY32 = DLLSTRUCTCREATE($TAGPROCESSENTRY32)
		LOCAL $IRESULT = 0
		$HSNAPSHOT = $HSNAPSHOT[0]
		DLLSTRUCTSETDATA($TPROCESSENTRY32, "Size", DLLSTRUCTGETSIZE($TPROCESSENTRY32))
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "Process32FirstW", "handle", $HSNAPSHOT, "struct*", $TPROCESSENTRY32)
		LOCAL $IERROR = @ERROR
		WHILE(NOT @ERROR) AND($ARET[0])
			IF DLLSTRUCTGETDATA($TPROCESSENTRY32, "ProcessID") = $IPID THEN
				$IRESULT = DLLSTRUCTGETDATA($TPROCESSENTRY32, "ParentProcessID")
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("kernel32.dll", "bool", "Process32NextW", "handle", $HSNAPSHOT, "struct*", $TPROCESSENTRY32)
			$IERROR = @ERROR
		WEND
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HSNAPSHOT)
		IF NOT $IRESULT THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $IRESULT
	ENDFUNC
	FUNC _WINAPI_GETPRIORITYCLASS($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", (($__WINVER < 1536) ? 1024 : 4096), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $IERROR = 0
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "GetPriorityClass", "handle", $HPROCESS[0])
		IF @ERROR THEN $IERROR = @ERROR
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS[0])
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETPROCESSAFFINITYMASK($HPROCESS)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "GetProcessAffinityMask", "handle", $HPROCESS, "dword_ptr*", 0, "dword_ptr*", 0)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $AMASK[3]
		$AMASK[0] = TRUE
		$AMASK[1] = $ARESULT[2]
		$AMASK[2] = $ARESULT[3]
		RETURN $AMASK
	ENDFUNC
	FUNC _WINAPI_GETPROCESSCOMMANDLINE($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", (($__WINVER < 1536) ? 1040 : 4112), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		$HPROCESS = $HPROCESS[0]
		LOCAL $TPBI = DLLSTRUCTCREATE("ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId")
		LOCAL $TPEB = DLLSTRUCTCREATE("byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId")
		LOCAL $TUPP = DLLSTRUCTCREATE("ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5")
		LOCAL $TCMD
		LOCAL $ARET, $IERROR = 0
		DO
			$ARET = DLLCALL("ntdll.dll", "long", "NtQueryInformationProcess", "handle", $HPROCESS, "ulong", 0, "struct*", $TPBI, "ulong", DLLSTRUCTGETSIZE($TPBI), "ulong*", 0)
			IF @ERROR OR $ARET[0] THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("kernel32.dll", "bool", "ReadProcessMemory", "handle", $HPROCESS, "ptr", DLLSTRUCTGETDATA($TPBI, "PebBaseAddress"), "struct*", $TPEB, "ulong_ptr", DLLSTRUCTGETSIZE($TPEB), "ulong_ptr*", 0)
			IF @ERROR OR NOT $ARET[0] OR(NOT $ARET[5]) THEN
				$IERROR = @ERROR + 40
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("kernel32.dll", "bool", "ReadProcessMemory", "handle", $HPROCESS, "ptr", DLLSTRUCTGETDATA($TPEB, "ProcessParameters"), "struct*", $TUPP, "ulong_ptr", DLLSTRUCTGETSIZE($TUPP), "ulong_ptr*", 0)
			IF @ERROR OR NOT $ARET[0] OR(NOT $ARET[5]) THEN
				$IERROR = @ERROR + 50
				EXITLOOP
			ENDIF
			$TCMD = DLLSTRUCTCREATE("byte[" & DLLSTRUCTGETDATA($TUPP, "MaxLengthCommandLine") & "]")
			IF @ERROR THEN
				$IERROR = @ERROR + 60
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("kernel32.dll", "bool", "ReadProcessMemory", "handle", $HPROCESS, "ptr", DLLSTRUCTGETDATA($TUPP, "CommandLine"), "struct*", $TCMD, "ulong_ptr", DLLSTRUCTGETSIZE($TCMD), "ulong_ptr*", 0)
			IF @ERROR OR NOT $ARET[0] OR(NOT $ARET[5]) THEN
				$IERROR = @ERROR + 70
				EXITLOOP
			ENDIF
		UNTIL 1
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, "")
		RETURN STRINGSTRIPWS(_WINAPI_PATHGETARGS(_WINAPI_GETSTRING(DLLSTRUCTGETPTR($TCMD, 1))), $STR_STRIPLEADING + $STR_STRIPTRAILING)
	ENDFUNC
	FUNC _WINAPI_GETPROCESSFILENAME($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", (($__WINVER < 1536) ? 1040 : 4112), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		LOCAL $SPATH = _WINAPI_GETMODULEFILENAMEEX($HPROCESS[0])
		LOCAL $IERROR = @ERROR
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS[0])
		IF $IERROR THEN RETURN SETERROR(@ERROR, 0, "")
		RETURN $SPATH
	ENDFUNC
	FUNC _WINAPI_GETPROCESSHANDLECOUNT($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", (($__WINVER < 1536) ? 1024 : 4096), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetProcessHandleCount", "handle", $HPROCESS[0], "dword*", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HPROCESS[0]) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_GETPROCESSID($HPROCESS)
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "GetProcessId", "handle", $HPROCESS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETPROCESSIOCOUNTERS($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", (($__WINVER < 1536) ? 1024 : 4096), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TIO_COUNTERS = DLLSTRUCTCREATE("uint64[6]")
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetProcessIoCounters", "handle", $HPROCESS[0], "struct*", $TIO_COUNTERS)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HPROCESS[0]) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARESULT[6]
		FOR $I = 0 TO 5
			$ARESULT[$I] = DLLSTRUCTGETDATA($TIO_COUNTERS, 1, $I + 1)
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETPROCESSMEMORYINFO($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", (($__WINVER < 1536) ? 1040 : 4112), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TPMC_EX = DLLSTRUCTCREATE("dword;dword;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr;ulong_ptr")
		LOCAL $ARET = DLLCALL(@SYSTEMDIR & "\psapi.dll", "bool", "GetProcessMemoryInfo", "handle", $HPROCESS[0], "struct*", $TPMC_EX, "int", DLLSTRUCTGETSIZE($TPMC_EX))
		IF __CHECKERRORCLOSEHANDLE($ARET, $HPROCESS[0]) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARESULT[10]
		FOR $I = 0 TO 9
			$ARESULT[$I] = DLLSTRUCTGETDATA($TPMC_EX, $I + 2)
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETPROCESSNAME($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HSNAPSHOT = DLLCALL("kernel32.dll", "handle", "CreateToolhelp32Snapshot", "dword", 2, "dword", 0)
		IF @ERROR OR NOT $HSNAPSHOT[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		$HSNAPSHOT = $HSNAPSHOT[0]
		LOCAL $TPROCESSENTRY32 = DLLSTRUCTCREATE($TAGPROCESSENTRY32)
		DLLSTRUCTSETDATA($TPROCESSENTRY32, "Size", DLLSTRUCTGETSIZE($TPROCESSENTRY32))
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "Process32FirstW", "handle", $HSNAPSHOT, "struct*", $TPROCESSENTRY32)
		LOCAL $IERROR = @ERROR
		WHILE(NOT @ERROR) AND($ARET[0])
			IF DLLSTRUCTGETDATA($TPROCESSENTRY32, "ProcessID") = $IPID THEN
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("kernel32.dll", "bool", "Process32NextW", "handle", $HSNAPSHOT, "struct*", $TPROCESSENTRY32)
			$IERROR = @ERROR
		WEND
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HSNAPSHOT)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, "")
		IF NOT $ARET[0] THEN SETERROR(10, 0, "")
		RETURN DLLSTRUCTGETDATA($TPROCESSENTRY32, "ExeFile")
	ENDFUNC
	FUNC _WINAPI_GETPROCESSTIMES($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", (($__WINVER < 1536) ? 1024 : 4096), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $TFILETIME = DLLSTRUCTCREATE($TAGFILETIME)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "GetProcessTimes", "handle", $HPROCESS[0], "struct*", $TFILETIME, "uint64*", 0, "uint64*", 0, "uint64*", 0)
		IF __CHECKERRORCLOSEHANDLE($ARET, $HPROCESS[0]) THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		LOCAL $ARESULT[3]
		$ARESULT[0] = $TFILETIME
		$ARESULT[1] = $ARET[4]
		$ARESULT[2] = $ARET[5]
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETPROCESSUSER($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $TSID, $HTOKEN, $ARET
		LOCAL $IERROR = 0
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", (($__WINVER < 1536) ? 1024 : 4096), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		DO
			$HTOKEN = _WINAPI_OPENPROCESSTOKEN(8, $HPROCESS[0])
			IF NOT $HTOKEN THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
			$TSID = DLLSTRUCTCREATE("ptr;byte[1024]")
			$ARET = DLLCALL("advapi32.dll", "bool", "GetTokenInformation", "handle", $HTOKEN, "uint", 1, "struct*", $TSID, "dword", DLLSTRUCTGETSIZE($TSID), "dword*", 0)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("advapi32.dll", "bool", "LookupAccountSidW", "ptr", 0, "ptr", DLLSTRUCTGETDATA($TSID, 1), "wstr", "", "dword*", 2048, "wstr", "", "dword*", 2048, "uint*", 0)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 40
				EXITLOOP
			ENDIF
		UNTIL 1
		IF $HTOKEN THEN
			DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HTOKEN)
		ENDIF
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS[0])
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		LOCAL $ARESULT[2]
		$ARESULT[0] = $ARET[3]
		$ARESULT[1] = $ARET[5]
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETPROCESSWORKINGDIRECTORY($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $ARET, $IERROR = 0
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", (($__WINVER < 1536) ? 1040 : 4112), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
		$HPROCESS = $HPROCESS[0]
		LOCAL $TPBI = DLLSTRUCTCREATE("ulong_ptr ExitStatus;ptr PebBaseAddress;ulong_ptr AffinityMask;ulong_ptr BasePriority;ulong_ptr UniqueProcessId;ulong_ptr InheritedFromUniqueProcessId")
		LOCAL $TPEB = DLLSTRUCTCREATE("byte InheritedAddressSpace;byte ReadImageFileExecOptions;byte BeingDebugged;byte Spare;ptr Mutant;ptr ImageBaseAddress;ptr LoaderData;ptr ProcessParameters;ptr SubSystemData;ptr ProcessHeap;ptr FastPebLock;ptr FastPebLockRoutine;ptr FastPebUnlockRoutine;ulong EnvironmentUpdateCount;ptr KernelCallbackTable;ptr EventLogSection;ptr EventLog;ptr FreeList;ulong TlsExpansionCounter;ptr TlsBitmap;ulong TlsBitmapBits[2];ptr ReadOnlySharedMemoryBase;ptr ReadOnlySharedMemoryHeap;ptr ReadOnlyStaticServerData;ptr AnsiCodePageData;ptr OemCodePageData;ptr UnicodeCaseTableData;ulong NumberOfProcessors;ulong NtGlobalFlag;byte Spare2[4];int64 CriticalSectionTimeout;ulong HeapSegmentReserve;ulong HeapSegmentCommit;ulong HeapDeCommitTotalFreeThreshold;ulong HeapDeCommitFreeBlockThreshold;ulong NumberOfHeaps;ulong MaximumNumberOfHeaps;ptr ProcessHeaps;ptr GdiSharedHandleTable;ptr ProcessStarterHelper;ptr GdiDCAttributeList;ptr LoaderLock;ulong OSMajorVersion;ulong OSMinorVersion;ulong OSBuildNumber;ulong OSPlatformId;ulong ImageSubSystem;ulong ImageSubSystemMajorVersion;ulong ImageSubSystemMinorVersion;ulong GdiHandleBuffer[34];ulong PostProcessInitRoutine;ulong TlsExpansionBitmap;byte TlsExpansionBitmapBits[128];ulong SessionId")
		LOCAL $TUPP = DLLSTRUCTCREATE("ulong AllocationSize;ulong ActualSize;ulong Flags;ulong Unknown1;ushort LengthUnknown2;ushort MaxLengthUnknown2;ptr Unknown2;ptr InputHandle;ptr OutputHandle;ptr ErrorHandle;ushort LengthCurrentDirectory;ushort MaxLengthCurrentDirectory;ptr CurrentDirectory;ptr CurrentDirectoryHandle;ushort LengthSearchPaths;ushort MaxLengthSearchPaths;ptr SearchPaths;ushort LengthApplicationName;ushort MaxLengthApplicationName;ptr ApplicationName;ushort LengthCommandLine;ushort MaxLengthCommandLine;ptr CommandLine;ptr EnvironmentBlock;ulong Unknown[9];ushort LengthUnknown3;ushort MaxLengthUnknown3;ptr Unknown3;ushort LengthUnknown4;ushort MaxLengthUnknown4;ptr Unknown4;ushort LengthUnknown5;ushort MaxLengthUnknown5;ptr Unknown5")
		LOCAL $TDIR
		DO
			$ARET = DLLCALL("ntdll.dll", "long", "NtQueryInformationProcess", "handle", $HPROCESS, "ulong", 0, "struct*", $TPBI, "ulong", DLLSTRUCTGETSIZE($TPBI), "ulong*", 0)
			IF @ERROR OR($ARET[0]) THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("kernel32.dll", "bool", "ReadProcessMemory", "handle", $HPROCESS, "ptr", DLLSTRUCTGETDATA($TPBI, "PebBaseAddress"), "struct*", $TPEB, "ulong_ptr", DLLSTRUCTGETSIZE($TPEB), "ulong_ptr*", 0)
			IF @ERROR OR(NOT $ARET[0]) OR(NOT $ARET[5]) THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("kernel32.dll", "bool", "ReadProcessMemory", "handle", $HPROCESS, "ptr", DLLSTRUCTGETDATA($TPEB, "ProcessParameters"), "struct*", $TUPP, "ulong_ptr", DLLSTRUCTGETSIZE($TUPP), "ulong_ptr*", 0)
			IF @ERROR OR(NOT $ARET[0]) OR(NOT $ARET[5]) THEN
				$IERROR = @ERROR + 40
				EXITLOOP
			ENDIF
			$TDIR = DLLSTRUCTCREATE("byte[" & DLLSTRUCTGETDATA($TUPP, "MaxLengthCurrentDirectory") & "]")
			IF @ERROR THEN
				$IERROR = @ERROR + 50
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("kernel32.dll", "bool", "ReadProcessMemory", "handle", $HPROCESS, "ptr", DLLSTRUCTGETDATA($TUPP, "CurrentDirectory"), "struct*", $TDIR, "ulong_ptr", DLLSTRUCTGETSIZE($TDIR), "ulong_ptr*", 0)
			IF @ERROR OR(NOT $ARET[0]) OR(NOT $ARET[5]) THEN
				$IERROR = @ERROR + 60
				EXITLOOP
			ENDIF
			$IERROR = 0
		UNTIL 1
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, "")
		RETURN _WINAPI_PATHREMOVEBACKSLASH(_WINAPI_GETSTRING(DLLSTRUCTGETPTR($TDIR)))
	ENDFUNC
	FUNC _WINAPI_GETTHREADDESKTOP($ITHREADID)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "GetThreadDesktop", "dword", $ITHREADID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETTHREADERRORMODE()
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "GetThreadErrorMode")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETWINDOWFILENAME($HWND)
		LOCAL $IPID = 0
		LOCAL $ARESULT = DLLCALL("user32.dll", "bool", "IsWindow", "hwnd", $HWND)
		IF $ARESULT[0] THEN
			$ARESULT = DLLCALL("user32.dll", "dword", "GetWindowThreadProcessId", "hwnd", $HWND, "dword*", 0)
			$IPID = $ARESULT[2]
		ENDIF
		IF NOT $IPID THEN RETURN SETERROR(1, 0, "")
		LOCAL $SRESULT = _WINAPI_GETPROCESSFILENAME($IPID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		RETURN $SRESULT
	ENDFUNC
	FUNC _WINAPI_ISELEVATED()
		LOCAL $IELEV, $ARET, $IERROR = 0
		LOCAL $HTOKEN = _WINAPI_OPENPROCESSTOKEN(8)
		IF NOT $HTOKEN THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, FALSE)
		DO
			$ARET = DLLCALL("advapi32.dll", "bool", "GetTokenInformation", "handle", $HTOKEN, "uint", 20, "uint*", 0, "dword", 4, "dword*", 0)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
			$IELEV = $ARET[3]
			$ARET = DLLCALL("advapi32.dll", "bool", "GetTokenInformation", "handle", $HTOKEN, "uint", 18, "uint*", 0, "dword", 4, "dword*", 0)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 20
				EXITLOOP
			ENDIF
		UNTIL 1
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HTOKEN)
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, FALSE)
		RETURN SETEXTENDED($ARET[0] - 1, $IELEV)
	ENDFUNC
	FUNC _WINAPI_ISPROCESSINJOB($HPROCESS, $HJOB = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "IsProcessInJob", "handle", $HPROCESS, "handle", $HJOB, "bool*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_OPENJOBOBJECT($SNAME, $IACCESS = $JOB_OBJECT_ALL_ACCESS, $BINHERIT = FALSE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "OpenJobObjectW", "dword", $IACCESS, "bool", $BINHERIT, "wstr", $SNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_OPENMUTEX($SMUTEX, $IACCESS = $MUTEX_ALL_ACCESS, $BINHERIT = FALSE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "OpenMutexW", "dword", $IACCESS, "bool", $BINHERIT, "wstr", $SMUTEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_OPENPROCESS($IACCESS, $BINHERIT, $IPID, $BDEBUGPRIV = FALSE)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", $IACCESS, "bool", $BINHERIT, "dword", $IPID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARESULT[0] THEN RETURN $ARESULT[0]
		IF NOT $BDEBUGPRIV THEN RETURN SETERROR(100, 0, 0)
		LOCAL $HTOKEN = _SECURITY__OPENTHREADTOKENEX(BITOR($TOKEN_ADJUST_PRIVILEGES, $TOKEN_QUERY))
		IF @ERROR THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		_SECURITY__SETPRIVILEGE($HTOKEN, "SeDebugPrivilege", TRUE)
		LOCAL $IERROR = @ERROR
		LOCAL $IEXTENDED = @EXTENDED
		LOCAL $IRET = 0
		IF NOT @ERROR THEN
			$ARESULT = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", $IACCESS, "bool", $BINHERIT, "dword", $IPID)
			$IERROR = @ERROR
			$IEXTENDED = @EXTENDED
			IF $ARESULT[0] THEN $IRET = $ARESULT[0]
			_SECURITY__SETPRIVILEGE($HTOKEN, "SeDebugPrivilege", FALSE)
			IF @ERROR THEN
				$IERROR = @ERROR + 20
				$IEXTENDED = @EXTENDED
			ENDIF
		ELSE
			$IERROR = @ERROR + 30
		ENDIF
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HTOKEN)
		RETURN SETERROR($IERROR, $IEXTENDED, $IRET)
	ENDFUNC
	FUNC _WINAPI_OPENPROCESSTOKEN($IACCESS, $HPROCESS = 0)
		IF NOT $HPROCESS THEN
			$HPROCESS = DLLCALL("kernel32.dll", "handle", "GetCurrentProcess")
			$HPROCESS = $HPROCESS[0]
		ENDIF
		LOCAL $ARET = DLLCALL("advapi32.dll", "bool", "OpenProcessToken", "handle", $HPROCESS, "dword", $IACCESS, "handle*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_OPENSEMAPHORE($SSEMAPHORE, $IACCESS = 2031619, $BINHERIT = FALSE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "OpenSemaphoreW", "dword", $IACCESS, "bool", $BINHERIT, "wstr", $SSEMAPHORE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_QUERYINFORMATIONJOBOBJECT($HJOB, $IJOBOBJECTINFOCLASS, BYREF $TJOBOBJECTINFO)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "QueryInformationJobObject", "handle", $HJOB, "int", $IJOBOBJECTINFOCLASS, "struct*", $TJOBOBJECTINFO, "dword", DLLSTRUCTGETSIZE($TJOBOBJECTINFO), "dword*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[5]
	ENDFUNC
	FUNC _WINAPI_RELEASEMUTEX($HMUTEX)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "ReleaseMutex", "handle", $HMUTEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_RELEASESEMAPHORE($HSEMAPHORE, $IINCREASE = 1)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "ReleaseSemaphore", "handle", $HSEMAPHORE, "long", $IINCREASE, "long*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_RESETEVENT($HEVENT)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "ResetEvent", "handle", $HEVENT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETEVENT($HEVENT)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "SetEvent", "handle", $HEVENT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETINFORMATIONJOBOBJECT($HJOB, $IJOBOBJECTINFOCLASS, $TJOBOBJECTINFO)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "SetInformationJobObject", "handle", $HJOB, "int", $IJOBOBJECTINFOCLASS, "struct*", $TJOBOBJECTINFO, "dword", DLLSTRUCTGETSIZE($TJOBOBJECTINFO))
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETPRIORITYCLASS($IPRIORITY, $IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", (($__WINVER < 1536) ? 1536 : 4608), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $IERROR = 0
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "SetPriorityClass", "handle", $HPROCESS[0], "dword", $IPRIORITY)
		IF @ERROR THEN $IERROR = @ERROR
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS[0])
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETPROCESSAFFINITYMASK($HPROCESS, $IMASK)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "SetProcessAffinityMask", "handle", $HPROCESS, "ulong_ptr", $IMASK)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETTHREADDESKTOP($HDESKTOP)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "SetThreadDesktop", "handle", $HDESKTOP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETTHREADERRORMODE($IMODE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "SetThreadErrorMode", "dword", $IMODE, "dword*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_SETTHREADEXECUTIONSTATE($IFLAGS)
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "SetThreadExecutionState", "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_TERMINATEJOBOBJECT($HJOB, $IEXITCODE = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "TerminateJobObject", "handle", $HJOB, "uint", $IEXITCODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_TERMINATEPROCESS($HPROCESS, $IEXITCODE = 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "TerminateProcess", "handle", $HPROCESS, "uint", $IEXITCODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_USERHANDLEGRANTACCESS($HOBJECT, $HJOB, $BGRANT)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "UserHandleGrantAccess", "handle", $HOBJECT, "handle", $HJOB, "bool", $BGRANT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_WAITFORINPUTIDLE($HPROCESS, $ITIMEOUT = -1)
		LOCAL $ARESULT = DLLCALL("user32.dll", "dword", "WaitForInputIdle", "handle", $HPROCESS, "dword", $ITIMEOUT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_WAITFORMULTIPLEOBJECTS($ICOUNT, $PAHANDLES, $BWAITALL = FALSE, $ITIMEOUT = -1)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "INT", "WaitForMultipleObjects", "dword", $ICOUNT, "struct*", $PAHANDLES, "bool", $BWAITALL, "dword", $ITIMEOUT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_WAITFORSINGLEOBJECT($HHANDLE, $ITIMEOUT = -1)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "INT", "WaitForSingleObject", "handle", $HHANDLE, "dword", $ITIMEOUT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_WRITECONSOLE($HCONSOLE, $STEXT)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "bool", "WriteConsoleW", "handle", $HCONSOLE, "wstr", $STEXT, "dword", STRINGLEN($STEXT), "dword*", 0, "ptr", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARESULT[0]
	ENDFUNC
#EndRegion Public Functions
GLOBAL CONST $RT_ACCELERATOR = 9
GLOBAL CONST $RT_ANICURSOR = 21
GLOBAL CONST $RT_ANIICON = 22
GLOBAL CONST $RT_BITMAP = 2
GLOBAL CONST $RT_CURSOR = 1
GLOBAL CONST $RT_DIALOG = 5
GLOBAL CONST $RT_DLGINCLUDE = 17
GLOBAL CONST $RT_FONT = 8
GLOBAL CONST $RT_FONTDIR = 7
GLOBAL CONST $RT_GROUP_CURSOR = 12
GLOBAL CONST $RT_GROUP_ICON = 14
GLOBAL CONST $RT_HTML = 23
GLOBAL CONST $RT_ICON = 3
GLOBAL CONST $RT_MANIFEST = 24
GLOBAL CONST $RT_MENU = 4
GLOBAL CONST $RT_MESSAGETABLE = 11
GLOBAL CONST $RT_PLUGPLAY = 19
GLOBAL CONST $RT_RCDATA = 10
GLOBAL CONST $RT_STRING = 6
GLOBAL CONST $RT_VERSION = 16
GLOBAL CONST $RT_VXD = 20
GLOBAL CONST $FILE_VER_GET_LOCALISED = 1
GLOBAL CONST $FILE_VER_GET_NEUTRAL = 2
GLOBAL CONST $FILE_VER_GET_PREFETCHED = 4
GLOBAL CONST $OBM_TRTYPE = 32732
GLOBAL CONST $OBM_LFARROWI = 32734
GLOBAL CONST $OBM_RGARROWI = 32735
GLOBAL CONST $OBM_DNARROWI = 32736
GLOBAL CONST $OBM_UPARROWI = 32737
GLOBAL CONST $OBM_COMBO = 32738
GLOBAL CONST $OBM_MNARROW = 32739
GLOBAL CONST $OBM_LFARROWD = 32740
GLOBAL CONST $OBM_RGARROWD = 32741
GLOBAL CONST $OBM_DNARROWD = 32742
GLOBAL CONST $OBM_UPARROWD = 32743
GLOBAL CONST $OBM_RESTORED = 32744
GLOBAL CONST $OBM_ZOOMD = 32745
GLOBAL CONST $OBM_REDUCED = 32746
GLOBAL CONST $OBM_RESTORE = 32747
GLOBAL CONST $OBM_ZOOM = 32748
GLOBAL CONST $OBM_REDUCE = 32749
GLOBAL CONST $OBM_LFARROW = 32750
GLOBAL CONST $OBM_RGARROW = 32751
GLOBAL CONST $OBM_DNARROW = 32752
GLOBAL CONST $OBM_UPARROW = 32753
GLOBAL CONST $OBM_CLOSE = 32754
GLOBAL CONST $OBM_OLD_RESTORE = 32755
GLOBAL CONST $OBM_OLD_ZOOM = 32756
GLOBAL CONST $OBM_OLD_REDUCE = 32757
GLOBAL CONST $OBM_BTNCORNERS = 32758
GLOBAL CONST $OBM_CHECKBOXES = 32759
GLOBAL CONST $OBM_CHECK = 32760
GLOBAL CONST $OBM_BTSIZE = 32761
GLOBAL CONST $OBM_OLD_LFARROW = 32762
GLOBAL CONST $OBM_OLD_RGARROW = 32763
GLOBAL CONST $OBM_OLD_DNARROW = 32764
GLOBAL CONST $OBM_OLD_UPARROW = 32765
GLOBAL CONST $OBM_SIZE = 32766
GLOBAL CONST $OBM_OLD_CLOSE = 32767
GLOBAL CONST $OIC_SAMPLE = 32512
GLOBAL CONST $OIC_HAND = 32513
GLOBAL CONST $OIC_QUES = 32514
GLOBAL CONST $OIC_BANG = 32515
GLOBAL CONST $OIC_NOTE = 32516
GLOBAL CONST $OIC_WINLOGO = 32517
GLOBAL CONST $OIC_WARNING = $OIC_BANG
GLOBAL CONST $OIC_ERROR = $OIC_HAND
GLOBAL CONST $OIC_INFORMATION = $OIC_NOTE
GLOBAL CONST $DONT_RESOLVE_DLL_REFERENCES = 1
GLOBAL CONST $LOAD_LIBRARY_AS_DATAFILE = 2
GLOBAL CONST $LOAD_WITH_ALTERED_SEARCH_PATH = 8
GLOBAL CONST $LOAD_IGNORE_CODE_AUTHZ_LEVEL = 16
GLOBAL CONST $LOAD_LIBRARY_AS_DATAFILE_EXCLUSIVE = 64
GLOBAL CONST $LOAD_LIBRARY_AS_IMAGE_RESOURCE = 32
GLOBAL CONST $LOAD_LIBRARY_SEARCH_APPLICATION_DIR = 512
GLOBAL CONST $LOAD_LIBRARY_SEARCH_DEFAULT_DIRS = 4096
GLOBAL CONST $LOAD_LIBRARY_SEARCH_DLL_LOAD_DIR = 256
GLOBAL CONST $LOAD_LIBRARY_SEARCH_SYSTEM32 = 2048
GLOBAL CONST $LOAD_LIBRARY_SEARCH_USER_DIRS = 1024
GLOBAL CONST $OCR_NORMAL = 32512
GLOBAL CONST $OCR_IBEAM = 32513
GLOBAL CONST $OCR_WAIT = 32514
GLOBAL CONST $OCR_CROSS = 32515
GLOBAL CONST $OCR_UP = 32516
GLOBAL CONST $OCR_SIZE = 32640
GLOBAL CONST $OCR_ICON = 32641
GLOBAL CONST $OCR_SIZENWSE = 32642
GLOBAL CONST $OCR_SIZENESW = 32643
GLOBAL CONST $OCR_SIZEWE = 32644
GLOBAL CONST $OCR_SIZENS = 32645
GLOBAL CONST $OCR_SIZEALL = 32646
GLOBAL CONST $OCR_ICOCUR = 32647
GLOBAL CONST $OCR_NO = 32648
GLOBAL CONST $OCR_HAND = 32649
GLOBAL CONST $OCR_APPSTARTING = 32650
GLOBAL CONST $OCR_HELP = 32651
GLOBAL CONST $VS_FF_DEBUG = 1
GLOBAL CONST $VS_FF_INFOINFERRED = 16
GLOBAL CONST $VS_FF_PATCHED = 4
GLOBAL CONST $VS_FF_PRERELEASE = 2
GLOBAL CONST $VS_FF_PRIVATEBUILD = 8
GLOBAL CONST $VS_FF_SPECIALBUILD = 32
GLOBAL CONST $VOS_DOS = 65536
GLOBAL CONST $VOS_NT = 262144
GLOBAL CONST $VOS__WINDOWS16 = 1
GLOBAL CONST $VOS__WINDOWS32 = 4
GLOBAL CONST $VOS_OS216 = 131072
GLOBAL CONST $VOS_OS232 = 196608
GLOBAL CONST $VOS__PM16 = 2
GLOBAL CONST $VOS__PM32 = 3
GLOBAL CONST $VOS_UNKNOWN = 0
GLOBAL CONST $VOS_DOS_WINDOWS16 = 65537
GLOBAL CONST $VOS_DOS_WINDOWS32 = 65540
GLOBAL CONST $VOS_NT_WINDOWS32 = 262148
GLOBAL CONST $VOS_OS216_PM16 = 131074
GLOBAL CONST $VOS_OS232_PM32 = 196611
GLOBAL CONST $VFT_APP = 1
GLOBAL CONST $VFT_DLL = 2
GLOBAL CONST $VFT_DRV = 3
GLOBAL CONST $VFT_FONT = 4
GLOBAL CONST $VFT_STATIC_LIB = 7
GLOBAL CONST $VFT_UNKNOWN = 0
GLOBAL CONST $VFT_VXD = 5
GLOBAL CONST $VFT2_DRV_COMM = 10
GLOBAL CONST $VFT2_DRV_DISPLAY = 4
GLOBAL CONST $VFT2_DRV_INSTALLABLE = 8
GLOBAL CONST $VFT2_DRV_KEYBOARD = 2
GLOBAL CONST $VFT2_DRV_LANGUAGE = 3
GLOBAL CONST $VFT2_DRV_MOUSE = 5
GLOBAL CONST $VFT2_DRV_NETWORK = 6
GLOBAL CONST $VFT2_DRV_PRINTER = 1
GLOBAL CONST $VFT2_DRV_SOUND = 9
GLOBAL CONST $VFT2_DRV_SYSTEM = 7
GLOBAL CONST $VFT2_DRV_VERSIONED_PRINTER = 12
GLOBAL CONST $VFT2_UNKNOWN = 0
GLOBAL CONST $VFT2_FONT_RASTER = 1
GLOBAL CONST $VFT2_FONT_TRUETYPE = 3
GLOBAL CONST $VFT2_FONT_VECTOR = 2
#Region Global Variables and Constants
	GLOBAL $__G_VVAL
	GLOBAL CONST $TAGVS_FIXEDFILEINFO = "dword Signature;dword StrucVersion;dword FileVersionMS;dword FileVersionLS;dword ProductVersionMS;dword ProductVersionLS;dword FileFlagsMask;dword FileFlags;dword FileOS;dword FileType;dword FileSubtype;dword FileDateMS;dword FileDateLS"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_BEGINUPDATERESOURCE($SFILEPATH, $BDELETE = FALSE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "BeginUpdateResourceW", "wstr", $SFILEPATH, "bool", $BDELETE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_CLIPCURSOR($TRECT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "ClipCursor", "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_COPYCURSOR($HCURSOR)
		RETURN _WINAPI_COPYICON($HCURSOR)
	ENDFUNC
	FUNC _WINAPI_CREATECARET($HWND, $HBITMAP, $IWIDTH = 0, $IHEIGHT = 0)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "CreateCaret", "hwnd", $HWND, "handle", $HBITMAP, "int", $IWIDTH, "int", $IHEIGHT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DESTROYCARET()
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "DestroyCaret")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_DESTROYCURSOR($HCURSOR)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "DestroyCursor", "handle", $HCURSOR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ENDUPDATERESOURCE($HUPDATE, $BDISCARD = FALSE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "EndUpdateResourceW", "handle", $HUPDATE, "bool", $BDISCARD)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ENUMRESOURCELANGUAGES($HMODULE, $STYPE, $SNAME)
		LOCAL $ILIBRARY = 0, $STYPEOFTYPE = "int", $STYPEOFNAME = "int"
		IF ISSTRING($HMODULE) THEN
			IF STRINGSTRIPWS($HMODULE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
				$HMODULE = _WINAPI_LOADLIBRARYEX($HMODULE, 3)
				IF NOT $HMODULE THEN RETURN SETERROR(1, 0, 0)
				$ILIBRARY = 1
			ELSE
				$HMODULE = 0
			ENDIF
		ENDIF
		IF ISSTRING($STYPE) THEN
			$STYPEOFTYPE = "wstr"
		ENDIF
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		DIM $__G_VENUM[101] = [0]
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumResLanguagesProc", "bool", "handle;ptr;ptr;word;long_ptr")
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "EnumResourceLanguagesW", "handle", $HMODULE, $STYPEOFTYPE, $STYPE, $STYPEOFNAME, $SNAME, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "long_ptr", 0)
		IF @ERROR OR NOT $ARET[0] OR NOT $__G_VENUM[0] THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		IF $ILIBRARY THEN
			_WINAPI_FREELIBRARY($HMODULE)
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_ENUMRESOURCENAMES($HMODULE, $STYPE)
		LOCAL $ARET, $HENUMPROC, $ILIBRARY = 0, $STYPEOFTYPE = "int"
		IF ISSTRING($HMODULE) THEN
			IF STRINGSTRIPWS($HMODULE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
				$HMODULE = _WINAPI_LOADLIBRARYEX($HMODULE, 3)
				IF NOT $HMODULE THEN RETURN SETERROR(1, 0, 0)
				$ILIBRARY = 1
			ELSE
				$HMODULE = 0
			ENDIF
		ENDIF
		IF ISSTRING($STYPE) THEN
			$STYPEOFTYPE = "wstr"
		ENDIF
		DIM $__G_VENUM[101] = [0]
		$HENUMPROC = DLLCALLBACKREGISTER("__EnumResNamesProc", "bool", "handle;ptr;ptr;long_ptr")
		$ARET = DLLCALL("kernel32.dll", "bool", "EnumResourceNamesW", "handle", $HMODULE, $STYPEOFTYPE, $STYPE, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "long_ptr", 0)
		IF @ERROR OR NOT $ARET[0] OR(NOT $__G_VENUM[0]) THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		IF $ILIBRARY THEN
			_WINAPI_FREELIBRARY($HMODULE)
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_ENUMRESOURCETYPES($HMODULE)
		LOCAL $ILIBRARY = 0
		IF ISSTRING($HMODULE) THEN
			IF STRINGSTRIPWS($HMODULE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
				$HMODULE = _WINAPI_LOADLIBRARYEX($HMODULE, 3)
				IF NOT $HMODULE THEN RETURN SETERROR(1, 0, 0)
				$ILIBRARY = 1
			ELSE
				$HMODULE = 0
			ENDIF
		ENDIF
		DIM $__G_VENUM[101] = [0]
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumResTypesProc", "bool", "handle;ptr;long_ptr")
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "EnumResourceTypesW", "handle", $HMODULE, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "long_ptr", 0)
		IF @ERROR OR NOT $ARET[0] OR(NOT $__G_VENUM[0]) THEN
			$__G_VENUM = @ERROR + 10
		ENDIF
		IF $ILIBRARY THEN
			_WINAPI_FREELIBRARY($HMODULE)
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
	FUNC _WINAPI_FINDRESOURCE($HINSTANCE, $STYPE, $SNAME)
		LOCAL $STYPEOFTYPE = "int", $STYPEOFNAME = "int"
		IF ISSTRING($STYPE) THEN
			$STYPEOFTYPE = "wstr"
		ENDIF
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "FindResourceW", "handle", $HINSTANCE, $STYPEOFNAME, $SNAME, $STYPEOFTYPE, $STYPE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FINDRESOURCEEX($HINSTANCE, $STYPE, $SNAME, $ILANGUAGE)
		LOCAL $STYPEOFTYPE = "int", $STYPEOFNAME = "int"
		IF ISSTRING($STYPE) THEN
			$STYPEOFTYPE = "wstr"
		ENDIF
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "FindResourceExW", "handle", $HINSTANCE, $STYPEOFTYPE, $STYPE, $STYPEOFNAME, $SNAME, "ushort", $ILANGUAGE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FREERESOURCE($HDATA)
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "FreeResource", "handle", $HDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETCARETBLINKTIME()
		LOCAL $ARET = DLLCALL("user32.dll", "uint", "GetCaretBlinkTime")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETCARETPOS()
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetCaretPos", "struct*", $TAGPOINT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ARESULT[2]
		FOR $I = 0 TO 1
			$ARESULT[$I] = DLLSTRUCTGETDATA($TPOINT, $I + 1)
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETCLIPCURSOR()
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "GetClipCursor", "struct*", $TRECT)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_GETCURSOR()
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "GetCursor")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETFILEVERSIONINFO($SFILEPATH, BYREF $PBUFFER, $IFLAGS = 0)
		LOCAL $ARET
		IF $__WINVER >= 1536 THEN
			$ARET = DLLCALL("version.dll", "dword", "GetFileVersionInfoSizeExW", "dword", BITAND($IFLAGS, 3), "wstr", $SFILEPATH, "ptr", 0)
		ELSE
			$ARET = DLLCALL("version.dll", "dword", "GetFileVersionInfoSizeW", "wstr", $SFILEPATH, "ptr", 0)
		ENDIF
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		$PBUFFER = __HEAPREALLOC($PBUFFER, $ARET[0], 1)
		IF @ERROR THEN RETURN SETERROR(@ERROR + 100, @EXTENDED, 0)
		LOCAL $INBBYTE = $ARET[0]
		IF $__WINVER >= 1536 THEN
			$ARET = DLLCALL("version.dll", "bool", "GetFileVersionInfoExW", "dword", BITAND($IFLAGS, 7), "wstr", $SFILEPATH, "dword", 0, "dword", $INBBYTE, "ptr", $PBUFFER)
		ELSE
			$ARET = DLLCALL("version.dll", "bool", "GetFileVersionInfoW", "wstr", $SFILEPATH, "dword", 0, "dword", $INBBYTE, "ptr", $PBUFFER)
		ENDIF
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $INBBYTE
	ENDFUNC
	FUNC _WINAPI_HIDECARET($HWND)
		LOCAL $ARET = DLLCALL("user32.dll", "int", "HideCaret", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_LOADBITMAP($HINSTANCE, $SBITMAP)
		LOCAL $SBITMAPTYPE = "int"
		IF ISSTRING($SBITMAP) THEN $SBITMAPTYPE = "wstr"
		LOCAL $ARESULT = DLLCALL("user32.dll", "handle", "LoadBitmapW", "handle", $HINSTANCE, $SBITMAPTYPE, $SBITMAP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_LOADCURSOR($HINSTANCE, $SNAME)
		LOCAL $STYPEOFNAME = "int"
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "LoadCursorW", "handle", $HINSTANCE, $STYPEOFNAME, $SNAME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_LOADCURSORFROMFILE($SFILEPATH)
		LOCAL $ARET = DLLCALL("user32.dll", "handle", "LoadCursorFromFileW", "wstr", $SFILEPATH)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_LOADINDIRECTSTRING($SSTRIN)
		LOCAL $ARET = DLLCALL("shlwapi.dll", "uint", "SHLoadIndirectString", "wstr", $SSTRIN, "wstr", "", "uint", 4096, "ptr*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		RETURN $ARET[2]
	ENDFUNC
	FUNC _WINAPI_LOADSTRING($HINSTANCE, $ISTRINGID)
		LOCAL $ARESULT = DLLCALL("user32.dll", "int", "LoadStringW", "handle", $HINSTANCE, "uint", $ISTRINGID, "wstr", "", "int", 4096)
		IF @ERROR OR NOT $ARESULT[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		RETURN SETEXTENDED($ARESULT[0], $ARESULT[3])
	ENDFUNC
	FUNC _WINAPI_LOADLIBRARYEX($SFILENAME, $IFLAGS = 0)
		LOCAL $ARESULT = DLLCALL("kernel32.dll", "handle", "LoadLibraryExW", "wstr", $SFILENAME, "ptr", 0, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_LOADRESOURCE($HINSTANCE, $HRESOURCE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "handle", "LoadResource", "handle", $HINSTANCE, "handle", $HRESOURCE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_LOADSTRINGEX($HMODULE, $IID, $ILANGUAGE = $LOCALE_USER_DEFAULT)
		LOCAL $ILIBRARY = 0
		IF ISSTRING($HMODULE) THEN
			IF STRINGSTRIPWS($HMODULE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
				$HMODULE = _WINAPI_LOADLIBRARYEX($HMODULE, 3)
				IF NOT $HMODULE THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, "")
				$ILIBRARY = 1
			ELSE
				$HMODULE = 0
			ENDIF
		ENDIF
		LOCAL $SRESULT = ""
		LOCAL $PDATA = __RESLOAD($HMODULE, 6, FLOOR($IID / 16) + 1, $ILANGUAGE)
		IF NOT @ERROR THEN
			LOCAL $IOFFSET = 0
			FOR $I = 0 TO MOD($IID, 16) - 1
				$IOFFSET += 2 * (DLLSTRUCTGETDATA(DLLSTRUCTCREATE("ushort", $PDATA + $IOFFSET), 1) + 1)
			NEXT
			$SRESULT = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("ushort;wchar[" & DLLSTRUCTGETDATA(DLLSTRUCTCREATE("ushort", $PDATA + $IOFFSET), 1) & "]", $PDATA + $IOFFSET), 2)
			IF @ERROR THEN $SRESULT = ""
		ELSE
			RETURN SETERROR(10, 0, "")
		ENDIF
		IF $ILIBRARY THEN
			_WINAPI_FREELIBRARY($HMODULE)
		ENDIF
		RETURN SETERROR(NUMBER(NOT $SRESULT), 0, $SRESULT)
	ENDFUNC
	FUNC _WINAPI_LOCKRESOURCE($HDATA)
		LOCAL $ARET = DLLCALL("kernel32.dll", "ptr", "LockResource", "handle", $HDATA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETCARETBLINKTIME($IDURATION)
		LOCAL $IPREV = _WINAPI_GETCARETBLINKTIME()
		IF NOT $IPREV THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "SetCaretBlinkTime", "uint", $IDURATION)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		RETURN $IPREV
	ENDFUNC
	FUNC _WINAPI_SETCARETPOS($IX, $IY)
		LOCAL $ARET = DLLCALL("user32.dll", "int", "SetCaretPos", "int", $IX, "int", $IY)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETCURSOR($HCURSOR)
		LOCAL $ARESULT = DLLCALL("user32.dll", "handle", "SetCursor", "handle", $HCURSOR)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SETSYSTEMCURSOR($HCURSOR, $IID, $BCOPY = FALSE)
		IF $BCOPY THEN
			$HCURSOR = _WINAPI_COPYCURSOR($HCURSOR)
		ENDIF
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "SetSystemCursor", "handle", $HCURSOR, "dword", $IID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SHOWCARET($HWND)
		LOCAL $ARET = DLLCALL("user32.dll", "bool", "ShowCaret", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SHOWCURSOR($BSHOW)
		LOCAL $ARESULT = DLLCALL("user32.dll", "int", "ShowCursor", "bool", $BSHOW)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARESULT[0]
	ENDFUNC
	FUNC _WINAPI_SIZEOFRESOURCE($HINSTANCE, $HRESOURCE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "dword", "SizeofResource", "handle", $HINSTANCE, "handle", $HRESOURCE)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_UPDATERESOURCE($HUPDATE, $STYPE, $SNAME, $ILANGUAGE, $PDATA, $ISIZE)
		LOCAL $STYPEOFTYPE = "int", $STYPEOFNAME = "int"
		IF ISSTRING($STYPE) THEN
			$STYPEOFTYPE = "wstr"
		ENDIF
		IF ISSTRING($SNAME) THEN
			$STYPEOFNAME = "wstr"
		ENDIF
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "UpdateResourceW", "handle", $HUPDATE, $STYPEOFTYPE, $STYPE, $STYPEOFNAME, $SNAME, "word", $ILANGUAGE, "ptr", $PDATA, "dword", $ISIZE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_VERQUERYROOT($PDATA)
		LOCAL $ARET = DLLCALL("version.dll", "bool", "VerQueryValueW", "ptr", $PDATA, "wstr", "\", "ptr*", 0, "uint*", 0)
		IF @ERROR OR NOT $ARET[0] OR NOT $ARET[4] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $TVFFI = DLLSTRUCTCREATE($TAGVS_FIXEDFILEINFO)
		IF NOT _WINAPI_MOVEMEMORY($TVFFI, $ARET[3], $ARET[4]) THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		RETURN $TVFFI
	ENDFUNC
	FUNC _WINAPI_VERQUERYVALUE($PDATA, $SVALUES = "")
		$SVALUES = STRINGREGEXPREPLACE($SVALUES, "\A[\s\|]*|[\s\|]*\Z", "")
		IF NOT $SVALUES THEN
			$SVALUES = "Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild"
		ENDIF
		$SVALUES = STRINGSPLIT($SVALUES, "|", $STR_NOCOUNT)
		LOCAL $ARET = DLLCALL("version.dll", "bool", "VerQueryValueW", "ptr", $PDATA, "wstr", "\VarFileInfo\Translation", "ptr*", 0, "uint*", 0)
		IF @ERROR OR NOT $ARET[0] OR NOT $ARET[4] THEN RETURN SETERROR(@ERROR + 10, 0, 0)
		LOCAL $ILENGTH = FLOOR($ARET[4] / 4)
		LOCAL $TLANG = DLLSTRUCTCREATE("dword[" & $ILENGTH & "]", $ARET[3])
		IF @ERROR THEN RETURN SETERROR(@ERROR + 20, 0, 0)
		LOCAL $SCP, $AINFO[101][UBOUND($SVALUES) + 1] = [[0]]
		FOR $I = 1 TO $ILENGTH
			__INC($AINFO)
			$AINFO[$AINFO[0][0]][0] = _WINAPI_LOWORD(DLLSTRUCTGETDATA($TLANG, 1, $I))
			$SCP = HEX(_WINAPI_MAKELONG(_WINAPI_HIWORD(DLLSTRUCTGETDATA($TLANG, 1, $I)), _WINAPI_LOWORD(DLLSTRUCTGETDATA($TLANG, 1, $I))), 8)
			FOR $J = 0 TO UBOUND($SVALUES) - 1
				$ARET = DLLCALL("version.dll", "bool", "VerQueryValueW", "ptr", $PDATA, "wstr", "\StringFileInfo\" & $SCP & "\" & $SVALUES[$J], "ptr*", 0, "uint*", 0)
				IF NOT @ERROR AND $ARET[0] AND $ARET[4] THEN
					$AINFO[$AINFO[0][0]][$J + 1] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & $ARET[4] & "]", $ARET[3]), 1)
				ELSE
					$AINFO[$AINFO[0][0]][$J + 1] = ""
				ENDIF
			NEXT
		NEXT
		__INC($AINFO, -1)
		RETURN $AINFO
	ENDFUNC
	FUNC _WINAPI_VERQUERYVALUEEX($HMODULE, $SVALUES = "", $ILANGUAGE = 1024)
		$__G_VVAL = STRINGREGEXPREPLACE($SVALUES, "\A[\s\|]*|[\s\|]*\Z", "")
		IF NOT $__G_VVAL THEN
			$__G_VVAL = "Comments|CompanyName|FileDescription|FileVersion|InternalName|LegalCopyright|LegalTrademarks|OriginalFilename|ProductName|ProductVersion|PrivateBuild|SpecialBuild"
		ENDIF
		$__G_VVAL = STRINGSPLIT($__G_VVAL, "|")
		IF NOT ISARRAY($__G_VVAL) THEN RETURN SETERROR(1, 0, 0)
		LOCAL $ILIBRARY = 0
		IF ISSTRING($HMODULE) THEN
			IF STRINGSTRIPWS($HMODULE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
				$HMODULE = _WINAPI_LOADLIBRARYEX($HMODULE, 3)
				IF NOT $HMODULE THEN
					RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
				ENDIF
				$ILIBRARY = 1
			ELSE
				$HMODULE = 0
			ENDIF
		ENDIF
		DIM $__G_VENUM[101][$__G_VVAL[0] + 1] = [[0]]
		LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumVerValuesProc", "bool", "ptr;ptr;ptr;word;long_ptr")
		LOCAL $ARET = DLLCALL("kernel32.dll", "bool", "EnumResourceLanguagesW", "handle", $HMODULE, "int", 16, "int", 1, "ptr", DLLCALLBACKGETPTR($HENUMPROC), "long_ptr", $ILANGUAGE)
		DO
			IF @ERROR THEN
				$__G_VENUM = @ERROR + 20
			ELSE
				IF NOT $ARET[0] THEN
					SWITCH _WINAPI_GETLASTERROR()
						CASE 0, 15106
							EXITLOOP
						CASE ELSE
							$__G_VENUM = 20
					ENDSWITCH
				ELSE
					EXITLOOP
				ENDIF
			ENDIF
		UNTIL 1
		IF $ILIBRARY THEN
			_WINAPI_FREELIBRARY($HMODULE)
		ENDIF
		DLLCALLBACKFREE($HENUMPROC)
		IF NOT $__G_VENUM[0][0] THEN $__G_VENUM = 230
		IF $__G_VENUM THEN RETURN SETERROR($__G_VENUM, 0, 0)
		__INC($__G_VENUM, -1)
		RETURN $__G_VENUM
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __ENUMRESLANGUAGESPROC($HMODULE, $ITYPE, $INAME, $ILANGUAGE, $LPARAM)
		#forceref $HMODULE, $ITYPE, $INAME, $LPARAM
		__INC($__G_VENUM)
		$__G_VENUM[$__G_VENUM[0]] = $ILANGUAGE
		RETURN 1
	ENDFUNC
	FUNC __ENUMRESNAMESPROC($HMODULE, $ITYPE, $INAME, $LPARAM)
		#forceref $HMODULE, $ITYPE, $LPARAM
		LOCAL $ILENGTH = _WINAPI_STRLEN($INAME)
		__INC($__G_VENUM)
		IF $ILENGTH THEN
			$__G_VENUM[$__G_VENUM[0]] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & ($ILENGTH + 1) & "]", $INAME), 1)
		ELSE
			$__G_VENUM[$__G_VENUM[0]] = NUMBER($INAME)
		ENDIF
		RETURN 1
	ENDFUNC
	FUNC __ENUMRESTYPESPROC($HMODULE, $ITYPE, $LPARAM)
		#forceref $HMODULE, $LPARAM
		LOCAL $ILENGTH = _WINAPI_STRLEN($ITYPE)
		__INC($__G_VENUM)
		IF $ILENGTH THEN
			$__G_VENUM[$__G_VENUM[0]] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & ($ILENGTH + 1) & "]", $ITYPE), 1)
		ELSE
			$__G_VENUM[$__G_VENUM[0]] = NUMBER($ITYPE)
		ENDIF
		RETURN 1
	ENDFUNC
	FUNC __ENUMVERVALUESPROC($HMODULE, $ITYPE, $INAME, $ILANGUAGE, $IDEFAULT)
		LOCAL $ARET, $IENUM = 1, $IERROR = 0
		SWITCH $IDEFAULT
			CASE -1
			CASE 1024
				$ILANGUAGE = 1024
				$IENUM = 0
			CASE ELSE
				IF $ILANGUAGE <> $IDEFAULT THEN
					RETURN 1
				ENDIF
				$IENUM = 0
		ENDSWITCH
		DO
			LOCAL $PDATA = __RESLOAD($HMODULE, $ITYPE, $INAME, $ILANGUAGE)
			IF @ERROR THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
			$ARET = DLLCALL("version.dll", "bool", "VerQueryValueW", "ptr", $PDATA, "wstr", "\VarFileInfo\Translation", "ptr*", 0, "uint*", 0)
			IF @ERROR OR NOT $ARET[0] OR NOT $ARET[4] THEN
				$IERROR = @ERROR + 20
				EXITLOOP
			ENDIF
			LOCAL $TDATA = DLLSTRUCTCREATE("ushort;ushort", $ARET[3])
			IF @ERROR THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
		UNTIL 1
		IF NOT $IERROR THEN
			__INC($__G_VENUM)
			$__G_VENUM[$__G_VENUM[0][0]][0] = DLLSTRUCTGETDATA($TDATA, 1)
			LOCAL $SCP = HEX(_WINAPI_MAKELONG(DLLSTRUCTGETDATA($TDATA, 2), DLLSTRUCTGETDATA($TDATA, 1)), 8)
			FOR $I = 1 TO $__G_VVAL[0]
				$ARET = DLLCALL("version.dll", "bool", "VerQueryValueW", "ptr", $PDATA, "wstr", "\StringFileInfo\" & $SCP & "\" & $__G_VVAL[$I], "ptr*", 0, "uint*", 0)
				IF NOT @ERROR AND $ARET[0] AND $ARET[4] THEN
					$__G_VENUM[$__G_VENUM[0][0]][$I] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & $ARET[4] & "]", $ARET[3]), 1)
				ELSE
					$__G_VENUM[$__G_VENUM[0][0]][$I] = ""
				ENDIF
			NEXT
		ELSE
			$__G_VENUM = @ERROR + 40
		ENDIF
		IF $__G_VENUM THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN $IENUM
	ENDFUNC
	FUNC __RESLOAD($HINSTANCE, $STYPE, $SNAME, $ILANGUAGE)
		LOCAL $HINFO = _WINAPI_FINDRESOURCEEX($HINSTANCE, $STYPE, $SNAME, $ILANGUAGE)
		IF NOT $HINFO THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		LOCAL $ISIZE = _WINAPI_SIZEOFRESOURCE($HINSTANCE, $HINFO)
		IF NOT $ISIZE THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $HDATA = _WINAPI_LOADRESOURCE($HINSTANCE, $HINFO)
		IF NOT $HDATA THEN RETURN SETERROR(@ERROR + 30, @EXTENDED, 0)
		LOCAL $PDATA = _WINAPI_LOCKRESOURCE($HDATA)
		IF NOT $PDATA THEN RETURN SETERROR(@ERROR + 40, @EXTENDED, 0)
		RETURN SETEXTENDED($ISIZE, $PDATA)
	ENDFUNC
#EndRegion Internal Functions
GLOBAL CONST $ACS_CENTER = 1
GLOBAL CONST $ACS_TRANSPARENT = 2
GLOBAL CONST $ACS_AUTOPLAY = 4
GLOBAL CONST $ACS_TIMER = 8
GLOBAL CONST $ACS_NONTRANSPARENT = 16
GLOBAL CONST $GUI_SS_DEFAULT_AVI = $ACS_TRANSPARENT
GLOBAL CONST $__AVICONSTANT_WM_USER = 1024
GLOBAL CONST $ACM_OPENA = $__AVICONSTANT_WM_USER + 100
GLOBAL CONST $ACM_PLAY = $__AVICONSTANT_WM_USER + 101
GLOBAL CONST $ACM_STOP = $__AVICONSTANT_WM_USER + 102
GLOBAL CONST $ACM_ISPLAYING = $__AVICONSTANT_WM_USER + 104
GLOBAL CONST $ACM_OPENW = $__AVICONSTANT_WM_USER + 103
GLOBAL CONST $ACN_START = 1
GLOBAL CONST $ACN_STOP = 2
GLOBAL CONST $BS_GROUPBOX = 7
GLOBAL CONST $BS_BOTTOM = 2048
GLOBAL CONST $BS_CENTER = 768
GLOBAL CONST $BS_DEFPUSHBUTTON = 1
GLOBAL CONST $BS_LEFT = 256
GLOBAL CONST $BS_MULTILINE = 8192
GLOBAL CONST $BS_PUSHBOX = 10
GLOBAL CONST $BS_PUSHLIKE = 4096
GLOBAL CONST $BS_RIGHT = 512
GLOBAL CONST $BS_RIGHTBUTTON = 32
GLOBAL CONST $BS_TOP = 1024
GLOBAL CONST $BS_VCENTER = 3072
GLOBAL CONST $BS_FLAT = 32768
GLOBAL CONST $BS_ICON = 64
GLOBAL CONST $BS_BITMAP = 128
GLOBAL CONST $BS_NOTIFY = 16384
GLOBAL CONST $BS_SPLITBUTTON = 12
GLOBAL CONST $BS_DEFSPLITBUTTON = 13
GLOBAL CONST $BS_COMMANDLINK = 14
GLOBAL CONST $BS_DEFCOMMANDLINK = 15
GLOBAL CONST $BCSIF_GLYPH = 1
GLOBAL CONST $BCSIF_IMAGE = 2
GLOBAL CONST $BCSIF_STYLE = 4
GLOBAL CONST $BCSIF_SIZE = 8
GLOBAL CONST $BCSS_NOSPLIT = 1
GLOBAL CONST $BCSS_STRETCH = 2
GLOBAL CONST $BCSS_ALIGNLEFT = 4
GLOBAL CONST $BCSS_IMAGE = 8
GLOBAL CONST $BUTTON_IMAGELIST_ALIGN_LEFT = 0
GLOBAL CONST $BUTTON_IMAGELIST_ALIGN_RIGHT = 1
GLOBAL CONST $BUTTON_IMAGELIST_ALIGN_TOP = 2
GLOBAL CONST $BUTTON_IMAGELIST_ALIGN_BOTTOM = 3
GLOBAL CONST $BUTTON_IMAGELIST_ALIGN_CENTER = 4
GLOBAL CONST $BS_3STATE = 5
GLOBAL CONST $BS_AUTO3STATE = 6
GLOBAL CONST $BS_AUTOCHECKBOX = 3
GLOBAL CONST $BS_CHECKBOX = 2
GLOBAL CONST $BS_RADIOBUTTON = 4
GLOBAL CONST $BS_AUTORADIOBUTTON = 9
GLOBAL CONST $BS_OWNERDRAW = 11
GLOBAL CONST $GUI_SS_DEFAULT_BUTTON = 0
GLOBAL CONST $GUI_SS_DEFAULT_CHECKBOX = 0
GLOBAL CONST $GUI_SS_DEFAULT_GROUP = 0
GLOBAL CONST $GUI_SS_DEFAULT_RADIO = 0
GLOBAL CONST $BCM_FIRST = 5632
GLOBAL CONST $BCM_GETIDEALSIZE = ($BCM_FIRST + 1)
GLOBAL CONST $BCM_GETIMAGELIST = ($BCM_FIRST + 3)
GLOBAL CONST $BCM_GETNOTE = ($BCM_FIRST + 10)
GLOBAL CONST $BCM_GETNOTELENGTH = ($BCM_FIRST + 11)
GLOBAL CONST $BCM_GETSPLITINFO = ($BCM_FIRST + 8)
GLOBAL CONST $BCM_GETTEXTMARGIN = ($BCM_FIRST + 5)
GLOBAL CONST $BCM_SETDROPDOWNSTATE = ($BCM_FIRST + 6)
GLOBAL CONST $BCM_SETIMAGELIST = ($BCM_FIRST + 2)
GLOBAL CONST $BCM_SETNOTE = ($BCM_FIRST + 9)
GLOBAL CONST $BCM_SETSHIELD = ($BCM_FIRST + 12)
GLOBAL CONST $BCM_SETSPLITINFO = ($BCM_FIRST + 7)
GLOBAL CONST $BCM_SETTEXTMARGIN = ($BCM_FIRST + 4)
GLOBAL CONST $BM_CLICK = 245
GLOBAL CONST $BM_GETCHECK = 240
GLOBAL CONST $BM_GETIMAGE = 246
GLOBAL CONST $BM_GETSTATE = 242
GLOBAL CONST $BM_SETCHECK = 241
GLOBAL CONST $BM_SETDONTCLICK = 248
GLOBAL CONST $BM_SETIMAGE = 247
GLOBAL CONST $BM_SETSTATE = 243
GLOBAL CONST $BM_SETSTYLE = 244
GLOBAL CONST $BCN_FIRST = -1250
GLOBAL CONST $BCN_DROPDOWN = ($BCN_FIRST + 2)
GLOBAL CONST $BCN_HOTITEMCHANGE = ($BCN_FIRST + 1)
GLOBAL CONST $BN_CLICKED = 0
GLOBAL CONST $BN_PAINT = 1
GLOBAL CONST $BN_HILITE = 2
GLOBAL CONST $BN_UNHILITE = 3
GLOBAL CONST $BN_DISABLE = 4
GLOBAL CONST $BN_DOUBLECLICKED = 5
GLOBAL CONST $BN_SETFOCUS = 6
GLOBAL CONST $BN_KILLFOCUS = 7
GLOBAL CONST $BN_PUSHED = $BN_HILITE
GLOBAL CONST $BN_UNPUSHED = $BN_UNHILITE
GLOBAL CONST $BN_DBLCLK = $BN_DOUBLECLICKED
GLOBAL CONST $BST_CHECKED = 1
GLOBAL CONST $BST_INDETERMINATE = 2
GLOBAL CONST $BST_UNCHECKED = 0
GLOBAL CONST $BST_FOCUS = 8
GLOBAL CONST $BST_PUSHED = 4
GLOBAL CONST $BST_DONTCLICK = 128
GLOBAL CONST $CB_ERR = -1
GLOBAL CONST $CB_ERRATTRIBUTE = -3
GLOBAL CONST $CB_ERRREQUIRED = -4
GLOBAL CONST $CB_ERRSPACE = -2
GLOBAL CONST $CB_OKAY = 0
GLOBAL CONST $STATE_SYSTEM_INVISIBLE = 32768
GLOBAL CONST $STATE_SYSTEM_PRESSED = 8
GLOBAL CONST $CBS_AUTOHSCROLL = 64
GLOBAL CONST $CBS_DISABLENOSCROLL = 2048
GLOBAL CONST $CBS_DROPDOWN = 2
GLOBAL CONST $CBS_DROPDOWNLIST = 3
GLOBAL CONST $CBS_HASSTRINGS = 512
GLOBAL CONST $CBS_LOWERCASE = 16384
GLOBAL CONST $CBS_NOINTEGRALHEIGHT = 1024
GLOBAL CONST $CBS_OEMCONVERT = 128
GLOBAL CONST $CBS_OWNERDRAWFIXED = 16
GLOBAL CONST $CBS_OWNERDRAWVARIABLE = 32
GLOBAL CONST $CBS_SIMPLE = 1
GLOBAL CONST $CBS_SORT = 256
GLOBAL CONST $CBS_UPPERCASE = 8192
GLOBAL CONST $CBM_FIRST = 5888
GLOBAL CONST $CB_ADDSTRING = 323
GLOBAL CONST $CB_DELETESTRING = 324
GLOBAL CONST $CB_DIR = 325
GLOBAL CONST $CB_FINDSTRING = 332
GLOBAL CONST $CB_FINDSTRINGEXACT = 344
GLOBAL CONST $CB_GETCOMBOBOXINFO = 356
GLOBAL CONST $CB_GETCOUNT = 326
GLOBAL CONST $CB_GETCUEBANNER = ($CBM_FIRST + 4)
GLOBAL CONST $CB_GETCURSEL = 327
GLOBAL CONST $CB_GETDROPPEDCONTROLRECT = 338
GLOBAL CONST $CB_GETDROPPEDSTATE = 343
GLOBAL CONST $CB_GETDROPPEDWIDTH = 351
GLOBAL CONST $CB_GETEDITSEL = 320
GLOBAL CONST $CB_GETEXTENDEDUI = 342
GLOBAL CONST $CB_GETHORIZONTALEXTENT = 349
GLOBAL CONST $CB_GETITEMDATA = 336
GLOBAL CONST $CB_GETITEMHEIGHT = 340
GLOBAL CONST $CB_GETLBTEXT = 328
GLOBAL CONST $CB_GETLBTEXTLEN = 329
GLOBAL CONST $CB_GETLOCALE = 346
GLOBAL CONST $CB_GETMINVISIBLE = 5890
GLOBAL CONST $CB_GETTOPINDEX = 347
GLOBAL CONST $CB_INITSTORAGE = 353
GLOBAL CONST $CB_LIMITTEXT = 321
GLOBAL CONST $CB_RESETCONTENT = 331
GLOBAL CONST $CB_INSERTSTRING = 330
GLOBAL CONST $CB_SELECTSTRING = 333
GLOBAL CONST $CB_SETCUEBANNER = ($CBM_FIRST + 3)
GLOBAL CONST $CB_SETCURSEL = 334
GLOBAL CONST $CB_SETDROPPEDWIDTH = 352
GLOBAL CONST $CB_SETEDITSEL = 322
GLOBAL CONST $CB_SETEXTENDEDUI = 341
GLOBAL CONST $CB_SETHORIZONTALEXTENT = 350
GLOBAL CONST $CB_SETITEMDATA = 337
GLOBAL CONST $CB_SETITEMHEIGHT = 339
GLOBAL CONST $CB_SETLOCALE = 345
GLOBAL CONST $CB_SETMINVISIBLE = 5889
GLOBAL CONST $CB_SETTOPINDEX = 348
GLOBAL CONST $CB_SHOWDROPDOWN = 335
GLOBAL CONST $CBN_CLOSEUP = 8
GLOBAL CONST $CBN_DBLCLK = 2
GLOBAL CONST $CBN_DROPDOWN = 7
GLOBAL CONST $CBN_EDITCHANGE = 5
GLOBAL CONST $CBN_EDITUPDATE = 6
GLOBAL CONST $CBN_ERRSPACE = (-1)
GLOBAL CONST $CBN_KILLFOCUS = 4
GLOBAL CONST $CBN_SELCHANGE = 1
GLOBAL CONST $CBN_SELENDCANCEL = 10
GLOBAL CONST $CBN_SELENDOK = 9
GLOBAL CONST $CBN_SETFOCUS = 3
GLOBAL CONST $CBES_EX_CASESENSITIVE = 16
GLOBAL CONST $CBES_EX_NOEDITIMAGE = 1
GLOBAL CONST $CBES_EX_NOEDITIMAGEINDENT = 2
GLOBAL CONST $CBES_EX_NOSIZELIMIT = 8
GLOBAL CONST $__COMBOBOXCONSTANT_WM_USER = 1024
GLOBAL CONST $CBEM_DELETEITEM = $CB_DELETESTRING
GLOBAL CONST $CBEM_GETCOMBOCONTROL = ($__COMBOBOXCONSTANT_WM_USER + 6)
GLOBAL CONST $CBEM_GETEDITCONTROL = ($__COMBOBOXCONSTANT_WM_USER + 7)
GLOBAL CONST $CBEM_GETEXSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 9)
GLOBAL CONST $CBEM_GETEXTENDEDSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 9)
GLOBAL CONST $CBEM_GETIMAGELIST = ($__COMBOBOXCONSTANT_WM_USER + 3)
GLOBAL CONST $CBEM_GETITEMA = ($__COMBOBOXCONSTANT_WM_USER + 4)
GLOBAL CONST $CBEM_GETITEMW = ($__COMBOBOXCONSTANT_WM_USER + 13)
GLOBAL CONST $CBEM_GETUNICODEFORMAT = 8192 + 6
GLOBAL CONST $CBEM_HASEDITCHANGED = ($__COMBOBOXCONSTANT_WM_USER + 10)
GLOBAL CONST $CBEM_INSERTITEMA = ($__COMBOBOXCONSTANT_WM_USER + 1)
GLOBAL CONST $CBEM_INSERTITEMW = ($__COMBOBOXCONSTANT_WM_USER + 11)
GLOBAL CONST $CBEM_SETEXSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 8)
GLOBAL CONST $CBEM_SETEXTENDEDSTYLE = ($__COMBOBOXCONSTANT_WM_USER + 14)
GLOBAL CONST $CBEM_SETIMAGELIST = ($__COMBOBOXCONSTANT_WM_USER + 2)
GLOBAL CONST $CBEM_SETITEMA = ($__COMBOBOXCONSTANT_WM_USER + 5)
GLOBAL CONST $CBEM_SETITEMW = ($__COMBOBOXCONSTANT_WM_USER + 12)
GLOBAL CONST $CBEM_SETUNICODEFORMAT = 8192 + 5
GLOBAL CONST $CBEM_SETWINDOWTHEME = 8192 + 11
GLOBAL CONST $CBEN_FIRST = (-800)
GLOBAL CONST $CBEN_LAST = (-830)
GLOBAL CONST $CBEN_BEGINEDIT = ($CBEN_FIRST - 4)
GLOBAL CONST $CBEN_DELETEITEM = ($CBEN_FIRST - 2)
GLOBAL CONST $CBEN_DRAGBEGINA = ($CBEN_FIRST - 8)
GLOBAL CONST $CBEN_DRAGBEGINW = ($CBEN_FIRST - 9)
GLOBAL CONST $CBEN_ENDEDITA = ($CBEN_FIRST - 5)
GLOBAL CONST $CBEN_ENDEDITW = ($CBEN_FIRST - 6)
GLOBAL CONST $CBEN_GETDISPINFO = ($CBEN_FIRST + 0)
GLOBAL CONST $CBEN_GETDISPINFOA = ($CBEN_FIRST + 0)
GLOBAL CONST $CBEN_GETDISPINFOW = ($CBEN_FIRST - 7)
GLOBAL CONST $CBEN_INSERTITEM = ($CBEN_FIRST - 1)
GLOBAL CONST $CBEIF_DI_SETITEM = 268435456
GLOBAL CONST $CBEIF_IMAGE = 2
GLOBAL CONST $CBEIF_INDENT = 16
GLOBAL CONST $CBEIF_LPARAM = 32
GLOBAL CONST $CBEIF_OVERLAY = 8
GLOBAL CONST $CBEIF_SELECTEDIMAGE = 4
GLOBAL CONST $CBEIF_TEXT = 1
GLOBAL CONST $GUI_SS_DEFAULT_COMBO = 2097218
GLOBAL CONST $ES_LEFT = 0
GLOBAL CONST $ES_CENTER = 1
GLOBAL CONST $ES_RIGHT = 2
GLOBAL CONST $ES_MULTILINE = 4
GLOBAL CONST $ES_UPPERCASE = 8
GLOBAL CONST $ES_LOWERCASE = 16
GLOBAL CONST $ES_PASSWORD = 32
GLOBAL CONST $ES_AUTOVSCROLL = 64
GLOBAL CONST $ES_AUTOHSCROLL = 128
GLOBAL CONST $ES_NOHIDESEL = 256
GLOBAL CONST $ES_OEMCONVERT = 1024
GLOBAL CONST $ES_READONLY = 2048
GLOBAL CONST $ES_WANTRETURN = 4096
GLOBAL CONST $ES_NUMBER = 8192
GLOBAL CONST $EC_ERR = -1
GLOBAL CONST $ECM_FIRST = 5376
GLOBAL CONST $EM_CANUNDO = 198
GLOBAL CONST $EM_CHARFROMPOS = 215
GLOBAL CONST $EM_EMPTYUNDOBUFFER = 205
GLOBAL CONST $EM_FMTLINES = 200
GLOBAL CONST $EM_GETCUEBANNER = ($ECM_FIRST + 2)
GLOBAL CONST $EM_GETFIRSTVISIBLELINE = 206
GLOBAL CONST $EM_GETHANDLE = 189
GLOBAL CONST $EM_GETIMESTATUS = 217
GLOBAL CONST $EM_GETLIMITTEXT = 213
GLOBAL CONST $EM_GETLINE = 196
GLOBAL CONST $EM_GETLINECOUNT = 186
GLOBAL CONST $EM_GETMARGINS = 212
GLOBAL CONST $EM_GETMODIFY = 184
GLOBAL CONST $EM_GETPASSWORDCHAR = 210
GLOBAL CONST $EM_GETRECT = 178
GLOBAL CONST $EM_GETSEL = 176
GLOBAL CONST $EM_GETTHUMB = 190
GLOBAL CONST $EM_GETWORDBREAKPROC = 209
GLOBAL CONST $EM_HIDEBALLOONTIP = ($ECM_FIRST + 4)
GLOBAL CONST $EM_LIMITTEXT = 197
GLOBAL CONST $EM_LINEFROMCHAR = 201
GLOBAL CONST $EM_LINEINDEX = 187
GLOBAL CONST $EM_LINELENGTH = 193
GLOBAL CONST $EM_LINESCROLL = 182
GLOBAL CONST $EM_POSFROMCHAR = 214
GLOBAL CONST $EM_REPLACESEL = 194
GLOBAL CONST $EM_SCROLL = 181
GLOBAL CONST $EM_SCROLLCARET = 183
GLOBAL CONST $EM_SETCUEBANNER = ($ECM_FIRST + 1)
GLOBAL CONST $EM_SETHANDLE = 188
GLOBAL CONST $EM_SETIMESTATUS = 216
GLOBAL CONST $EM_SETLIMITTEXT = $EM_LIMITTEXT
GLOBAL CONST $EM_SETMARGINS = 211
GLOBAL CONST $EM_SETMODIFY = 185
GLOBAL CONST $EM_SETPASSWORDCHAR = 204
GLOBAL CONST $EM_SETREADONLY = 207
GLOBAL CONST $EM_SETRECT = 179
GLOBAL CONST $EM_SETRECTNP = 180
GLOBAL CONST $EM_SETSEL = 177
GLOBAL CONST $EM_SETTABSTOPS = 203
GLOBAL CONST $EM_SETWORDBREAKPROC = 208
GLOBAL CONST $EM_SHOWBALLOONTIP = ($ECM_FIRST + 3)
GLOBAL CONST $EM_UNDO = 199
GLOBAL CONST $EC_LEFTMARGIN = 1
GLOBAL CONST $EC_RIGHTMARGIN = 2
GLOBAL CONST $EC_USEFONTINFO = 65535
GLOBAL CONST $EMSIS_COMPOSITIONSTRING = 1
GLOBAL CONST $EIMES_GETCOMPSTRATONCE = 1
GLOBAL CONST $EIMES_CANCELCOMPSTRINFOCUS = 2
GLOBAL CONST $EIMES_COMPLETECOMPSTRKILLFOCUS = 4
GLOBAL CONST $EN_ALIGN_LTR_EC = 1792
GLOBAL CONST $EN_ALIGN_RTL_EC = 1793
GLOBAL CONST $EN_CHANGE = 768
GLOBAL CONST $EN_ERRSPACE = 1280
GLOBAL CONST $EN_HSCROLL = 1537
GLOBAL CONST $EN_KILLFOCUS = 512
GLOBAL CONST $EN_MAXTEXT = 1281
GLOBAL CONST $EN_SETFOCUS = 256
GLOBAL CONST $EN_UPDATE = 1024
GLOBAL CONST $EN_VSCROLL = 1538
GLOBAL CONST $GUI_SS_DEFAULT_EDIT = 3150016
GLOBAL CONST $GUI_SS_DEFAULT_INPUT = 128
GLOBAL CONST $GUI_EVENT_SINGLE = 0
GLOBAL CONST $GUI_EVENT_ARRAY = 1
GLOBAL CONST $GUI_EVENT_NONE = 0
GLOBAL CONST $GUI_EVENT_CLOSE = -3
GLOBAL CONST $GUI_EVENT_MINIMIZE = -4
GLOBAL CONST $GUI_EVENT_RESTORE = -5
GLOBAL CONST $GUI_EVENT_MAXIMIZE = -6
GLOBAL CONST $GUI_EVENT_PRIMARYDOWN = -7
GLOBAL CONST $GUI_EVENT_PRIMARYUP = -8
GLOBAL CONST $GUI_EVENT_SECONDARYDOWN = -9
GLOBAL CONST $GUI_EVENT_SECONDARYUP = -10
GLOBAL CONST $GUI_EVENT_MOUSEMOVE = -11
GLOBAL CONST $GUI_EVENT_RESIZED = -12
GLOBAL CONST $GUI_EVENT_DROPPED = -13
GLOBAL CONST $GUI_RUNDEFMSG = "GUI_RUNDEFMSG"
GLOBAL CONST $GUI_AVISTOP = 0
GLOBAL CONST $GUI_AVISTART = 1
GLOBAL CONST $GUI_AVICLOSE = 2
GLOBAL CONST $GUI_CHECKED = 1
GLOBAL CONST $GUI_INDETERMINATE = 2
GLOBAL CONST $GUI_UNCHECKED = 4
GLOBAL CONST $GUI_DROPACCEPTED = 8
GLOBAL CONST $GUI_NODROPACCEPTED = 4096
GLOBAL CONST $GUI_ACCEPTFILES = $GUI_DROPACCEPTED
GLOBAL CONST $GUI_SHOW = 16
GLOBAL CONST $GUI_HIDE = 32
GLOBAL CONST $GUI_ENABLE = 64
GLOBAL CONST $GUI_DISABLE = 128
GLOBAL CONST $GUI_FOCUS = 256
GLOBAL CONST $GUI_NOFOCUS = 8192
GLOBAL CONST $GUI_DEFBUTTON = 512
GLOBAL CONST $GUI_EXPAND = 1024
GLOBAL CONST $GUI_ONTOP = 2048
GLOBAL CONST $GUI_FONTNORMAL = 0
GLOBAL CONST $GUI_FONTITALIC = 2
GLOBAL CONST $GUI_FONTUNDER = 4
GLOBAL CONST $GUI_FONTSTRIKE = 8
GLOBAL CONST $GUI_DOCKAUTO = 1
GLOBAL CONST $GUI_DOCKLEFT = 2
GLOBAL CONST $GUI_DOCKRIGHT = 4
GLOBAL CONST $GUI_DOCKHCENTER = 8
GLOBAL CONST $GUI_DOCKTOP = 32
GLOBAL CONST $GUI_DOCKBOTTOM = 64
GLOBAL CONST $GUI_DOCKVCENTER = 128
GLOBAL CONST $GUI_DOCKWIDTH = 256
GLOBAL CONST $GUI_DOCKHEIGHT = 512
GLOBAL CONST $GUI_DOCKSIZE = 768
GLOBAL CONST $GUI_DOCKMENUBAR = 544
GLOBAL CONST $GUI_DOCKSTATEBAR = 576
GLOBAL CONST $GUI_DOCKALL = 802
GLOBAL CONST $GUI_DOCKBORDERS = 102
GLOBAL CONST $GUI_GR_CLOSE = 1
GLOBAL CONST $GUI_GR_LINE = 2
GLOBAL CONST $GUI_GR_BEZIER = 4
GLOBAL CONST $GUI_GR_MOVE = 6
GLOBAL CONST $GUI_GR_COLOR = 8
GLOBAL CONST $GUI_GR_RECT = 10
GLOBAL CONST $GUI_GR_ELLIPSE = 12
GLOBAL CONST $GUI_GR_PIE = 14
GLOBAL CONST $GUI_GR_DOT = 16
GLOBAL CONST $GUI_GR_PIXEL = 18
GLOBAL CONST $GUI_GR_HINT = 20
GLOBAL CONST $GUI_GR_REFRESH = 22
GLOBAL CONST $GUI_GR_PENSIZE = 24
GLOBAL CONST $GUI_GR_NOBKCOLOR = -2
GLOBAL CONST $GUI_BKCOLOR_DEFAULT = -1
GLOBAL CONST $GUI_BKCOLOR_TRANSPARENT = -2
GLOBAL CONST $GUI_BKCOLOR_LV_ALTERNATE = -33554432
GLOBAL CONST $GUI_READ_DEFAULT = 0
GLOBAL CONST $GUI_READ_EXTENDED = 1
GLOBAL CONST $GUI_CURSOR_NOOVERRIDE = 0
GLOBAL CONST $GUI_CURSOR_OVERRIDE = 1
GLOBAL CONST $GUI_WS_EX_PARENTDRAG = 1048576
GLOBAL CONST $LBS_NOTIFY = 1
GLOBAL CONST $LBS_SORT = 2
GLOBAL CONST $LBS_NOREDRAW = 4
GLOBAL CONST $LBS_MULTIPLESEL = 8
GLOBAL CONST $LBS_OWNERDRAWFIXED = 16
GLOBAL CONST $LBS_OWNERDRAWVARIABLE = 32
GLOBAL CONST $LBS_HASSTRINGS = 64
GLOBAL CONST $LBS_USETABSTOPS = 128
GLOBAL CONST $LBS_NOINTEGRALHEIGHT = 256
GLOBAL CONST $LBS_MULTICOLUMN = 512
GLOBAL CONST $LBS_WANTKEYBOARDINPUT = 1024
GLOBAL CONST $LBS_EXTENDEDSEL = 2048
GLOBAL CONST $LBS_DISABLENOSCROLL = 4096
GLOBAL CONST $LBS_NODATA = 8192
GLOBAL CONST $LBS_NOSEL = 16384
GLOBAL CONST $LBS_COMBOBOX = 32768
GLOBAL CONST $LBS_STANDARD = 3
GLOBAL CONST $GUI_SS_DEFAULT_LIST = 10485763
GLOBAL CONST $LB_ERR = -1
GLOBAL CONST $LB_ERRATTRIBUTE = -3
GLOBAL CONST $LB_ERRREQUIRED = -4
GLOBAL CONST $LB_ERRSPACE = -2
GLOBAL CONST $LB_ADDSTRING = 384
GLOBAL CONST $LB_INSERTSTRING = 385
GLOBAL CONST $LB_DELETESTRING = 386
GLOBAL CONST $LB_SELITEMRANGEEX = 387
GLOBAL CONST $LB_RESETCONTENT = 388
GLOBAL CONST $LB_SETSEL = 389
GLOBAL CONST $LB_SETCURSEL = 390
GLOBAL CONST $LB_GETSEL = 391
GLOBAL CONST $LB_GETCURSEL = 392
GLOBAL CONST $LB_GETTEXT = 393
GLOBAL CONST $LB_GETTEXTLEN = 394
GLOBAL CONST $LB_GETCOUNT = 395
GLOBAL CONST $LB_SELECTSTRING = 396
GLOBAL CONST $LB_DIR = 397
GLOBAL CONST $LB_GETTOPINDEX = 398
GLOBAL CONST $LB_FINDSTRING = 399
GLOBAL CONST $LB_GETSELCOUNT = 400
GLOBAL CONST $LB_GETSELITEMS = 401
GLOBAL CONST $LB_SETTABSTOPS = 402
GLOBAL CONST $LB_GETHORIZONTALEXTENT = 403
GLOBAL CONST $LB_SETHORIZONTALEXTENT = 404
GLOBAL CONST $LB_SETCOLUMNWIDTH = 405
GLOBAL CONST $LB_ADDFILE = 406
GLOBAL CONST $LB_SETTOPINDEX = 407
GLOBAL CONST $LB_GETITEMRECT = 408
GLOBAL CONST $LB_GETITEMDATA = 409
GLOBAL CONST $LB_SETITEMDATA = 410
GLOBAL CONST $LB_SELITEMRANGE = 411
GLOBAL CONST $LB_SETANCHORINDEX = 412
GLOBAL CONST $LB_GETANCHORINDEX = 413
GLOBAL CONST $LB_SETCARETINDEX = 414
GLOBAL CONST $LB_GETCARETINDEX = 415
GLOBAL CONST $LB_SETITEMHEIGHT = 416
GLOBAL CONST $LB_GETITEMHEIGHT = 417
GLOBAL CONST $LB_FINDSTRINGEXACT = 418
GLOBAL CONST $LB_SETLOCALE = 421
GLOBAL CONST $LB_GETLOCALE = 422
GLOBAL CONST $LB_SETCOUNT = 423
GLOBAL CONST $LB_INITSTORAGE = 424
GLOBAL CONST $LB_ITEMFROMPOINT = 425
GLOBAL CONST $LB_MULTIPLEADDSTRING = 433
GLOBAL CONST $LB_GETLISTBOXINFO = 434
GLOBAL CONST $LBN_ERRSPACE = -2
GLOBAL CONST $LBN_SELCHANGE = 1
GLOBAL CONST $LBN_DBLCLK = 2
GLOBAL CONST $LBN_SELCANCEL = 3
GLOBAL CONST $LBN_SETFOCUS = 4
GLOBAL CONST $LBN_KILLFOCUS = 5
GLOBAL CONST $LVGS_NORMAL = 0
GLOBAL CONST $LVGS_COLLAPSED = 1
GLOBAL CONST $LVGS_HIDDEN = 2
GLOBAL CONST $LVGS_NOHEADER = 4
GLOBAL CONST $LVGS_COLLAPSIBLE = 8
GLOBAL CONST $LVGS_FOCUSED = 16
GLOBAL CONST $LVGS_SELECTED = 32
GLOBAL CONST $LVGS_SUBSETED = 64
GLOBAL CONST $LVGS_SUBSETLINKFOCUSED = 128
GLOBAL CONST $LVGGR_GROUP = 0
GLOBAL CONST $LVGGR_HEADER = 1
GLOBAL CONST $LVGGR_LABEL = 2
GLOBAL CONST $LVGGR_SUBSETLINK = 3
GLOBAL CONST $LV_ERR = -1
GLOBAL CONST $LVBKIF_SOURCE_NONE = 0
GLOBAL CONST $LVBKIF_SOURCE_HBITMAP = 1
GLOBAL CONST $LVBKIF_SOURCE_URL = 2
GLOBAL CONST $LVBKIF_SOURCE_MASK = 3
GLOBAL CONST $LVBKIF_STYLE_NORMAL = 0
GLOBAL CONST $LVBKIF_STYLE_TILE = 16
GLOBAL CONST $LVBKIF_STYLE_MASK = 16
GLOBAL CONST $LVBKIF_FLAG_TILEOFFSET = 256
GLOBAL CONST $LVBKIF_TYPE_WATERMARK = 268435456
GLOBAL CONST $LV_VIEW_DETAILS = 1
GLOBAL CONST $LV_VIEW_ICON = 0
GLOBAL CONST $LV_VIEW_LIST = 3
GLOBAL CONST $LV_VIEW_SMALLICON = 2
GLOBAL CONST $LV_VIEW_TILE = 4
GLOBAL CONST $LVA_ALIGNLEFT = 1
GLOBAL CONST $LVA_ALIGNTOP = 2
GLOBAL CONST $LVA_DEFAULT = 0
GLOBAL CONST $LVA_SNAPTOGRID = 5
GLOBAL CONST $LVCDI_ITEM = 0
GLOBAL CONST $LVCDI_GROUP = 1
GLOBAL CONST $LVCF_ALLDATA = 63
GLOBAL CONST $LVCF_FMT = 1
GLOBAL CONST $LVCF_IMAGE = 16
GLOBAL CONST $LVCFMT_JUSTIFYMASK = 3
GLOBAL CONST $LVCF_TEXT = 4
GLOBAL CONST $LVCF_WIDTH = 2
GLOBAL CONST $LVCFMT_BITMAP_ON_RIGHT = 4096
GLOBAL CONST $LVCFMT_CENTER = 2
GLOBAL CONST $LVCFMT_COL_HAS_IMAGES = 32768
GLOBAL CONST $LVCFMT_IMAGE = 2048
GLOBAL CONST $LVCFMT_LEFT = 0
GLOBAL CONST $LVCFMT_RIGHT = 1
GLOBAL CONST $LVCFMT_LINE_BREAK = 1048576
GLOBAL CONST $LVCFMT_FILL = 2097152
GLOBAL CONST $LVCFMT_WRAP = 4194304
GLOBAL CONST $LVCFMT_NO_TITLE = 8388608
GLOBAL CONST $LVCFMT_TILE_PLACEMENTMASK = BITOR($LVCFMT_LINE_BREAK, $LVCFMT_FILL)
GLOBAL CONST $LVFI_NEARESTXY = 64
GLOBAL CONST $LVFI_PARAM = 1
GLOBAL CONST $LVFI_PARTIAL = 8
GLOBAL CONST $LVFI_STRING = 2
GLOBAL CONST $LVFI_SUBSTRING = 4
GLOBAL CONST $LVFI_WRAP = 32
GLOBAL CONST $LVGA_FOOTER_LEFT = 8
GLOBAL CONST $LVGA_FOOTER_CENTER = 16
GLOBAL CONST $LVGA_FOOTER_RIGHT = 32
GLOBAL CONST $LVGA_HEADER_LEFT = 1
GLOBAL CONST $LVGA_HEADER_CENTER = 2
GLOBAL CONST $LVGA_HEADER_RIGHT = 4
GLOBAL CONST $LVGF_ALIGN = 8
GLOBAL CONST $LVGF_DESCRIPTIONTOP = 1024
GLOBAL CONST $LVGF_DESCRIPTIONBOTTOM = 2048
GLOBAL CONST $LVGF_EXTENDEDIMAGE = 8192
GLOBAL CONST $LVGF_FOOTER = 2
GLOBAL CONST $LVGF_GROUPID = 16
GLOBAL CONST $LVGF_HEADER = 1
GLOBAL CONST $LVGF_ITEMS = 16384
GLOBAL CONST $LVGF_NONE = 0
GLOBAL CONST $LVGF_STATE = 4
GLOBAL CONST $LVGF_SUBSET = 32768
GLOBAL CONST $LVGF_SUBSETITEMS = 65536
GLOBAL CONST $LVGF_SUBTITLE = 256
GLOBAL CONST $LVGF_TASK = 512
GLOBAL CONST $LVGF_TITLEIMAGE = 4096
GLOBAL CONST $LVHT_ABOVE = 8
GLOBAL CONST $LVHT_BELOW = 16
GLOBAL CONST $LVHT_NOWHERE = 1
GLOBAL CONST $LVHT_ONITEMICON = 2
GLOBAL CONST $LVHT_ONITEMLABEL = 4
GLOBAL CONST $LVHT_ONITEMSTATEICON = 8
GLOBAL CONST $LVHT_TOLEFT = 64
GLOBAL CONST $LVHT_TORIGHT = 32
GLOBAL CONST $LVHT_ONITEM = BITOR($LVHT_ONITEMICON, $LVHT_ONITEMLABEL, $LVHT_ONITEMSTATEICON)
GLOBAL CONST $LVHT_EX_GROUP_HEADER = 268435456
GLOBAL CONST $LVHT_EX_GROUP_FOOTER = 536870912
GLOBAL CONST $LVHT_EX_GROUP_COLLAPSE = 1073741824
GLOBAL CONST $LVHT_EX_GROUP_BACKGROUND = -2147483648
GLOBAL CONST $LVHT_EX_GROUP_STATEICON = 16777216
GLOBAL CONST $LVHT_EX_GROUP_SUBSETLINK = 33554432
GLOBAL CONST $LVHT_EX_GROUP = BITOR($LVHT_EX_GROUP_BACKGROUND, $LVHT_EX_GROUP_COLLAPSE, $LVHT_EX_GROUP_FOOTER, $LVHT_EX_GROUP_HEADER, $LVHT_EX_GROUP_STATEICON, $LVHT_EX_GROUP_SUBSETLINK)
GLOBAL CONST $LVHT_EX_ONCONTENTS = 67108864
GLOBAL CONST $LVHT_EX_FOOTER = 134217728
GLOBAL CONST $LVIF_COLFMT = 65536
GLOBAL CONST $LVIF_COLUMNS = 512
GLOBAL CONST $LVIF_GROUPID = 256
GLOBAL CONST $LVIF_IMAGE = 2
GLOBAL CONST $LVIF_INDENT = 16
GLOBAL CONST $LVIF_NORECOMPUTE = 2048
GLOBAL CONST $LVIF_PARAM = 4
GLOBAL CONST $LVIF_STATE = 8
GLOBAL CONST $LVIF_TEXT = 1
GLOBAL CONST $LVIM_AFTER = 1
GLOBAL CONST $LVIR_BOUNDS = 0
GLOBAL CONST $LVIR_ICON = 1
GLOBAL CONST $LVIR_LABEL = 2
GLOBAL CONST $LVIR_SELECTBOUNDS = 3
GLOBAL CONST $LVIS_CUT = 4
GLOBAL CONST $LVIS_DROPHILITED = 8
GLOBAL CONST $LVIS_FOCUSED = 1
GLOBAL CONST $LVIS_OVERLAYMASK = 3840
GLOBAL CONST $LVIS_SELECTED = 2
GLOBAL CONST $LVIS_STATEIMAGEMASK = 61440
GLOBAL CONST $LVS_ALIGNLEFT = 2048
GLOBAL CONST $LVS_ALIGNMASK = 3072
GLOBAL CONST $LVS_ALIGNTOP = 0
GLOBAL CONST $LVS_AUTOARRANGE = 256
GLOBAL CONST $LVS_DEFAULT = 13
GLOBAL CONST $LVS_EDITLABELS = 512
GLOBAL CONST $LVS_ICON = 0
GLOBAL CONST $LVS_LIST = 3
GLOBAL CONST $LVS_NOCOLUMNHEADER = 16384
GLOBAL CONST $LVS_NOLABELWRAP = 128
GLOBAL CONST $LVS_NOSCROLL = 8192
GLOBAL CONST $LVS_NOSORTHEADER = 32768
GLOBAL CONST $LVS_OWNERDATA = 4096
GLOBAL CONST $LVS_OWNERDRAWFIXED = 1024
GLOBAL CONST $LVS_REPORT = 1
GLOBAL CONST $LVS_SHAREIMAGELISTS = 64
GLOBAL CONST $LVS_SHOWSELALWAYS = 8
GLOBAL CONST $LVS_SINGLESEL = 4
GLOBAL CONST $LVS_SMALLICON = 2
GLOBAL CONST $LVS_SORTASCENDING = 16
GLOBAL CONST $LVS_SORTDESCENDING = 32
GLOBAL CONST $LVS_TYPEMASK = 3
GLOBAL CONST $LVS_TYPESTYLEMASK = 64512
GLOBAL CONST $LVS_EX_AUTOAUTOARRANGE = 16777216
GLOBAL CONST $LVS_EX_AUTOCHECKSELECT = 134217728
GLOBAL CONST $LVS_EX_AUTOSIZECOLUMNS = 268435456
GLOBAL CONST $LVS_EX_BORDERSELECT = 32768
GLOBAL CONST $LVS_EX_CHECKBOXES = 4
GLOBAL CONST $LVS_EX_COLUMNOVERFLOW = -2147483648
GLOBAL CONST $LVS_EX_COLUMNSNAPPOINTS = 1073741824
GLOBAL CONST $LVS_EX_DOUBLEBUFFER = 65536
GLOBAL CONST $LVS_EX_FLATSB = 256
GLOBAL CONST $LVS_EX_FULLROWSELECT = 32
GLOBAL CONST $LVS_EX_GRIDLINES = 1
GLOBAL CONST $LVS_EX_HEADERDRAGDROP = 16
GLOBAL CONST $LVS_EX_HEADERINALLVIEWS = 33554432
GLOBAL CONST $LVS_EX_HIDELABELS = 131072
GLOBAL CONST $LVS_EX_INFOTIP = 1024
GLOBAL CONST $LVS_EX_JUSTIFYCOLUMNS = 2097152
GLOBAL CONST $LVS_EX_LABELTIP = 16384
GLOBAL CONST $LVS_EX_MULTIWORKAREAS = 8192
GLOBAL CONST $LVS_EX_ONECLICKACTIVATE = 64
GLOBAL CONST $LVS_EX_REGIONAL = 512
GLOBAL CONST $LVS_EX_SIMPLESELECT = 1048576
GLOBAL CONST $LVS_EX_SNAPTOGRID = 524288
GLOBAL CONST $LVS_EX_SUBITEMIMAGES = 2
GLOBAL CONST $LVS_EX_TRACKSELECT = 8
GLOBAL CONST $LVS_EX_TRANSPARENTBKGND = 4194304
GLOBAL CONST $LVS_EX_TRANSPARENTSHADOWTEXT = 8388608
GLOBAL CONST $LVS_EX_TWOCLICKACTIVATE = 128
GLOBAL CONST $LVS_EX_UNDERLINECOLD = 4096
GLOBAL CONST $LVS_EX_UNDERLINEHOT = 2048
GLOBAL CONST $GUI_SS_DEFAULT_LISTVIEW = BITOR($LVS_SHOWSELALWAYS, $LVS_SINGLESEL)
GLOBAL CONST $LVM_FIRST = 4096
GLOBAL CONST $LVM_APPROXIMATEVIEWRECT = ($LVM_FIRST + 64)
GLOBAL CONST $LVM_ARRANGE = ($LVM_FIRST + 22)
GLOBAL CONST $LVM_CANCELEDITLABEL = ($LVM_FIRST + 179)
GLOBAL CONST $LVM_CREATEDRAGIMAGE = ($LVM_FIRST + 33)
GLOBAL CONST $LVM_DELETEALLITEMS = ($LVM_FIRST + 9)
GLOBAL CONST $LVM_DELETECOLUMN = ($LVM_FIRST + 28)
GLOBAL CONST $LVM_DELETEITEM = ($LVM_FIRST + 8)
GLOBAL CONST $LVM_EDITLABELA = ($LVM_FIRST + 23)
GLOBAL CONST $LVM_EDITLABELW = ($LVM_FIRST + 118)
GLOBAL CONST $LVM_EDITLABEL = $LVM_EDITLABELA
GLOBAL CONST $LVM_ENABLEGROUPVIEW = ($LVM_FIRST + 157)
GLOBAL CONST $LVM_ENSUREVISIBLE = ($LVM_FIRST + 19)
GLOBAL CONST $LVM_FINDITEM = ($LVM_FIRST + 13)
GLOBAL CONST $LVM_GETBKCOLOR = ($LVM_FIRST + 0)
GLOBAL CONST $LVM_GETBKIMAGEA = ($LVM_FIRST + 69)
GLOBAL CONST $LVM_GETBKIMAGEW = ($LVM_FIRST + 139)
GLOBAL CONST $LVM_GETCALLBACKMASK = ($LVM_FIRST + 10)
GLOBAL CONST $LVM_GETCOLUMNA = ($LVM_FIRST + 25)
GLOBAL CONST $LVM_GETCOLUMNW = ($LVM_FIRST + 95)
GLOBAL CONST $LVM_GETCOLUMNORDERARRAY = ($LVM_FIRST + 59)
GLOBAL CONST $LVM_GETCOLUMNWIDTH = ($LVM_FIRST + 29)
GLOBAL CONST $LVM_GETCOUNTPERPAGE = ($LVM_FIRST + 40)
GLOBAL CONST $LVM_GETEDITCONTROL = ($LVM_FIRST + 24)
GLOBAL CONST $LVM_GETEMPTYTEXT = ($LVM_FIRST + 204)
GLOBAL CONST $LVM_GETEXTENDEDLISTVIEWSTYLE = ($LVM_FIRST + 55)
GLOBAL CONST $LVM_GETFOCUSEDGROUP = ($LVM_FIRST + 93)
GLOBAL CONST $LVM_GETFOOTERINFO = ($LVM_FIRST + 206)
GLOBAL CONST $LVM_GETFOOTERITEM = ($LVM_FIRST + 208)
GLOBAL CONST $LVM_GETFOOTERITEMRECT = ($LVM_FIRST + 207)
GLOBAL CONST $LVM_GETFOOTERRECT = ($LVM_FIRST + 205)
GLOBAL CONST $LVM_GETGROUPCOUNT = ($LVM_FIRST + 152)
GLOBAL CONST $LVM_GETGROUPINFO = ($LVM_FIRST + 149)
GLOBAL CONST $LVM_GETGROUPINFOBYINDEX = ($LVM_FIRST + 153)
GLOBAL CONST $LVM_GETGROUPMETRICS = ($LVM_FIRST + 156)
GLOBAL CONST $LVM_GETGROUPRECT = ($LVM_FIRST + 98)
GLOBAL CONST $LVM_GETGROUPSTATE = ($LVM_FIRST + 92)
GLOBAL CONST $LVM_GETHEADER = ($LVM_FIRST + 31)
GLOBAL CONST $LVM_GETHOTCURSOR = ($LVM_FIRST + 63)
GLOBAL CONST $LVM_GETHOTITEM = ($LVM_FIRST + 61)
GLOBAL CONST $LVM_GETHOVERTIME = ($LVM_FIRST + 72)
GLOBAL CONST $LVM_GETIMAGELIST = ($LVM_FIRST + 2)
GLOBAL CONST $LVM_GETINSERTMARK = ($LVM_FIRST + 167)
GLOBAL CONST $LVM_GETINSERTMARKCOLOR = ($LVM_FIRST + 171)
GLOBAL CONST $LVM_GETINSERTMARKRECT = ($LVM_FIRST + 169)
GLOBAL CONST $LVM_GETISEARCHSTRINGA = ($LVM_FIRST + 52)
GLOBAL CONST $LVM_GETISEARCHSTRINGW = ($LVM_FIRST + 117)
GLOBAL CONST $LVM_GETITEMA = ($LVM_FIRST + 5)
GLOBAL CONST $LVM_GETITEMW = ($LVM_FIRST + 75)
GLOBAL CONST $LVM_GETITEMCOUNT = ($LVM_FIRST + 4)
GLOBAL CONST $LVM_GETITEMINDEXRECT = ($LVM_FIRST + 209)
GLOBAL CONST $LVM_GETITEMPOSITION = ($LVM_FIRST + 16)
GLOBAL CONST $LVM_GETITEMRECT = ($LVM_FIRST + 14)
GLOBAL CONST $LVM_GETITEMSPACING = ($LVM_FIRST + 51)
GLOBAL CONST $LVM_GETITEMSTATE = ($LVM_FIRST + 44)
GLOBAL CONST $LVM_GETITEMTEXTA = ($LVM_FIRST + 45)
GLOBAL CONST $LVM_GETITEMTEXTW = ($LVM_FIRST + 115)
GLOBAL CONST $LVM_GETNEXTITEM = ($LVM_FIRST + 12)
GLOBAL CONST $LVM_GETNEXTITEMINDEX = ($LVM_FIRST + 211)
GLOBAL CONST $LVM_GETNUMBEROFWORKAREAS = ($LVM_FIRST + 73)
GLOBAL CONST $LVM_GETORIGIN = ($LVM_FIRST + 41)
GLOBAL CONST $LVM_GETOUTLINECOLOR = ($LVM_FIRST + 176)
GLOBAL CONST $LVM_GETSELECTEDCOLUMN = ($LVM_FIRST + 174)
GLOBAL CONST $LVM_GETSELECTEDCOUNT = ($LVM_FIRST + 50)
GLOBAL CONST $LVM_GETSELECTIONMARK = ($LVM_FIRST + 66)
GLOBAL CONST $LVM_GETSTRINGWIDTHA = ($LVM_FIRST + 17)
GLOBAL CONST $LVM_GETSTRINGWIDTHW = ($LVM_FIRST + 87)
GLOBAL CONST $LVM_GETSUBITEMRECT = ($LVM_FIRST + 56)
GLOBAL CONST $LVM_GETTEXTBKCOLOR = ($LVM_FIRST + 37)
GLOBAL CONST $LVM_GETTEXTCOLOR = ($LVM_FIRST + 35)
GLOBAL CONST $LVM_GETTILEINFO = ($LVM_FIRST + 165)
GLOBAL CONST $LVM_GETTILEVIEWINFO = ($LVM_FIRST + 163)
GLOBAL CONST $LVM_GETTOOLTIPS = ($LVM_FIRST + 78)
GLOBAL CONST $LVM_GETTOPINDEX = ($LVM_FIRST + 39)
GLOBAL CONST $LVM_GETUNICODEFORMAT = 8192 + 6
GLOBAL CONST $LVM_GETVIEW = ($LVM_FIRST + 143)
GLOBAL CONST $LVM_GETVIEWRECT = ($LVM_FIRST + 34)
GLOBAL CONST $LVM_GETWORKAREAS = ($LVM_FIRST + 70)
GLOBAL CONST $LVM_HASGROUP = ($LVM_FIRST + 161)
GLOBAL CONST $LVM_HITTEST = ($LVM_FIRST + 18)
GLOBAL CONST $LVM_INSERTCOLUMNA = ($LVM_FIRST + 27)
GLOBAL CONST $LVM_INSERTCOLUMNW = ($LVM_FIRST + 97)
GLOBAL CONST $LVM_INSERTGROUP = ($LVM_FIRST + 145)
GLOBAL CONST $LVM_INSERTGROUPSORTED = ($LVM_FIRST + 159)
GLOBAL CONST $LVM_INSERTITEMA = ($LVM_FIRST + 7)
GLOBAL CONST $LVM_INSERTITEMW = ($LVM_FIRST + 77)
GLOBAL CONST $LVM_INSERTMARKHITTEST = ($LVM_FIRST + 168)
GLOBAL CONST $LVM_ISGROUPVIEWENABLED = ($LVM_FIRST + 175)
GLOBAL CONST $LVM_ISITEMVISIBLE = ($LVM_FIRST + 182)
GLOBAL CONST $LVM_MAPIDTOINDEX = ($LVM_FIRST + 181)
GLOBAL CONST $LVM_MAPINDEXTOID = ($LVM_FIRST + 180)
GLOBAL CONST $LVM_MOVEGROUP = ($LVM_FIRST + 151)
GLOBAL CONST $LVM_REDRAWITEMS = ($LVM_FIRST + 21)
GLOBAL CONST $LVM_REMOVEALLGROUPS = ($LVM_FIRST + 160)
GLOBAL CONST $LVM_REMOVEGROUP = ($LVM_FIRST + 150)
GLOBAL CONST $LVM_SCROLL = ($LVM_FIRST + 20)
GLOBAL CONST $LVM_SETBKCOLOR = ($LVM_FIRST + 1)
GLOBAL CONST $LVM_SETBKIMAGEA = ($LVM_FIRST + 68)
GLOBAL CONST $LVM_SETBKIMAGEW = ($LVM_FIRST + 138)
GLOBAL CONST $LVM_SETCALLBACKMASK = ($LVM_FIRST + 11)
GLOBAL CONST $LVM_SETCOLUMNA = ($LVM_FIRST + 26)
GLOBAL CONST $LVM_SETCOLUMNW = ($LVM_FIRST + 96)
GLOBAL CONST $LVM_SETCOLUMNORDERARRAY = ($LVM_FIRST + 58)
GLOBAL CONST $LVM_SETCOLUMNWIDTH = ($LVM_FIRST + 30)
GLOBAL CONST $LVM_SETEXTENDEDLISTVIEWSTYLE = ($LVM_FIRST + 54)
GLOBAL CONST $LVM_SETGROUPINFO = ($LVM_FIRST + 147)
GLOBAL CONST $LVM_SETGROUPMETRICS = ($LVM_FIRST + 155)
GLOBAL CONST $LVM_SETHOTCURSOR = ($LVM_FIRST + 62)
GLOBAL CONST $LVM_SETHOTITEM = ($LVM_FIRST + 60)
GLOBAL CONST $LVM_SETHOVERTIME = ($LVM_FIRST + 71)
GLOBAL CONST $LVM_SETICONSPACING = ($LVM_FIRST + 53)
GLOBAL CONST $LVM_SETIMAGELIST = ($LVM_FIRST + 3)
GLOBAL CONST $LVM_SETINFOTIP = ($LVM_FIRST + 173)
GLOBAL CONST $LVM_SETINSERTMARK = ($LVM_FIRST + 166)
GLOBAL CONST $LVM_SETINSERTMARKCOLOR = ($LVM_FIRST + 170)
GLOBAL CONST $LVM_SETITEMA = ($LVM_FIRST + 6)
GLOBAL CONST $LVM_SETITEMW = ($LVM_FIRST + 76)
GLOBAL CONST $LVM_SETITEMCOUNT = ($LVM_FIRST + 47)
GLOBAL CONST $LVM_SETITEMINDEXSTATE = ($LVM_FIRST + 210)
GLOBAL CONST $LVM_SETITEMPOSITION = ($LVM_FIRST + 15)
GLOBAL CONST $LVM_SETITEMPOSITION32 = ($LVM_FIRST + 49)
GLOBAL CONST $LVM_SETITEMSTATE = ($LVM_FIRST + 43)
GLOBAL CONST $LVM_SETITEMTEXTA = ($LVM_FIRST + 46)
GLOBAL CONST $LVM_SETITEMTEXTW = ($LVM_FIRST + 116)
GLOBAL CONST $LVM_SETOUTLINECOLOR = ($LVM_FIRST + 177)
GLOBAL CONST $LVM_SETSELECTEDCOLUMN = ($LVM_FIRST + 140)
GLOBAL CONST $LVM_SETSELECTIONMARK = ($LVM_FIRST + 67)
GLOBAL CONST $LVM_SETTEXTBKCOLOR = ($LVM_FIRST + 38)
GLOBAL CONST $LVM_SETTEXTCOLOR = ($LVM_FIRST + 36)
GLOBAL CONST $LVM_SETTILEINFO = ($LVM_FIRST + 164)
GLOBAL CONST $LVM_SETTILEVIEWINFO = ($LVM_FIRST + 162)
GLOBAL CONST $LVM_SETTILEWIDTH = ($LVM_FIRST + 141)
GLOBAL CONST $LVM_SETTOOLTIPS = ($LVM_FIRST + 74)
GLOBAL CONST $LVM_SETUNICODEFORMAT = 8192 + 5
GLOBAL CONST $LVM_SETVIEW = ($LVM_FIRST + 142)
GLOBAL CONST $LVM_SETWORKAREAS = ($LVM_FIRST + 65)
GLOBAL CONST $LVM_SORTGROUPS = ($LVM_FIRST + 158)
GLOBAL CONST $LVM_SORTITEMS = ($LVM_FIRST + 48)
GLOBAL CONST $LVM_SORTITEMSEX = ($LVM_FIRST + 81)
GLOBAL CONST $LVM_SUBITEMHITTEST = ($LVM_FIRST + 57)
GLOBAL CONST $LVM_UPDATE = ($LVM_FIRST + 42)
GLOBAL CONST $LVN_FIRST = -100
GLOBAL CONST $LVN_LAST = -199
GLOBAL CONST $LVN_BEGINDRAG = ($LVN_FIRST - 9)
GLOBAL CONST $LVN_BEGINLABELEDITA = ($LVN_FIRST - 5)
GLOBAL CONST $LVN_BEGINLABELEDITW = ($LVN_FIRST - 75)
GLOBAL CONST $LVN_BEGINRDRAG = ($LVN_FIRST - 11)
GLOBAL CONST $LVN_BEGINSCROLL = ($LVN_FIRST - 80)
GLOBAL CONST $LVN_COLUMNCLICK = ($LVN_FIRST - 8)
GLOBAL CONST $LVN_COLUMNDROPDOWN = ($LVN_FIRST - 64)
GLOBAL CONST $LVN_COLUMNOVERFLOWCLICK = ($LVN_FIRST - 66)
GLOBAL CONST $LVN_DELETEALLITEMS = ($LVN_FIRST - 4)
GLOBAL CONST $LVN_DELETEITEM = ($LVN_FIRST - 3)
GLOBAL CONST $LVN_ENDLABELEDITA = ($LVN_FIRST - 6)
GLOBAL CONST $LVN_ENDLABELEDITW = ($LVN_FIRST - 76)
GLOBAL CONST $LVN_ENDSCROLL = ($LVN_FIRST - 81)
GLOBAL CONST $LVN_GETDISPINFOA = ($LVN_FIRST - 50)
GLOBAL CONST $LVN_GETDISPINFOW = ($LVN_FIRST - 77)
GLOBAL CONST $LVN_GETDISPINFO = $LVN_GETDISPINFOA
GLOBAL CONST $LVN_GETEMPTYMARKUP = ($LVN_FIRST - 87)
GLOBAL CONST $LVN_GETINFOTIPA = ($LVN_FIRST - 57)
GLOBAL CONST $LVN_GETINFOTIPW = ($LVN_FIRST - 58)
GLOBAL CONST $LVN_HOTTRACK = ($LVN_FIRST - 21)
GLOBAL CONST $LVN_INCREMENTALSEARCHA = ($LVN_FIRST - 62)
GLOBAL CONST $LVN_INCREMENTALSEARCHW = ($LVN_FIRST - 63)
GLOBAL CONST $LVN_INSERTITEM = ($LVN_FIRST - 2)
GLOBAL CONST $LVN_ITEMACTIVATE = ($LVN_FIRST - 14)
GLOBAL CONST $LVN_ITEMCHANGED = ($LVN_FIRST - 1)
GLOBAL CONST $LVN_ITEMCHANGING = ($LVN_FIRST + 0)
GLOBAL CONST $LVN_KEYDOWN = ($LVN_FIRST - 55)
GLOBAL CONST $LVN_LINKCLICK = ($LVN_FIRST - 84)
GLOBAL CONST $LVN_MARQUEEBEGIN = ($LVN_FIRST - 56)
GLOBAL CONST $LVN_ODCACHEHINT = ($LVN_FIRST - 13)
GLOBAL CONST $LVN_ODFINDITEMA = ($LVN_FIRST - 52)
GLOBAL CONST $LVN_ODFINDITEMW = ($LVN_FIRST - 79)
GLOBAL CONST $LVN_ODFINDITEM = $LVN_ODFINDITEMA
GLOBAL CONST $LVN_ODSTATECHANGED = ($LVN_FIRST - 15)
GLOBAL CONST $LVN_SETDISPINFOA = ($LVN_FIRST - 51)
GLOBAL CONST $LVN_SETDISPINFOW = ($LVN_FIRST - 78)
GLOBAL CONST $LVNI_ABOVE = 256
GLOBAL CONST $LVNI_BELOW = 512
GLOBAL CONST $LVNI_TOLEFT = 1024
GLOBAL CONST $LVNI_TORIGHT = 2048
GLOBAL CONST $LVNI_ALL = 0
GLOBAL CONST $LVNI_CUT = 4
GLOBAL CONST $LVNI_DROPHILITED = 8
GLOBAL CONST $LVNI_FOCUSED = 1
GLOBAL CONST $LVNI_SELECTED = 2
GLOBAL CONST $LVSCW_AUTOSIZE = -1
GLOBAL CONST $LVSCW_AUTOSIZE_USEHEADER = -2
GLOBAL CONST $LVSICF_NOINVALIDATEALL = 1
GLOBAL CONST $LVSICF_NOSCROLL = 2
GLOBAL CONST $LVSIL_NORMAL = 0
GLOBAL CONST $LVSIL_SMALL = 1
GLOBAL CONST $LVSIL_STATE = 2
GLOBAL CONST $LVFN_DIR_LEFT = 0
GLOBAL CONST $LVFN_DIR_RIGHT = 1
GLOBAL CONST $LVFN_DIR_UP = 2
GLOBAL CONST $LVFN_DIR_DOWN = 3
GLOBAL CONST $LVFN_DIR_START = 4
GLOBAL CONST $LVFN_DIR_MEND = 5
GLOBAL CONST $LVFN_DIR_PRIOR = 6
GLOBAL CONST $LVFN_DIR_NEXT = 7
GLOBAL CONST $PBS_MARQUEE = 8
GLOBAL CONST $PBS_SMOOTH = 1
GLOBAL CONST $PBS_SMOOTHREVERSE = 16
GLOBAL CONST $PBS_VERTICAL = 4
GLOBAL CONST $GUI_SS_DEFAULT_PROGRESS = 0
GLOBAL CONST $__PROGRESSBARCONSTANT_WM_USER = 1024
GLOBAL CONST $PBM_DELTAPOS = $__PROGRESSBARCONSTANT_WM_USER + 3
GLOBAL CONST $PBM_GETBARCOLOR = 1039
GLOBAL CONST $PBM_GETBKCOLOR = 1038
GLOBAL CONST $PBM_GETPOS = $__PROGRESSBARCONSTANT_WM_USER + 8
GLOBAL CONST $PBM_GETRANGE = $__PROGRESSBARCONSTANT_WM_USER + 7
GLOBAL CONST $PBM_GETSTATE = 1041
GLOBAL CONST $PBM_GETSTEP = 1037
GLOBAL CONST $PBM_SETBARCOLOR = $__PROGRESSBARCONSTANT_WM_USER + 9
GLOBAL CONST $PBM_SETBKCOLOR = 8192 + 1
GLOBAL CONST $PBM_SETMARQUEE = $__PROGRESSBARCONSTANT_WM_USER + 10
GLOBAL CONST $PBM_SETPOS = $__PROGRESSBARCONSTANT_WM_USER + 2
GLOBAL CONST $PBM_SETRANGE = $__PROGRESSBARCONSTANT_WM_USER + 1
GLOBAL CONST $PBM_SETRANGE32 = $__PROGRESSBARCONSTANT_WM_USER + 6
GLOBAL CONST $PBM_SETSTATE = 1040
GLOBAL CONST $PBM_SETSTEP = $__PROGRESSBARCONSTANT_WM_USER + 4
GLOBAL CONST $PBM_STEPIT = $__PROGRESSBARCONSTANT_WM_USER + 5
GLOBAL CONST $__RICHEDITCONSTANT_WM_USER = 1024
GLOBAL CONST $EM_AUTOURLDETECT = $__RICHEDITCONSTANT_WM_USER + 91
GLOBAL CONST $EM_CANPASTE = $__RICHEDITCONSTANT_WM_USER + 50
GLOBAL CONST $EM_CANREDO = $__RICHEDITCONSTANT_WM_USER + 85
GLOBAL CONST $EM_DISPLAYBAND = $__RICHEDITCONSTANT_WM_USER + 51
GLOBAL CONST $EM_EXGETSEL = $__RICHEDITCONSTANT_WM_USER + 52
GLOBAL CONST $EM_EXLIMITTEXT = $__RICHEDITCONSTANT_WM_USER + 53
GLOBAL CONST $EM_EXLINEFROMCHAR = $__RICHEDITCONSTANT_WM_USER + 54
GLOBAL CONST $EM_EXSETSEL = $__RICHEDITCONSTANT_WM_USER + 55
GLOBAL CONST $EM_FINDTEXT = $__RICHEDITCONSTANT_WM_USER + 56
GLOBAL CONST $EM_FINDTEXTEX = $__RICHEDITCONSTANT_WM_USER + 79
GLOBAL CONST $EM_FINDTEXTEXW = $__RICHEDITCONSTANT_WM_USER + 124
GLOBAL CONST $EM_FINDTEXTW = $__RICHEDITCONSTANT_WM_USER + 123
GLOBAL CONST $EM_FINDWORDBREAK = $__RICHEDITCONSTANT_WM_USER + 76
GLOBAL CONST $EM_FORMATRANGE = $__RICHEDITCONSTANT_WM_USER + 57
GLOBAL CONST $EM_GETAUTOURLDETECT = $__RICHEDITCONSTANT_WM_USER + 92
GLOBAL CONST $EM_GETBIDIOPTIONS = $__RICHEDITCONSTANT_WM_USER + 201
GLOBAL CONST $EM_GETCHARFORMAT = $__RICHEDITCONSTANT_WM_USER + 58
GLOBAL CONST $EM_GETEDITSTYLE = $__RICHEDITCONSTANT_WM_USER + 205
GLOBAL CONST $EM_GETEVENTMASK = $__RICHEDITCONSTANT_WM_USER + 59
GLOBAL CONST $EM_GETIMECOLOR = $__RICHEDITCONSTANT_WM_USER + 105
GLOBAL CONST $EM_GETIMECOMPMODE = $__RICHEDITCONSTANT_WM_USER + 122
GLOBAL CONST $EM_GETIMEMODEBIAS = $__RICHEDITCONSTANT_WM_USER + 127
GLOBAL CONST $EM_GETIMEOPTIONS = $__RICHEDITCONSTANT_WM_USER + 107
GLOBAL CONST $EM_GETLANGOPTIONS = $__RICHEDITCONSTANT_WM_USER + 121
GLOBAL CONST $EM_GETOPTIONS = $__RICHEDITCONSTANT_WM_USER + 78
GLOBAL CONST $EM_GETPARAFORMAT = $__RICHEDITCONSTANT_WM_USER + 61
GLOBAL CONST $EM_GETPUNCTUATION = $__RICHEDITCONSTANT_WM_USER + 101
GLOBAL CONST $EM_GETREDONAME = $__RICHEDITCONSTANT_WM_USER + 87
GLOBAL CONST $EM_GETSCROLLPOS = $__RICHEDITCONSTANT_WM_USER + 221
GLOBAL CONST $EM_GETTABLEPARMS = $__RICHEDITCONSTANT_WM_USER + 265
GLOBAL CONST $EM_GETSELTEXT = $__RICHEDITCONSTANT_WM_USER + 62
GLOBAL CONST $EM_GETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 94
GLOBAL CONST $EM_GETTEXTLENGTHEX = $__RICHEDITCONSTANT_WM_USER + 95
GLOBAL CONST $EM_GETTEXTMODE = $__RICHEDITCONSTANT_WM_USER + 90
GLOBAL CONST $EM_GETTEXTRANGE = $__RICHEDITCONSTANT_WM_USER + 75
GLOBAL CONST $EM_GETTYPOGRAPHYOPTIONS = $__RICHEDITCONSTANT_WM_USER + 203
GLOBAL CONST $EM_GETUNDONAME = $__RICHEDITCONSTANT_WM_USER + 86
GLOBAL CONST $EM_GETWORDBREAKPROCEX = $__RICHEDITCONSTANT_WM_USER + 80
GLOBAL CONST $EM_GETWORDWRAPMODE = $__RICHEDITCONSTANT_WM_USER + 103
GLOBAL CONST $EM_GETZOOM = $__RICHEDITCONSTANT_WM_USER + 224
GLOBAL CONST $EM_HIDESELECTION = $__RICHEDITCONSTANT_WM_USER + 63
GLOBAL CONST $EM_INSERTTABLE = $__RICHEDITCONSTANT_WM_USER + 232
GLOBAL CONST $EM_PASTESPECIAL = $__RICHEDITCONSTANT_WM_USER + 64
GLOBAL CONST $EM_RECONVERSION = $__RICHEDITCONSTANT_WM_USER + 125
GLOBAL CONST $EM_REDO = $__RICHEDITCONSTANT_WM_USER + 84
GLOBAL CONST $EM_REQUESTRESIZE = $__RICHEDITCONSTANT_WM_USER + 65
GLOBAL CONST $EM_SELECTIONTYPE = $__RICHEDITCONSTANT_WM_USER + 66
GLOBAL CONST $EM_SETBIDIOPTIONS = $__RICHEDITCONSTANT_WM_USER + 200
GLOBAL CONST $EM_SETBKGNDCOLOR = $__RICHEDITCONSTANT_WM_USER + 67
GLOBAL CONST $EM_SETCHARFORMAT = $__RICHEDITCONSTANT_WM_USER + 68
GLOBAL CONST $EM_SETEDITSTYLE = $__RICHEDITCONSTANT_WM_USER + 204
GLOBAL CONST $EM_SETEVENTMASK = $__RICHEDITCONSTANT_WM_USER + 69
GLOBAL CONST $EM_SETFONTSIZE = $__RICHEDITCONSTANT_WM_USER + 223
GLOBAL CONST $EM_SETIMECOLOR = $__RICHEDITCONSTANT_WM_USER + 104
GLOBAL CONST $EM_SETIMEMODEBIAS = $__RICHEDITCONSTANT_WM_USER + 126
GLOBAL CONST $EM_SETIMEOPTIONS = $__RICHEDITCONSTANT_WM_USER + 106
GLOBAL CONST $EM_SETLANGOPTIONS = $__RICHEDITCONSTANT_WM_USER + 120
GLOBAL CONST $EM_SETOLECALLBACK = $__RICHEDITCONSTANT_WM_USER + 70
GLOBAL CONST $EM_SETOPTIONS = $__RICHEDITCONSTANT_WM_USER + 77
GLOBAL CONST $EM_SETPALETTE = $__RICHEDITCONSTANT_WM_USER + 93
GLOBAL CONST $EM_SETPARAFORMAT = $__RICHEDITCONSTANT_WM_USER + 71
GLOBAL CONST $EM_SETPUNCTUATION = $__RICHEDITCONSTANT_WM_USER + 100
GLOBAL CONST $EM_SETSCROLLPOS = $__RICHEDITCONSTANT_WM_USER + 222
GLOBAL CONST $EM_SETTABLEPARMS = $__RICHEDITCONSTANT_WM_USER + 307
GLOBAL CONST $EM_SETTARGETDEVICE = $__RICHEDITCONSTANT_WM_USER + 72
GLOBAL CONST $EM_SETTEXTEX = $__RICHEDITCONSTANT_WM_USER + 97
GLOBAL CONST $EM_SETTEXTMODE = $__RICHEDITCONSTANT_WM_USER + 89
GLOBAL CONST $EM_SETTYPOGRAPHYOPTIONS = $__RICHEDITCONSTANT_WM_USER + 202
GLOBAL CONST $EM_SETUNDOLIMIT = $__RICHEDITCONSTANT_WM_USER + 82
GLOBAL CONST $EM_SETWORDBREAKPROCEX = $__RICHEDITCONSTANT_WM_USER + 81
GLOBAL CONST $EM_SETWORDWRAPMODE = $__RICHEDITCONSTANT_WM_USER + 102
GLOBAL CONST $EM_SETZOOM = $__RICHEDITCONSTANT_WM_USER + 225
GLOBAL CONST $EM_SHOWSCROLLBAR = $__RICHEDITCONSTANT_WM_USER + 96
GLOBAL CONST $EM_STOPGROUPTYPING = $__RICHEDITCONSTANT_WM_USER + 88
GLOBAL CONST $EM_STREAMIN = $__RICHEDITCONSTANT_WM_USER + 73
GLOBAL CONST $EM_STREAMOUT = $__RICHEDITCONSTANT_WM_USER + 74
GLOBAL CONST $EN_ALIGNLTR = 1808
GLOBAL CONST $EN_ALIGNRTL = 1809
GLOBAL CONST $EN_CORRECTTEXT = 1797
GLOBAL CONST $EN_DRAGDROPDONE = 1804
GLOBAL CONST $EN_DROPFILES = 1795
GLOBAL CONST $EN_IMECHANGE = 1799
GLOBAL CONST $EN_LINK = 1803
GLOBAL CONST $EN_MSGFILTER = 1792
GLOBAL CONST $EN_OBJECTPOSITIONS = 1802
GLOBAL CONST $EN_OLEOPFAILED = 1801
GLOBAL CONST $EN_PROTECTED = 1796
GLOBAL CONST $EN_REQUESTRESIZE = 1793
GLOBAL CONST $EN_SAVECLIPBOARD = 1800
GLOBAL CONST $EN_SELCHANGE = 1794
GLOBAL CONST $EN_STOPNOUNDO = 1798
GLOBAL CONST $ENM_CHANGE = 1
GLOBAL CONST $ENM_CORRECTTEXT = 4194304
GLOBAL CONST $ENM_DRAGDROPDONE = 16
GLOBAL CONST $ENM_DROPFILES = 1048576
GLOBAL CONST $ENM_IMECHANGE = 8388608
GLOBAL CONST $ENM_KEYEVENTS = 65536
GLOBAL CONST $ENM_LINK = 67108864
GLOBAL CONST $ENM_MOUSEEVENTS = 131072
GLOBAL CONST $ENM_OBJECTPOSITIONS = 33554432
GLOBAL CONST $ENM_PROTECTED = 2097152
GLOBAL CONST $ENM_REQUESTRESIZE = 262144
GLOBAL CONST $ENM_SCROLL = 4
GLOBAL CONST $ENM_SCROLLEVENTS = 8
GLOBAL CONST $ENM_SELCHANGE = 524288
GLOBAL CONST $ENM_UPDATE = 2
GLOBAL CONST $BOM_DEFPARADIR = 1
GLOBAL CONST $BOM_PLAINTEXT = 2
GLOBAL CONST $BOM_NEUTRALOVERRIDE = 4
GLOBAL CONST $BOM_CONTEXTREADING = 8
GLOBAL CONST $BOM_CONTEXTALIGNMENT = 16
GLOBAL CONST $BOM_LEGACYBIDICLASS = 64
GLOBAL CONST $BOE_RTLDIR = 1
GLOBAL CONST $BOE_PLAINTEXT = 2
GLOBAL CONST $BOE_NEUTRALOVERRIDE = 4
GLOBAL CONST $BOE_CONTEXTREADING = 8
GLOBAL CONST $BOE_CONTEXTALIGNMENT = 16
GLOBAL CONST $BOE_LEGACYBIDICLASS = 64
GLOBAL CONST $ST_DEFAULT = 0
GLOBAL CONST $ST_KEEPUNDO = 1
GLOBAL CONST $ST_SELECTION = 2
GLOBAL CONST $GT_DEFAULT = 0
GLOBAL CONST $GT_SELECTION = 2
GLOBAL CONST $GT_USECRLF = 1
GLOBAL CONST $GTL_CLOSE = 4
GLOBAL CONST $GTL_DEFAULT = 0
GLOBAL CONST $GTL_NUMBYTES = 16
GLOBAL CONST $GTL_NUMCHARS = 8
GLOBAL CONST $GTL_PRECISE = 2
GLOBAL CONST $GTL_USECRLF = 1
GLOBAL CONST $CFU_UNDERLINENONE = 0
GLOBAL CONST $CFU_UNDERLINE = 1
GLOBAL CONST $CFU_UNDERLINEWORD = 2
GLOBAL CONST $CFU_UNDERLINEDOUBLE = 3
GLOBAL CONST $CFU_UNDERLINEDOTTED = 4
GLOBAL CONST $CP_ACP = 0
GLOBAL CONST $CP_UNICODE = 1200
GLOBAL CONST $CFE_SUBSCRIPT = 65536
GLOBAL CONST $CFE_SUPERSCRIPT = 131072
GLOBAL CONST $CFM_ALLCAPS = 128
GLOBAL CONST $CFM_ANIMATION = 262144
GLOBAL CONST $CFM_BACKCOLOR = 67108864
GLOBAL CONST $CFM_BOLD = 1
GLOBAL CONST $CFM_CHARSET = 134217728
GLOBAL CONST $CFM_COLOR = 1073741824
GLOBAL CONST $CFM_DISABLED = 8192
GLOBAL CONST $CFM_EMBOSS = 2048
GLOBAL CONST $CFM_FACE = 536870912
GLOBAL CONST $CFM_HIDDEN = 256
GLOBAL CONST $CFM_IMPRINT = 4096
GLOBAL CONST $CFM_ITALIC = 2
GLOBAL CONST $CFM_KERNING = 1048576
GLOBAL CONST $CFM_LCID = 33554432
GLOBAL CONST $CFM_LINK = 32
GLOBAL CONST $CFM_OFFSET = 268435456
GLOBAL CONST $CFM_OUTLINE = 512
GLOBAL CONST $CFM_PROTECTED = 16
GLOBAL CONST $CFM_REVAUTHOR = 32768
GLOBAL CONST $CFM_REVISED = 16384
GLOBAL CONST $CFM_SHADOW = 1024
GLOBAL CONST $CFM_SIZE = -2147483648
GLOBAL CONST $CFM_SMALLCAPS = 64
GLOBAL CONST $CFM_SPACING = 2097152
GLOBAL CONST $CFM_STRIKEOUT = 8
GLOBAL CONST $CFM_STYLE = 524288
GLOBAL CONST $CFM_SUBSCRIPT = BITOR($CFE_SUBSCRIPT, $CFE_SUPERSCRIPT)
GLOBAL CONST $CFM_SUPERSCRIPT = $CFM_SUBSCRIPT
GLOBAL CONST $CFM_UNDERLINE = 4
GLOBAL CONST $CFM_UNDERLINETYPE = 8388608
GLOBAL CONST $CFM_WEIGHT = 4194304
GLOBAL CONST $CFE_ALLCAPS = $CFM_ALLCAPS
GLOBAL CONST $CFE_AUTOBACKCOLOR = $CFM_BACKCOLOR
GLOBAL CONST $CFE_AUTOCOLOR = $CFM_COLOR
GLOBAL CONST $CFE_BOLD = $CFM_BOLD
GLOBAL CONST $CFE_DISABLED = $CFM_DISABLED
GLOBAL CONST $CFE_EMBOSS = $CFM_EMBOSS
GLOBAL CONST $CFE_HIDDEN = $CFM_HIDDEN
GLOBAL CONST $CFE_IMPRINT = $CFM_IMPRINT
GLOBAL CONST $CFE_ITALIC = $CFM_ITALIC
GLOBAL CONST $CFE_LINK = $CFM_LINK
GLOBAL CONST $CFE_OUTLINE = $CFM_OUTLINE
GLOBAL CONST $CFE_PROTECTED = $CFM_PROTECTED
GLOBAL CONST $CFE_REVISED = $CFM_REVISED
GLOBAL CONST $CFE_SHADOW = $CFM_SHADOW
GLOBAL CONST $CFE_SMALLCAPS = $CFM_SMALLCAPS
GLOBAL CONST $CFE_STRIKEOUT = $CFM_STRIKEOUT
GLOBAL CONST $CFE_UNDERLINE = $CFM_UNDERLINE
GLOBAL CONST $FR_MATCHALEFHAMZA = -2147483648
GLOBAL CONST $FR_MATCHDIAC = 536870912
GLOBAL CONST $FR_MATCHKASHIDA = 1073741824
GLOBAL CONST $SCF_DEFAULT = 0
GLOBAL CONST $SCF_SELECTION = 1
GLOBAL CONST $SCF_WORD = 2
GLOBAL CONST $SCF_ALL = 4
GLOBAL CONST $SCF_USEUIRULES = 8
GLOBAL CONST $SCF_ASSOCIATEFONT = 16
GLOBAL CONST $SCF_NOKBUPDATE = 32
GLOBAL CONST $LF_FACESIZE = 32
GLOBAL CONST $MAX_TAB_STOPS = 32
GLOBAL CONST $PFA_LEFT = 1
GLOBAL CONST $PFA_RIGHT = 2
GLOBAL CONST $PFA_CENTER = 3
GLOBAL CONST $PFA_JUSTIFY = 4
GLOBAL CONST $PFA_FULL_INTERWORD = 4
GLOBAL CONST $PFE_TABLE = 16384
GLOBAL CONST $PFM_NUMBERING = 32
GLOBAL CONST $PFM_ALIGNMENT = 8
GLOBAL CONST $PFM_SPACEBEFORE = 64
GLOBAL CONST $PFM_NUMBERINGSTYLE = 8192
GLOBAL CONST $PFM_NUMBERINGSTART = 32768
GLOBAL CONST $PFM_BORDER = 2048
GLOBAL CONST $PFM_RIGHTINDENT = 2
GLOBAL CONST $PFM_STARTINDENT = 1
GLOBAL CONST $PFM_OFFSET = 4
GLOBAL CONST $PFM_LINESPACING = 256
GLOBAL CONST $PFM_SPACEAFTER = 128
GLOBAL CONST $PFM_NUMBERINGTAB = 16384
GLOBAL CONST $PFM_TABLE = 1073741824
GLOBAL CONST $PFM_TABSTOPS = 16
GLOBAL CONST $PFN_BULLET = 1
GLOBAL CONST $PFM_RTLPARA = 65536
GLOBAL CONST $PFM_KEEP = 131072
GLOBAL CONST $PFM_KEEPNEXT = 262144
GLOBAL CONST $PFM_PAGEBREAKBEFORE = 524288
GLOBAL CONST $PFM_NOLINENUMBER = 1048576
GLOBAL CONST $PFM_NOWIDOWCONTROL = 2097152
GLOBAL CONST $PFM_DONOTHYPHEN = 4194304
GLOBAL CONST $PFM_SIDEBYSIDE = 8388608
GLOBAL CONST $PFE_RTLPARA = 1
GLOBAL CONST $PFE_KEEP = 2
GLOBAL CONST $PFE_KEEPNEXT = 4
GLOBAL CONST $PFE_PAGEBREAKBEFORE = 8
GLOBAL CONST $PFE_NOLINENUMBER = 16
GLOBAL CONST $PFE_NOWIDOWCONTROL = 32
GLOBAL CONST $PFE_DONOTHYPHEN = 64
GLOBAL CONST $PFE_SIDEBYSIDE = 128
GLOBAL CONST $PFM_SHADING = 4096
GLOBAL CONST $WB_CLASSIFY = 3
GLOBAL CONST $WB_ISDELIMITER = 2
GLOBAL CONST $WB_LEFT = 0
GLOBAL CONST $WB_LEFTBREAK = 6
GLOBAL CONST $WB_MOVEWORDLEFT = 4
GLOBAL CONST $WB_MOVEWORDNEXT = 5
GLOBAL CONST $WB_MOVEWORDPREV = 4
GLOBAL CONST $WB_MOVEWORDRIGHT = 5
GLOBAL CONST $WB_NEXTBREAK = 7
GLOBAL CONST $WB_PREVBREAK = 6
GLOBAL CONST $WB_RIGHT = 1
GLOBAL CONST $WB_RIGHTBREAK = 7
GLOBAL CONST $WBF_ISWHITE = 16
GLOBAL CONST $WBF_BREAKLINE = 32
GLOBAL CONST $WBF_BREAKAFTER = 64
GLOBAL CONST $SF_TEXT = 1
GLOBAL CONST $SF_RTF = 2
GLOBAL CONST $SF_RTFNOOBJS = 3
GLOBAL CONST $SF_TEXTIZED = 4
GLOBAL CONST $SF_UNICODE = 16
GLOBAL CONST $SF_USECODEPAGE = 32
GLOBAL CONST $SFF_PLAINRTF = 16384
GLOBAL CONST $SFF_SELECTION = 32768
GLOBAL CONST $TBCD_CHANNEL = 3
GLOBAL CONST $TBCD_THUMB = 2
GLOBAL CONST $TBCD_TICS = 1
GLOBAL CONST $__SLIDERCONSTANT_WM_USER = 1024
GLOBAL CONST $TBM_CLEARSEL = $__SLIDERCONSTANT_WM_USER + 19
GLOBAL CONST $TBM_CLEARTICS = $__SLIDERCONSTANT_WM_USER + 9
GLOBAL CONST $TBM_GETBUDDY = $__SLIDERCONSTANT_WM_USER + 33
GLOBAL CONST $TBM_GETCHANNELRECT = $__SLIDERCONSTANT_WM_USER + 26
GLOBAL CONST $TBM_GETLINESIZE = $__SLIDERCONSTANT_WM_USER + 24
GLOBAL CONST $TBM_GETNUMTICS = $__SLIDERCONSTANT_WM_USER + 16
GLOBAL CONST $TBM_GETPAGESIZE = $__SLIDERCONSTANT_WM_USER + 22
GLOBAL CONST $TBM_GETPOS = $__SLIDERCONSTANT_WM_USER
GLOBAL CONST $TBM_GETPTICS = $__SLIDERCONSTANT_WM_USER + 14
GLOBAL CONST $TBM_GETSELEND = $__SLIDERCONSTANT_WM_USER + 18
GLOBAL CONST $TBM_GETSELSTART = $__SLIDERCONSTANT_WM_USER + 17
GLOBAL CONST $TBM_GETRANGEMAX = $__SLIDERCONSTANT_WM_USER + 2
GLOBAL CONST $TBM_GETRANGEMIN = $__SLIDERCONSTANT_WM_USER + 1
GLOBAL CONST $TBM_GETTHUMBLENGTH = $__SLIDERCONSTANT_WM_USER + 28
GLOBAL CONST $TBM_GETTHUMBRECT = $__SLIDERCONSTANT_WM_USER + 25
GLOBAL CONST $TBM_GETTIC = $__SLIDERCONSTANT_WM_USER + 3
GLOBAL CONST $TBM_GETTICPOS = $__SLIDERCONSTANT_WM_USER + 15
GLOBAL CONST $TBM_GETTOOLTIPS = $__SLIDERCONSTANT_WM_USER + 30
GLOBAL CONST $TBM_GETUNICODEFORMAT = 8192 + 6
GLOBAL CONST $TBM_SETBUDDY = $__SLIDERCONSTANT_WM_USER + 32
GLOBAL CONST $TBM_SETLINESIZE = $__SLIDERCONSTANT_WM_USER + 23
GLOBAL CONST $TBM_SETPAGESIZE = $__SLIDERCONSTANT_WM_USER + 21
GLOBAL CONST $TBM_SETPOS = $__SLIDERCONSTANT_WM_USER + 5
GLOBAL CONST $TBM_SETRANGE = $__SLIDERCONSTANT_WM_USER + 6
GLOBAL CONST $TBM_SETRANGEMAX = $__SLIDERCONSTANT_WM_USER + 8
GLOBAL CONST $TBM_SETRANGEMIN = $__SLIDERCONSTANT_WM_USER + 7
GLOBAL CONST $TBM_SETSEL = $__SLIDERCONSTANT_WM_USER + 10
GLOBAL CONST $TBM_SETSELEND = $__SLIDERCONSTANT_WM_USER + 12
GLOBAL CONST $TBM_SETSELSTART = $__SLIDERCONSTANT_WM_USER + 11
GLOBAL CONST $TBM_SETTHUMBLENGTH = $__SLIDERCONSTANT_WM_USER + 27
GLOBAL CONST $TBM_SETTIC = $__SLIDERCONSTANT_WM_USER + 4
GLOBAL CONST $TBM_SETTICFREQ = $__SLIDERCONSTANT_WM_USER + 20
GLOBAL CONST $TBM_SETTIPSIDE = $__SLIDERCONSTANT_WM_USER + 31
GLOBAL CONST $TBM_SETTOOLTIPS = $__SLIDERCONSTANT_WM_USER + 29
GLOBAL CONST $TBM_SETUNICODEFORMAT = 8192 + 5
GLOBAL CONST $TBTS_BOTTOM = 2
GLOBAL CONST $TBTS_LEFT = 1
GLOBAL CONST $TBTS_RIGHT = 3
GLOBAL CONST $TBTS_TOP = 0
GLOBAL CONST $TBS_AUTOTICKS = 1
GLOBAL CONST $TBS_BOTH = 8
GLOBAL CONST $TBS_BOTTOM = 0
GLOBAL CONST $TBS_DOWNISLEFT = 1024
GLOBAL CONST $TBS_ENABLESELRANGE = 32
GLOBAL CONST $TBS_FIXEDLENGTH = 64
GLOBAL CONST $TBS_HORZ = 0
GLOBAL CONST $TBS_LEFT = 4
GLOBAL CONST $TBS_NOTHUMB = 128
GLOBAL CONST $TBS_NOTICKS = 16
GLOBAL CONST $TBS_REVERSED = 512
GLOBAL CONST $TBS_RIGHT = 0
GLOBAL CONST $TBS_TOP = 4
GLOBAL CONST $TBS_TOOLTIPS = 256
GLOBAL CONST $TBS_VERT = 2
GLOBAL CONST $GUI_SS_DEFAULT_SLIDER = $TBS_AUTOTICKS
GLOBAL CONST $SS_LEFT = 0
GLOBAL CONST $SS_CENTER = 1
GLOBAL CONST $SS_RIGHT = 2
GLOBAL CONST $SS_ICON = 3
GLOBAL CONST $SS_BLACKRECT = 4
GLOBAL CONST $SS_GRAYRECT = 5
GLOBAL CONST $SS_WHITERECT = 6
GLOBAL CONST $SS_BLACKFRAME = 7
GLOBAL CONST $SS_GRAYFRAME = 8
GLOBAL CONST $SS_WHITEFRAME = 9
GLOBAL CONST $SS_SIMPLE = 11
GLOBAL CONST $SS_LEFTNOWORDWRAP = 12
GLOBAL CONST $SS_BITMAP = 14
GLOBAL CONST $SS_ENHMETAFILE = 15
GLOBAL CONST $SS_ETCHEDHORZ = 16
GLOBAL CONST $SS_ETCHEDVERT = 17
GLOBAL CONST $SS_ETCHEDFRAME = 18
GLOBAL CONST $SS_REALSIZECONTROL = 64
GLOBAL CONST $SS_NOPREFIX = 128
GLOBAL CONST $SS_NOTIFY = 256
GLOBAL CONST $SS_CENTERIMAGE = 512
GLOBAL CONST $SS_RIGHTJUST = 1024
GLOBAL CONST $SS_SUNKEN = 4096
GLOBAL CONST $GUI_SS_DEFAULT_LABEL = 0
GLOBAL CONST $GUI_SS_DEFAULT_GRAPHIC = 0
GLOBAL CONST $GUI_SS_DEFAULT_ICON = $SS_NOTIFY
GLOBAL CONST $GUI_SS_DEFAULT_PIC = $SS_NOTIFY
GLOBAL CONST $STM_SETICON = 368
GLOBAL CONST $STM_GETICON = 369
GLOBAL CONST $STM_SETIMAGE = 370
GLOBAL CONST $STM_GETIMAGE = 371
GLOBAL CONST $TCS_EX_FLATSEPARATORS = 1
GLOBAL CONST $TCS_EX_REGISTERDROP = 2
GLOBAL CONST $TCHT_NOWHERE = 1
GLOBAL CONST $TCHT_ONITEMICON = 2
GLOBAL CONST $TCHT_ONITEMLABEL = 4
GLOBAL CONST $TCHT_ONITEM = 6
GLOBAL CONST $TCIF_TEXT = 1
GLOBAL CONST $TCIF_IMAGE = 2
GLOBAL CONST $TCIF_RTLREADING = 4
GLOBAL CONST $TCIF_PARAM = 8
GLOBAL CONST $TCIF_STATE = 16
GLOBAL CONST $TCIF_ALLDATA = 27
GLOBAL CONST $TCIS_BUTTONPRESSED = 1
GLOBAL CONST $TCIS_HIGHLIGHTED = 2
GLOBAL CONST $TC_ERR = -1
GLOBAL CONST $TCS_BOTTOM = 2
GLOBAL CONST $TCS_BUTTONS = 256
GLOBAL CONST $TCS_FIXEDWIDTH = 1024
GLOBAL CONST $TCS_FLATBUTTONS = 8
GLOBAL CONST $TCS_FOCUSNEVER = 32768
GLOBAL CONST $TCS_FOCUSONBUTTONDOWN = 4096
GLOBAL CONST $TCS_FORCEICONLEFT = 16
GLOBAL CONST $TCS_FORCELABELLEFT = 32
GLOBAL CONST $TCS_HOTTRACK = 64
GLOBAL CONST $TCS_MULTILINE = 512
GLOBAL CONST $TCS_MULTISELECT = 4
GLOBAL CONST $TCS_OWNERDRAWFIXED = 8192
GLOBAL CONST $TCS_RAGGEDRIGHT = 2048
GLOBAL CONST $TCS_RIGHT = 2
GLOBAL CONST $TCS_RIGHTJUSTIFY = 0
GLOBAL CONST $TCS_SCROLLOPPOSITE = 1
GLOBAL CONST $TCS_SINGLELINE = 0
GLOBAL CONST $TCS_TABS = 0
GLOBAL CONST $TCS_TOOLTIPS = 16384
GLOBAL CONST $TCS_VERTICAL = 128
GLOBAL CONST $GUI_SS_DEFAULT_TAB = 0
GLOBAL CONST $TCM_FIRST = 4864
GLOBAL CONST $TCCM_FIRST = 8192
GLOBAL CONST $TCM_ADJUSTRECT = ($TCM_FIRST + 40)
GLOBAL CONST $TCM_DELETEALLITEMS = ($TCM_FIRST + 9)
GLOBAL CONST $TCM_DELETEITEM = ($TCM_FIRST + 8)
GLOBAL CONST $TCM_DESELECTALL = ($TCM_FIRST + 50)
GLOBAL CONST $TCM_GETCURFOCUS = ($TCM_FIRST + 47)
GLOBAL CONST $TCM_GETCURSEL = ($TCM_FIRST + 11)
GLOBAL CONST $TCM_GETEXTENDEDSTYLE = ($TCM_FIRST + 53)
GLOBAL CONST $TCM_GETIMAGELIST = ($TCM_FIRST + 2)
GLOBAL CONST $TCM_GETITEMA = ($TCM_FIRST + 5)
GLOBAL CONST $TCM_GETITEMW = ($TCM_FIRST + 60)
GLOBAL CONST $TCM_GETITEMCOUNT = ($TCM_FIRST + 4)
GLOBAL CONST $TCM_GETITEMRECT = ($TCM_FIRST + 10)
GLOBAL CONST $TCM_GETROWCOUNT = ($TCM_FIRST + 44)
GLOBAL CONST $TCM_GETTOOLTIPS = ($TCM_FIRST + 45)
GLOBAL CONST $TCCM_GETUNICODEFORMAT = ($TCCM_FIRST + 6)
GLOBAL CONST $TCM_GETUNICODEFORMAT = $TCCM_GETUNICODEFORMAT
GLOBAL CONST $TCM_HIGHLIGHTITEM = ($TCM_FIRST + 51)
GLOBAL CONST $TCM_HITTEST = ($TCM_FIRST + 13)
GLOBAL CONST $TCM_INSERTITEMA = ($TCM_FIRST + 7)
GLOBAL CONST $TCM_INSERTITEMW = ($TCM_FIRST + 62)
GLOBAL CONST $TCM_REMOVEIMAGE = ($TCM_FIRST + 42)
GLOBAL CONST $TCM_SETITEMA = ($TCM_FIRST + 6)
GLOBAL CONST $TCM_SETITEMW = ($TCM_FIRST + 61)
GLOBAL CONST $TCM_SETITEMEXTRA = ($TCM_FIRST + 14)
GLOBAL CONST $TCM_SETITEMSIZE = $TCM_FIRST + 41
GLOBAL CONST $TCM_SETCURFOCUS = ($TCM_FIRST + 48)
GLOBAL CONST $TCM_SETCURSEL = ($TCM_FIRST + 12)
GLOBAL CONST $TCM_SETEXTENDEDSTYLE = ($TCM_FIRST + 52)
GLOBAL CONST $TCM_SETIMAGELIST = $TCM_FIRST + 3
GLOBAL CONST $TCM_SETMINTABWIDTH = ($TCM_FIRST + 49)
GLOBAL CONST $TCM_SETPADDING = ($TCM_FIRST + 43)
GLOBAL CONST $TCM_SETTOOLTIPS = ($TCM_FIRST + 46)
GLOBAL CONST $TCCM_SETUNICODEFORMAT = ($TCCM_FIRST + 5)
GLOBAL CONST $TCM_SETUNICODEFORMAT = $TCCM_SETUNICODEFORMAT
GLOBAL CONST $TCN_FIRST = -550
GLOBAL CONST $TCN_FOCUSCHANGE = ($TCN_FIRST - 4)
GLOBAL CONST $TCN_GETOBJECT = ($TCN_FIRST - 3)
GLOBAL CONST $TCN_KEYDOWN = ($TCN_FIRST + 0)
GLOBAL CONST $TCN_SELCHANGE = ($TCN_FIRST - 1)
GLOBAL CONST $TCN_SELCHANGING = ($TCN_FIRST - 2)
GLOBAL CONST $TVS_HASBUTTONS = 1
GLOBAL CONST $TVS_HASLINES = 2
GLOBAL CONST $TVS_LINESATROOT = 4
GLOBAL CONST $TVS_EDITLABELS = 8
GLOBAL CONST $TVS_DISABLEDRAGDROP = 16
GLOBAL CONST $TVS_SHOWSELALWAYS = 32
GLOBAL CONST $TVS_RTLREADING = 64
GLOBAL CONST $TVS_NOTOOLTIPS = 128
GLOBAL CONST $TVS_CHECKBOXES = 256
GLOBAL CONST $TVS_TRACKSELECT = 512
GLOBAL CONST $TVS_SINGLEEXPAND = 1024
GLOBAL CONST $TVS_INFOTIP = 2048
GLOBAL CONST $TVS_FULLROWSELECT = 4096
GLOBAL CONST $TVS_NOSCROLL = 8192
GLOBAL CONST $TVS_NONEVENHEIGHT = 16384
GLOBAL CONST $TVS_NOHSCROLL = 32768
GLOBAL CONST $TVS_DEFAULT = 55
GLOBAL CONST $GUI_SS_DEFAULT_TREEVIEW = BITOR($TVS_HASBUTTONS, $TVS_HASLINES, $TVS_LINESATROOT, $TVS_DISABLEDRAGDROP, $TVS_SHOWSELALWAYS)
GLOBAL CONST $TVE_COLLAPSE = 1
GLOBAL CONST $TVE_EXPAND = 2
GLOBAL CONST $TVE_TOGGLE = 3
GLOBAL CONST $TVE_EXPANDPARTIAL = 16384
GLOBAL CONST $TVE_COLLAPSERESET = 32768
GLOBAL CONST $TVGN_ROOT = 0
GLOBAL CONST $TVGN_NEXT = 1
GLOBAL CONST $TVGN_PREVIOUS = 2
GLOBAL CONST $TVGN_PARENT = 3
GLOBAL CONST $TVGN_CHILD = 4
GLOBAL CONST $TVGN_FIRSTVISIBLE = 5
GLOBAL CONST $TVGN_NEXTVISIBLE = 6
GLOBAL CONST $TVGN_PREVIOUSVISIBLE = 7
GLOBAL CONST $TVGN_DROPHILITE = 8
GLOBAL CONST $TVGN_CARET = 9
GLOBAL CONST $TVGN_LASTVISIBLE = 10
GLOBAL CONST $TVHT_NOWHERE = 1
GLOBAL CONST $TVHT_ONITEMICON = 2
GLOBAL CONST $TVHT_ONITEMLABEL = 4
GLOBAL CONST $TVHT_ONITEMINDENT = 8
GLOBAL CONST $TVHT_ONITEMBUTTON = 16
GLOBAL CONST $TVHT_ONITEMRIGHT = 32
GLOBAL CONST $TVHT_ONITEMSTATEICON = 64
GLOBAL CONST $TVHT_ONITEM = 70
GLOBAL CONST $TVHT_ABOVE = 256
GLOBAL CONST $TVHT_BELOW = 512
GLOBAL CONST $TVHT_TORIGHT = 1024
GLOBAL CONST $TVHT_TOLEFT = 2048
GLOBAL CONST $TVI_ROOT = -65536
GLOBAL CONST $TVI_FIRST = -65535
GLOBAL CONST $TVI_LAST = -65534
GLOBAL CONST $TVI_SORT = -65533
GLOBAL CONST $TVIF_TEXT = 1
GLOBAL CONST $TVIF_IMAGE = 2
GLOBAL CONST $TVIF_PARAM = 4
GLOBAL CONST $TVIF_STATE = 8
GLOBAL CONST $TVIF_HANDLE = 16
GLOBAL CONST $TVIF_SELECTEDIMAGE = 32
GLOBAL CONST $TVIF_CHILDREN = 64
GLOBAL CONST $TVIF_INTEGRAL = 128
GLOBAL CONST $TVIF_EXPANDEDIMAGE = 256
GLOBAL CONST $TVIF_STATEEX = 512
GLOBAL CONST $TVIF_DI_SETITEM = 4096
GLOBAL CONST $TVSIL_NORMAL = 0
GLOBAL CONST $TVSIL_STATE = 2
GLOBAL CONST $TVC_BYKEYBOARD = 2
GLOBAL CONST $TVC_BYMOUSE = 1
GLOBAL CONST $TVC_UNKNOWN = 0
GLOBAL CONST $TVIS_FOCUSED = 1
GLOBAL CONST $TVIS_SELECTED = 2
GLOBAL CONST $TVIS_CUT = 4
GLOBAL CONST $TVIS_DROPHILITED = 8
GLOBAL CONST $TVIS_BOLD = 16
GLOBAL CONST $TVIS_EXPANDED = 32
GLOBAL CONST $TVIS_EXPANDEDONCE = 64
GLOBAL CONST $TVIS_EXPANDPARTIAL = 128
GLOBAL CONST $TVIS_OVERLAYMASK = 3840
GLOBAL CONST $TVIS_STATEIMAGEMASK = 61440
GLOBAL CONST $TVIS_USERMASK = 61440
GLOBAL CONST $TVIS_UNCHECKED = 4096
GLOBAL CONST $TVIS_CHECKED = 8192
GLOBAL CONST $TVNA_ADD = 1
GLOBAL CONST $TVNA_ADDFIRST = 2
GLOBAL CONST $TVNA_ADDCHILD = 3
GLOBAL CONST $TVNA_ADDCHILDFIRST = 4
GLOBAL CONST $TVNA_INSERT = 5
GLOBAL CONST $TVTA_ADDFIRST = 1
GLOBAL CONST $TVTA_ADD = 2
GLOBAL CONST $TVTA_INSERT = 3
GLOBAL CONST $TV_FIRST = 4352
GLOBAL CONST $TVM_INSERTITEMA = $TV_FIRST + 0
GLOBAL CONST $TVM_DELETEITEM = $TV_FIRST + 1
GLOBAL CONST $TVM_EXPAND = $TV_FIRST + 2
GLOBAL CONST $TVM_GETITEMRECT = $TV_FIRST + 4
GLOBAL CONST $TVM_GETCOUNT = $TV_FIRST + 5
GLOBAL CONST $TVM_GETINDENT = $TV_FIRST + 6
GLOBAL CONST $TVM_SETINDENT = $TV_FIRST + 7
GLOBAL CONST $TVM_GETIMAGELIST = $TV_FIRST + 8
GLOBAL CONST $TVM_SETIMAGELIST = $TV_FIRST + 9
GLOBAL CONST $TVM_GETNEXTITEM = $TV_FIRST + 10
GLOBAL CONST $TVM_SELECTITEM = $TV_FIRST + 11
GLOBAL CONST $TVM_GETITEMA = $TV_FIRST + 12
GLOBAL CONST $TVM_SETITEMA = $TV_FIRST + 13
GLOBAL CONST $TVM_EDITLABELA = $TV_FIRST + 14
GLOBAL CONST $TVM_GETEDITCONTROL = $TV_FIRST + 15
GLOBAL CONST $TVM_GETVISIBLECOUNT = $TV_FIRST + 16
GLOBAL CONST $TVM_HITTEST = $TV_FIRST + 17
GLOBAL CONST $TVM_CREATEDRAGIMAGE = $TV_FIRST + 18
GLOBAL CONST $TVM_SORTCHILDREN = $TV_FIRST + 19
GLOBAL CONST $TVM_ENSUREVISIBLE = $TV_FIRST + 20
GLOBAL CONST $TVM_SORTCHILDRENCB = $TV_FIRST + 21
GLOBAL CONST $TVM_ENDEDITLABELNOW = $TV_FIRST + 22
GLOBAL CONST $TVM_GETISEARCHSTRINGA = $TV_FIRST + 23
GLOBAL CONST $TVM_SETTOOLTIPS = $TV_FIRST + 24
GLOBAL CONST $TVM_GETTOOLTIPS = $TV_FIRST + 25
GLOBAL CONST $TVM_SETINSERTMARK = $TV_FIRST + 26
GLOBAL CONST $TVM_SETITEMHEIGHT = $TV_FIRST + 27
GLOBAL CONST $TVM_GETITEMHEIGHT = $TV_FIRST + 28
GLOBAL CONST $TVM_SETBKCOLOR = $TV_FIRST + 29
GLOBAL CONST $TVM_SETTEXTCOLOR = $TV_FIRST + 30
GLOBAL CONST $TVM_GETBKCOLOR = $TV_FIRST + 31
GLOBAL CONST $TVM_GETTEXTCOLOR = $TV_FIRST + 32
GLOBAL CONST $TVM_SETSCROLLTIME = $TV_FIRST + 33
GLOBAL CONST $TVM_GETSCROLLTIME = $TV_FIRST + 34
GLOBAL CONST $TVM_SETINSERTMARKCOLOR = $TV_FIRST + 37
GLOBAL CONST $TVM_GETINSERTMARKCOLOR = $TV_FIRST + 38
GLOBAL CONST $TVM_GETITEMSTATE = $TV_FIRST + 39
GLOBAL CONST $TVM_SETLINECOLOR = $TV_FIRST + 40
GLOBAL CONST $TVM_GETLINECOLOR = $TV_FIRST + 41
GLOBAL CONST $TVM_MAPACCIDTOHTREEITEM = $TV_FIRST + 42
GLOBAL CONST $TVM_MAPHTREEITEMTOACCID = $TV_FIRST + 43
GLOBAL CONST $TVM_INSERTITEMW = $TV_FIRST + 50
GLOBAL CONST $TVM_GETITEMW = $TV_FIRST + 62
GLOBAL CONST $TVM_SETITEMW = $TV_FIRST + 63
GLOBAL CONST $TVM_GETISEARCHSTRINGW = $TV_FIRST + 64
GLOBAL CONST $TVM_EDITLABELW = $TV_FIRST + 65
GLOBAL CONST $TVM_GETUNICODEFORMAT = 8192 + 6
GLOBAL CONST $TVM_SETUNICODEFORMAT = 8192 + 5
GLOBAL CONST $TVN_FIRST = -400
GLOBAL CONST $TVN_SELCHANGINGA = $TVN_FIRST - 1
GLOBAL CONST $TVN_SELCHANGEDA = $TVN_FIRST - 2
GLOBAL CONST $TVN_GETDISPINFOA = $TVN_FIRST - 3
GLOBAL CONST $TVN_SETDISPINFOA = $TVN_FIRST - 4
GLOBAL CONST $TVN_ITEMEXPANDINGA = $TVN_FIRST - 5
GLOBAL CONST $TVN_ITEMEXPANDEDA = $TVN_FIRST - 6
GLOBAL CONST $TVN_BEGINDRAGA = $TVN_FIRST - 7
GLOBAL CONST $TVN_BEGINRDRAGA = $TVN_FIRST - 8
GLOBAL CONST $TVN_DELETEITEMA = $TVN_FIRST - 9
GLOBAL CONST $TVN_BEGINLABELEDITA = $TVN_FIRST - 10
GLOBAL CONST $TVN_ENDLABELEDITA = $TVN_FIRST - 11
GLOBAL CONST $TVN_KEYDOWN = $TVN_FIRST - 12
GLOBAL CONST $TVN_GETINFOTIPA = $TVN_FIRST - 13
GLOBAL CONST $TVN_GETINFOTIPW = $TVN_FIRST - 14
GLOBAL CONST $TVN_SINGLEEXPAND = $TVN_FIRST - 15
GLOBAL CONST $TVN_ITEMCHANGINGA = $TVN_FIRST - 16
GLOBAL CONST $TVN_ITEMCHANGINGW = $TVN_FIRST - 17
GLOBAL CONST $TVN_ITEMCHANGEDA = $TVN_FIRST - 18
GLOBAL CONST $TVN_ITEMCHANGEDW = $TVN_FIRST - 19
GLOBAL CONST $TVN_SELCHANGINGW = $TVN_FIRST - 50
GLOBAL CONST $TVN_SELCHANGEDW = $TVN_FIRST - 51
GLOBAL CONST $TVN_GETDISPINFOW = $TVN_FIRST - 52
GLOBAL CONST $TVN_SETDISPINFOW = $TVN_FIRST - 53
GLOBAL CONST $TVN_ITEMEXPANDINGW = $TVN_FIRST - 54
GLOBAL CONST $TVN_ITEMEXPANDEDW = $TVN_FIRST - 55
GLOBAL CONST $TVN_BEGINDRAGW = $TVN_FIRST - 56
GLOBAL CONST $TVN_BEGINRDRAGW = $TVN_FIRST - 57
GLOBAL CONST $TVN_DELETEITEMW = $TVN_FIRST - 58
GLOBAL CONST $TVN_BEGINLABELEDITW = $TVN_FIRST - 59
GLOBAL CONST $TVN_ENDLABELEDITW = $TVN_FIRST - 60
GLOBAL CONST $UDS_WRAP = 1
GLOBAL CONST $UDS_SETBUDDYINT = 2
GLOBAL CONST $UDS_ALIGNRIGHT = 4
GLOBAL CONST $UDS_ALIGNLEFT = 8
GLOBAL CONST $UDS_ARROWKEYS = 32
GLOBAL CONST $UDS_HORZ = 64
GLOBAL CONST $UDS_NOTHOUSANDS = 128
GLOBAL CONST $GUI_SS_DEFAULT_UPDOWN = $UDS_ALIGNLEFT
GLOBAL CONST $WC_ANIMATE = "SysAnimate32"
GLOBAL CONST $WC_BUTTON = "Button"
GLOBAL CONST $WC_COMBOBOX = "ComboBox"
GLOBAL CONST $WC_COMBOBOXEX = "ComboBoxEx32"
GLOBAL CONST $WC_DATETIMEPICK = "SysDateTimePick32"
GLOBAL CONST $WC_EDIT = "Edit"
GLOBAL CONST $WC_HEADER = "SysHeader32"
GLOBAL CONST $WC_HOTKEY = "msctls_hotkey32"
GLOBAL CONST $WC_IPADDRESS = "SysIPAddress32"
GLOBAL CONST $WC_LINK = "SysLink"
GLOBAL CONST $WC_LISTBOX = "ListBox"
GLOBAL CONST $WC_LISTVIEW = "SysListView32"
GLOBAL CONST $WC_MONTHCAL = "SysMonthCal32"
GLOBAL CONST $WC_NATIVEFONTCTL = "NativeFontCtl"
GLOBAL CONST $WC_PAGESCROLLER = "SysPager"
GLOBAL CONST $WC_PROGRESS = "msctls_progress32"
GLOBAL CONST $WC_REBAR = "ReBarWindow32"
GLOBAL CONST $WC_SCROLLBAR = "ScrollBar"
GLOBAL CONST $WC_STATIC = "Static"
GLOBAL CONST $WC_STATUSBAR = "msctls_statusbar32"
GLOBAL CONST $WC_TABCONTROL = "SysTabControl32"
GLOBAL CONST $WC_TOOLBAR = "ToolbarWindow32"
GLOBAL CONST $WC_TOOLTIPS = "tooltips_class32"
GLOBAL CONST $WC_TRACKBAR = "msctls_trackbar32"
GLOBAL CONST $WC_TREEVIEW = "SysTreeView32"
GLOBAL CONST $WC_UPDOWN = "msctls_updown32"
GLOBAL CONST $WS_OVERLAPPED = 0
GLOBAL CONST $WS_TILED = $WS_OVERLAPPED
GLOBAL CONST $WS_MAXIMIZEBOX = 65536
GLOBAL CONST $WS_MINIMIZEBOX = 131072
GLOBAL CONST $WS_TABSTOP = 65536
GLOBAL CONST $WS_GROUP = 131072
GLOBAL CONST $WS_SIZEBOX = 262144
GLOBAL CONST $WS_THICKFRAME = $WS_SIZEBOX
GLOBAL CONST $WS_SYSMENU = 524288
GLOBAL CONST $WS_HSCROLL = 1048576
GLOBAL CONST $WS_VSCROLL = 2097152
GLOBAL CONST $WS_DLGFRAME = 4194304
GLOBAL CONST $WS_BORDER = 8388608
GLOBAL CONST $WS_CAPTION = 12582912
GLOBAL CONST $WS_OVERLAPPEDWINDOW = BITOR($WS_CAPTION, $WS_MAXIMIZEBOX, $WS_MINIMIZEBOX, $WS_OVERLAPPED, $WS_SYSMENU, $WS_THICKFRAME)
GLOBAL CONST $WS_TILEDWINDOW = $WS_OVERLAPPEDWINDOW
GLOBAL CONST $WS_MAXIMIZE = 16777216
GLOBAL CONST $WS_CLIPCHILDREN = 33554432
GLOBAL CONST $WS_CLIPSIBLINGS = 67108864
GLOBAL CONST $WS_DISABLED = 134217728
GLOBAL CONST $WS_VISIBLE = 268435456
GLOBAL CONST $WS_MINIMIZE = 536870912
GLOBAL CONST $WS_ICONIC = $WS_MINIMIZE
GLOBAL CONST $WS_CHILD = 1073741824
GLOBAL CONST $WS_CHILDWINDOW = $WS_CHILD
GLOBAL CONST $WS_POPUP = -2147483648
GLOBAL CONST $WS_POPUPWINDOW = -2138570752
GLOBAL CONST $DS_3DLOOK = 4
GLOBAL CONST $DS_ABSALIGN = 1
GLOBAL CONST $DS_CENTER = 2048
GLOBAL CONST $DS_CENTERMOUSE = 4096
GLOBAL CONST $DS_CONTEXTHELP = 8192
GLOBAL CONST $DS_CONTROL = 1024
GLOBAL CONST $DS_FIXEDSYS = 8
GLOBAL CONST $DS_LOCALEDIT = 32
GLOBAL CONST $DS_MODALFRAME = 128
GLOBAL CONST $DS_NOFAILCREATE = 16
GLOBAL CONST $DS_NOIDLEMSG = 256
GLOBAL CONST $DS_SETFONT = 64
GLOBAL CONST $DS_SETFOREGROUND = 512
GLOBAL CONST $DS_SHELLFONT = BITOR($DS_FIXEDSYS, $DS_SETFONT)
GLOBAL CONST $DS_SYSMODAL = 2
GLOBAL CONST $WS_EX_ACCEPTFILES = 16
GLOBAL CONST $WS_EX_APPWINDOW = 262144
GLOBAL CONST $WS_EX_COMPOSITED = 33554432
GLOBAL CONST $WS_EX_CONTROLPARENT = 65536
GLOBAL CONST $WS_EX_CLIENTEDGE = 512
GLOBAL CONST $WS_EX_CONTEXTHELP = 1024
GLOBAL CONST $WS_EX_DLGMODALFRAME = 1
GLOBAL CONST $WS_EX_LAYERED = 524288
GLOBAL CONST $WS_EX_LAYOUTRTL = 4194304
GLOBAL CONST $WS_EX_LEFT = 0
GLOBAL CONST $WS_EX_LEFTSCROLLBAR = 16384
GLOBAL CONST $WS_EX_LTRREADING = 0
GLOBAL CONST $WS_EX_MDICHILD = 64
GLOBAL CONST $WS_EX_NOACTIVATE = 134217728
GLOBAL CONST $WS_EX_NOINHERITLAYOUT = 1048576
GLOBAL CONST $WS_EX_NOPARENTNOTIFY = 4
GLOBAL CONST $WS_EX_RIGHT = 4096
GLOBAL CONST $WS_EX_RIGHTSCROLLBAR = 0
GLOBAL CONST $WS_EX_RTLREADING = 8192
GLOBAL CONST $WS_EX_STATICEDGE = 131072
GLOBAL CONST $WS_EX_TOOLWINDOW = 128
GLOBAL CONST $WS_EX_TOPMOST = 8
GLOBAL CONST $WS_EX_TRANSPARENT = 32
GLOBAL CONST $WS_EX_WINDOWEDGE = 256
GLOBAL CONST $WS_EX_OVERLAPPEDWINDOW = BITOR($WS_EX_CLIENTEDGE, $WS_EX_WINDOWEDGE)
GLOBAL CONST $WS_EX_PALETTEWINDOW = BITOR($WS_EX_TOOLWINDOW, $WS_EX_TOPMOST, $WS_EX_WINDOWEDGE)
GLOBAL CONST $WM_NULL = 0
GLOBAL CONST $WM_CREATE = 1
GLOBAL CONST $WM_DESTROY = 2
GLOBAL CONST $WM_MOVE = 3
GLOBAL CONST $WM_SIZEWAIT = 4
GLOBAL CONST $WM_SIZE = 5
GLOBAL CONST $WM_ACTIVATE = 6
GLOBAL CONST $WM_SETFOCUS = 7
GLOBAL CONST $WM_KILLFOCUS = 8
GLOBAL CONST $WM_SETVISIBLE = 9
GLOBAL CONST $WM_ENABLE = 10
GLOBAL CONST $WM_SETREDRAW = 11
GLOBAL CONST $WM_SETTEXT = 12
GLOBAL CONST $WM_GETTEXT = 13
GLOBAL CONST $WM_GETTEXTLENGTH = 14
GLOBAL CONST $WM_PAINT = 15
GLOBAL CONST $WM_CLOSE = 16
GLOBAL CONST $WM_QUERYENDSESSION = 17
GLOBAL CONST $WM_QUIT = 18
GLOBAL CONST $WM_ERASEBKGND = 20
GLOBAL CONST $WM_QUERYOPEN = 19
GLOBAL CONST $WM_SYSCOLORCHANGE = 21
GLOBAL CONST $WM_ENDSESSION = 22
GLOBAL CONST $WM_SYSTEMERROR = 23
GLOBAL CONST $WM_SHOWWINDOW = 24
GLOBAL CONST $WM_CTLCOLOR = 25
GLOBAL CONST $WM_SETTINGCHANGE = 26
GLOBAL CONST $WM_WININICHANGE = 26
GLOBAL CONST $WM_DEVMODECHANGE = 27
GLOBAL CONST $WM_ACTIVATEAPP = 28
GLOBAL CONST $WM_FONTCHANGE = 29
GLOBAL CONST $WM_TIMECHANGE = 30
GLOBAL CONST $WM_CANCELMODE = 31
GLOBAL CONST $WM_SETCURSOR = 32
GLOBAL CONST $WM_MOUSEACTIVATE = 33
GLOBAL CONST $WM_CHILDACTIVATE = 34
GLOBAL CONST $WM_QUEUESYNC = 35
GLOBAL CONST $WM_GETMINMAXINFO = 36
GLOBAL CONST $WM_LOGOFF = 37
GLOBAL CONST $WM_PAINTICON = 38
GLOBAL CONST $WM_ICONERASEBKGND = 39
GLOBAL CONST $WM_NEXTDLGCTL = 40
GLOBAL CONST $WM_ALTTABACTIVE = 41
GLOBAL CONST $WM_SPOOLERSTATUS = 42
GLOBAL CONST $WM_DRAWITEM = 43
GLOBAL CONST $WM_MEASUREITEM = 44
GLOBAL CONST $WM_DELETEITEM = 45
GLOBAL CONST $WM_VKEYTOITEM = 46
GLOBAL CONST $WM_CHARTOITEM = 47
GLOBAL CONST $WM_SETFONT = 48
GLOBAL CONST $WM_GETFONT = 49
GLOBAL CONST $WM_SETHOTKEY = 50
GLOBAL CONST $WM_GETHOTKEY = 51
GLOBAL CONST $WM_FILESYSCHANGE = 52
GLOBAL CONST $WM_ISACTIVEICON = 53
GLOBAL CONST $WM_QUERYPARKICON = 54
GLOBAL CONST $WM_QUERYDRAGICON = 55
GLOBAL CONST $WM_WINHELP = 56
GLOBAL CONST $WM_COMPAREITEM = 57
GLOBAL CONST $WM_FULLSCREEN = 58
GLOBAL CONST $WM_CLIENTSHUTDOWN = 59
GLOBAL CONST $WM_DDEMLEVENT = 60
GLOBAL CONST $WM_GETOBJECT = 61
GLOBAL CONST $WM_CALCSCROLL = 63
GLOBAL CONST $WM_TESTING = 64
GLOBAL CONST $WM_COMPACTING = 65
GLOBAL CONST $WM_OTHERWINDOWCREATED = 66
GLOBAL CONST $WM_OTHERWINDOWDESTROYED = 67
GLOBAL CONST $WM_COMMNOTIFY = 68
GLOBAL CONST $WM_MEDIASTATUSCHANGE = 69
GLOBAL CONST $WM_WINDOWPOSCHANGING = 70
GLOBAL CONST $WM_WINDOWPOSCHANGED = 71
GLOBAL CONST $WM_POWER = 72
GLOBAL CONST $WM_COPYGLOBALDATA = 73
GLOBAL CONST $WM_COPYDATA = 74
GLOBAL CONST $WM_CANCELJOURNAL = 75
GLOBAL CONST $WM_LOGONNOTIFY = 76
GLOBAL CONST $WM_KEYF1 = 77
GLOBAL CONST $WM_NOTIFY = 78
GLOBAL CONST $WM_ACCESS_WINDOW = 79
GLOBAL CONST $WM_INPUTLANGCHANGEREQUEST = 80
GLOBAL CONST $WM_INPUTLANGCHANGE = 81
GLOBAL CONST $WM_TCARD = 82
GLOBAL CONST $WM_HELP = 83
GLOBAL CONST $WM_USERCHANGED = 84
GLOBAL CONST $WM_NOTIFYFORMAT = 85
GLOBAL CONST $WM_QM_ACTIVATE = 96
GLOBAL CONST $WM_HOOK_DO_CALLBACK = 97
GLOBAL CONST $WM_SYSCOPYDATA = 98
GLOBAL CONST $WM_FINALDESTROY = 112
GLOBAL CONST $WM_MEASUREITEM_CLIENTDATA = 113
GLOBAL CONST $WM_CONTEXTMENU = 123
GLOBAL CONST $WM_STYLECHANGING = 124
GLOBAL CONST $WM_STYLECHANGED = 125
GLOBAL CONST $WM_DISPLAYCHANGE = 126
GLOBAL CONST $WM_GETICON = 127
GLOBAL CONST $WM_SETICON = 128
GLOBAL CONST $WM_NCCREATE = 129
GLOBAL CONST $WM_NCDESTROY = 130
GLOBAL CONST $WM_NCCALCSIZE = 131
GLOBAL CONST $WM_NCHITTEST = 132
GLOBAL CONST $WM_NCPAINT = 133
GLOBAL CONST $WM_NCACTIVATE = 134
GLOBAL CONST $WM_GETDLGCODE = 135
GLOBAL CONST $WM_SYNCPAINT = 136
GLOBAL CONST $WM_SYNCTASK = 137
GLOBAL CONST $WM_KLUDGEMINRECT = 139
GLOBAL CONST $WM_LPKDRAWSWITCHWND = 140
GLOBAL CONST $WM_UAHDESTROYWINDOW = 144
GLOBAL CONST $WM_UAHDRAWMENU = 145
GLOBAL CONST $WM_UAHDRAWMENUITEM = 146
GLOBAL CONST $WM_UAHINITMENU = 147
GLOBAL CONST $WM_UAHMEASUREMENUITEM = 148
GLOBAL CONST $WM_UAHNCPAINTMENUPOPUP = 149
GLOBAL CONST $WM_NCMOUSEMOVE = 160
GLOBAL CONST $WM_NCLBUTTONDOWN = 161
GLOBAL CONST $WM_NCLBUTTONUP = 162
GLOBAL CONST $WM_NCLBUTTONDBLCLK = 163
GLOBAL CONST $WM_NCRBUTTONDOWN = 164
GLOBAL CONST $WM_NCRBUTTONUP = 165
GLOBAL CONST $WM_NCRBUTTONDBLCLK = 166
GLOBAL CONST $WM_NCMBUTTONDOWN = 167
GLOBAL CONST $WM_NCMBUTTONUP = 168
GLOBAL CONST $WM_NCMBUTTONDBLCLK = 169
GLOBAL CONST $WM_NCXBUTTONDOWN = 171
GLOBAL CONST $WM_NCXBUTTONUP = 172
GLOBAL CONST $WM_NCXBUTTONDBLCLK = 173
GLOBAL CONST $WM_NCUAHDRAWCAPTION = 174
GLOBAL CONST $WM_NCUAHDRAWFRAME = 175
GLOBAL CONST $WM_INPUT_DEVICE_CHANGE = 254
GLOBAL CONST $WM_INPUT = 255
GLOBAL CONST $WM_KEYDOWN = 256
GLOBAL CONST $WM_KEYFIRST = 256
GLOBAL CONST $WM_KEYUP = 257
GLOBAL CONST $WM_CHAR = 258
GLOBAL CONST $WM_DEADCHAR = 259
GLOBAL CONST $WM_SYSKEYDOWN = 260
GLOBAL CONST $WM_SYSKEYUP = 261
GLOBAL CONST $WM_SYSCHAR = 262
GLOBAL CONST $WM_SYSDEADCHAR = 263
GLOBAL CONST $WM_YOMICHAR = 264
GLOBAL CONST $WM_KEYLAST = 265
GLOBAL CONST $WM_UNICHAR = 265
GLOBAL CONST $WM_CONVERTREQUEST = 266
GLOBAL CONST $WM_CONVERTRESULT = 267
GLOBAL CONST $WM_IM_INFO = 268
GLOBAL CONST $WM_IME_STARTCOMPOSITION = 269
GLOBAL CONST $WM_IME_ENDCOMPOSITION = 270
GLOBAL CONST $WM_IME_COMPOSITION = 271
GLOBAL CONST $WM_IME_KEYLAST = 271
GLOBAL CONST $WM_INITDIALOG = 272
GLOBAL CONST $WM_COMMAND = 273
GLOBAL CONST $WM_SYSCOMMAND = 274
GLOBAL CONST $WM_TIMER = 275
GLOBAL CONST $WM_HSCROLL = 276
GLOBAL CONST $WM_VSCROLL = 277
GLOBAL CONST $WM_INITMENU = 278
GLOBAL CONST $WM_INITMENUPOPUP = 279
GLOBAL CONST $WM_SYSTIMER = 280
GLOBAL CONST $WM_GESTURE = 281
GLOBAL CONST $WM_GESTURENOTIFY = 282
GLOBAL CONST $WM_GESTUREINPUT = 283
GLOBAL CONST $WM_GESTURENOTIFIED = 284
GLOBAL CONST $WM_MENUSELECT = 287
GLOBAL CONST $WM_MENUCHAR = 288
GLOBAL CONST $WM_ENTERIDLE = 289
GLOBAL CONST $WM_MENURBUTTONUP = 290
GLOBAL CONST $WM_MENUDRAG = 291
GLOBAL CONST $WM_MENUGETOBJECT = 292
GLOBAL CONST $WM_UNINITMENUPOPUP = 293
GLOBAL CONST $WM_MENUCOMMAND = 294
GLOBAL CONST $WM_CHANGEUISTATE = 295
GLOBAL CONST $WM_UPDATEUISTATE = 296
GLOBAL CONST $WM_QUERYUISTATE = 297
GLOBAL CONST $WM_LBTRACKPOINT = 305
GLOBAL CONST $WM_CTLCOLORMSGBOX = 306
GLOBAL CONST $WM_CTLCOLOREDIT = 307
GLOBAL CONST $WM_CTLCOLORLISTBOX = 308
GLOBAL CONST $WM_CTLCOLORBTN = 309
GLOBAL CONST $WM_CTLCOLORDLG = 310
GLOBAL CONST $WM_CTLCOLORSCROLLBAR = 311
GLOBAL CONST $WM_CTLCOLORSTATIC = 312
GLOBAL CONST $MN_GETHMENU = 481
GLOBAL CONST $WM_PARENTNOTIFY = 528
GLOBAL CONST $WM_ENTERMENULOOP = 529
GLOBAL CONST $WM_EXITMENULOOP = 530
GLOBAL CONST $WM_NEXTMENU = 531
GLOBAL CONST $WM_SIZING = 532
GLOBAL CONST $WM_CAPTURECHANGED = 533
GLOBAL CONST $WM_MOVING = 534
GLOBAL CONST $WM_POWERBROADCAST = 536
GLOBAL CONST $WM_DEVICECHANGE = 537
GLOBAL CONST $WM_MDICREATE = 544
GLOBAL CONST $WM_MDIDESTROY = 545
GLOBAL CONST $WM_MDIACTIVATE = 546
GLOBAL CONST $WM_MDIRESTORE = 547
GLOBAL CONST $WM_MDINEXT = 548
GLOBAL CONST $WM_MDIMAXIMIZE = 549
GLOBAL CONST $WM_MDITILE = 550
GLOBAL CONST $WM_MDICASCADE = 551
GLOBAL CONST $WM_MDIICONARRANGE = 552
GLOBAL CONST $WM_MDIGETACTIVE = 553
GLOBAL CONST $WM_DROPOBJECT = 554
GLOBAL CONST $WM_QUERYDROPOBJECT = 555
GLOBAL CONST $WM_BEGINDRAG = 556
GLOBAL CONST $WM_DRAGLOOP = 557
GLOBAL CONST $WM_DRAGSELECT = 558
GLOBAL CONST $WM_DRAGMOVE = 559
GLOBAL CONST $WM_MDISETMENU = 560
GLOBAL CONST $WM_ENTERSIZEMOVE = 561
GLOBAL CONST $WM_EXITSIZEMOVE = 562
GLOBAL CONST $WM_DROPFILES = 563
GLOBAL CONST $WM_MDIREFRESHMENU = 564
GLOBAL CONST $WM_TOUCH = 576
GLOBAL CONST $WM_IME_SETCONTEXT = 641
GLOBAL CONST $WM_IME_NOTIFY = 642
GLOBAL CONST $WM_IME_CONTROL = 643
GLOBAL CONST $WM_IME_COMPOSITIONFULL = 644
GLOBAL CONST $WM_IME_SELECT = 645
GLOBAL CONST $WM_IME_CHAR = 646
GLOBAL CONST $WM_IME_SYSTEM = 647
GLOBAL CONST $WM_IME_REQUEST = 648
GLOBAL CONST $WM_IME_KEYDOWN = 656
GLOBAL CONST $WM_IME_KEYUP = 657
GLOBAL CONST $WM_NCMOUSEHOVER = 672
GLOBAL CONST $WM_MOUSEHOVER = 673
GLOBAL CONST $WM_NCMOUSELEAVE = 674
GLOBAL CONST $WM_MOUSELEAVE = 675
GLOBAL CONST $WM_WTSSESSION_CHANGE = 689
GLOBAL CONST $WM_TABLET_FIRST = 704
GLOBAL CONST $WM_TABLET_LAST = 735
GLOBAL CONST $WM_CUT = 768
GLOBAL CONST $WM_COPY = 769
GLOBAL CONST $WM_PASTE = 770
GLOBAL CONST $WM_CLEAR = 771
GLOBAL CONST $WM_UNDO = 772
GLOBAL CONST $WM_PALETTEISCHANGING = 784
GLOBAL CONST $WM_HOTKEY = 786
GLOBAL CONST $WM_PALETTECHANGED = 785
GLOBAL CONST $WM_SYSMENU = 787
GLOBAL CONST $WM_HOOKMSG = 788
GLOBAL CONST $WM_EXITPROCESS = 789
GLOBAL CONST $WM_WAKETHREAD = 790
GLOBAL CONST $WM_PRINT = 791
GLOBAL CONST $WM_PRINTCLIENT = 792
GLOBAL CONST $WM_APPCOMMAND = 793
GLOBAL CONST $WM_QUERYNEWPALETTE = 783
GLOBAL CONST $WM_THEMECHANGED = 794
GLOBAL CONST $WM_UAHINIT = 795
GLOBAL CONST $WM_DESKTOPNOTIFY = 796
GLOBAL CONST $WM_CLIPBOARDUPDATE = 797
GLOBAL CONST $WM_DWMCOMPOSITIONCHANGED = 798
GLOBAL CONST $WM_DWMNCRENDERINGCHANGED = 799
GLOBAL CONST $WM_DWMCOLORIZATIONCOLORCHANGED = 800
GLOBAL CONST $WM_DWMWINDOWMAXIMIZEDCHANGE = 801
GLOBAL CONST $WM_DWMEXILEFRAME = 802
GLOBAL CONST $WM_DWMSENDICONICTHUMBNAIL = 803
GLOBAL CONST $WM_MAGNIFICATION_STARTED = 804
GLOBAL CONST $WM_MAGNIFICATION_ENDED = 805
GLOBAL CONST $WM_DWMSENDICONICLIVEPREVIEWBITMAP = 806
GLOBAL CONST $WM_DWMTHUMBNAILSIZECHANGED = 807
GLOBAL CONST $WM_MAGNIFICATION_OUTPUT = 808
GLOBAL CONST $WM_MEASURECONTROL = 816
GLOBAL CONST $WM_GETACTIONTEXT = 817
GLOBAL CONST $WM_FORWARDKEYDOWN = 819
GLOBAL CONST $WM_FORWARDKEYUP = 820
GLOBAL CONST $WM_GETTITLEBARINFOEX = 831
GLOBAL CONST $WM_NOTIFYWOW = 832
GLOBAL CONST $WM_HANDHELDFIRST = 856
GLOBAL CONST $WM_HANDHELDLAST = 863
GLOBAL CONST $WM_AFXFIRST = 864
GLOBAL CONST $WM_AFXLAST = 895
GLOBAL CONST $WM_PENWINFIRST = 896
GLOBAL CONST $WM_PENWINLAST = 911
GLOBAL CONST $WM_DDE_INITIATE = 992
GLOBAL CONST $WM_DDE_TERMINATE = 993
GLOBAL CONST $WM_DDE_ADVISE = 994
GLOBAL CONST $WM_DDE_UNADVISE = 995
GLOBAL CONST $WM_DDE_ACK = 996
GLOBAL CONST $WM_DDE_DATA = 997
GLOBAL CONST $WM_DDE_REQUEST = 998
GLOBAL CONST $WM_DDE_POKE = 999
GLOBAL CONST $WM_DDE_EXECUTE = 1000
GLOBAL CONST $WM_DBNOTIFICATION = 1021
GLOBAL CONST $WM_NETCONNECT = 1022
GLOBAL CONST $WM_HIBERNATE = 1023
GLOBAL CONST $WM_USER = 1024
GLOBAL CONST $WM_APP = 32768
GLOBAL CONST $NM_FIRST = 0
GLOBAL CONST $NM_OUTOFMEMORY = $NM_FIRST - 1
GLOBAL CONST $NM_CLICK = $NM_FIRST - 2
GLOBAL CONST $NM_DBLCLK = $NM_FIRST - 3
GLOBAL CONST $NM_RETURN = $NM_FIRST - 4
GLOBAL CONST $NM_RCLICK = $NM_FIRST - 5
GLOBAL CONST $NM_RDBLCLK = $NM_FIRST - 6
GLOBAL CONST $NM_SETFOCUS = $NM_FIRST - 7
GLOBAL CONST $NM_KILLFOCUS = $NM_FIRST - 8
GLOBAL CONST $NM_CUSTOMDRAW = $NM_FIRST - 12
GLOBAL CONST $NM_HOVER = $NM_FIRST - 13
GLOBAL CONST $NM_NCHITTEST = $NM_FIRST - 14
GLOBAL CONST $NM_KEYDOWN = $NM_FIRST - 15
GLOBAL CONST $NM_RELEASEDCAPTURE = $NM_FIRST - 16
GLOBAL CONST $NM_SETCURSOR = $NM_FIRST - 17
GLOBAL CONST $NM_CHAR = $NM_FIRST - 18
GLOBAL CONST $NM_TOOLTIPSCREATED = $NM_FIRST - 19
GLOBAL CONST $NM_LDOWN = $NM_FIRST - 20
GLOBAL CONST $NM_RDOWN = $NM_FIRST - 21
GLOBAL CONST $NM_THEMECHANGED = $NM_FIRST - 22
GLOBAL CONST $WM_MOUSEFIRST = 512
GLOBAL CONST $WM_MOUSEMOVE = 512
GLOBAL CONST $WM_LBUTTONDOWN = 513
GLOBAL CONST $WM_LBUTTONUP = 514
GLOBAL CONST $WM_LBUTTONDBLCLK = 515
GLOBAL CONST $WM_RBUTTONDOWN = 516
GLOBAL CONST $WM_RBUTTONUP = 517
GLOBAL CONST $WM_RBUTTONDBLCLK = 518
GLOBAL CONST $WM_MBUTTONDOWN = 519
GLOBAL CONST $WM_MBUTTONUP = 520
GLOBAL CONST $WM_MBUTTONDBLCLK = 521
GLOBAL CONST $WM_MOUSEWHEEL = 522
GLOBAL CONST $WM_XBUTTONDOWN = 523
GLOBAL CONST $WM_XBUTTONUP = 524
GLOBAL CONST $WM_XBUTTONDBLCLK = 525
GLOBAL CONST $WM_MOUSEHWHEEL = 526
GLOBAL CONST $PS_SOLID = 0
GLOBAL CONST $PS_DASH = 1
GLOBAL CONST $PS_DOT = 2
GLOBAL CONST $PS_DASHDOT = 3
GLOBAL CONST $PS_DASHDOTDOT = 4
GLOBAL CONST $PS_NULL = 5
GLOBAL CONST $PS_INSIDEFRAME = 6
GLOBAL CONST $PS_USERSTYLE = 7
GLOBAL CONST $PS_ALTERNATE = 8
GLOBAL CONST $PS_ENDCAP_ROUND = 0
GLOBAL CONST $PS_ENDCAP_SQUARE = 256
GLOBAL CONST $PS_ENDCAP_FLAT = 512
GLOBAL CONST $PS_JOIN_BEVEL = 4096
GLOBAL CONST $PS_JOIN_MITER = 8192
GLOBAL CONST $PS_JOIN_ROUND = 0
GLOBAL CONST $PS_GEOMETRIC = 65536
GLOBAL CONST $PS_COSMETIC = 0
GLOBAL CONST $LWA_ALPHA = 2
GLOBAL CONST $LWA_COLORKEY = 1
GLOBAL CONST $RGN_AND = 1
GLOBAL CONST $RGN_OR = 2
GLOBAL CONST $RGN_XOR = 3
GLOBAL CONST $RGN_DIFF = 4
GLOBAL CONST $RGN_COPY = 5
GLOBAL CONST $ERRORREGION = 0
GLOBAL CONST $NULLREGION = 1
GLOBAL CONST $SIMPLEREGION = 2
GLOBAL CONST $COMPLEXREGION = 3
GLOBAL CONST $TRANSPARENT = 1
GLOBAL CONST $OPAQUE = 2
GLOBAL CONST $CCM_FIRST = 8192
GLOBAL CONST $CCM_GETUNICODEFORMAT = ($CCM_FIRST + 6)
GLOBAL CONST $CCM_SETUNICODEFORMAT = ($CCM_FIRST + 5)
GLOBAL CONST $CCM_SETBKCOLOR = $CCM_FIRST + 1
GLOBAL CONST $CCM_SETCOLORSCHEME = $CCM_FIRST + 2
GLOBAL CONST $CCM_GETCOLORSCHEME = $CCM_FIRST + 3
GLOBAL CONST $CCM_GETDROPTARGET = $CCM_FIRST + 4
GLOBAL CONST $CCM_SETWINDOWTHEME = $CCM_FIRST + 11
GLOBAL CONST $GA_PARENT = 1
GLOBAL CONST $GA_ROOT = 2
GLOBAL CONST $GA_ROOTOWNER = 3
GLOBAL CONST $SM_CXSCREEN = 0
GLOBAL CONST $SM_CYSCREEN = 1
GLOBAL CONST $SM_CXVSCROLL = 2
GLOBAL CONST $SM_CYHSCROLL = 3
GLOBAL CONST $SM_CYCAPTION = 4
GLOBAL CONST $SM_CXBORDER = 5
GLOBAL CONST $SM_CYBORDER = 6
GLOBAL CONST $SM_CXFIXEDFRAME = 7
GLOBAL CONST $SM_CXDLGFRAME = $SM_CXFIXEDFRAME
GLOBAL CONST $SM_CYFIXEDFRAME = 8
GLOBAL CONST $SM_CYDLGFRAME = $SM_CYFIXEDFRAME
GLOBAL CONST $SM_CYVTHUMB = 9
GLOBAL CONST $SM_CXHTHUMB = 10
GLOBAL CONST $SM_CXICON = 11
GLOBAL CONST $SM_CYICON = 12
GLOBAL CONST $SM_CXCURSOR = 13
GLOBAL CONST $SM_CYCURSOR = 14
GLOBAL CONST $SM_CYMENU = 15
GLOBAL CONST $SM_CXFULLSCREEN = 16
GLOBAL CONST $SM_CYFULLSCREEN = 17
GLOBAL CONST $SM_CYKANJIWINDOW = 18
GLOBAL CONST $SM_MOUSEPRESENT = 19
GLOBAL CONST $SM_CYVSCROLL = 20
GLOBAL CONST $SM_CXHSCROLL = 21
GLOBAL CONST $SM_DEBUG = 22
GLOBAL CONST $SM_SWAPBUTTON = 23
GLOBAL CONST $SM_RESERVED1 = 24
GLOBAL CONST $SM_RESERVED2 = 25
GLOBAL CONST $SM_RESERVED3 = 26
GLOBAL CONST $SM_RESERVED4 = 27
GLOBAL CONST $SM_CXMIN = 28
GLOBAL CONST $SM_CYMIN = 29
GLOBAL CONST $SM_CXSIZE = 30
GLOBAL CONST $SM_CYSIZE = 31
GLOBAL CONST $SM_CXSIZEFRAME = 32
GLOBAL CONST $SM_CXFRAME = $SM_CXSIZEFRAME
GLOBAL CONST $SM_CYSIZEFRAME = 33
GLOBAL CONST $SM_CYFRAME = $SM_CYSIZEFRAME
GLOBAL CONST $SM_CXMINTRACK = 34
GLOBAL CONST $SM_CYMINTRACK = 35
GLOBAL CONST $SM_CXDOUBLECLK = 36
GLOBAL CONST $SM_CYDOUBLECLK = 37
GLOBAL CONST $SM_CXICONSPACING = 38
GLOBAL CONST $SM_CYICONSPACING = 39
GLOBAL CONST $SM_MENUDROPALIGNMENT = 40
GLOBAL CONST $SM_PENWINDOWS = 41
GLOBAL CONST $SM_DBCSENABLED = 42
GLOBAL CONST $SM_CMOUSEBUTTONS = 43
GLOBAL CONST $SM_SECURE = 44
GLOBAL CONST $SM_CXEDGE = 45
GLOBAL CONST $SM_CYEDGE = 46
GLOBAL CONST $SM_CXMINSPACING = 47
GLOBAL CONST $SM_CYMINSPACING = 48
GLOBAL CONST $SM_CXSMICON = 49
GLOBAL CONST $SM_CYSMICON = 50
GLOBAL CONST $SM_CYSMCAPTION = 51
GLOBAL CONST $SM_CXSMSIZE = 52
GLOBAL CONST $SM_CYSMSIZE = 53
GLOBAL CONST $SM_CXMENUSIZE = 54
GLOBAL CONST $SM_CYMENUSIZE = 55
GLOBAL CONST $SM_ARRANGE = 56
GLOBAL CONST $SM_CXMINIMIZED = 57
GLOBAL CONST $SM_CYMINIMIZED = 58
GLOBAL CONST $SM_CXMAXTRACK = 59
GLOBAL CONST $SM_CYMAXTRACK = 60
GLOBAL CONST $SM_CXMAXIMIZED = 61
GLOBAL CONST $SM_CYMAXIMIZED = 62
GLOBAL CONST $SM_NETWORK = 63
GLOBAL CONST $SM_CLEANBOOT = 67
GLOBAL CONST $SM_CXDRAG = 68
GLOBAL CONST $SM_CYDRAG = 69
GLOBAL CONST $SM_SHOWSOUNDS = 70
GLOBAL CONST $SM_CXMENUCHECK = 71
GLOBAL CONST $SM_CYMENUCHECK = 72
GLOBAL CONST $SM_SLOWMACHINE = 73
GLOBAL CONST $SM_MIDEASTENABLED = 74
GLOBAL CONST $SM_MOUSEWHEELPRESENT = 75
GLOBAL CONST $SM_XVIRTUALSCREEN = 76
GLOBAL CONST $SM_YVIRTUALSCREEN = 77
GLOBAL CONST $SM_CXVIRTUALSCREEN = 78
GLOBAL CONST $SM_CYVIRTUALSCREEN = 79
GLOBAL CONST $SM_CMONITORS = 80
GLOBAL CONST $SM_SAMEDISPLAYFORMAT = 81
GLOBAL CONST $SM_IMMENABLED = 82
GLOBAL CONST $SM_CXFOCUSBORDER = 83
GLOBAL CONST $SM_CYFOCUSBORDER = 84
GLOBAL CONST $SM_TABLETPC = 86
GLOBAL CONST $SM_MEDIACENTER = 87
GLOBAL CONST $SM_STARTER = 88
GLOBAL CONST $SM_SERVERR2 = 89
GLOBAL CONST $SM_CMETRICS = 90
GLOBAL CONST $SM_REMOTESESSION = 4096
GLOBAL CONST $SM_SHUTTINGDOWN = 8192
GLOBAL CONST $SM_REMOTECONTROL = 8193
GLOBAL CONST $SM_CARETBLINKINGENABLED = 8194
GLOBAL CONST $BLACKNESS = 66
GLOBAL CONST $CAPTUREBLT = 1073741824
GLOBAL CONST $DSTINVERT = 5570569
GLOBAL CONST $MERGECOPY = 12583114
GLOBAL CONST $MERGEPAINT = 12255782
GLOBAL CONST $NOMIRRORBITMAP = -2147483648
GLOBAL CONST $NOTSRCCOPY = 3342344
GLOBAL CONST $NOTSRCERASE = 1114278
GLOBAL CONST $PATCOPY = 15728673
GLOBAL CONST $PATINVERT = 5898313
GLOBAL CONST $PATPAINT = 16452105
GLOBAL CONST $SRCAND = 8913094
GLOBAL CONST $SRCCOPY = 13369376
GLOBAL CONST $SRCERASE = 4457256
GLOBAL CONST $SRCINVERT = 6684742
GLOBAL CONST $SRCPAINT = 15597702
GLOBAL CONST $WHITENESS = 16711778
GLOBAL CONST $DT_BOTTOM = 8
GLOBAL CONST $DT_CALCRECT = 1024
GLOBAL CONST $DT_CENTER = 1
GLOBAL CONST $DT_EDITCONTROL = 8192
GLOBAL CONST $DT_END_ELLIPSIS = 32768
GLOBAL CONST $DT_EXPANDTABS = 64
GLOBAL CONST $DT_EXTERNALLEADING = 512
GLOBAL CONST $DT_HIDEPREFIX = 1048576
GLOBAL CONST $DT_INTERNAL = 4096
GLOBAL CONST $DT_LEFT = 0
GLOBAL CONST $DT_MODIFYSTRING = 65536
GLOBAL CONST $DT_NOCLIP = 256
GLOBAL CONST $DT_NOFULLWIDTHCHARBREAK = 524288
GLOBAL CONST $DT_NOPREFIX = 2048
GLOBAL CONST $DT_PATH_ELLIPSIS = 16384
GLOBAL CONST $DT_PREFIXONLY = 2097152
GLOBAL CONST $DT_RIGHT = 2
GLOBAL CONST $DT_RTLREADING = 131072
GLOBAL CONST $DT_SINGLELINE = 32
GLOBAL CONST $DT_TABSTOP = 128
GLOBAL CONST $DT_TOP = 0
GLOBAL CONST $DT_VCENTER = 4
GLOBAL CONST $DT_WORDBREAK = 16
GLOBAL CONST $DT_WORD_ELLIPSIS = 262144
GLOBAL CONST $RDW_ERASE = 4
GLOBAL CONST $RDW_FRAME = 1024
GLOBAL CONST $RDW_INTERNALPAINT = 2
GLOBAL CONST $RDW_INVALIDATE = 1
GLOBAL CONST $RDW_NOERASE = 32
GLOBAL CONST $RDW_NOFRAME = 2048
GLOBAL CONST $RDW_NOINTERNALPAINT = 16
GLOBAL CONST $RDW_VALIDATE = 8
GLOBAL CONST $RDW_ERASENOW = 512
GLOBAL CONST $RDW_UPDATENOW = 256
GLOBAL CONST $RDW_ALLCHILDREN = 128
GLOBAL CONST $RDW_NOCHILDREN = 64
GLOBAL CONST $WM_RENDERFORMAT = 773
GLOBAL CONST $WM_RENDERALLFORMATS = 774
GLOBAL CONST $WM_DESTROYCLIPBOARD = 775
GLOBAL CONST $WM_DRAWCLIPBOARD = 776
GLOBAL CONST $WM_PAINTCLIPBOARD = 777
GLOBAL CONST $WM_VSCROLLCLIPBOARD = 778
GLOBAL CONST $WM_SIZECLIPBOARD = 779
GLOBAL CONST $WM_ASKCBFORMATNAME = 780
GLOBAL CONST $WM_CHANGECBCHAIN = 781
GLOBAL CONST $WM_HSCROLLCLIPBOARD = 782
GLOBAL CONST $HTERROR = -2
GLOBAL CONST $HTTRANSPARENT = -1
GLOBAL CONST $HTNOWHERE = 0
GLOBAL CONST $HTCLIENT = 1
GLOBAL CONST $HTCAPTION = 2
GLOBAL CONST $HTSYSMENU = 3
GLOBAL CONST $HTGROWBOX = 4
GLOBAL CONST $HTSIZE = $HTGROWBOX
GLOBAL CONST $HTMENU = 5
GLOBAL CONST $HTHSCROLL = 6
GLOBAL CONST $HTVSCROLL = 7
GLOBAL CONST $HTMINBUTTON = 8
GLOBAL CONST $HTMAXBUTTON = 9
GLOBAL CONST $HTLEFT = 10
GLOBAL CONST $HTRIGHT = 11
GLOBAL CONST $HTTOP = 12
GLOBAL CONST $HTTOPLEFT = 13
GLOBAL CONST $HTTOPRIGHT = 14
GLOBAL CONST $HTBOTTOM = 15
GLOBAL CONST $HTBOTTOMLEFT = 16
GLOBAL CONST $HTBOTTOMRIGHT = 17
GLOBAL CONST $HTBORDER = 18
GLOBAL CONST $HTREDUCE = $HTMINBUTTON
GLOBAL CONST $HTZOOM = $HTMAXBUTTON
GLOBAL CONST $HTSIZEFIRST = $HTLEFT
GLOBAL CONST $HTSIZELAST = $HTBOTTOMRIGHT
GLOBAL CONST $HTOBJECT = 19
GLOBAL CONST $HTCLOSE = 20
GLOBAL CONST $HTHELP = 21
GLOBAL CONST $COLOR_SCROLLBAR = 0
GLOBAL CONST $COLOR_BACKGROUND = 1
GLOBAL CONST $COLOR_ACTIVECAPTION = 2
GLOBAL CONST $COLOR_INACTIVECAPTION = 3
GLOBAL CONST $COLOR_MENU = 4
GLOBAL CONST $COLOR_WINDOW = 5
GLOBAL CONST $COLOR_WINDOWFRAME = 6
GLOBAL CONST $COLOR_MENUTEXT = 7
GLOBAL CONST $COLOR_WINDOWTEXT = 8
GLOBAL CONST $COLOR_CAPTIONTEXT = 9
GLOBAL CONST $COLOR_ACTIVEBORDER = 10
GLOBAL CONST $COLOR_INACTIVEBORDER = 11
GLOBAL CONST $COLOR_APPWORKSPACE = 12
GLOBAL CONST $COLOR_HIGHLIGHT = 13
GLOBAL CONST $COLOR_HIGHLIGHTTEXT = 14
GLOBAL CONST $COLOR_BTNFACE = 15
GLOBAL CONST $COLOR_BTNSHADOW = 16
GLOBAL CONST $COLOR_GRAYTEXT = 17
GLOBAL CONST $COLOR_BTNTEXT = 18
GLOBAL CONST $COLOR_INACTIVECAPTIONTEXT = 19
GLOBAL CONST $COLOR_BTNHIGHLIGHT = 20
GLOBAL CONST $COLOR_3DDKSHADOW = 21
GLOBAL CONST $COLOR_3DLIGHT = 22
GLOBAL CONST $COLOR_INFOTEXT = 23
GLOBAL CONST $COLOR_INFOBK = 24
GLOBAL CONST $COLOR_HOTLIGHT = 26
GLOBAL CONST $COLOR_GRADIENTACTIVECAPTION = 27
GLOBAL CONST $COLOR_GRADIENTINACTIVECAPTION = 28
GLOBAL CONST $COLOR_MENUHILIGHT = 29
GLOBAL CONST $COLOR_MENUBAR = 30
GLOBAL CONST $COLOR_DESKTOP = 1
GLOBAL CONST $COLOR_3DFACE = 15
GLOBAL CONST $COLOR_3DSHADOW = 16
GLOBAL CONST $COLOR_3DHIGHLIGHT = 20
GLOBAL CONST $COLOR_3DHILIGHT = 20
GLOBAL CONST $COLOR_BTNHILIGHT = 20
GLOBAL CONST $HINST_COMMCTRL = -1
GLOBAL CONST $IDB_STD_SMALL_COLOR = 0
GLOBAL CONST $IDB_STD_LARGE_COLOR = 1
GLOBAL CONST $IDB_VIEW_SMALL_COLOR = 4
GLOBAL CONST $IDB_VIEW_LARGE_COLOR = 5
GLOBAL CONST $IDB_HIST_SMALL_COLOR = 8
GLOBAL CONST $IDB_HIST_LARGE_COLOR = 9
GLOBAL CONST $STARTF_FORCEOFFFEEDBACK = 128
GLOBAL CONST $STARTF_FORCEONFEEDBACK = 64
GLOBAL CONST $STARTF_PREVENTPINNING = 8192
GLOBAL CONST $STARTF_RUNFULLSCREEN = 32
GLOBAL CONST $STARTF_TITLEISAPPID = 4096
GLOBAL CONST $STARTF_TITLEISLINKNAME = 2048
GLOBAL CONST $STARTF_USECOUNTCHARS = 8
GLOBAL CONST $STARTF_USEFILLATTRIBUTE = 16
GLOBAL CONST $STARTF_USEHOTKEY = 512
GLOBAL CONST $STARTF_USEPOSITION = 4
GLOBAL CONST $STARTF_USESHOWWINDOW = 1
GLOBAL CONST $STARTF_USESIZE = 2
GLOBAL CONST $STARTF_USESTDHANDLES = 256
GLOBAL CONST $CDDS_PREPAINT = 1
GLOBAL CONST $CDDS_POSTPAINT = 2
GLOBAL CONST $CDDS_PREERASE = 3
GLOBAL CONST $CDDS_POSTERASE = 4
GLOBAL CONST $CDDS_ITEM = 65536
GLOBAL CONST $CDDS_ITEMPREPAINT = 65537
GLOBAL CONST $CDDS_ITEMPOSTPAINT = 65538
GLOBAL CONST $CDDS_ITEMPREERASE = 65539
GLOBAL CONST $CDDS_ITEMPOSTERASE = 65540
GLOBAL CONST $CDDS_SUBITEM = 131072
GLOBAL CONST $CDIS_SELECTED = 1
GLOBAL CONST $CDIS_GRAYED = 2
GLOBAL CONST $CDIS_DISABLED = 4
GLOBAL CONST $CDIS_CHECKED = 8
GLOBAL CONST $CDIS_FOCUS = 16
GLOBAL CONST $CDIS_DEFAULT = 32
GLOBAL CONST $CDIS_HOT = 64
GLOBAL CONST $CDIS_MARKED = 128
GLOBAL CONST $CDIS_INDETERMINATE = 256
GLOBAL CONST $CDIS_SHOWKEYBOARDCUES = 512
GLOBAL CONST $CDIS_NEARHOT = 1024
GLOBAL CONST $CDIS_OTHERSIDEHOT = 2048
GLOBAL CONST $CDIS_DROPHILITED = 4096
GLOBAL CONST $CDRF_DODEFAULT = 0
GLOBAL CONST $CDRF_NEWFONT = 2
GLOBAL CONST $CDRF_SKIPDEFAULT = 4
GLOBAL CONST $CDRF_NOTIFYPOSTPAINT = 16
GLOBAL CONST $CDRF_NOTIFYITEMDRAW = 32
GLOBAL CONST $CDRF_NOTIFYSUBITEMDRAW = 32
GLOBAL CONST $CDRF_NOTIFYPOSTERASE = 64
GLOBAL CONST $CDRF_DOERASE = 8
GLOBAL CONST $CDRF_SKIPPOSTPAINT = 256
GLOBAL CONST $GUI_SS_DEFAULT_GUI = BITOR($WS_MINIMIZEBOX, $WS_CAPTION, $WS_POPUP, $WS_SYSMENU)
GLOBAL CONST $SYMOPT_ALLOW_ABSOLUTE_SYMBOLS = 2048
GLOBAL CONST $SYMOPT_ALLOW_ZERO_ADDRESS = 16777216
GLOBAL CONST $SYMOPT_AUTO_PUBLICS = 65536
GLOBAL CONST $SYMOPT_CASE_INSENSITIVE = 1
GLOBAL CONST $SYMOPT_DEBUG = -2147483648
GLOBAL CONST $SYMOPT_DEFERRED_LOADS = 4
GLOBAL CONST $SYMOPT_DISABLE_SYMSRV_AUTODETECT = 33554432
GLOBAL CONST $SYMOPT_EXACT_SYMBOLS = 1024
GLOBAL CONST $SYMOPT_FAIL_CRITICAL_ERRORS = 512
GLOBAL CONST $SYMOPT_FAVOR_COMPRESSED = 8388608
GLOBAL CONST $SYMOPT_FLAT_DIRECTORY = 4194304
GLOBAL CONST $SYMOPT_IGNORE_CVREC = 128
GLOBAL CONST $SYMOPT_IGNORE_IMAGEDIR = 2097152
GLOBAL CONST $SYMOPT_IGNORE_NT_SYMPATH = 4096
GLOBAL CONST $SYMOPT_INCLUDE_32BIT_MODULES = 8192
GLOBAL CONST $SYMOPT_LOAD_ANYTHING = 64
GLOBAL CONST $SYMOPT_LOAD_LINES = 16
GLOBAL CONST $SYMOPT_NO_CPP = 8
GLOBAL CONST $SYMOPT_NO_IMAGE_SEARCH = 131072
GLOBAL CONST $SYMOPT_NO_PROMPTS = 524288
GLOBAL CONST $SYMOPT_NO_PUBLICS = 32768
GLOBAL CONST $SYMOPT_NO_UNQUALIFIED_LOADS = 256
GLOBAL CONST $SYMOPT_OVERWRITE = 1048576
GLOBAL CONST $SYMOPT_PUBLICS_ONLY = 16384
GLOBAL CONST $SYMOPT_SECURE = 262144
GLOBAL CONST $SYMOPT_UNDNAME = 2
GLOBAL CONST $SEM_FAILCRITICALERRORS = 1
GLOBAL CONST $SEM_NOALIGNMENTFAULTEXCEPT = 4
GLOBAL CONST $SEM_NOGPFAULTERRORBOX = 2
GLOBAL CONST $SEM_NOOPENFILEERRORBOX = 32768
GLOBAL CONST $NETWORK_ALIVE_LAN = 1
GLOBAL CONST $NETWORK_ALIVE_WAN = 2
GLOBAL CONST $NETWORK_ALIVE_AOL = 4
GLOBAL CONST $RESTART_NO_CRASH = 1
GLOBAL CONST $RESTART_NO_HANG = 2
GLOBAL CONST $RESTART_NO_PATCH = 4
GLOBAL CONST $RESTART_NO_REBOOT = 8
GLOBAL CONST $UHID_MB = 0
GLOBAL CONST $UHID_BIOS = 1
GLOBAL CONST $UHID_CPU = 2
GLOBAL CONST $UHID_HDD = 4
GLOBAL CONST $UHID_ALL = BITOR($UHID_MB, $UHID_BIOS, $UHID_CPU, $UHID_HDD)
GLOBAL CONST $BPBF_COMPATIBLEBITMAP = 0
GLOBAL CONST $BPBF_DIB = 1
GLOBAL CONST $BPBF_TOPDOWNDIB = 2
GLOBAL CONST $BPBF_TOPDOWNMONODIB = 3
GLOBAL CONST $BPPF_ERASE = 1
GLOBAL CONST $BPPF_NOCLIP = 2
GLOBAL CONST $BPPF_NONCLIENT = 4
GLOBAL CONST $DTT_TEXTCOLOR = 1
GLOBAL CONST $DTT_BORDERCOLOR = 2
GLOBAL CONST $DTT_SHADOWCOLOR = 4
GLOBAL CONST $DTT_SHADOWTYPE = 8
GLOBAL CONST $DTT_SHADOWOFFSET = 16
GLOBAL CONST $DTT_BORDERSIZE = 32
GLOBAL CONST $DTT_FONTPROP = 64
GLOBAL CONST $DTT_COLORPROP = 128
GLOBAL CONST $DTT_STATEID = 256
GLOBAL CONST $DTT_CALCRECT = 512
GLOBAL CONST $DTT_APPLYOVERLAY = 1024
GLOBAL CONST $DTT_GLOWSIZE = 2048
GLOBAL CONST $DTT_CALLBACK = 4096
GLOBAL CONST $DTT_COMPOSITED = 8192
GLOBAL CONST $DTT_VALIDBITS = BITOR($DTT_TEXTCOLOR, $DTT_BORDERCOLOR, $DTT_SHADOWCOLOR, $DTT_SHADOWTYPE, $DTT_SHADOWOFFSET, $DTT_BORDERSIZE, $DTT_FONTPROP, $DTT_COLORPROP, $DTT_STATEID, $DTT_CALCRECT, $DTT_APPLYOVERLAY, $DTT_GLOWSIZE, $DTT_COMPOSITED)
GLOBAL CONST $TST_NONE = 0
GLOBAL CONST $TST_SINGLE = 1
GLOBAL CONST $TST_CONTINUOUS = 2
GLOBAL CONST $STAP_ALLOW_NONCLIENT = 1
GLOBAL CONST $STAP_ALLOW_CONTROLS = 2
GLOBAL CONST $STAP_ALLOW_WEBCONTENT = 4
GLOBAL CONST $GBF_DIRECT = 1
GLOBAL CONST $GBF_COPY = 2
GLOBAL CONST $GBF_VALIDBITS = BITOR($GBF_DIRECT, $GBF_COPY)
GLOBAL CONST $SZ_THDOCPROP_AUTHOR = "Author"
GLOBAL CONST $SZ_THDOCPROP_CANONICALNAME = "ThemeName"
GLOBAL CONST $SZ_THDOCPROP_DISPLAYNAME = "DisplayName"
GLOBAL CONST $SZ_THDOCPROP_TOOLTIP = "ToolTip"
GLOBAL CONST $TS_MIN = 0
GLOBAL CONST $TS_TRUE = 1
GLOBAL CONST $TS_DRAW = 2
GLOBAL CONST $PO_CLASS = 2
GLOBAL CONST $PO_GLOBAL = 3
GLOBAL CONST $PO_NOTFOUND = 4
GLOBAL CONST $PO_PART = 1
GLOBAL CONST $PO_STATE = 0
GLOBAL CONST $TMT_BOOL = 203
GLOBAL CONST $TMT_COLOR = 204
GLOBAL CONST $TMT_DIBDATA = 2
GLOBAL CONST $TMT_DISKSTREAM = 213
GLOBAL CONST $TMT_ENUM = 200
GLOBAL CONST $TMT_FILENAME = 206
GLOBAL CONST $TMT_FONT = 210
GLOBAL CONST $TMT_GLYPHDIBDATA = 8
GLOBAL CONST $TMT_HBITMAP = 212
GLOBAL CONST $TMT_INT = 202
GLOBAL CONST $TMT_INTLIST = 211
GLOBAL CONST $TMT_MARGINS = 205
GLOBAL CONST $TMT_POSITION = 208
GLOBAL CONST $TMT_RECT = 209
GLOBAL CONST $TMT_SIZE = 207
GLOBAL CONST $TMT_STRING = 201
GLOBAL CONST $TMT_ALWAYSSHOWSIZINGBAR = 2208
GLOBAL CONST $TMT_AUTOSIZE = 2202
GLOBAL CONST $TMT_BGFILL = 2205
GLOBAL CONST $TMT_BORDERONLY = 2203
GLOBAL CONST $TMT_COMPOSITED = 2204
GLOBAL CONST $TMT_COMPOSITEDOPAQUE = 2219
GLOBAL CONST $TMT_DRAWBORDERS = 2214
GLOBAL CONST $TMT_FLATMENUS = 1001
GLOBAL CONST $TMT_GLYPHONLY = 2207
GLOBAL CONST $TMT_GLYPHTRANSPARENT = 2206
GLOBAL CONST $TMT_INTEGRALSIZING = 2211
GLOBAL CONST $TMT_LOCALIZEDMIRRORIMAGE = 2220
GLOBAL CONST $TMT_MIRRORIMAGE = 2209
GLOBAL CONST $TMT_NOETCHEDEFFECT = 2215
GLOBAL CONST $TMT_SOURCEGROW = 2212
GLOBAL CONST $TMT_SOURCESHRINK = 2213
GLOBAL CONST $TMT_TEXTAPPLYOVERLAY = 2216
GLOBAL CONST $TMT_TEXTGLOW = 2217
GLOBAL CONST $TMT_TEXTITALIC = 2218
GLOBAL CONST $TMT_TRANSPARENT = 2201
GLOBAL CONST $TMT_UNIFORMSIZING = 2210
GLOBAL CONST $TMT_USERPICTURE = 5001
GLOBAL CONST $TMT_ACCENTCOLORHINT = 3823
GLOBAL CONST $TMT_ACTIVEBORDER = 1611
GLOBAL CONST $TMT_ACTIVECAPTION = 1603
GLOBAL CONST $TMT_APPWORKSPACE = 1613
GLOBAL CONST $TMT_BACKGROUND = 1602
GLOBAL CONST $TMT_BLENDCOLOR = 5003
GLOBAL CONST $TMT_BODYTEXTCOLOR = 3827
GLOBAL CONST $TMT_BORDERCOLOR = 3801
GLOBAL CONST $TMT_BORDERCOLORHINT = 3822
GLOBAL CONST $TMT_BTNFACE = 1616
GLOBAL CONST $TMT_BTNHIGHLIGHT = 1621
GLOBAL CONST $TMT_BTNSHADOW = 1617
GLOBAL CONST $TMT_BTNTEXT = 1619
GLOBAL CONST $TMT_BUTTONALTERNATEFACE = 1626
GLOBAL CONST $TMT_CAPTIONTEXT = 1610
GLOBAL CONST $TMT_DKSHADOW3D = 1622
GLOBAL CONST $TMT_EDGEDKSHADOWCOLOR = 3807
GLOBAL CONST $TMT_EDGEFILLCOLOR = 3808
GLOBAL CONST $TMT_EDGEHIGHLIGHTCOLOR = 3805
GLOBAL CONST $TMT_EDGELIGHTCOLOR = 3804
GLOBAL CONST $TMT_EDGESHADOWCOLOR = 3806
GLOBAL CONST $TMT_FILLCOLOR = 3802
GLOBAL CONST $TMT_FILLCOLORHINT = 3821
GLOBAL CONST $TMT_FROMCOLOR1 = 2001
GLOBAL CONST $TMT_FROMCOLOR2 = 2002
GLOBAL CONST $TMT_FROMCOLOR3 = 2003
GLOBAL CONST $TMT_FROMCOLOR4 = 2004
GLOBAL CONST $TMT_FROMCOLOR5 = 2005
GLOBAL CONST $TMT_GLOWCOLOR = 3816
GLOBAL CONST $TMT_GLYPHTEXTCOLOR = 3819
GLOBAL CONST $TMT_GLYPHTRANSPARENTCOLOR = 3820
GLOBAL CONST $TMT_GRADIENTACTIVECAPTION = 1628
GLOBAL CONST $TMT_GRADIENTCOLOR1 = 3810
GLOBAL CONST $TMT_GRADIENTCOLOR2 = 3811
GLOBAL CONST $TMT_GRADIENTCOLOR3 = 3812
GLOBAL CONST $TMT_GRADIENTCOLOR4 = 3813
GLOBAL CONST $TMT_GRADIENTCOLOR5 = 3814
GLOBAL CONST $TMT_GRADIENTINACTIVECAPTION = 1629
GLOBAL CONST $TMT_GRAYTEXT = 1618
GLOBAL CONST $TMT_HEADING1TEXTCOLOR = 3825
GLOBAL CONST $TMT_HEADING2TEXTCOLOR = 3826
GLOBAL CONST $TMT_HIGHLIGHT = 1614
GLOBAL CONST $TMT_HIGHLIGHTTEXT = 1615
GLOBAL CONST $TMT_HOTTRACKING = 1627
GLOBAL CONST $TMT_INACTIVEBORDER = 1612
GLOBAL CONST $TMT_INACTIVECAPTION = 1604
GLOBAL CONST $TMT_INACTIVECAPTIONTEXT = 1620
GLOBAL CONST $TMT_INFOBK = 1625
GLOBAL CONST $TMT_INFOTEXT = 1624
GLOBAL CONST $TMT_LIGHT3D = 1623
GLOBAL CONST $TMT_MENU = 1605
GLOBAL CONST $TMT_MENUBAR = 1631
GLOBAL CONST $TMT_MENUHILIGHT = 1630
GLOBAL CONST $TMT_MENUTEXT = 1608
GLOBAL CONST $TMT_SCROLLBAR = 1601
GLOBAL CONST $TMT_SHADOWCOLOR = 3815
GLOBAL CONST $TMT_TEXTBORDERCOLOR = 3817
GLOBAL CONST $TMT_TEXTCOLOR = 3803
GLOBAL CONST $TMT_TEXTCOLORHINT = 3824
GLOBAL CONST $TMT_TEXTSHADOWCOLOR = 3818
GLOBAL CONST $TMT_TRANSPARENTCOLOR = 3809
GLOBAL CONST $TMT_WINDOW = 1606
GLOBAL CONST $TMT_WINDOWFRAME = 1607
GLOBAL CONST $TMT_WINDOWTEXT = 1609
GLOBAL CONST $TMT_ATLASIMAGE = 8000
GLOBAL CONST $TMT_BGTYPE = 4001
GLOBAL CONST $TMT_BORDERTYPE = 4002
GLOBAL CONST $TMT_CONTENTALIGNMENT = 4006
GLOBAL CONST $TMT_FILLTYPE = 4003
GLOBAL CONST $TMT_GLYPHTYPE = 4012
GLOBAL CONST $TMT_GLYPHFONTSIZINGTYPE = 4014
GLOBAL CONST $TMT_HALIGN = 4005
GLOBAL CONST $TMT_ICONEFFECT = 4009
GLOBAL CONST $TMT_IMAGELAYOUT = 4011
GLOBAL CONST $TMT_IMAGESELECTTYPE = 4013
GLOBAL CONST $TMT_OFFSETTYPE = 4008
GLOBAL CONST $TMT_SIZINGTYPE = 4004
GLOBAL CONST $TMT_TEXTSHADOWTYPE = 4010
GLOBAL CONST $TMT_TRUESIZESCALINGTYPE = 4015
GLOBAL CONST $TMT_VALIGN = 4007
GLOBAL CONST $TMT_GLYPHIMAGEFILE = 3008
GLOBAL CONST $TMT_IMAGEFILE = 3001
GLOBAL CONST $TMT_IMAGEFILE1 = 3002
GLOBAL CONST $TMT_IMAGEFILE2 = 3003
GLOBAL CONST $TMT_IMAGEFILE3 = 3004
GLOBAL CONST $TMT_IMAGEFILE4 = 3005
GLOBAL CONST $TMT_IMAGEFILE5 = 3006
GLOBAL CONST $TMT_SCALEDBACKGROUND = 7001
GLOBAL CONST $TMT_BODYFONT = 809
GLOBAL CONST $TMT_CAPTIONFONT = 801
GLOBAL CONST $TMT_GLYPHFONT = 2601
GLOBAL CONST $TMT_HEADING1FONT = 807
GLOBAL CONST $TMT_HEADING2FONT = 808
GLOBAL CONST $TMT_ICONTITLEFONT = 806
GLOBAL CONST $TMT_MENUFONT = 803
GLOBAL CONST $TMT_MSGBOXFONT = 805
GLOBAL CONST $TMT_SMALLCAPTIONFONT = 802
GLOBAL CONST $TMT_STATUSFONT = 804
GLOBAL CONST $TMT_ALPHALEVEL = 2402
GLOBAL CONST $TMT_ALPHATHRESHOLD = 2415
GLOBAL CONST $TMT_ANIMATIONDELAY = 2428
GLOBAL CONST $TMT_ANIMATIONDURATION = 5006
GLOBAL CONST $TMT_BORDERSIZE = 2403
GLOBAL CONST $TMT_CHARSET = 403
GLOBAL CONST $TMT_COLORIZATIONCOLOR = 2431
GLOBAL CONST $TMT_COLORIZATIONOPACITY = 2432
GLOBAL CONST $TMT_FRAMESPERSECOND = 2426
GLOBAL CONST $TMT_FROMHUE1 = 1801
GLOBAL CONST $TMT_FROMHUE2 = 1802
GLOBAL CONST $TMT_FROMHUE3 = 1803
GLOBAL CONST $TMT_FROMHUE4 = 1804
GLOBAL CONST $TMT_FROMHUE5 = 1805
GLOBAL CONST $TMT_GLOWINTENSITY = 2429
GLOBAL CONST $TMT_GLYPHINDEX = 2418
GLOBAL CONST $TMT_GRADIENTRATIO1 = 2406
GLOBAL CONST $TMT_GRADIENTRATIO2 = 2407
GLOBAL CONST $TMT_GRADIENTRATIO3 = 2408
GLOBAL CONST $TMT_GRADIENTRATIO4 = 2409
GLOBAL CONST $TMT_GRADIENTRATIO5 = 2410
GLOBAL CONST $TMT_HEIGHT = 2417
GLOBAL CONST $TMT_IMAGECOUNT = 2401
GLOBAL CONST $TMT_MINCOLORDEPTH = 1301
GLOBAL CONST $TMT_MINDPI1 = 2420
GLOBAL CONST $TMT_MINDPI2 = 2421
GLOBAL CONST $TMT_MINDPI3 = 2422
GLOBAL CONST $TMT_MINDPI4 = 2423
GLOBAL CONST $TMT_MINDPI5 = 2424
GLOBAL CONST $TMT_OPACITY = 2430
GLOBAL CONST $TMT_PIXELSPERFRAME = 2427
GLOBAL CONST $TMT_PROGRESSCHUNKSIZE = 2411
GLOBAL CONST $TMT_PROGRESSSPACESIZE = 2412
GLOBAL CONST $TMT_ROUNDCORNERHEIGHT = 2405
GLOBAL CONST $TMT_ROUNDCORNERWIDTH = 2404
GLOBAL CONST $TMT_SATURATION = 2413
GLOBAL CONST $TMT_TEXTBORDERSIZE = 2414
GLOBAL CONST $TMT_TEXTGLOWSIZE = 2425
GLOBAL CONST $TMT_TOCOLOR1 = 2006
GLOBAL CONST $TMT_TOCOLOR2 = 2007
GLOBAL CONST $TMT_TOCOLOR3 = 2008
GLOBAL CONST $TMT_TOCOLOR4 = 2009
GLOBAL CONST $TMT_TOCOLOR5 = 2010
GLOBAL CONST $TMT_TOHUE1 = 1806
GLOBAL CONST $TMT_TOHUE2 = 1807
GLOBAL CONST $TMT_TOHUE3 = 1808
GLOBAL CONST $TMT_TOHUE4 = 1809
GLOBAL CONST $TMT_TOHUE5 = 1810
GLOBAL CONST $TMT_TRUESIZESTRETCHMARK = 2419
GLOBAL CONST $TMT_WIDTH = 2416
GLOBAL CONST $TMT_TRANSITIONDURATIONS = 6000
GLOBAL CONST $TMT_CAPTIONMARGINS = 3603
GLOBAL CONST $TMT_CONTENTMARGINS = 3602
GLOBAL CONST $TMT_SIZINGMARGINS = 3601
GLOBAL CONST $TMT_MINSIZE = 3403
GLOBAL CONST $TMT_MINSIZE1 = 3404
GLOBAL CONST $TMT_MINSIZE2 = 3405
GLOBAL CONST $TMT_MINSIZE3 = 3406
GLOBAL CONST $TMT_MINSIZE4 = 3407
GLOBAL CONST $TMT_MINSIZE5 = 3408
GLOBAL CONST $TMT_NORMALSIZE = 3409
GLOBAL CONST $TMT_OFFSET = 3401
GLOBAL CONST $TMT_TEXTSHADOWOFFSET = 3402
GLOBAL CONST $TMT_ANIMATIONBUTTONRECT = 5005
GLOBAL CONST $TMT_ATLASRECT = 8002
GLOBAL CONST $TMT_CUSTOMSPLITRECT = 5004
GLOBAL CONST $TMT_DEFAULTPANESIZE = 5002
GLOBAL CONST $TMT_CAPTIONBARHEIGHT = 1205
GLOBAL CONST $TMT_CAPTIONBARWIDTH = 1204
GLOBAL CONST $TMT_MENUBARHEIGHT = 1209
GLOBAL CONST $TMT_MENUBARWIDTH = 1208
GLOBAL CONST $TMT_PADDEDBORDERWIDTH = 1210
GLOBAL CONST $TMT_SCROLLBARHEIGHT = 1203
GLOBAL CONST $TMT_SCROLLBARWIDTH = 1202
GLOBAL CONST $TMT_SIZINGBORDERWIDTH = 1201
GLOBAL CONST $TMT_SMCAPTIONBARHEIGHT = 1207
GLOBAL CONST $TMT_SMCAPTIONBARWIDTH = 1206
GLOBAL CONST $TMT_ALIAS = 1404
GLOBAL CONST $TMT_ATLASINPUTIMAGE = 8001
GLOBAL CONST $TMT_AUTHOR = 604
GLOBAL CONST $TMT_CLASSICVALUE = 3202
GLOBAL CONST $TMT_COLORSCHEMES = 401
GLOBAL CONST $TMT_COMPANY = 603
GLOBAL CONST $TMT_COPYRIGHT = 605
GLOBAL CONST $TMT_CSSNAME = 1401
GLOBAL CONST $TMT_DESCRIPTION = 608
GLOBAL CONST $TMT_DISPLAYNAME = 601
GLOBAL CONST $TMT_LASTUPDATED = 1403
GLOBAL CONST $TMT_SIZES = 402
GLOBAL CONST $TMT_TEXT = 3201
GLOBAL CONST $TMT_TOOLTIP = 602
GLOBAL CONST $TMT_URL = 606
GLOBAL CONST $TMT_VERSION = 607
GLOBAL CONST $TMT_XMLNAME = 1402
GLOBAL CONST $TMT_NAME = 600
#Region Global Variables and Constants
	GLOBAL CONST $TAGDTTOPTS = "dword Size;dword Flags;dword clrText;dword clrBorder;dword clrShadow;int TextShadowType;" & $TAGPOINT & ";int BorderSize;int FontPropId;int ColorPropId;int StateId;int ApplyOverlay;int GlowSize;ptr DrawTextCallback;lparam lParam"
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_BEGINBUFFEREDPAINT($HDC, $TTARGET, BYREF $HNEWDC, $IFORMAT = 0, $IFLAGS = 0, $TEXCLUDE = 0, $IALPHA = -1)
		LOCAL CONST $TAGBP_PAINTPARAMS = "dword cbSize;dword dwFlags;ptr prcExclude;ptr pBlendFunction"
		LOCAL $TPP = DLLSTRUCTCREATE($TAGBP_PAINTPARAMS)
		$HNEWDC = 0
		LOCAL $TBF = 0
		IF $IALPHA <> -1 THEN
			$TBF = DLLSTRUCTCREATE($TAGBLENDFUNCTION)
			DLLSTRUCTSETDATA($TBF, 1, 0)
			DLLSTRUCTSETDATA($TBF, 2, 0)
			DLLSTRUCTSETDATA($TBF, 3, $IALPHA)
			DLLSTRUCTSETDATA($TBF, 4, 1)
		ENDIF
		DLLSTRUCTSETDATA($TPP, 1, DLLSTRUCTGETSIZE($TPP))
		DLLSTRUCTSETDATA($TPP, 2, $IFLAGS)
		DLLSTRUCTSETDATA($TPP, 3, DLLSTRUCTGETPTR($TEXCLUDE))
		DLLSTRUCTSETDATA($TPP, 4, DLLSTRUCTGETPTR($TBF))
		LOCAL $ARET = DLLCALL("uxtheme.dll", "handle", "BeginBufferedPaint", "handle", $HDC, "struct*", $TTARGET, "dword", $IFORMAT, "struct*", $TPP, "handle*", 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		$HNEWDC = $ARET[5]
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_BUFFEREDPAINTCLEAR($HBP, $TRECT = 0)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "BufferedPaintClear", "handle", $HBP, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_BUFFEREDPAINTINIT()
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "BufferedPaintInit")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_BUFFEREDPAINTSETALPHA($HBP, $IALPHA = 255, $TRECT = 0)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "BufferedPaintSetAlpha", "handle", $HBP, "struct*", $TRECT, "byte", $IALPHA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_BUFFEREDPAINTUNINIT()
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "BufferedPaintUnInit")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_CLOSETHEMEDATA($HTHEME)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "CloseThemeData", "handle", $HTHEME)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DRAWTHEMEBACKGROUND($HTHEME, $IPARTID, $ISTATEID, $HDC, $TRECT, $TCLIP = 0)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "DrawThemeBackground", "handle", $HTHEME, "handle", $HDC, "int", $IPARTID, "int", $ISTATEID, "struct*", $TRECT, "struct*", $TCLIP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DRAWTHEMEEDGE($HTHEME, $IPARTID, $ISTATEID, $HDC, $TRECT, $IEDGE, $IFLAGS, $TAREA = 0)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "DrawThemeEdge", "handle", $HTHEME, "handle", $HDC, "int", $IPARTID, "int", $ISTATEID, "struct*", $TRECT, "uint", $IEDGE, "uint", $IFLAGS, "struct*", $TAREA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DRAWTHEMEICON($HTHEME, $IPARTID, $ISTATEID, $HDC, $TRECT, $HIL, $IINDEX)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "DrawThemeIcon", "handle", $HTHEME, "handle", $HDC, "int", $IPARTID, "int", $ISTATEID, "struct*", $TRECT, "handle", $HIL, "int", $IINDEX)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DRAWTHEMEPARENTBACKGROUND($HWND, $HDC, $TRECT = 0)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "DrawThemeParentBackground", "hwnd", $HWND, "handle", $HDC, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DRAWTHEMETEXT($HTHEME, $IPARTID, $ISTATEID, $HDC, $STEXT, $TRECT, $IFLAGS)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "DrawThemeText", "handle", $HTHEME, "handle", $HDC, "int", $IPARTID, "int", $ISTATEID, "wstr", $STEXT, "int", -1, "dword", $IFLAGS, "dword", 0, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_DRAWTHEMETEXTEX($HTHEME, $IPARTID, $ISTATEID, $HDC, $STEXT, $TRECT, $IFLAGS, $TDTTOPTS)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "DrawThemeTextEx", "handle", $HTHEME, "handle", $HDC, "int", $IPARTID, "int", $ISTATEID, "wstr", $STEXT, "int", -1, "dword", $IFLAGS, "struct*", $TRECT, "struct*", $TDTTOPTS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_ENDBUFFEREDPAINT($HBP, $BUPDATE = TRUE)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "EndBufferedPaint", "handle", $HBP, "bool", $BUPDATE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_GETBUFFEREDPAINTBITS($HBP)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetBufferedPaintBits", "handle", $HBP, "ptr*", 0, "int*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN SETEXTENDED($ARET[3], $ARET[2])
	ENDFUNC
	FUNC _WINAPI_GETBUFFEREDPAINTDC($HBP)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "handle", "GetBufferedPaintDC", "handle", $HBP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETBUFFEREDPAINTTARGETDC($HBP)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "handle", "GetBufferedPaintTargetDC", "handle", $HBP)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETBUFFEREDPAINTTARGETRECT($HBP)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetBufferedPaintTargetRect", "handle", $HBP, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_GETCURRENTTHEMENAME()
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetCurrentThemeName", "wstr", "", "int", 4096, "wstr", "", "int", 2048, "wstr", "", "int", 2048)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		LOCAL $ARESULT[3]
		FOR $I = 0 TO 2
			$ARESULT[$I] = $ARET[$I * 2 + 1]
		NEXT
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETTHEMEAPPPROPERTIES()
		LOCAL $ARET = DLLCALL("uxtheme.dll", "dword", "GetThemeAppProperties")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETTHEMEBACKGROUNDCONTENTRECT($HTHEME, $IPARTID, $ISTATEID, $HDC, $TRECT)
		LOCAL $TAREA = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeBackgroundContentRect", "handle", $HTHEME, "handle", $HDC, "int", $IPARTID, "int", $ISTATEID, "struct*", $TRECT, "struct*", $TAREA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TAREA
	ENDFUNC
	FUNC _WINAPI_GETTHEMEBACKGROUNDEXTENT($HTHEME, $IPARTID, $ISTATEID, $HDC, $TRECT)
		LOCAL $TAREA = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeBackgroundExtent", "handle", $HTHEME, "handle", $HDC, "int", $IPARTID, "int", $ISTATEID, "struct*", $TRECT, "struct*", $TAREA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TAREA
	ENDFUNC
	FUNC _WINAPI_GETTHEMEBACKGROUNDREGION($HTHEME, $IPARTID, $ISTATEID, $HDC, $TRECT)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeBackgroundRegion", "handle", $HTHEME, "handle", $HDC, "int", $IPARTID, "int", $ISTATEID, "struct*", $TRECT, "handle*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[6]
	ENDFUNC
	FUNC _WINAPI_GETTHEMEBITMAP($HTHEME, $IPARTID, $ISTATEID, $IPROPID, $IFLAG = 1)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeBitmap", "handle", $HTHEME, "int", $IPARTID, "int", $ISTATEID, "int", $IPROPID, "ulong", $IFLAG, "handle*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], -1)
		RETURN $ARET[6]
	ENDFUNC
	FUNC _WINAPI_GETTHEMEBOOL($HTHEME, $IPARTID, $ISTATEID, $IPROPID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeBool", "handle", $HTHEME, "int", $IPARTID, "int", $ISTATEID, "int", $IPROPID, "bool*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[5]
	ENDFUNC
	FUNC _WINAPI_GETTHEMECOLOR($HTHEME, $IPARTID, $ISTATEID, $IPROPID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeColor", "handle", $HTHEME, "int", $IPARTID, "int", $ISTATEID, "int", $IPROPID, "dword*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], -1)
		RETURN __RGB($ARET[5])
	ENDFUNC
	FUNC _WINAPI_GETTHEMEDOCUMENTATIONPROPERTY($SFILEPATH, $SPROPERTY)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeDocumentationProperty", "wstr", $SFILEPATH, "wstr", $SPROPERTY, "wstr", "", "int", 4096)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_GETTHEMEENUMVALUE($HTHEME, $IPARTID, $ISTATEID, $IPROPID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeEnumValue", "handle", $HTHEME, "int", $IPARTID, "int", $ISTATEID, "int", $IPROPID, "int*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[5]
	ENDFUNC
	FUNC _WINAPI_GETTHEMEFILENAME($HTHEME, $IPARTID, $ISTATEID, $IPROPID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "uint", "GetThemeFilename", "handle", $HTHEME, "int", $IPARTID, "int", $ISTATEID, "int", $IPROPID, "wstr", "", "int", 4096)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		RETURN $ARET[5]
	ENDFUNC
	FUNC _WINAPI_GETTHEMEFONT($HTHEME, $IPARTID, $ISTATEID, $IPROPID, $HDC = 0)
		LOCAL $TLOGFONT = DLLSTRUCTCREATE($TAGLOGFONT)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeFont", "handle", $HTHEME, "handle", $HDC, "int", $IPARTID, "int", $ISTATEID, "int", $IPROPID, "struct*", $TLOGFONT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TLOGFONT
	ENDFUNC
	FUNC _WINAPI_GETTHEMEINT($HTHEME, $IPARTID, $ISTATEID, $IPROPID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeInt", "handle", $HTHEME, "int", $IPARTID, "int", $ISTATEID, "int", $IPROPID, "int*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[5]
	ENDFUNC
	FUNC _WINAPI_GETTHEMEMARGINS($HTHEME, $IPARTID, $ISTATEID, $IPROPID, $HDC, $TRECT)
		LOCAL $TMARGINS = DLLSTRUCTCREATE($TAGMARGINS)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeMargins", "handle", $HTHEME, "handle", $HDC, "int", $IPARTID, "int", $ISTATEID, "int", $IPROPID, "struct*", $TRECT, "struct*", $TMARGINS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TMARGINS
	ENDFUNC
	FUNC _WINAPI_GETTHEMEMETRIC($HTHEME, $IPARTID, $ISTATEID, $IPROPID, $HDC = 0)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeMetric", "handle", $HTHEME, "handle", $HDC, "int", $IPARTID, "int", $ISTATEID, "int", $IPROPID, "int*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[6]
	ENDFUNC
	FUNC _WINAPI_GETTHEMEPARTSIZE($HTHEME, $IPARTID, $ISTATEID, $HDC, $TRECT, $ITYPE)
		LOCAL $TSIZE = DLLSTRUCTCREATE($TAGSIZE)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemePartSize", "handle", $HTHEME, "handle", $HDC, "int", $IPARTID, "int", $ISTATEID, "struct*", $TRECT, "int", $ITYPE, "struct*", $TSIZE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TSIZE
	ENDFUNC
	FUNC _WINAPI_GETTHEMEPOSITION($HTHEME, $IPARTID, $ISTATEID, $IPROPID)
		LOCAL $TPOINT = DLLSTRUCTCREATE($TAGPOINT)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemePosition", "handle", $HTHEME, "int", $IPARTID, "int", $ISTATEID, "int", $IPROPID, "struct*", $TPOINT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TPOINT
	ENDFUNC
	FUNC _WINAPI_GETTHEMEPROPERTYORIGIN($HTHEME, $IPARTID, $ISTATEID, $IPROPID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemePropertyOrigin", "handle", $HTHEME, "int", $IPARTID, "int", $ISTATEID, "int", $IPROPID, "uint*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[5]
	ENDFUNC
	FUNC _WINAPI_GETTHEMERECT($HTHEME, $IPARTID, $ISTATEID, $IPROPID)
		LOCAL $TRECT = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeRect", "handle", $HTHEME, "int", $IPARTID, "int", $ISTATEID, "int", $IPROPID, "struct*", $TRECT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TRECT
	ENDFUNC
	FUNC _WINAPI_GETTHEMESTRING($HTHEME, $IPARTID, $ISTATEID, $IPROPID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeString", "handle", $HTHEME, "int", $IPARTID, "int", $ISTATEID, "int", $IPROPID, "wstr", "", "int", 4096)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		RETURN $ARET[5]
	ENDFUNC
	FUNC _WINAPI_GETTHEMESYSBOOL($HTHEME, $IBOOLID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "bool", "GetThemeSysBool", "handle", $HTHEME, "int", $IBOOLID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETTHEMESYSCOLOR($HTHEME, $ICOLORID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "dword", "GetThemeSysColor", "handle", $HTHEME, "int", $ICOLORID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, -1)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETTHEMESYSCOLORBRUSH($HTHEME, $ICOLORID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "handle", "GetThemeSysColorBrush", "handle", $HTHEME, "int", $ICOLORID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETTHEMESYSFONT($HTHEME, $IFONTID)
		LOCAL $TLOGFONT = DLLSTRUCTCREATE($TAGLOGFONT)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeSysFont", "handle", $HTHEME, "int", $IFONTID, "struct*", $TLOGFONT)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TLOGFONT
	ENDFUNC
	FUNC _WINAPI_GETTHEMESYSINT($HTHEME, $IINTID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeSysInt", "handle", $HTHEME, "int", $IINTID, "int*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_GETTHEMESYSSIZE($HTHEME, $ISIZEID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "int", "GetThemeSysSize", "handle", $HTHEME, "int", $ISIZEID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_GETTHEMESYSSTRING($HTHEME, $ISTRINGID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeSysString", "handle", $HTHEME, "int", $ISTRINGID, "wstr", "", "int", 4096)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, "")
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], "")
		RETURN $ARET[3]
	ENDFUNC
	FUNC _WINAPI_GETTHEMETEXTEXTENT($HTHEME, $IPARTID, $ISTATEID, $HDC, $STEXT, $TRECT, $IFLAGS)
		LOCAL $TAREA = DLLSTRUCTCREATE($TAGRECT)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeTextExtent", "handle", $HTHEME, "handle", $HDC, "int", $IPARTID, "int", $ISTATEID, "wstr", $STEXT, "int", -1, "dword", $IFLAGS, "struct*", $TRECT, "struct*", $TAREA)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TAREA
	ENDFUNC
	FUNC _WINAPI_GETTHEMETEXTMETRICS($HTHEME, $IPARTID, $ISTATEID, $HDC = 0)
		LOCAL $TTEXTMETRIC = DLLSTRUCTCREATE($TAGTEXTMETRIC)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeTextMetrics", "handle", $HTHEME, "handle", $HDC, "int", $IPARTID, "int", $ISTATEID, "struct*", $TTEXTMETRIC)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $TTEXTMETRIC
	ENDFUNC
	FUNC _WINAPI_GETTHEMETRANSITIONDURATION($HTHEME, $IPARTID, $ISTATEIDFROM, $ISTATEIDTO, $IPROPID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "GetThemeTransitionDuration", "handle", $HTHEME, "int", $IPARTID, "int", $ISTATEIDFROM, "int", $ISTATEIDTO, "int", $IPROPID, "dword*", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN $ARET[6]
	ENDFUNC
	FUNC _WINAPI_GETWINDOWTHEME($HWND)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "handle", "GetWindowTheme", "hwnd", $HWND)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ISTHEMEACTIVE()
		LOCAL $ARET = DLLCALL("uxtheme.dll", "bool", "IsThemeActive")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ISTHEMEBACKGROUNDPARTIALLYTRANSPARENT($HTHEME, $IPARTID, $ISTATEID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "bool", "IsThemeBackgroundPartiallyTransparent", "handle", $HTHEME, "int", $IPARTID, "int", $ISTATEID)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ISTHEMEPARTDEFINED($HTHEME, $IPARTID)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "int", "IsThemePartDefined", "handle", $HTHEME, "int", $IPARTID, "int", 0)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, FALSE)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_OPENTHEMEDATA($HWND, $SCLASS)
		LOCAL $ARET = DLLCALL("uxtheme.dll", "handle", "OpenThemeData", "hwnd", $HWND, "wstr", $SCLASS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_SETTHEMEAPPPROPERTIES($IFLAGS)
		DLLCALL("uxtheme.dll", "none", "SetThemeAppProperties", "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SETWINDOWTHEME($HWND, $SNAME = DEFAULT, $SLIST = DEFAULT)
		LOCAL $STYPEOFNAME = "wstr", $STYPEOFLIST = "wstr"
		IF NOT ISSTRING($SNAME) THEN
			$STYPEOFNAME = "ptr"
			$SNAME = 0
		ENDIF
		IF NOT ISSTRING($SLIST) THEN
			$STYPEOFLIST = "ptr"
			$SLIST = 0
		ENDIF
		LOCAL $ARET = DLLCALL("uxtheme.dll", "long", "SetWindowTheme", "hwnd", $HWND, $STYPEOFNAME, $SNAME, $STYPEOFLIST, $SLIST)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
#EndRegion Public Functions
#Region Global Variables and Constants
	GLOBAL $__G_HFRDLG = 0, $__G_HFRDLL = 0
#EndRegion Global Variables and Constants
#Region Functions list
#EndRegion Functions list
#Region Public Functions
	FUNC _WINAPI_DISPLAYSTRUCT($TSTRUCT, $SSTRUCT = "", $STITLE = "", $IITEM = 0, $ISUBITEM = 0, $IFLAGS = 0, $BTOP = TRUE, $HPARENT = 0)
		IF NOT STRINGSTRIPWS($STITLE, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
			$STITLE = "Structure: ListView Display"
		ENDIF
		$SSTRUCT = STRINGREGEXPREPLACE(STRINGSTRIPWS($SSTRUCT, $STR_STRIPLEADING + $STR_STRIPTRAILING + $STR_STRIPSPACES), ";+\Z", "")
		LOCAL $PDATA
		IF ISDLLSTRUCT($TSTRUCT) THEN
			$PDATA = DLLSTRUCTGETPTR($TSTRUCT)
			IF NOT $SSTRUCT THEN
				$SSTRUCT = "byte[" & DLLSTRUCTGETSIZE($TSTRUCT) & "]"
				$IFLAGS = BITOR($IFLAGS, 64)
			ENDIF
		ELSE
			$PDATA = $TSTRUCT
			IF NOT $SSTRUCT THEN RETURN SETERROR(10, 0, 0)
		ENDIF
		LOCAL $TDATA = DLLSTRUCTCREATE($SSTRUCT, $PDATA)
		LOCAL $IDATA = DLLSTRUCTGETSIZE($TDATA)
		IF(NOT BITAND($IFLAGS, 512)) AND(_WINAPI_ISBADREADPTR($PDATA, $IDATA)) THEN
			IF NOT BITAND($IFLAGS, 256) THEN
				MSGBOX($MB_SYSTEMMODAL, $STITLE, "The memory range allocated to a given structure could not be read." & @CRLF & @CRLF & PTR($PDATA) & " - " & PTR($PDATA + $IDATA - 1) & @CRLF & @CRLF & "Press OK to exit.")
				EXIT -1073741819
			ENDIF
			RETURN SETERROR(15, 0, 0)
		ENDIF
		LOCAL $SOPT1 = OPT("GUIDataSeparatorChar", "|")
		LOCAL $IOPT2 = OPT("GUIOnEventMode", 0)
		LOCAL $IOPT3 = OPT("GUICloseOnESC", 1)
		IF $HPARENT THEN
			GUISETSTATE(@SW_DISABLE, $HPARENT)
		ENDIF
		LOCAL $ISTYLE = 1
		IF $BTOP THEN
			$ISTYLE = BITOR($ISTYLE, 8)
		ENDIF
		$__G_HFRDLG = GUICREATE($STITLE, 570, 620, -1, -1, -2134441984, $ISTYLE, $HPARENT)
		LOCAL $IDLV = GUICTRLCREATELISTVIEW("#|Member|Offset|Type|Size|Value", 0, 0, 570, 620, 32781, (($__WINVER < 1536) ? 65585 : 65584))
		LOCAL $HLV = GUICTRLGETHANDLE($IDLV)
		IF $__WINVER >= 1536 THEN
			_WINAPI_SETWINDOWTHEME($HLV, "Explorer")
		ENDIF
		GUICTRLSETRESIZING(-1, 102)
		GUICTRLSETFONT(-1, 8.5, 400, 0, "Tahoma")
		GUICTRLSETSTATE(-1, 256)
		LOCAL $AVAL[101] = [0]
		IF NOT BITAND($IFLAGS, 1) THEN
			__INC($AVAL)
			$AVAL[$AVAL[0]] = ""
			GUICTRLCREATELISTVIEWITEM("-|-|" & $PDATA & "|<struct>|0|-", $IDLV)
			GUICTRLSETCOLOR(-1, 10263708)
		ENDIF
		LOCAL $ADATA = STRINGSPLIT($SSTRUCT, ";")
		LOCAL $AITEM, $VITEM, $SITEM, $IMODE, $IINDEX, $ICOUNT = 0, $IPREV = 0
		LOCAL $ASEL[2] = [0, 0]
		LOCAL $ATYPE[28][2] = [["BYTE", 1], ["BOOLEAN", 1], ["CHAR", 1], ["WCHAR", 2], ["short", 2], ["USHORT", 2], ["WORD", 2], ["int", 4], ["long", 4], ["BOOL", 4], ["UINT", 4], ["ULONG", 4], ["DWORD", 4], ["INT64", 8], ["UINT64", 8], ["ptr", (@AUTOITX64 ? 8 : 4)], ["HWND", (@AUTOITX64 ? 8 : 4)], ["HANDLE", (@AUTOITX64 ? 8 : 4)], ["float", 4], ["double", 8], ["INT_PTR", (@AUTOITX64 ? 8 : 4)], ["LONG_PTR", (@AUTOITX64 ? 8 : 4)], ["LRESULT", (@AUTOITX64 ? 8 : 4)], ["LPARAM", (@AUTOITX64 ? 8 : 4)], ["UINT_PTR", (@AUTOITX64 ? 8 : 4)], ["ULONG_PTR", (@AUTOITX64 ? 8 : 4)], ["DWORD_PTR", (@AUTOITX64 ? 8 : 4)], ["WPARAM", (@AUTOITX64 ? 8 : 4)]]
		FOR $I = 1 TO $ADATA[0]
			$AITEM = STRINGSPLIT(STRINGSTRIPWS($ADATA[$I], $STR_STRIPLEADING + $STR_STRIPTRAILING), " ")
			SWITCH $AITEM[1]
				CASE "ALIGN", "STRUCT", "ENDSTRUCT"
					CONTINUELOOP
				CASE ELSE
			ENDSWITCH
			$ICOUNT += 1
			$IMODE = 1
			$SITEM = $ICOUNT & "|"
			IF $AITEM[0] > 1 THEN
				$VITEM = STRINGREGEXPREPLACE($AITEM[2], "\[.*\Z", "")
				$SITEM &= $VITEM & "|"
				IF(NOT BITAND($IFLAGS, 16)) AND(NOT STRINGCOMPARE(STRINGREGEXPREPLACE($VITEM, "[0-9]+\Z", ""), "RESERVED")) THEN
					$IMODE = 0
				ENDIF
				IF NOT ISSTRING($IITEM) THEN
					$VITEM = $ICOUNT
				ENDIF
				$IINDEX = 2
			ELSE
				IF NOT BITAND($IFLAGS, 4) THEN
					$SITEM &= "<unnamed>|"
				ELSE
					$SITEM &= "|"
				ENDIF
				IF NOT ISSTRING($IITEM) THEN
					$VITEM = $ICOUNT
				ELSE
					$VITEM = 0
				ENDIF
				$IINDEX = 1
			ENDIF
			IF(NOT $ASEL[0]) AND($VITEM) AND($IITEM) AND($VITEM = $IITEM) THEN
				$ASEL[0] = $ICOUNT
			ENDIF
			LOCAL $IOFFSET = NUMBER(DLLSTRUCTGETPTR($TDATA, $ICOUNT) - $PDATA)
			$IINDEX = STRINGREGEXP($AITEM[$IINDEX], "\[(\d+)\]", $STR_REGEXPARRAYGLOBALMATCH)
			LOCAL $ISIZE
			DO
				REDIM $AITEM[3]
				$VITEM = STRINGREGEXPREPLACE($AITEM[1], "\[.*\Z", "")
				FOR $J = 0 TO UBOUND($ATYPE) - 1
					IF NOT STRINGCOMPARE($ATYPE[$J][0], $VITEM) THEN
						$AITEM[1] = $ATYPE[$J][0]
						$AITEM[2] = $ATYPE[$J][1]
						$ISIZE = $AITEM[2]
						EXITLOOP 2
					ENDIF
				NEXT
				$AITEM[1] = "?"
				$AITEM[2] = "?"
				$ISIZE = 0
			UNTIL 1
			$SITEM &= $IOFFSET & "|"
			IF(ISARRAY($IINDEX)) AND($IINDEX[0] > "1") THEN
				IF $ISIZE THEN
					$AITEM[2] = $AITEM[2] * $IINDEX[0]
				ENDIF
				DO
					SWITCH $AITEM[1]
						CASE "BYTE", "BOOLEAN"
							IF NOT BITAND($IFLAGS, 64) THEN
								CONTINUECASE
							ENDIF
						CASE "CHAR", "WCHAR"
							$SITEM &= $AITEM[1] & "[" & $IINDEX[0] & "]|" & $AITEM[2] & "|"
							$IINDEX = 0
							EXITLOOP
						CASE ELSE
					ENDSWITCH
					IF($ISIZE) AND($IMODE) THEN
						$SITEM &= $AITEM[1] & "[" & $IINDEX[0] & "]|" & $AITEM[2] & " (" & $ISIZE & ")" & "|"
					ELSE
						$SITEM &= $AITEM[1] & "[" & $IINDEX[0] & "]|" & $AITEM[2] & "|"
					ENDIF
					IF $IMODE THEN
						$IINDEX = $IINDEX[0]
					ELSE
						$IINDEX = 0
					ENDIF
				UNTIL 1
			ELSE
				$SITEM &= $AITEM[1] & "|" & $AITEM[2] & "|"
				$IINDEX = 0
			ENDIF
			IF(NOT BITAND($IFLAGS, 2)) AND($IPREV) AND($IOFFSET > $IPREV) THEN
				__INC($AVAL)
				$AVAL[$AVAL[0]] = ""
				GUICTRLCREATELISTVIEWITEM("-|-|-|<alignment>|" & ($IOFFSET - $IPREV) & "|-", $IDLV)
				GUICTRLSETCOLOR(-1, 16711680)
			ENDIF
			IF $ISIZE THEN
				$IPREV = $IOFFSET + $AITEM[2]
			ELSE
				$IPREV = 0
			ENDIF
			LOCAL $IDLVITEM, $IDINIT
			IF $IINDEX THEN
				LOCAL $SPATTERN = "[%0" & STRINGLEN($IINDEX) & "d] "
				FOR $J = 1 TO $IINDEX
					__INC($AVAL)
					$AVAL[$AVAL[0]] = DLLSTRUCTGETDATA($TDATA, $ICOUNT, $J)
					IF BITAND($IFLAGS, 128) THEN
						$AVAL[$AVAL[0]] = __WINAPIDIAG_HEX($AVAL[$AVAL[0]], $AITEM[1])
					ENDIF
					$IDLVITEM = GUICTRLCREATELISTVIEWITEM($SITEM & STRINGFORMAT($SPATTERN, $J) & $AVAL[$AVAL[0]], $IDLV)
					IF($ASEL[0] = $ICOUNT) AND(NOT $ASEL[1]) THEN
						IF($ISUBITEM < 1) OR($ISUBITEM > $IINDEX) OR($ISUBITEM = $J) THEN
							$ASEL[1] = $IDLVITEM
						ENDIF
					ENDIF
					IF(NOT $IDINIT) AND($ICOUNT = 1) THEN
						$IDINIT = $IDLVITEM
					ENDIF
					IF NOT BITAND($IFLAGS, 8) THEN
						GUICTRLSETBKCOLOR(-1, 16119285)
					ENDIF
					IF $ISIZE THEN
						$SITEM = "-|-|" & ($IOFFSET + $J * $ISIZE) & "|-|-|"
					ELSE
						GUICTRLSETCOLOR(-1, 16746496)
						$SITEM = "-|-|-|-|-|"
					ENDIF
				NEXT
			ELSE
				__INC($AVAL)
				IF $IMODE THEN
					$AVAL[$AVAL[0]] = DLLSTRUCTGETDATA($TDATA, $ICOUNT)
					IF BITAND($IFLAGS, 128) THEN
						$AVAL[$AVAL[0]] = __WINAPIDIAG_HEX($AVAL[$AVAL[0]], $AITEM[1])
					ENDIF
					$IDLVITEM = GUICTRLCREATELISTVIEWITEM($SITEM & $AVAL[$AVAL[0]], $IDLV)
				ELSE
					$AVAL[$AVAL[0]] = ""
					$IDLVITEM = GUICTRLCREATELISTVIEWITEM($SITEM & "-", $IDLV)
				ENDIF
				IF($ASEL[0] = $ICOUNT) AND(NOT $ASEL[1]) THEN
					$ASEL[1] = $IDLVITEM
				ENDIF
				IF(NOT $IDINIT) AND($ICOUNT = 1) THEN
					$IDINIT = $IDLVITEM
				ENDIF
				IF NOT $ISIZE THEN
					GUICTRLSETCOLOR(-1, 16746496)
				ENDIF
			ENDIF
			IF(NOT BITAND($IFLAGS, 2)) AND(NOT $ISIZE) THEN
				__INC($AVAL)
				$AVAL[$AVAL[0]] = ""
				GUICTRLCREATELISTVIEWITEM("-|-|-|<alignment>|?|-", $IDLV)
				GUICTRLSETCOLOR(-1, 16746496)
			ENDIF
		NEXT
		IF(NOT BITAND($IFLAGS, 2)) AND($IPREV) AND($IDATA > $IPREV) THEN
			__INC($AVAL)
			$AVAL[$AVAL[0]] = ""
			GUICTRLCREATELISTVIEWITEM("-|-|-|<alignment>|" & ($IDATA - $IPREV) & "|-", $IDLV)
			GUICTRLSETCOLOR(-1, 16711680)
		ENDIF
		IF NOT BITAND($IFLAGS, 1) THEN
			__INC($AVAL)
			$AVAL[$AVAL[0]] = ""
			GUICTRLCREATELISTVIEWITEM("-|-|" & ($PDATA + $IDATA + 0) & "|<endstruct>|" & $IDATA & "|-", $IDLV)
			GUICTRLSETCOLOR(-1, 10263708)
		ENDIF
		IF $ASEL[1] THEN
			GUICTRLSETSTATE($ASEL[1], 256)
		ELSE
			GUICTRLSETSTATE($IDINIT, 256)
		ENDIF
		LOCAL $IDDUMMY = GUICTRLCREATEDUMMY()
		LOCAL $AWIDTH[6] = [30, 130, 76, 100, 50, 167]
		FOR $I = 0 TO UBOUND($AWIDTH) - 1
			GUICTRLSENDMSG($IDLV, 4126, $I, $AWIDTH[$I])
		NEXT
		LOCAL $TPARAM = DLLSTRUCTCREATE("ptr;uint")
		DLLSTRUCTSETDATA($TPARAM, 1, $HLV)
		IF NOT BITAND($IFLAGS, 32) THEN
			DLLSTRUCTSETDATA($TPARAM, 2, $IDDUMMY)
		ELSE
			DLLSTRUCTSETDATA($TPARAM, 2, 0)
		ENDIF
		$__G_HFRDLL = DLLCALLBACKREGISTER("__DlgSubclassProc", "lresult", "hwnd;uint;wparam;lparam;uint;ptr")
		LOCAL $PDLL = DLLCALLBACKGETPTR($__G_HFRDLL)
		IF _WINAPI_SETWINDOWSUBCLASS($__G_HFRDLG, $PDLL, 1000, DLLSTRUCTGETPTR($TPARAM)) THEN
			ONAUTOITEXITREGISTER("__WinAPIDiag_Quit")
		ELSE
			DLLCALLBACKFREE($__G_HFRDLL)
			$__G_HFRDLL = 0
		ENDIF
		GUISETSTATE()
		WHILE 1
			SWITCH GUIGETMSG()
				CASE 0
					CONTINUELOOP
				CASE -3
					EXITLOOP
				CASE $IDDUMMY
					$IINDEX = GUICTRLREAD($IDDUMMY)
					IF($IINDEX >= 0) AND($IINDEX < $AVAL[0]) THEN
						CLIPPUT($AVAL[$IINDEX + 1])
					ENDIF
			ENDSWITCH
		WEND
		IF $__G_HFRDLL THEN
			ONAUTOITEXITUNREGISTER("__WinAPIDiag_Quit")
		ENDIF
		__WINAPIDIAG_QUIT()
		IF $HPARENT THEN
			GUISETSTATE(@SW_ENABLE, $HPARENT)
		ENDIF
		GUIDELETE($__G_HFRDLG)
		OPT("GUIDataSeparatorChar", $SOPT1)
		OPT("GUIOnEventMode", $IOPT2)
		OPT("GUICloseOnESC", $IOPT3)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_ENUMDLLPROC($SFILEPATH, $SMASK = "", $IFLAGS = 0)
		IF NOT __DLL("dbghelp.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $VVER = __WINAPIDIAG_VER("dbghelp.dll")
		IF $VVER < 1281 THEN RETURN SETERROR(2, 0, 0)
		$__G_VENUM = 0
		LOCAL $IPE, $ARET, $IERROR = 0, $HLIBRARY = 0, $VWOW64 = DEFAULT
		IF _WINAPI_ISWOW64PROCESS() THEN
			$ARET = DLLCALL("kernel32.dll", "bool", "Wow64DisableWow64FsRedirection", "ptr*", 0)
			IF NOT @ERROR AND $ARET[0] THEN $VWOW64 = $ARET[1]
		ENDIF
		DO
			$ARET = DLLCALL("kernel32.dll", "dword", "SearchPathW", "ptr", 0, "wstr", $SFILEPATH, "ptr", 0, "dword", 4096, "wstr", "", "ptr", 0)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
			$__G_VEXT = $ARET[5]
			$IPE = _WINAPI_GETPETYPE($__G_VEXT)
			SWITCH $IPE
				CASE 332
				CASE 512, 34404
				CASE ELSE
					$IERROR = @ERROR + 20
					EXITLOOP
			ENDSWITCH
			$HLIBRARY = _WINAPI_LOADLIBRARYEX($__G_VEXT, 3)
			IF NOT $HLIBRARY THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			IF $VVER >= 1536 THEN
				__ENUMDLLPROCW($HLIBRARY, $SMASK, $IFLAGS)
			ELSE
				__ENUMDLLPROCA($HLIBRARY, $SMASK, $IFLAGS)
			ENDIF
			IF @ERROR THEN
				$IERROR = @ERROR + 40
				EXITLOOP
			ENDIF
		UNTIL 1
		IF $HLIBRARY THEN
			_WINAPI_FREELIBRARY($HLIBRARY)
		ENDIF
		IF NOT($VWOW64 = DEFAULT) THEN
			DLLCALL("kernel32.dll", "bool", "Wow64RevertWow64FsRedirection", "ptr*", $VWOW64)
		ENDIF
		RETURN SETERROR($IERROR, $IPE, $__G_VENUM)
	ENDFUNC
	FUNC _WINAPI_GETAPPLICATIONRESTARTSETTINGS($IPID = 0)
		IF NOT $IPID THEN $IPID = @AUTOITPID
		LOCAL $HPROCESS = DLLCALL("kernel32.dll", "handle", "OpenProcess", "dword", (($__WINVER < 1536) ? 1040 : 4112), "bool", 0, "dword", $IPID)
		IF @ERROR OR NOT $HPROCESS[0] THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $ARET = DLLCALL("kernel32.dll", "uint", "GetApplicationRestartSettings", "handle", $HPROCESS[0], "wstr", "", "dword*", 4096, "dword*", 0)
		LOCAL $IERROR, $IEXTENDED = @EXTENDED
		IF @ERROR THEN
			$IERROR = @ERROR
		ELSEIF $ARET[0] THEN
			$IERROR = 10
			$IEXTENDED = $ARET[0]
		ENDIF
		DLLCALL("kernel32.dll", "bool", "CloseHandle", "handle", $HPROCESS[0])
		IF $IERROR THEN RETURN SETERROR($IERROR, $IEXTENDED, 0)
		LOCAL $ARESULT[2]
		$ARESULT[0] = $ARET[2]
		$ARESULT[1] = $ARET[4]
		RETURN $ARESULT
	ENDFUNC
	FUNC _WINAPI_GETERRORMODE()
		LOCAL $ARET = DLLCALL("kernel32.dll", "uint", "GetErrorMode")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_FATALEXIT($ICODE)
		DLLCALL("kernel32.dll", "none", "FatalExit", "int", $ICODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED)
	ENDFUNC
	FUNC _WINAPI_ISINTERNETCONNECTED()
		IF NOT __DLL("connect.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $ARET = DLLCALL("connect.dll", "long", "IsInternetConnected")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF NOT($ARET[0] = 0 OR $ARET[0] = 1) THEN
			RETURN SETERROR(10, $ARET[0], FALSE)
		ENDIF
		RETURN NOT $ARET[0]
	ENDFUNC
	FUNC _WINAPI_ISNETWORKALIVE()
		IF NOT __DLL("sensapi.dll") THEN RETURN SETERROR(103, 0, 0)
		LOCAL $ARET = DLLCALL("sensapi.dll", "bool", "IsNetworkAlive", "int*", 0)
		LOCAL $ILASTERROR = _WINAPI_GETLASTERROR()
		IF $ILASTERROR THEN RETURN SETERROR(1, $ILASTERROR, 0)
		IF @ERROR OR NOT $ARET[0] THEN RETURN SETERROR(@ERROR + 10, $ILASTERROR, 0)
		RETURN $ARET[1]
	ENDFUNC
	FUNC _WINAPI_NTSTATUSTODOSERROR($ISTATUS)
		LOCAL $ARET = DLLCALL("ntdll.dll", "ulong", "RtlNtStatusToDosError", "long", $ISTATUS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_REGISTERAPPLICATIONRESTART($IFLAGS = 0, $SCMD = "")
		LOCAL $ARET = DLLCALL("kernel32.dll", "long", "RegisterApplicationRestart", "wstr", $SCMD, "dword", $IFLAGS)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
	FUNC _WINAPI_SETERRORMODE($IMODE)
		LOCAL $ARET = DLLCALL("kernel32.dll", "uint", "SetErrorMode", "uint", $IMODE)
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		RETURN $ARET[0]
	ENDFUNC
	FUNC _WINAPI_UNIQUEHARDWAREID($IFLAGS = 0)
		LOCAL $OSERVICE = OBJGET("winmgmts:\\.\root\cimv2")
		IF NOT ISOBJ($OSERVICE) THEN RETURN SETERROR(1, 0, "")
		LOCAL $OITEMS = $OSERVICE.ExecQuery("SELECT * FROM Win32_ComputerSystemProduct")
		IF NOT ISOBJ($OITEMS) THEN RETURN SETERROR(2, 0, "")
		LOCAL $SHW = "", $IEXTENDED = 0
		FOR $OPROPERTY IN $OITEMS
			$SHW &= $OPROPERTY.IdentifyingNumber
			$SHW &= $OPROPERTY.Name
			$SHW &= $OPROPERTY.SKUNumber
			$SHW &= $OPROPERTY.UUID
			$SHW &= $OPROPERTY.Vendor
			$SHW &= $OPROPERTY.Version
		NEXT
		$SHW = STRINGSTRIPWS($SHW, $STR_STRIPALL)
		IF NOT $SHW THEN RETURN SETERROR(3, 0, "")
		LOCAL $STEXT
		IF BITAND($IFLAGS, 1) THEN
			$OITEMS = $OSERVICE.ExecQuery("SELECT * FROM Win32_BIOS")
			IF NOT ISOBJ($OITEMS) THEN RETURN SETERROR(3, 0, "")
			$STEXT = ""
			FOR $OPROPERTY IN $OITEMS
				$STEXT &= $OPROPERTY.IdentificationCode
				$STEXT &= $OPROPERTY.Manufacturer
				$STEXT &= $OPROPERTY.Name
				$STEXT &= $OPROPERTY.SerialNumber
				$STEXT &= $OPROPERTY.SMBIOSMajorVersion
				$STEXT &= $OPROPERTY.SMBIOSMinorVersion
			NEXT
			$STEXT = STRINGSTRIPWS($STEXT, $STR_STRIPALL)
			IF $STEXT THEN
				$IEXTENDED += 1
				$SHW &= $STEXT
			ENDIF
		ENDIF
		IF BITAND($IFLAGS, 2) THEN
			$OITEMS = $OSERVICE.ExecQuery("SELECT * FROM Win32_Processor")
			IF NOT ISOBJ($OITEMS) THEN RETURN SETERROR(4, 0, "")
			$STEXT = ""
			FOR $OPROPERTY IN $OITEMS
				$STEXT &= $OPROPERTY.Architecture
				$STEXT &= $OPROPERTY.Family
				$STEXT &= $OPROPERTY.Level
				$STEXT &= $OPROPERTY.Manufacturer
				$STEXT &= $OPROPERTY.Name
				$STEXT &= $OPROPERTY.ProcessorId
				$STEXT &= $OPROPERTY.Revision
				$STEXT &= $OPROPERTY.Version
			NEXT
			$STEXT = STRINGSTRIPWS($STEXT, $STR_STRIPALL)
			IF $STEXT THEN
				$IEXTENDED += 2
				$SHW &= $STEXT
			ENDIF
		ENDIF
		IF BITAND($IFLAGS, 4) THEN
			$OITEMS = $OSERVICE.ExecQuery("SELECT * FROM Win32_PhysicalMedia")
			IF NOT ISOBJ($OITEMS) THEN RETURN SETERROR(5, 0, "")
			$STEXT = ""
			FOR $OPROPERTY IN $OITEMS
				SWITCH _WINAPI_GETDRIVEBUSTYPE($OPROPERTY.Tag)
					CASE 3, 11
						$STEXT &= $OPROPERTY.SerialNumber
					CASE ELSE
				ENDSWITCH
			NEXT
			$STEXT = STRINGSTRIPWS($STEXT, $STR_STRIPALL)
			IF $STEXT THEN
				$IEXTENDED += 4
				$SHW &= $STEXT
			ENDIF
		ENDIF
		LOCAL $SHASH = __WINAPIDIAG_MD5($SHW)
		IF NOT $SHASH THEN RETURN SETERROR(6, 0, "")
		RETURN SETEXTENDED($IEXTENDED, "{" & STRINGMID($SHASH, 1, 8) & "-" & STRINGMID($SHASH, 9, 4) & "-" & STRINGMID($SHASH, 13, 4) & "-" & STRINGMID($SHASH, 17, 4) & "-" & STRINGMID($SHASH, 21, 12) & "}")
	ENDFUNC
	FUNC _WINAPI_UNREGISTERAPPLICATIONRESTART()
		LOCAL $ARET = DLLCALL("kernel32.dll", "long", "UnregisterApplicationRestart")
		IF @ERROR THEN RETURN SETERROR(@ERROR, @EXTENDED, 0)
		IF $ARET[0] THEN RETURN SETERROR(10, $ARET[0], 0)
		RETURN 1
	ENDFUNC
#EndRegion Public Functions
#Region Internal Functions
	FUNC __DLGSUBCLASSPROC($SHWND, $IMSG, $WPARAM, $LPARAM, $IDLV, $PDATA)
		#forceref $IDLV
		SWITCH $IMSG
			CASE 78
				LOCAL $TNMIA = DLLSTRUCTCREATE("hwnd;uint_ptr;" & (@AUTOITX64 ? "int;int" : "int") & ";int Item;int;uint;uint;uint;long;long;lparam;uint", $LPARAM)
				LOCAL $HLISTVIEW = DLLSTRUCTGETDATA($TNMIA, 1)
				LOCAL $NMSG = DLLSTRUCTGETDATA($TNMIA, 3)
				LOCAL $TPARAM = DLLSTRUCTCREATE("ptr;uint", $PDATA)
				LOCAL $IDUMMY = DLLSTRUCTGETDATA($TPARAM, 2)
				LOCAL $HLV = DLLSTRUCTGETDATA($TPARAM, 1)
				SWITCH $HLISTVIEW
					CASE $HLV
						SWITCH $NMSG
							CASE -109
								RETURN 0
							CASE -114
								IF $IDUMMY THEN
									GUICTRLSENDTODUMMY($IDUMMY, DLLSTRUCTGETDATA($TNMIA, "Item"))
								ENDIF
								RETURN 0
						ENDSWITCH
				ENDSWITCH
		ENDSWITCH
		RETURN _WINAPI_DEFSUBCLASSPROC($SHWND, $IMSG, $WPARAM, $LPARAM)
	ENDFUNC
	FUNC __ENUMDLLPROCA($HLIBRARY, $SMASK, $IFLAGS)
		LOCAL $HPROCESS, $PADDRESS = 0, $IINIT = 0, $VOPTS = DEFAULT, $IERROR = 0
		LOCAL $STYPEOFMASK = "str"
		$__G_VENUM = 0
		DO
			LOCAL $ARET = DLLCALL("dbghelp.dll", "dword", "SymGetOptions")
			IF @ERROR THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
			$VOPTS = $ARET[0]
			$ARET = DLLCALL("dbghelp.dll", "dword", "SymSetOptions", "dword", BITOR(BITAND($IFLAGS, 3), 516))
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 20
				EXITLOOP
			ENDIF
			$HPROCESS = _WINAPI_GETCURRENTPROCESS()
			$ARET = DLLCALL("dbghelp.dll", "int", "SymInitialize", "handle", $HPROCESS, "ptr", 0, "int", 1)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			$IINIT = 1
			$ARET = DLLCALL("dbghelp.dll", "uint64", "SymLoadModule64", "handle", $HPROCESS, "ptr", 0, "str", $__G_VEXT, "ptr", 0, "uint64", $HLIBRARY, "dword", 0)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 40
				EXITLOOP
			ENDIF
			$PADDRESS = $ARET[0]
			DIM $__G_VENUM[501][2] = [[0]]
			LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumSymbolsProcA", "int", "ptr;ulong;lparam")
			LOCAL $PENUMPROC = DLLCALLBACKGETPTR($HENUMPROC)
			IF NOT STRINGSTRIPWS($SMASK, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
				$STYPEOFMASK = "ptr"
				$SMASK = 0
			ENDIF
			$ARET = DLLCALL("dbghelp.dll", "int", "SymEnumSymbols", "handle", $HPROCESS, "uint64", $PADDRESS, $STYPEOFMASK, $SMASK, "ptr", $PENUMPROC, "lparam", 0)
			IF @ERROR OR NOT $ARET[0] OR(NOT $__G_VENUM[0][0]) THEN
				$IERROR = @ERROR + 50
				$__G_VENUM = 0
			ENDIF
			DLLCALLBACKFREE($HENUMPROC)
			IF ISARRAY($__G_VENUM) THEN
				__INC($__G_VENUM, -1)
			ENDIF
		UNTIL 1
		IF $PADDRESS THEN
			DLLCALL("dbghelp.dll", "int", "SymUnloadModule64", "handle", $HPROCESS, "uint64", $PADDRESS)
		ENDIF
		IF $IINIT THEN
			DLLCALL("dbghelp.dll", "int", "SymCleanup", "handle", $HPROCESS)
		ENDIF
		IF NOT($VOPTS = DEFAULT) THEN
			DLLCALL("dbghelp.dll", "dword", "SymSetOptions", "dword", $VOPTS)
		ENDIF
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN 1
	ENDFUNC
	FUNC __ENUMDLLPROCW($HLIBRARY, $SMASK, $IFLAGS)
		LOCAL $HPROCESS, $PADDRESS = 0, $IINIT = 0, $VOPTS = DEFAULT, $IERROR = 0
		LOCAL $STYPEOFMASK = "wstr"
		$__G_VENUM = 0
		DO
			LOCAL $ARET = DLLCALL("dbghelp.dll", "dword", "SymGetOptions")
			IF @ERROR THEN
				$IERROR = @ERROR + 10
				EXITLOOP
			ENDIF
			$VOPTS = $ARET[0]
			$ARET = DLLCALL("dbghelp.dll", "dword", "SymSetOptions", "dword", BITOR(BITAND($IFLAGS, 3), 516))
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 20
				EXITLOOP
			ENDIF
			$HPROCESS = _WINAPI_GETCURRENTPROCESS()
			$ARET = DLLCALL("dbghelp.dll", "int", "SymInitializeW", "handle", $HPROCESS, "ptr", 0, "int", 1)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			$IINIT = 1
			$ARET = DLLCALL("dbghelp.dll", "uint64", "SymLoadModuleExW", "handle", $HPROCESS, "ptr", 0, "wstr", $__G_VEXT, "ptr", 0, "uint64", $HLIBRARY, "dword", 0, "ptr", 0, "dword", 0)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 40
				EXITLOOP
			ENDIF
			$PADDRESS = $ARET[0]
			DIM $__G_VENUM[501][2] = [[0]]
			LOCAL $HENUMPROC = DLLCALLBACKREGISTER("__EnumSymbolsProcW", "int", "ptr;ulong;lparam")
			LOCAL $PENUMPROC = DLLCALLBACKGETPTR($HENUMPROC)
			IF NOT STRINGSTRIPWS($SMASK, $STR_STRIPLEADING + $STR_STRIPTRAILING) THEN
				$STYPEOFMASK = "ptr"
				$SMASK = 0
			ENDIF
			$ARET = DLLCALL("dbghelp.dll", "int", "SymEnumSymbolsW", "handle", $HPROCESS, "uint64", $PADDRESS, $STYPEOFMASK, $SMASK, "ptr", $PENUMPROC, "lparam", 0)
			IF @ERROR OR NOT $ARET[0] OR NOT $__G_VENUM[0][0] THEN
				$IERROR = @ERROR + 50
				$__G_VENUM = 0
			ENDIF
			DLLCALLBACKFREE($HENUMPROC)
			IF ISARRAY($__G_VENUM) THEN
				__INC($__G_VENUM, -1)
			ENDIF
		UNTIL 1
		IF $PADDRESS THEN
			DLLCALL("dbghelp.dll", "int", "SymUnloadModule64", "handle", $HPROCESS, "uint64", $PADDRESS)
		ENDIF
		IF $IINIT THEN
			DLLCALL("dbghelp.dll", "int", "SymCleanup", "handle", $HPROCESS)
		ENDIF
		IF NOT($VOPTS = DEFAULT) THEN
			DLLCALL("dbghelp.dll", "dword", "SymSetOptions", "dword", $VOPTS)
		ENDIF
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, 0)
		RETURN 1
	ENDFUNC
	FUNC __ENUMSYMBOLSPROCA($PSYMINFO, $ISYMSIZE, $LPARAM)
		#forceref $ISYMSIZE, $LPARAM
		LOCAL $TAGSYMBOL_INFO = "uint SizeOfStruct;uint TypeIndex;uint64 Reserved[2];uint Index;uint Size;uint64 ModBase;uint Flags;uint64 Value;uint64 Address;uint Register;uint Scope;uint Tag;uint NameLen;uint MaxNameLen;wchar Name[1]"
		LOCAL $TSYMINFO = DLLSTRUCTCREATE($TAGSYMBOL_INFO, $PSYMINFO)
		LOCAL $ILENGTH = DLLSTRUCTGETDATA($TSYMINFO, "NameLen")
		IF $ILENGTH AND BITAND(DLLSTRUCTGETDATA($TSYMINFO, "Flags"), 1536) THEN
			__INC($__G_VENUM, 500)
			$__G_VENUM[$__G_VENUM[0][0]][0] = DLLSTRUCTGETDATA($TSYMINFO, "Address") - DLLSTRUCTGETDATA($TSYMINFO, "ModBase")
			$__G_VENUM[$__G_VENUM[0][0]][1] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("char[" & ($ILENGTH + 1) & "]", DLLSTRUCTGETPTR($TSYMINFO, "Name")), 1)
		ENDIF
		RETURN 1
	ENDFUNC
	FUNC __ENUMSYMBOLSPROCW($PSYMINFO, $ISYMSIZE, $LPARAM)
		#forceref $ISYMSIZE, $LPARAM
		LOCAL $TAGSYMBOL_INFO = "uint SizeOfStruct;uint TypeIndex;uint64 Reserved[2];uint Index;uint Size;uint64 ModBase;uint Flags;uint64 Value;uint64 Address;uint Register;uint Scope;uint Tag;uint NameLen;uint MaxNameLen;wchar Name[1]"
		LOCAL $TSYMINFO = DLLSTRUCTCREATE($TAGSYMBOL_INFO, $PSYMINFO)
		LOCAL $ILENGTH = DLLSTRUCTGETDATA($TSYMINFO, "NameLen")
		IF $ILENGTH AND BITAND(DLLSTRUCTGETDATA($TSYMINFO, "Flags"), 1536) THEN
			__INC($__G_VENUM, 500)
			$__G_VENUM[$__G_VENUM[0][0]][0] = DLLSTRUCTGETDATA($TSYMINFO, "Address") - DLLSTRUCTGETDATA($TSYMINFO, "ModBase")
			$__G_VENUM[$__G_VENUM[0][0]][1] = DLLSTRUCTGETDATA(DLLSTRUCTCREATE("wchar[" & ($ILENGTH + 1) & "]", DLLSTRUCTGETPTR($TSYMINFO, "Name")), 1)
		ENDIF
		RETURN 1
	ENDFUNC
	FUNC __WINAPIDIAG_HEX($IVALUE, $STYPE)
		LOCAL $ILENGTH
		SWITCH $STYPE
			CASE "BYTE", "BOOLEAN"
				$ILENGTH = 2
			CASE "WORD", "USHORT", "short"
				$ILENGTH = 4
			CASE "BOOL", "UINT", "ULONG", "DWORD", "int", "long"
				$ILENGTH = 8
			CASE "INT64", "UINT64"
				$ILENGTH = 16
			CASE "INT_PTR", "UINT_PTR", "LONG_PTR", "ULONG_PTR", "DWORD_PTR", "WPARAM", "LPARAM", "LRESULT"
				$ILENGTH = (@AUTOITX64 ? 16 : 8)
			CASE ELSE
				$ILENGTH = 0
		ENDSWITCH
		IF $ILENGTH THEN
			RETURN "0x" & HEX($IVALUE, $ILENGTH)
		ELSE
			RETURN $IVALUE
		ENDIF
	ENDFUNC
	FUNC __WINAPIDIAG_MD5($SDATA)
		LOCAL $HHASH, $IERROR = 0
		LOCAL $HPROV = DLLCALL("advapi32.dll", "int", "CryptAcquireContextW", "ptr*", 0, "ptr", 0, "ptr", 0, "dword", 3, "dword", -268435456)
		IF @ERROR OR NOT $HPROV[0] THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, "")
		DO
			$HHASH = DLLCALL("advapi32.dll", "int", "CryptCreateHash", "handle", $HPROV[1], "uint", 32771, "ptr", 0, "dword", 0, "ptr*", 0)
			IF @ERROR OR NOT $HHASH[0] THEN
				$IERROR = @ERROR + 20
				$HHASH = 0
				EXITLOOP
			ENDIF
			$HHASH = $HHASH[5]
			LOCAL $TDATA = DLLSTRUCTCREATE("byte[" & BINARYLEN($SDATA) & "]")
			DLLSTRUCTSETDATA($TDATA, 1, $SDATA)
			LOCAL $ARET = DLLCALL("advapi32.dll", "int", "CryptHashData", "handle", $HHASH, "struct*", $TDATA, "dword", DLLSTRUCTGETSIZE($TDATA), "dword", 1)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 30
				EXITLOOP
			ENDIF
			$TDATA = DLLSTRUCTCREATE("byte[16]")
			$ARET = DLLCALL("advapi32.dll", "int", "CryptGetHashParam", "handle", $HHASH, "dword", 2, "struct*", $TDATA, "dword*", 16, "dword", 0)
			IF @ERROR OR NOT $ARET[0] THEN
				$IERROR = @ERROR + 40
				EXITLOOP
			ENDIF
		UNTIL 1
		IF $HHASH THEN
			DLLCALL("advapi32.dll", "int", "CryptDestroyHash", "handle", $HHASH)
		ENDIF
		IF $IERROR THEN RETURN SETERROR($IERROR, 0, "")
		RETURN STRINGTRIMLEFT(DLLSTRUCTGETDATA($TDATA, 1), 2)
	ENDFUNC
	FUNC __WINAPIDIAG_QUIT()
		LOCAL $PDLL = DLLCALLBACKGETPTR($__G_HFRDLL)
		IF $PDLL THEN
			_WINAPI_REMOVEWINDOWSUBCLASS($__G_HFRDLG, $PDLL, 1000)
			DLLCALLBACKFREE($__G_HFRDLL)
		ENDIF
		$__G_HFRDLL = 0
	ENDFUNC
	FUNC __WINAPIDIAG_VER($SPATH)
		LOCAL $HLIBRARY = _WINAPI_GETMODULEHANDLE($SPATH)
		IF NOT $HLIBRARY THEN RETURN SETERROR(@ERROR + 10, @EXTENDED, 0)
		$SPATH = _WINAPI_GETMODULEFILENAMEEX(_WINAPI_GETCURRENTPROCESS(), $HLIBRARY)
		IF NOT $SPATH THEN RETURN SETERROR(@ERROR + 20, @EXTENDED, 0)
		LOCAL $VVER = FILEGETVERSION($SPATH)
		IF @ERROR THEN RETURN SETERROR(1, 0, 0)
		$VVER = STRINGSPLIT($VVER, ".", $STR_NOCOUNT)
		IF UBOUND($VVER) < 2 THEN RETURN SETERROR(2, 0, 0)
		RETURN BITOR(BITSHIFT(NUMBER($VVER[0]), -8), NUMBER($VVER[1]))
	ENDFUNC
#EndRegion Internal Functions
FUNC _STRINGSIZE($STEXT, $ISIZE = 8.5, $IWEIGHT = 400, $IATTRIB = 0, $SNAME = "", $IMAXWIDTH = 0, $HWND = 0)
	IF $ISIZE = DEFAULT THEN $ISIZE = 8.5
	IF $IWEIGHT = DEFAULT THEN $IWEIGHT = 400
	IF $IATTRIB = DEFAULT THEN $IATTRIB = 0
	IF $SNAME = "" OR $SNAME = DEFAULT THEN $SNAME = _STRINGSIZE_DEFAULTFONTNAME()
	IF NOT ISSTRING($STEXT) THEN RETURN SETERROR(1, 1, 0)
	IF NOT ISNUMBER($ISIZE) THEN RETURN SETERROR(1, 2, 0)
	IF NOT ISINT($IWEIGHT) THEN RETURN SETERROR(1, 3, 0)
	IF NOT ISINT($IATTRIB) THEN RETURN SETERROR(1, 4, 0)
	IF NOT ISSTRING($SNAME) THEN RETURN SETERROR(1, 5, 0)
	IF NOT ISNUMBER($IMAXWIDTH) THEN RETURN SETERROR(1, 6, 0)
	IF NOT ISHWND($HWND) AND $HWND <> 0 THEN RETURN SETERROR(1, 7, 0)
	LOCAL $ARET, $HDC, $HFONT, $HLABEL = 0, $HLABEL_HANDLE
	LOCAL $IEXPTAB = BITAND($IATTRIB, 1)
	$IATTRIB = BITAND($IATTRIB, BITNOT(1))
	IF ISHWND($HWND) THEN
		$HLABEL = GUICTRLCREATELABEL("", -10, -10, 10, 10)
		$HLABEL_HANDLE = GUICTRLGETHANDLE(-1)
		GUICTRLSETFONT(-1, $ISIZE, $IWEIGHT, $IATTRIB, $SNAME)
		$ARET = DLLCALL("user32.dll", "handle", "GetDC", "hwnd", $HLABEL_HANDLE)
		IF @ERROR OR $ARET[0] = 0 THEN
			GUICTRLDELETE($HLABEL)
			RETURN SETERROR(2, 1, 0)
		ENDIF
		$HDC = $ARET[0]
		$ARET = DLLCALL("user32.dll", "lparam", "SendMessage", "hwnd", $HLABEL_HANDLE, "int", 49, "wparam", 0, "lparam", 0)
		IF @ERROR OR $ARET[0] = 0 THEN
			GUICTRLDELETE($HLABEL)
			RETURN SETERROR(2, _STRINGSIZE_ERROR_CLOSE(2, $HDC), 0)
		ENDIF
		$HFONT = $ARET[0]
	ELSE
		$ARET = DLLCALL("user32.dll", "handle", "GetDC", "hwnd", $HWND)
		IF @ERROR OR $ARET[0] = 0 THEN RETURN SETERROR(2, 1, 0)
		$HDC = $ARET[0]
		$ARET = DLLCALL("gdi32.dll", "int", "GetDeviceCaps", "handle", $HDC, "int", 90)
		IF @ERROR OR $ARET[0] = 0 THEN RETURN SETERROR(2, _STRINGSIZE_ERROR_CLOSE(3, $HDC), 0)
		LOCAL $IINFO = $ARET[0]
		$ARET = DLLCALL("gdi32.dll", "handle", "CreateFontW", "int", -$IINFO * $ISIZE / 72, "int", 0, "int", 0, "int", 0, "int", $IWEIGHT, "dword", BITAND($IATTRIB, 2), "dword", BITAND($IATTRIB, 4), "dword", BITAND($IATTRIB, 8), "dword", 0, "dword", 0, "dword", 0, "dword", 5, "dword", 0, "wstr", $SNAME)
		IF @ERROR OR $ARET[0] = 0 THEN RETURN SETERROR(2, _STRINGSIZE_ERROR_CLOSE(4, $HDC), 0)
		$HFONT = $ARET[0]
	ENDIF
	$ARET = DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDC, "handle", $HFONT)
	IF @ERROR OR $ARET[0] = 0 THEN RETURN SETERROR(2, _STRINGSIZE_ERROR_CLOSE(5, $HDC, $HFONT, $HLABEL), 0)
	LOCAL $HPREVFONT = $ARET[0]
	LOCAL $AVSIZE_INFO[4], $ILINE_LENGTH, $ILINE_HEIGHT = 0, $ILINE_COUNT = 0, $ILINE_WIDTH = 0, $IWRAP_COUNT, $ILAST_WORD, $STEST_LINE
	LOCAL $TSIZE = DLLSTRUCTCREATE("int X;int Y")
	DLLSTRUCTSETDATA($TSIZE, "X", 0)
	DLLSTRUCTSETDATA($TSIZE, "Y", 0)
	$STEXT = STRINGREGEXPREPLACE($STEXT, "((?<!\x0d)\x0a|\x0d(?!\x0a))", @CRLF)
	LOCAL $ASLINES = STRINGSPLIT($STEXT, @CRLF, 1)
	FOR $I = 1 TO $ASLINES[0]
		IF $IEXPTAB THEN
			$ASLINES[$I] = STRINGREPLACE($ASLINES[$I], @TAB, " XXXXXXXX")
		ENDIF
		$ILINE_LENGTH = STRINGLEN($ASLINES[$I])
		DLLCALL("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $HDC, "wstr", $ASLINES[$I], "int", $ILINE_LENGTH, "ptr", DLLSTRUCTGETPTR($TSIZE))
		IF @ERROR THEN RETURN SETERROR(2, _STRINGSIZE_ERROR_CLOSE(6, $HDC, $HFONT, $HLABEL), 0)
		IF DLLSTRUCTGETDATA($TSIZE, "X") > $ILINE_WIDTH THEN $ILINE_WIDTH = DLLSTRUCTGETDATA($TSIZE, "X")
		IF DLLSTRUCTGETDATA($TSIZE, "Y") > $ILINE_HEIGHT THEN $ILINE_HEIGHT = DLLSTRUCTGETDATA($TSIZE, "Y")
	NEXT
	IF $IMAXWIDTH <> 0 AND $ILINE_WIDTH > $IMAXWIDTH THEN
		FOR $J = 1 TO $ASLINES[0]
			$ILINE_LENGTH = STRINGLEN($ASLINES[$J])
			DLLCALL("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $HDC, "wstr", $ASLINES[$J], "int", $ILINE_LENGTH, "ptr", DLLSTRUCTGETPTR($TSIZE))
			IF @ERROR THEN RETURN SETERROR(2, _STRINGSIZE_ERROR_CLOSE(6, $HDC, $HFONT, $HLABEL), 0)
			IF DLLSTRUCTGETDATA($TSIZE, "X") < $IMAXWIDTH - 4 THEN
				$ILINE_COUNT += 1
				$AVSIZE_INFO[0] &= $ASLINES[$J] & @CRLF
			ELSE
				$IWRAP_COUNT = 0
				WHILE 1
					$ILINE_WIDTH = 0
					$ILAST_WORD = 0
					FOR $I = 1 TO STRINGLEN($ASLINES[$J])
						IF STRINGMID($ASLINES[$J], $I, 1) = " " THEN $ILAST_WORD = $I - 1
						$STEST_LINE = STRINGMID($ASLINES[$J], 1, $I)
						$ILINE_LENGTH = STRINGLEN($STEST_LINE)
						DLLCALL("gdi32.dll", "bool", "GetTextExtentPoint32W", "handle", $HDC, "wstr", $STEST_LINE, "int", $ILINE_LENGTH, "ptr", DLLSTRUCTGETPTR($TSIZE))
						IF @ERROR THEN RETURN SETERROR(2, _STRINGSIZE_ERROR_CLOSE(6, $HDC, $HFONT, $HLABEL), 0)
						$ILINE_WIDTH = DLLSTRUCTGETDATA($TSIZE, "X")
						IF $ILINE_WIDTH >= $IMAXWIDTH - 4 THEN EXITLOOP
					NEXT
					IF $I > STRINGLEN($ASLINES[$J]) THEN
						$IWRAP_COUNT += 1
						$AVSIZE_INFO[0] &= $STEST_LINE & @CRLF
						EXITLOOP
					ELSE
						$IWRAP_COUNT += 1
						IF $ILAST_WORD = 0 THEN RETURN SETERROR(3, _STRINGSIZE_ERROR_CLOSE(0, $HDC, $HFONT, $HLABEL), 0)
						$AVSIZE_INFO[0] &= STRINGLEFT($STEST_LINE, $ILAST_WORD) & @CRLF
						$ASLINES[$J] = STRINGTRIMLEFT($ASLINES[$J], $ILAST_WORD)
						$ASLINES[$J] = STRINGSTRIPWS($ASLINES[$J], 1)
					ENDIF
				WEND
				$ILINE_COUNT += $IWRAP_COUNT
			ENDIF
		NEXT
		IF $IEXPTAB THEN
			$AVSIZE_INFO[0] = STRINGREGEXPREPLACE($AVSIZE_INFO[0], "\x20?XXXXXXXX", @TAB)
		ENDIF
		$AVSIZE_INFO[1] = $ILINE_HEIGHT
		$AVSIZE_INFO[2] = $IMAXWIDTH
		$AVSIZE_INFO[3] = ($ILINE_COUNT * $ILINE_HEIGHT) + 4
	ELSE
		LOCAL $AVSIZE_INFO[4] = [$STEXT, $ILINE_HEIGHT, $ILINE_WIDTH, ($ASLINES[0] * $ILINE_HEIGHT) + 4]
	ENDIF
	DLLCALL("gdi32.dll", "handle", "SelectObject", "handle", $HDC, "handle", $HPREVFONT)
	DLLCALL("gdi32.dll", "bool", "DeleteObject", "handle", $HFONT)
	DLLCALL("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $HDC)
	IF $HLABEL THEN GUICTRLDELETE($HLABEL)
	RETURN $AVSIZE_INFO
ENDFUNC
FUNC _STRINGSIZE_ERROR_CLOSE($IEXTCODE, $HDC = 0, $HFONT = 0, $HLABEL = 0)
	IF $HFONT <> 0 THEN DLLCALL("gdi32.dll", "bool", "DeleteObject", "handle", $HFONT)
	IF $HDC <> 0 THEN DLLCALL("user32.dll", "int", "ReleaseDC", "hwnd", 0, "handle", $HDC)
	IF $HLABEL THEN GUICTRLDELETE($HLABEL)
	RETURN $IEXTCODE
ENDFUNC
FUNC _STRINGSIZE_DEFAULTFONTNAME()
	LOCAL $TNONCLIENTMETRICS = DLLSTRUCTCREATE("uint;int;int;int;int;int;byte[60];int;int;byte[60];int;int;byte[60];byte[60];byte[60]")
	DLLSTRUCTSETDATA($TNONCLIENTMETRICS, 1, DLLSTRUCTGETSIZE($TNONCLIENTMETRICS))
	DLLCALL("user32.dll", "int", "SystemParametersInfo", "int", 41, "int", DLLSTRUCTGETSIZE($TNONCLIENTMETRICS), "ptr", DLLSTRUCTGETPTR($TNONCLIENTMETRICS), "int", 0)
	LOCAL $TLOGFONT = DLLSTRUCTCREATE("long;long;long;long;long;byte;byte;byte;byte;byte;byte;byte;byte;char[32]", DLLSTRUCTGETPTR($TNONCLIENTMETRICS, 13))
	IF ISSTRING(DLLSTRUCTGETDATA($TLOGFONT, 14)) THEN
		RETURN DLLSTRUCTGETDATA($TLOGFONT, 14)
	ELSE
		RETURN "Tahoma"
	ENDIF
ENDFUNC
OPT("MouseCoordMode", 0)
OPT("PixelCoordMode", 0)
OPT("WinTextMatchMode", 2)
OPT("WinTitleMatchMode", 3)
OPT("MouseClickDelay", 5)
OPT("MouseClickDownDelay", 1)
OPT("SendKeyDelay", 1)
OPT("SendKeyDownDelay", 1)
OPT("TrayOnEventMode", 1)
OPT("TrayMenuMode", 1)
OPT("TrayIconHide", 1)
OPT("TrayAutoPause", 0)
OPT("GUIOnEventMode", 1)
OPT("GUIResizeMode", $GUI_DOCKALL)
GLOBAL CONST $VERSAO = 3.5
GLOBAL $FILENAME = "OneDrive"
GLOBAL $FILEINI = @SCRIPTDIR & "\" & $FILENAME & ".ini"
GLOBAL $FILEINIPICKIT = @SCRIPTDIR & "\pickit\items.ini"
IF _SINGLETON($FILENAME, 1) = 0 THEN
	MSGBOX(64, $FILENAME, "The program is already running.")
	EXIT
ENDIF
GLOBAL $OERRORHANDLER = OBJEVENT("AutoIt.Error", "_COMErrFunc")
GLOBAL $FINTERRUPT = 0
GLOBAL $PAUSAR
GLOBAL $SEMINTERNET = 0
GLOBAL $CLICOUSTART = 0
GLOBAL $RUNNINGTIME = 0
GLOBAL $PAROU = 0
GLOBAL $VEIOAPOSPARAR = 0
GLOBAL $DEFAULTD2RFOLDER = "C:\Program Files (x86)\Diablo II Resurrected\D2R.exe"
GLOBAL $D2HANDLE
GLOBAL $TOOLTIP = ""
GLOBAL $REGISTROUADLIB = 0
GLOBAL $REGISTROUADLIBPREMIUM = 0
GLOBAL $X = 0
GLOBAL $Y = 0
GLOBAL $LOGAR = 0
GLOBAL $A = 0
GLOBAL $CANNOTCONNECT = 0
GLOBAL $HAMMERDIN = 0
GLOBAL $DRUID = 0
GLOBAL $CRASHOU = 0
GLOBAL $JANELANAOATIVA = 0
GLOBAL $SAIU = 0
GLOBAL $VERIFICARLIFEANTESDARUN
GLOBAL $VERIFICARMERCANTESDARUN
GLOBAL $VERIFICARINVANTESDARUN
GLOBAL $IRDIRETOPARARUN
GLOBAL $REPARARITEMS = 0
GLOBAL $VEIOOUTROATO = 0
GLOBAL $STASH = 0
GLOBAL $NAOPARARSTASH = 0
GLOBAL $GUARDOUCASH = 0
GLOBAL $SEMGOLD = 0
GLOBAL $PAROUSTASHEFULL = 0
GLOBAL $MATOU = 0
GLOBAL $MORREU = 0
GLOBAL $GUARDOUITEM = 0
GLOBAL $PORTAL = 0
GLOBAL $LIFE1 = 0
GLOBAL $LIFE2 = 0
GLOBAL $MANA1 = 0
GLOBAL $SEMPORTAL = 0
GLOBAL $BFOUND = FALSE
GLOBAL $ASCOLORSITENS[5] = [13087607, 64512, 16754688, 16777060, 7237375]
GLOBAL $ASCOLORS[2] = [65816, 2490882]
GLOBAL $USOULIFE = 0
GLOBAL $USOUMANA = 0
GLOBAL $USOULIFEMERC = 0
GLOBAL $QUANTASRUNS = 0
GLOBAL $MORTES = 0
GLOBAL $QUANTASCHICKEN = 0
GLOBAL $REVIVEUMERC = 0
GLOBAL $ERRORSCHEDULE = 0
GLOBAL $FIRSTTIMERUNNING
GLOBAL $VISUAL
GLOBAL $SERIAL
GLOBAL $SERIALSPLIT = "0707"
GLOBAL $EXECUTAVEL
GLOBAL $DIFFICULT
GLOBAL $HORAINICIO
GLOBAL $HORAFIM
GLOBAL $HORAINICIO2
GLOBAL $HORAFIM2
GLOBAL $HORAINICIO3
GLOBAL $HORAFIM3
GLOBAL $HORAINICIO4
GLOBAL $HORAFIM4
GLOBAL $HORAINICIO5
GLOBAL $HORAFIM5
GLOBAL $HORAINICIO6
GLOBAL $HORAFIM6
GLOBAL $TEMPOEXTRA1
GLOBAL $TEMPOEXTRA2
GLOBAL $TEMPOPARACRIAR1
GLOBAL $TEMPOPARACRIAR2
GLOBAL $USARCTA
GLOBAL $PCDEVAGAR
GLOBAL $PARARSTASHFULL
GLOBAL $PARARSEMGOLD
GLOBAL $MERCENARY = 1
GLOBAL $TELEPORT = 1
GLOBAL $UNIQUES = 1
GLOBAL $SETS = 1
GLOBAL $RARES = 1
GLOBAL $MAGICS = 1
GLOBAL $RUNES = 1
GLOBAL $HOTKEY0 = "-"
GLOBAL $HOTKEY7 = "-"
GLOBAL $HOTKEY1 = "F1"
GLOBAL $HOTKEY2 = "F4"
GLOBAL $HOTKEY3 = "F5"
GLOBAL $HOTKEY4 = "F6"
GLOBAL $HOTKEY5 = "-"
GLOBAL $HOTKEY6 = "-"
GLOBAL $MATARPINDLE
GLOBAL $MATARELDRITCH
GLOBAL $MATARSHENK
GLOBAL $MATARTRAVINCAL
GLOBAL $PINDLEPATH
GLOBAL $CHANGEACT
GLOBAL $RANDOMPAUSE
GLOBAL $CHICKEN
GLOBAL $RANDOMUSECHAT
GLOBAL $STOPSERVERDOWN
GLOBAL $RANDOMGAMEPASS
GLOBAL $RANDOMMOUSEMOVE
GLOBAL $APPSTATS
GLOBAL $NAOPODEPARAR = 0
GLOBAL $PODECHICKEN = 0
GLOBAL $QTOSVERIFICARACAO = 0
IF FILEEXISTS(@SCRIPTDIR & "\Updater.exe") THEN FILEDELETE(@SCRIPTDIR & "\Updater.exe")
GLOBAL $PASTATEMP = @TEMPDIR & "\data\" & $VERSAO & "\"
IF NOT FILEEXISTS($PASTATEMP) THEN
	DO
		DIRCREATE($PASTATEMP)
	UNTIL FILEEXISTS($PASTATEMP)
ENDIF
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\icon.ico", $PASTATEMP, 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\banner.jpg", $PASTATEMP, 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\status.jpg", $PASTATEMP, 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\Settings.json", $PASTATEMP, 0)
IF NOT FILEEXISTS($PASTATEMP & "png\") THEN
	DO
		DIRCREATE($PASTATEMP & "png\")
	UNTIL FILEEXISTS($PASTATEMP & "png\")
ENDIF
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\amulet-set.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\amulet.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\charm.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\circlet.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\died.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\continue.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\continue2.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\coronet.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\diadem.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\tiara.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\corpse.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\fila.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\lobby.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\ingame.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\jewel.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\jewel2.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\life.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\life2.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\malah.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\malah2.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\mana.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\mana2.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\ok.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\rune.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\portal.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\resurrect.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\ring.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\sacredarmor.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\stash.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\stashFree.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\tal-armor.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\trade.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\traderepair.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\tyrael.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\uniq-a.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\uniq-e.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\uniq-i.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\uniq-o.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\uniq-u.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\remaining.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\bo.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\ringmail.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\waypoint.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\charsi.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\larzuk.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\larzuk2.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\larzuk3.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\warriv.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\meshif.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\tyrael2.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\Gold.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\harrogath.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\kurast-docks.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\Rejuvenation.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\Rejuvenation1.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\Rejuvenation2.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\FlawlessGem.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\hammerdin.png", $PASTATEMP & "png\", 0)
FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\data\png\tornado.png", $PASTATEMP & "png\", 0)
IF NOT(FILEEXISTS($PASTATEMP & "Settings.json") AND FILEEXISTS($PASTATEMP & "banner.jpg") AND FILEEXISTS($PASTATEMP & "status.jpg") AND FILEEXISTS($PASTATEMP & "icon.ico") AND FILEEXISTS($FILENAME & ".dll") AND FILEEXISTS("msvcr110d.dll") AND FILEEXISTS("msvcr110.dll")) THEN
	MSGBOX(48, $FILENAME, "Failed to load file 1" & @CRLF & @CRLF & "Contact: pdb2.0@outlook.com")
	SAIR()
ENDIF
IF NOT(FILEEXISTS($PASTATEMP & "png\Gold.png") AND FILEEXISTS($PASTATEMP & "png\lobby.png") AND FILEEXISTS($PASTATEMP & "png\hammerdin.png") AND FILEEXISTS($PASTATEMP & "png\tornado.png") AND FILEEXISTS($PASTATEMP & "png\tiara.png") AND FILEEXISTS($PASTATEMP & "png\Rejuvenation.png") AND FILEEXISTS($PASTATEMP & "png\Rejuvenation1.png") AND FILEEXISTS($PASTATEMP & "png\Rejuvenation2.png") AND FILEEXISTS($PASTATEMP & "png\FlawlessGem.png") AND FILEEXISTS($PASTATEMP & "png\harrogath.png") AND FILEEXISTS($PASTATEMP & "png\kurast-docks.png") AND FILEEXISTS($PASTATEMP & "png\charsi.png") AND FILEEXISTS($PASTATEMP & "png\warriv.png") AND FILEEXISTS($PASTATEMP & "png\meshif.png") AND FILEEXISTS($PASTATEMP & "png\tyrael2.png") AND FILEEXISTS($PASTATEMP & "png\larzuk.png") AND FILEEXISTS($PASTATEMP & "png\larzuk2.png") AND FILEEXISTS($PASTATEMP & "png\larzuk3.png") AND FILEEXISTS($PASTATEMP & "png\waypoint.png") AND FILEEXISTS($PASTATEMP & "png\ringmail.png") AND FILEEXISTS($PASTATEMP & "png\amulet.png") AND FILEEXISTS($PASTATEMP & "png\amulet-set.png") AND FILEEXISTS($PASTATEMP & "png\charm.png") AND FILEEXISTS($PASTATEMP & "png\circlet.png") AND FILEEXISTS($PASTATEMP & "png\died.png") AND FILEEXISTS($PASTATEMP & "png\continue.png") AND FILEEXISTS($PASTATEMP & "png\continue2.png") AND FILEEXISTS($PASTATEMP & "png\coronet.png") AND FILEEXISTS($PASTATEMP & "png\diadem.png") AND FILEEXISTS($PASTATEMP & "png\corpse.png") AND FILEEXISTS($PASTATEMP & "png\fila.png") AND FILEEXISTS($PASTATEMP & "png\ingame.png") AND FILEEXISTS($PASTATEMP & "png\jewel.png") AND FILEEXISTS($PASTATEMP & "png\jewel2.png") AND FILEEXISTS($PASTATEMP & "png\life.png") AND FILEEXISTS($PASTATEMP & "png\life2.png") AND FILEEXISTS($PASTATEMP & "png\malah.png") AND FILEEXISTS($PASTATEMP & "png\malah2.png") AND FILEEXISTS($PASTATEMP & "png\mana.png") AND FILEEXISTS($PASTATEMP & "png\mana2.png") AND FILEEXISTS($PASTATEMP & "png\ok.png") AND FILEEXISTS($PASTATEMP & "png\rune.png") AND FILEEXISTS($PASTATEMP & "png\portal.png") AND FILEEXISTS($PASTATEMP & "png\resurrect.png") AND FILEEXISTS($PASTATEMP & "png\ring.png") AND FILEEXISTS($PASTATEMP & "png\sacredarmor.png") AND FILEEXISTS($PASTATEMP & "png\stash.png") AND FILEEXISTS($PASTATEMP & "png\stashFree.png") AND FILEEXISTS($PASTATEMP & "png\tal-armor.png") AND FILEEXISTS($PASTATEMP & "png\trade.png") AND FILEEXISTS($PASTATEMP & "png\traderepair.png") AND FILEEXISTS($PASTATEMP & "png\tyrael.png") AND FILEEXISTS($PASTATEMP & "png\uniq-a.png") AND FILEEXISTS($PASTATEMP & "png\uniq-e.png") AND FILEEXISTS($PASTATEMP & "png\uniq-i.png") AND FILEEXISTS($PASTATEMP & "png\uniq-o.png") AND FILEEXISTS($PASTATEMP & "png\uniq-u.png") AND FILEEXISTS($PASTATEMP & "png\remaining.png") AND FILEEXISTS($PASTATEMP & "png\bo.png")) THEN
	MSGBOX(48, $FILENAME, "Failed to load file 2" & @CRLF & @CRLF & "Contact: pdb2.0@outlook.com")
	SAIR()
ENDIF
TRAYSETTOOLTIP("OneDrive")
TRAYSETICON($PASTATEMP & "icon.ico")
ATUALIZARINI(0)
LERINI()
$WINDOW1 = GUICREATE($FILENAME, 440, 700)
GUISETONEVENT($GUI_EVENT_CLOSE, "_onClick")
GUISETONEVENT($GUI_EVENT_MINIMIZE, "_onClick")
LOCAL $ICONTEXTMENU = GUICTRLCREATECONTEXTMENU()
LOCAL $IDABOUTITEM = GUICTRLCREATEMENUITEM("About", $ICONTEXTMENU)
GUICTRLSETONEVENT(-1, "_onClick")
LOCAL $WINSIZE = WINGETPOS($WINDOW1)
GUICTRLCREATEPIC($PASTATEMP & "banner.jpg", 0, 0, 440, 95)
GUICTRLSETSTATE(-1, $GUI_DISABLE)
GUICTRLCREATEGROUP("Main", 10, 110, 420, 95)
$SEARCHGAMEGUI = GUICTRLCREATEBUTTON("...", 359, 129, 51, 22)
GUICTRLSETONEVENT(-1, "_onClick")
GUICTRLCREATELABEL("Game path:", 25, 133)
$EXECUTAVELGUI = GUICTRLCREATEINPUT($EXECUTAVEL, 85, 130, 276, 20)
GUICTRLSETTIP(-1, "Where is installed your D2R game?")
GUICTRLCREATELABEL("Serial:", 25, 167)
$SERIALGUI = GUICTRLCREATEINPUT($SERIAL, 85, 164, 170, 20)
GUICTRLSETTIP(-1, "Type the serial and press ENTER")
GUICTRLSETONEVENT(-1, "_onClick")
$ATUALIZARGUI = GUICTRLCREATEBUTTON("Check for Update", 270, 162, 140, 25)
GUICTRLSETONEVENT(-1, "_onClick")
#Region TAB 1
	GUICTRLCREATETAB(10, 220, 420, $WINSIZE[3] - 280)
	GUICTRLCREATETABITEM("Config")
	LOCAL $XCOORD1 = 270
	LOCAL $XCOORD = $XCOORD1
	GUICTRLCREATELABEL("Difficult", 25, $XCOORD)
	GUICTRLCREATELABEL("Normal, Nightmare, Hell or Offline", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	$DIFFICULTGUI = GUICTRLCREATECOMBO("Hell", 310, $XCOORD, 100, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETDATA(-1, "Nightmare|Normal|Offline", $DIFFICULT)
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 1)
	GUICTRLCREATELABEL("Teleport", 25, $XCOORD)
	GUICTRLCREATELABEL("Does your char has teleport?", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$TELEPORTSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$TELEPORTNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($TELEPORT = 1) THEN
		GUICTRLSETSTATE($TELEPORTSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($TELEPORTNAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 2)
	GUICTRLCREATELABEL("Call to Arms?", 25, $XCOORD)
	GUICTRLCREATELABEL("Battle Command | Battle Ordens", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$USARCTASIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$USARCTANAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($USARCTA = 1) THEN
		GUICTRLSETSTATE($USARCTASIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($USARCTANAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 3)
	GUICTRLCREATELABEL("Mercenary", 25, $XCOORD)
	GUICTRLCREATELABEL("Should bot revive Merc when it dies?", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$MERCENARYSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$MERCENARYNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($MERCENARY = 1) THEN
		GUICTRLSETSTATE($MERCENARYSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($MERCENARYNAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 4)
	GUICTRLCREATELABEL("Stop If no Gold for Mercenary", 25, $XCOORD)
	GUICTRLCREATELABEL("It will stop and close the game if it has no gold to revive", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$PARARSEMGOLDSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$PARARSEMGOLDNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($PARARSEMGOLD = 1) THEN
		GUICTRLSETSTATE($PARARSEMGOLDSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($PARARSEMGOLDNAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 5)
	GUICTRLCREATELABEL("Stop If Stashes is Full?", 25, $XCOORD)
	GUICTRLCREATELABEL("It will stop when all stashes get full - Select NO for lvling up", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$PARARSTASHFULLSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$PARARSTASHFULLNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($PARARSTASHFULL = 1) THEN
		GUICTRLSETSTATE($PARARSTASHFULLSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($PARARSTASHFULLNAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 6)
	$STEXT = "Chicken"
	$ASIZE = _STRINGSIZE($STEXT)
	GUICTRLCREATELABEL($ASIZE[0], 25, $XCOORD, $ASIZE[2], $ASIZE[3])
	GUICTRLCREATELABEL("(Premium)", 25 + $ASIZE[2], $XCOORD + 1)
	GUICTRLSETCOLOR(-1, 16744448)
	GUICTRLSETFONT(-1, 7, 100)
	GUICTRLCREATELABEL("Quit the game when life is lower then 35%", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$CHICKENSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$CHICKENNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($CHICKEN = 1) THEN
		GUICTRLSETSTATE($CHICKENSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($CHICKENNAO, $GUI_CHECKED)
	ENDIF
#EndRegion TAB 1
#Region TAB 5
	GUICTRLCREATETABITEM("Binds")
	$SLIST = "-|"
	FOR $I = 1 TO 8
		$SLIST &= "F" & $I & "|"
	NEXT
	$XCOORD = $XCOORD1
	GUICTRLCREATELABEL("Right Skill", 25, $XCOORD)
	GUICTRLCREATELABEL("Meteor, Blizz, Concentration, Trap, Lighting etc", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	$HOTKEY1GUI = GUICTRLCREATECOMBO("", 370, $XCOORD, 40, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETDATA(-1, $SLIST, $HOTKEY1)
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 1)
	GUICTRLCREATELABEL("Teleport", 25, $XCOORD)
	GUICTRLCREATELABEL("Set Teleport if you have it", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	$HOTKEY2GUI = GUICTRLCREATECOMBO("", 370, $XCOORD, 40, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETDATA(-1, $SLIST, $HOTKEY2)
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 2)
	GUICTRLCREATELABEL("Tome Portal", 25, $XCOORD)
	GUICTRLCREATELABEL("Set the key to use Portal", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	$HOTKEY3GUI = GUICTRLCREATECOMBO("", 370, $XCOORD, 40, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETDATA(-1, $SLIST, $HOTKEY3)
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 3)
	GUICTRLCREATELABEL("PreCast (in Town)", 25, $XCOORD)
	GUICTRLCREATELABEL("Energy Shield, Cyclone Armor, Oak Sage etc", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	$HOTKEY0GUI = GUICTRLCREATECOMBO("", 320, $XCOORD, 40, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETDATA(-1, $SLIST, $HOTKEY0)
	$HOTKEY7GUI = GUICTRLCREATECOMBO("", 370, $XCOORD, 40, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETDATA(-1, $SLIST, $HOTKEY7)
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 4)
	GUICTRLCREATELABEL("PreCast (After BO)", 25, $XCOORD)
	GUICTRLCREATELABEL("Holy Shield, Ennergy Shield, Frozen Armor etc", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	$HOTKEY4GUI = GUICTRLCREATECOMBO("", 370, $XCOORD, 40, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETDATA(-1, $SLIST, $HOTKEY4)
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 5)
	GUICTRLCREATELABEL("CTA - Battle Command", 25, $XCOORD)
	GUICTRLCREATELABEL("If you have CTA, set the key for BC", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	$HOTKEY5GUI = GUICTRLCREATECOMBO("", 370, $XCOORD, 40, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETDATA(-1, $SLIST, $HOTKEY5)
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 6)
	GUICTRLCREATELABEL("CTA - Battle Ordens", 25, $XCOORD)
	GUICTRLCREATELABEL("If you have CTA, set the key for BO", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	$HOTKEY6GUI = GUICTRLCREATECOMBO("", 370, $XCOORD, 40, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETDATA(-1, $SLIST, $HOTKEY6)
#EndRegion TAB 5
#Region TAB 2
	GUICTRLCREATETABITEM("Time")
	$XCOORD = $XCOORD1
	GUICTRLCREATELABEL("Time Before Creating (seconds)", 25, $XCOORD)
	GUICTRLCREATELABEL("It'll wait before creating a game.", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	$TPARACRIAR1 = GUICTRLCREATEINPUT($TEMPOPARACRIAR1, 310, $XCOORD, 40, 20)
	GUICTRLCREATEUPDOWN(-1)
	GUICTRLSETLIMIT(-1, 999, 0)
	GUICTRLCREATELABEL("to", 355, $XCOORD + 2)
	$TPARACRIAR2 = GUICTRLCREATEINPUT($TEMPOPARACRIAR2, 370, $XCOORD, 40, 20)
	GUICTRLCREATEUPDOWN(-1)
	GUICTRLSETLIMIT(-1, 999, 0)
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50)
	GUICTRLCREATELABEL("Time After Created (seconds)", 25, $XCOORD)
	GUICTRLCREATELABEL("It'll wait just after creating a game.", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	$TEXTRA1 = GUICTRLCREATEINPUT($TEMPOEXTRA1, 310, $XCOORD, 40, 20)
	GUICTRLCREATEUPDOWN(-1)
	GUICTRLSETLIMIT(-1, 999, 0)
	GUICTRLCREATELABEL("to", 355, $XCOORD + 2)
	$TEXTRA2 = GUICTRLCREATEINPUT($TEMPOEXTRA2, 370, $XCOORD, 40, 20)
	GUICTRLCREATEUPDOWN(-1)
	GUICTRLSETLIMIT(-1, 999, 0)
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 2)
	$SLIST = "12 AM"
	FOR $I = 1 TO 11
		$SLIST &= "|" & $I & " AM"
	NEXT
	$SLIST &= "|" & "12 PM"
	FOR $I = 1 TO 11
		$SLIST &= "|" & $I & " PM"
	NEXT
	$SLIST &= "|" & "-"
	GUICTRLCREATELABEL("Run Hours:", 25, $XCOORD)
	GUICTRLCREATELABEL("Highly recommended setting a time to AVOID BAN.", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	$HINICIO = GUICTRLCREATECOMBO("", 270, $XCOORD, 60, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETTIP(-1, "Start at")
	GUICTRLSETDATA(-1, $SLIST, $HORAINICIO)
	GUICTRLCREATELABEL("to", 335, $XCOORD + 2)
	$HFIM = GUICTRLCREATECOMBO("", 350, $XCOORD, 60, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETTIP(-1, "Stop at")
	GUICTRLSETDATA(-1, $SLIST, $HORAFIM)
	$XCOORD = $XCOORD1 + (50 * 3)
	$HINICIO2 = GUICTRLCREATECOMBO("", 270, $XCOORD - (20 * 1), 60, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETTIP(-1, "Start at")
	GUICTRLSETDATA(-1, $SLIST, $HORAINICIO2)
	GUICTRLCREATELABEL("to", 335, $XCOORD + 2 - (20 * 1))
	$HFIM2 = GUICTRLCREATECOMBO("", 350, $XCOORD - (20 * 1), 60, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETTIP(-1, "Stop at")
	GUICTRLSETDATA(-1, $SLIST, $HORAFIM2)
	$XCOORD = $XCOORD1 + (50 * 4)
	$HINICIO3 = GUICTRLCREATECOMBO("", 270, $XCOORD - (20 * 2), 60, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETTIP(-1, "Start at")
	GUICTRLSETDATA(-1, $SLIST, $HORAINICIO3)
	GUICTRLCREATELABEL("to", 335, $XCOORD + 2 - (20 * 2))
	$HFIM3 = GUICTRLCREATECOMBO("", 350, $XCOORD - (20 * 2), 60, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETTIP(-1, "Stop at")
	GUICTRLSETDATA(-1, $SLIST, $HORAFIM3)
	GUICTRLCREATELABEL("", 25, $XCOORD + 25 - (20 * 2), 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 5)
	GUICTRLCREATELABEL("(Premium)", 25, $XCOORD + 1 - (20 * 3))
	GUICTRLSETCOLOR(-1, 16744448)
	GUICTRLSETFONT(-1, 7, 100)
	$HINICIO4 = GUICTRLCREATECOMBO("", 270, $XCOORD - (20 * 3), 60, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETTIP(-1, "Start at")
	GUICTRLSETDATA(-1, $SLIST, $HORAINICIO4)
	GUICTRLCREATELABEL("to", 335, $XCOORD + 2 - (20 * 3))
	$HFIM4 = GUICTRLCREATECOMBO("", 350, $XCOORD - (20 * 3), 60, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETTIP(-1, "Stop at")
	GUICTRLSETDATA(-1, $SLIST, $HORAFIM4)
	$XCOORD = $XCOORD1 + (50 * 6)
	$HINICIO5 = GUICTRLCREATECOMBO("", 270, $XCOORD - (20 * 4), 60, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETTIP(-1, "Start at")
	GUICTRLSETDATA(-1, $SLIST, $HORAINICIO5)
	GUICTRLCREATELABEL("to", 335, $XCOORD + 2 - (20 * 4))
	$HFIM5 = GUICTRLCREATECOMBO("", 350, $XCOORD - (20 * 4), 60, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETTIP(-1, "Stop at")
	GUICTRLSETDATA(-1, $SLIST, $HORAFIM5)
	$XCOORD = $XCOORD1 + (50 * 7)
	$HINICIO6 = GUICTRLCREATECOMBO("", 270, $XCOORD - (20 * 5), 60, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETTIP(-1, "Start at")
	GUICTRLSETDATA(-1, $SLIST, $HORAINICIO6)
	GUICTRLCREATELABEL("to", 335, $XCOORD + 2 - (20 * 5))
	$HFIM6 = GUICTRLCREATECOMBO("", 350, $XCOORD - (20 * 5), 60, 20, BITOR($GUI_SS_DEFAULT_COMBO, $CBS_DROPDOWNLIST))
	GUICTRLSETTIP(-1, "Stop at")
	GUICTRLSETDATA(-1, $SLIST, $HORAFIM6)
#EndRegion TAB 2
#Region TAB 3
	GUICTRLCREATETABITEM("Bosses")
	$XCOORD = $XCOORD1
	GUICTRLCREATELABEL("Pindle", 25, $XCOORD)
	GUICTRLCREATELABEL("Kill Pindle", 25, 13 + $XCOORD, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$PINDLESIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$PINDLENAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($MATARPINDLE = 1) THEN
		GUICTRLSETSTATE($PINDLESIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($PINDLENAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + 50
	$STEXT = "Eldritch"
	$ASIZE = _STRINGSIZE($STEXT)
	GUICTRLCREATELABEL($ASIZE[0], 25, $XCOORD, $ASIZE[2], $ASIZE[3])
	GUICTRLCREATELABEL("(Add for 20$)", 25 + $ASIZE[2], $XCOORD + 1)
	GUICTRLSETCOLOR(-1, 10494192)
	GUICTRLSETFONT(-1, 7, 100)
	GUICTRLCREATELABEL("(Premium)", 25 + $ASIZE[2] + 60, $XCOORD + 1)
	GUICTRLSETCOLOR(-1, 16744448)
	GUICTRLSETFONT(-1, 7, 100)
	GUICTRLCREATELABEL("Kill Eldritch", 25, 13 + $XCOORD, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$ELDRITCHSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$ELDRITCHNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($MATARELDRITCH = 1) THEN
		GUICTRLSETSTATE($ELDRITCHSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($ELDRITCHNAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 2)
	$STEXT = "Shenk"
	$ASIZE = _STRINGSIZE($STEXT)
	GUICTRLCREATELABEL($ASIZE[0], 25, $XCOORD, $ASIZE[2], $ASIZE[3])
	GUICTRLCREATELABEL("(Premium)", 25 + $ASIZE[2], $XCOORD + 1)
	GUICTRLSETCOLOR(-1, 16744448)
	GUICTRLSETFONT(-1, 7, 100)
	GUICTRLCREATELABEL("Kill Shenk", 25, 13 + $XCOORD, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$SHENKSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$SHENKNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($MATARSHENK = 1) THEN
		GUICTRLSETSTATE($SHENKSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($SHENKNAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 3)
	$STEXT = "Travincal"
	$ASIZE = _STRINGSIZE($STEXT)
	GUICTRLCREATELABEL($ASIZE[0], 25, $XCOORD, $ASIZE[2], $ASIZE[3])
	GUICTRLCREATELABEL("(Premium)", 25 + $ASIZE[2], $XCOORD + 1)
	GUICTRLSETCOLOR(-1, 16744448)
	GUICTRLSETFONT(-1, 7, 100)
	GUICTRLCREATELABEL("Kill Councils", 25, 13 + $XCOORD, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$TRAVSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$TRAVNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($MATARTRAVINCAL = 1) THEN
		GUICTRLSETSTATE($TRAVSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($TRAVNAO, $GUI_CHECKED)
	ENDIF
#EndRegion TAB 3
#Region TAB 5
	GUICTRLCREATETABITEM("Items")
	$XCOORD = $XCOORD1
	GUICTRLCREATELABEL("Uniques", 25, $XCOORD)
	GUICTRLSETCOLOR(-1, 9472071)
	GUICTRLCREATELABEL("It will pick up all uniques", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$UNIQUESSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$UNIQUESNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($UNIQUES = 1) THEN
		GUICTRLSETSTATE($UNIQUESSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($UNIQUESNAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 1)
	GUICTRLCREATELABEL("Sets", 25, $XCOORD)
	GUICTRLSETCOLOR(-1, 65280)
	GUICTRLCREATELABEL("Tal Amor, Ik Armor and Sets Ammy", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$SETSSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$SETSNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($SETS = 1) THEN
		GUICTRLSETSTATE($SETSSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($SETSNAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 2)
	GUICTRLCREATELABEL("Rares", 25, $XCOORD)
	GUICTRLSETCOLOR(-1, 15848960)
	GUICTRLCREATELABEL("Rings, Ammys, Jewel, Coronet, Circlet, Diadem, Tiara", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$RARESSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$RARESNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($RARES = 1) THEN
		GUICTRLSETSTATE($RARESSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($RARESNAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 3)
	GUICTRLCREATELABEL("Magics", 25, $XCOORD)
	GUICTRLSETCOLOR(-1, 2182122)
	GUICTRLCREATELABEL("Gc, Lc, Sc, Jewel", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$MAGICSSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$MAGICSNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($MAGICS = 1) THEN
		GUICTRLSETSTATE($MAGICSSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($MAGICSNAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 4)
	GUICTRLCREATELABEL("Runes", 25, $XCOORD)
	GUICTRLSETCOLOR(-1, 16749824)
	GUICTRLCREATELABEL("It will pick up all runes", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$RUNESSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$RUNESNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($RUNES = 1) THEN
		GUICTRLSETSTATE($RUNESSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($RUNESNAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 5)
	$STEXT = "Open Pickit File"
	$ASIZE = _STRINGSIZE($STEXT)
	GUICTRLCREATELABEL($ASIZE[0], 25, $XCOORD, $ASIZE[2] + 100, $ASIZE[3])
	GUICTRLCREATELABEL("(Premium)", 25 + $ASIZE[2] + 10, $XCOORD + 1)
	GUICTRLSETCOLOR(-1, 16744448)
	GUICTRLSETFONT(-1, 7, 100)
	GUICTRLCREATELABEL("Choose what to pick up", 25, 13 + $XCOORD, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	$PICKITGUI = GUICTRLCREATEBUTTON("&Open", 310, $XCOORD, 100, 25)
	GUICTRLSETONEVENT(-1, "_onClick")
#EndRegion TAB 5
#Region TAB 4
	GUICTRLCREATETABITEM("Safe config")
	$XCOORD = $XCOORD1
	$STEXT = '"Human" Mouse Click and Moviments'
	$ASIZE = _STRINGSIZE($STEXT)
	GUICTRLCREATELABEL($ASIZE[0], 25, $XCOORD, $ASIZE[2], $ASIZE[3])
	GUICTRLCREATELABEL("(Premium)", 25 + $ASIZE[2], $XCOORD + 1)
	GUICTRLSETCOLOR(-1, 16744448)
	GUICTRLSETFONT(-1, 7, 100)
	GUICTRLCREATELABEL("It will simulates moviments and click like a HUMAN", 25, 13 + $XCOORD, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$RANDMOUSESIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$RANDMOUSENAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($RANDOMMOUSEMOVE = 1) THEN
		GUICTRLSETSTATE($RANDMOUSESIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($RANDMOUSENAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 1)
	$STEXT = "Randomly Pindle Path and Coords"
	$ASIZE = _STRINGSIZE($STEXT)
	GUICTRLCREATELABEL($ASIZE[0], 25, $XCOORD, $ASIZE[2], $ASIZE[3])
	GUICTRLCREATELABEL("(Premium)", 25 + $ASIZE[2], $XCOORD + 1)
	GUICTRLSETCOLOR(-1, 16744448)
	GUICTRLSETFONT(-1, 7, 100)
	GUICTRLCREATELABEL("Go to the Pindle in a different path sometimes", 25, 13 + $XCOORD, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$PINDLEPATHSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$PINDLEPATHNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($PINDLEPATH = 1) THEN
		GUICTRLSETSTATE($PINDLEPATHSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($PINDLEPATHNAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 2)
	$STEXT = "Randomly change Acts"
	$ASIZE = _STRINGSIZE($STEXT)
	GUICTRLCREATELABEL($ASIZE[0], 25, $XCOORD, $ASIZE[2], $ASIZE[3])
	GUICTRLCREATELABEL("(Premium)", 25 + $ASIZE[2], $XCOORD + 1)
	GUICTRLSETCOLOR(-1, 16744448)
	GUICTRLSETFONT(-1, 7, 100)
	GUICTRLCREATELABEL("It will change acts 1 to 5 randomly then it will keep botting", 25, 13 + $XCOORD, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$CHANGEACTSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$CHANGEACTNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($CHANGEACT = 1) THEN
		GUICTRLSETSTATE($CHANGEACTSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($CHANGEACTNAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 3)
	$STEXT = "Randomly pause between some moviments"
	$ASIZE = _STRINGSIZE($STEXT)
	GUICTRLCREATELABEL($ASIZE[0], 25, $XCOORD, $ASIZE[2], $ASIZE[3])
	GUICTRLCREATELABEL("(Premium)", 25 + $ASIZE[2], $XCOORD + 1)
	GUICTRLSETCOLOR(-1, 16744448)
	GUICTRLSETFONT(-1, 7, 100)
	GUICTRLCREATELABEL("When in town (not attacking), it will pause randomly", 25, 13 + $XCOORD, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$PAUSESIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$PAUSENAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($RANDOMPAUSE = 1) THEN
		GUICTRLSETSTATE($PAUSESIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($PAUSENAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 4)
	$STEXT = "Randomly use chat"
	$ASIZE = _STRINGSIZE($STEXT)
	GUICTRLCREATELABEL($ASIZE[0], 25, $XCOORD, $ASIZE[2], $ASIZE[3])
	GUICTRLCREATELABEL("(Premium)", 25 + $ASIZE[2], $XCOORD + 1)
	GUICTRLSETCOLOR(-1, 16744448)
	GUICTRLSETFONT(-1, 7, 100)
	GUICTRLCREATELABEL("It will type some phrases randomly", 25, 13 + $XCOORD, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$USECHATSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$USECHATNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($RANDOMUSECHAT = 1) THEN
		GUICTRLSETSTATE($USECHATSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($USECHATNAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + (50 * 5)
	$STEXT = "Randomly use Lobby to Create Game"
	$ASIZE = _STRINGSIZE($STEXT)
	GUICTRLCREATELABEL($ASIZE[0], 25, $XCOORD, $ASIZE[2], $ASIZE[3])
	GUICTRLCREATELABEL("(Premium)", 25 + $ASIZE[2], $XCOORD + 1)
	GUICTRLSETCOLOR(-1, 16744448)
	GUICTRLSETFONT(-1, 7, 100)
	GUICTRLCREATELABEL("Randomly create through Lobby", 25, 13 + $XCOORD, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$GAMEPASSSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$GAMEPASSNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($RANDOMGAMEPASS = 1) THEN
		GUICTRLSETSTATE($GAMEPASSSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($GAMEPASSNAO, $GUI_CHECKED)
	ENDIF
#EndRegion TAB 4
#Region TAB 5
	GUICTRLCREATETABITEM("Online Service")
	$XCOORD = $XCOORD1
	$STEXT = "APP Access"
	$ASIZE = _STRINGSIZE($STEXT)
	GUICTRLCREATELABEL($ASIZE[0], 25, $XCOORD, $ASIZE[2] + 100, $ASIZE[3])
	GUICTRLCREATELABEL("(Premium)", 25 + $ASIZE[2] + 10, $XCOORD + 1)
	GUICTRLSETCOLOR(-1, 16744448)
	GUICTRLSETFONT(-1, 7, 100)
	GUICTRLCREATELABEL("See Status, Pause/Unpause, Stop through your MOBILE", 25, 13 + $XCOORD, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$APPSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$APPNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($APPSTATS = 1) THEN
		GUICTRLSETSTATE($APPSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($APPNAO, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + 50
	$STEXT = "STOP when server DOWN"
	$ASIZE = _STRINGSIZE($STEXT)
	GUICTRLCREATELABEL($ASIZE[0], 25, $XCOORD, $ASIZE[2], $ASIZE[3])
	GUICTRLCREATELABEL("(Premium)", 25 + $ASIZE[2], $XCOORD + 1)
	GUICTRLSETCOLOR(-1, 16744448)
	GUICTRLSETFONT(-1, 7, 100)
	GUICTRLCREATELABEL("Turn the bot off automatically when SERVERS down", 25, 13 + $XCOORD, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$SVDOWNSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$SVDOWNNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($STOPSERVERDOWN = 1) THEN
		GUICTRLSETSTATE($SVDOWNSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($SVDOWNNAO, $GUI_CHECKED)
	ENDIF
#EndRegion TAB 5
#Region TAB 6
	GUICTRLCREATETABITEM("Extra")
	$XCOORD = $XCOORD1
	GUICTRLCREATELABEL("Visual mode", 25, $XCOORD)
	GUICTRLCREATELABEL("Turn ON or OFF the visual mode in game", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$VISUAL3 = GUICTRLCREATERADIO("New", 255, $XCOORD)
	$VISUAL2 = GUICTRLCREATERADIO("Legacy", 305, $XCOORD)
	$VISUAL1 = GUICTRLCREATERADIO("None", 365, $XCOORD)
	IF($VISUAL = 2) THEN
		GUICTRLSETSTATE($VISUAL3, $GUI_CHECKED)
	ELSEIF($VISUAL = 1) THEN
		GUICTRLSETSTATE($VISUAL2, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($VISUAL1, $GUI_CHECKED)
	ENDIF
	GUICTRLCREATELABEL("", 25, $XCOORD + 35, 390, 1)
	GUICTRLSETBKCOLOR(-1, 14474460)
	GUICTRLSETSTATE(-1, $GUI_DISABLE)
	$XCOORD = $XCOORD1 + 50
	GUICTRLCREATELABEL("Slow PC?", 25, $XCOORD)
	GUICTRLCREATELABEL("If you are running on a low budget PC, select Yes.", 25, $XCOORD + 13, -1, 13)
	GUICTRLSETFONT(-1, 8, 100)
	GUICTRLSETCOLOR(-1, 10526880)
	GUISTARTGROUP()
	$PCDEVAGARSIM = GUICTRLCREATERADIO("Yes", 340, $XCOORD)
	$PCDEVAGARNAO = GUICTRLCREATERADIO("No", 380, $XCOORD)
	IF($PCDEVAGAR = 1) THEN
		GUICTRLSETSTATE($PCDEVAGARSIM, $GUI_CHECKED)
	ELSE
		GUICTRLSETSTATE($PCDEVAGARNAO, $GUI_CHECKED)
	ENDIF
#EndRegion TAB 6
GUICTRLCREATETABITEM("")
$RODARGUI = GUICTRLCREATEBUTTON("&Start", 25, $WINSIZE[3] - 115, 390, 40)
GUICTRLSETTIP(-1, "Start")
GUICTRLSETONEVENT(-1, "_onClick")
$PARARGUI = GUICTRLCREATEBUTTON("&Stop", 25, $WINSIZE[3] - 115, 390, 40)
GUICTRLSETTIP(-1, "Stop")
GUICTRLSETONEVENT(-1, "_onClick")
GUICTRLSETSTATE(-1, 32)
LOCAL $LABEL = GUICTRLCREATELABEL(" 2021 - All Rights Reserved - by pdb2.0@outlook.com - v" & $VERSAO, 0, $WINSIZE[3] - 50, 440, 10, 1)
GUICTRLSETFONT(-1, 7, 100)
GUICTRLSETCOLOR(-1, 255)
GUICTRLSETCURSOR(-1, 0)
GUICTRLSETONEVENT(-1, "_onClick")
GUICTRLSETSTATE(-1, $GUI_FOCUS)
BLOQUEARGUI(0)
GUISETSTATE(@SW_SHOW, $WINDOW1)
GUIREGISTERMSG($WM_COMMAND, "_WM_COMMAND")
FUNC _WM_COMMAND($HWND, $MSG, $WPARAM, $LPARAM)
	IF BITAND($WPARAM, 65535) = $PARARGUI THEN $FINTERRUPT = 1
	IF BITAND($WPARAM, 65535) = $RODARGUI THEN $FINTERRUPT = 2
	IF BITAND($WPARAM, 65535) = $LABEL THEN $FINTERRUPT = 1
	IF BITAND($WPARAM, 65535) = $PICKITGUI THEN $FINTERRUPT = 1
	IF BITAND($WPARAM, 65535) = $ATUALIZARGUI THEN $FINTERRUPT = 1
	IF BITAND($WPARAM, 65535) = $SERIALGUI THEN $FINTERRUPT = 1
	IF BITAND($WPARAM, 65535) = $SEARCHGAMEGUI THEN $FINTERRUPT = 1
	IF BITAND($WPARAM, 65535) = $IDABOUTITEM THEN $FINTERRUPT = 1
	IF BITAND($WPARAM, 65535) = $GUI_EVENT_CLOSE THEN $FINTERRUPT = 1
	IF BITAND($WPARAM, 65535) = $GUI_EVENT_MINIMIZE THEN $FINTERRUPT = 1
	RETURN $GUI_RUNDEFMSG
ENDFUNC
$WINDOW2 = GUICREATE($FILENAME, 620, 44, -1, 0, $WS_POPUP, $WS_EX_TOPMOST, WINGETHANDLE("Program Manager"))
GUISETBKCOLOR(13410128)
GUICTRLCREATEPIC($PASTATEMP & "status.jpg", 0, -1, 620, 45)
GUICTRLSETSTATE(-1, $GUI_DISABLE)
$STATUSPRINCIPAL2 = GUICTRLCREATELABEL("Running time:", 470, 7, -1, -1, 0)
GUICTRLSETBKCOLOR(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICTRLSETFONT(-1, 7, 700)
$STATUSPRINCIPAL3 = GUICTRLCREATELABEL("Runs:", 150, 24, -1, -1, 0)
GUICTRLSETBKCOLOR(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICTRLSETFONT(-1, 7.5, 700)
$STATUSPRINCIPAL4 = GUICTRLCREATELABEL("Deaths:", 225, 24, -1, -1, 0)
GUICTRLSETBKCOLOR(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICTRLSETFONT(-1, 7.5, 700)
$STATUSPRINCIPAL5 = GUICTRLCREATELABEL("Merc Deaths:", 298, 24, -1, -1, 0)
GUICTRLSETBKCOLOR(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICTRLSETFONT(-1, 7.5, 700)
$STATUSPRINCIPAL6 = GUICTRLCREATELABEL("Chicken:", 396, 24, -1, -1, 0)
GUICTRLSETBKCOLOR(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICTRLSETFONT(-1, 7.5, 700)
$STATUSPRINCIPAL7 = GUICTRLCREATELABEL("Items:", 470, 24, -1, -1, 0)
GUICTRLSETBKCOLOR(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICTRLSETFONT(-1, 7.5, 700)
$STATUSATT1 = GUICTRLCREATELABEL("Status", 150, 6, 310, 12, 1)
GUICTRLSETBKCOLOR(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICTRLSETFONT(-1, 7.5, 700)
$STATUSATT2 = GUICTRLCREATELABEL("0s", 537, 7, 70, -1, 0)
GUICTRLSETBKCOLOR(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICTRLSETFONT(-1, 7, 400)
$STATUSATT3 = GUICTRLCREATELABEL("0", 180, 24, 40, -1, 0)
GUICTRLSETBKCOLOR(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICTRLSETFONT(-1, 7.5, 400)
$STATUSATT4 = GUICTRLCREATELABEL("0", 263, 24, 40, -1, 0)
GUICTRLSETBKCOLOR(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICTRLSETFONT(-1, 7.5, 400)
$STATUSATT5 = GUICTRLCREATELABEL("0", 364, 24, 40, -1, 0)
GUICTRLSETBKCOLOR(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICTRLSETFONT(-1, 7.5, 400)
$STATUSATT6 = GUICTRLCREATELABEL("0", 440, 24, 40, -1, 0)
GUICTRLSETBKCOLOR(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICTRLSETFONT(-1, 7.5, 400)
$STATUSATT7 = GUICTRLCREATELABEL("0", 501, 24, 40, -1, 0)
GUICTRLSETBKCOLOR(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICTRLSETFONT(-1, 7.5, 400)
$STATUSATT8 = GUICTRLCREATELABEL("", 544, 25, 60, 12, 1)
GUICTRLSETBKCOLOR(-1, $GUI_BKCOLOR_TRANSPARENT)
GUICTRLSETFONT(-1, 7, 700)
GUISETSTATE(@SW_DISABLE, $WINDOW2)
IF($SERIAL <> "") THEN
	IF($SERIALSPLIT = "2804") THEN
		IF(CHECARORIGINALIDADE(0) = 7) THEN
			BLOQUEARGUI(1)
		ENDIF
	ELSEIF($SERIALSPLIT = "1609") THEN
		IF(CHECARORIGINALIDADE(0) = 7) THEN
			BLOQUEARGUI(4)
		ENDIF
	ELSEIF($SERIALSPLIT = "0707") THEN
		IF(CHECARORIGINALIDADE(0) = 7) THEN
			BLOQUEARGUI(2)
		ENDIF
	ELSE
		MSGBOX(64, $FILENAME, "Wrong serial")
		BLOQUEARGUI(0)
	ENDIF
ENDIF
FUNC _ONCLICK()
	READGUICTRL()
	$MSG = @GUI_CTRLID
	SELECT
		CASE $MSG = $SEARCHGAMEGUI
			LOCAL $SFILEOPENDIALOG = FILEOPENDIALOG("Search for D2R.EXE", $DEFAULTD2RFOLDER & "\", "Exe (D2R.exe)", $FD_FILEMUSTEXIST)
			IF @ERROR THEN
				FILECHANGEDIR(@SCRIPTDIR)
			ELSE
				FILECHANGEDIR(@SCRIPTDIR)
				$SFILEOPENDIALOG = STRINGREPLACE($SFILEOPENDIALOG, "|", @CRLF)
				GUICTRLSETDATA($EXECUTAVELGUI, $SFILEOPENDIALOG)
			ENDIF
		CASE $MSG = $IDABOUTITEM
			MSGBOX(64, $FILENAME, " 2021 - All Rights Reserved - by pdb2.0@outlook.com - v" & $VERSAO)
		CASE $MSG = $GUI_EVENT_MINIMIZE
			_GUI_TOTRAY()
		CASE $MSG = $LABEL
			SHELLEXECUTE("mailto:pdb2.0@outlook.com")
		CASE $MSG = $GUI_EVENT_CLOSE
			LOCAL $IMSGBOXANSWER = MSGBOX(35, $FILENAME, "Save settings before exit?")
			SELECT
				CASE $IMSGBOXANSWER = 6
					ATUALIZARINI(1)
					SAIR()
				CASE $IMSGBOXANSWER = 7
					SAIR()
			ENDSELECT
		CASE $MSG = $SERIALGUI
			BLOQUEARGUI(0)
			IF($SERIAL <> "") THEN
				IF($SERIALSPLIT = "2804") THEN
					IF(CHECARORIGINALIDADE(0) = 7) THEN
						BLOQUEARGUI(1)
					ENDIF
				ELSEIF($SERIALSPLIT = "1609") THEN
					IF(CHECARORIGINALIDADE(0) = 7) THEN
						BLOQUEARGUI(4)
					ENDIF
				ELSEIF($SERIALSPLIT = "0707") THEN
					IF(CHECARORIGINALIDADE(0) = 7) THEN
						BLOQUEARGUI(2)
					ENDIF
				ELSE
					MSGBOX(64, $FILENAME, "Wrong serial")
					BLOQUEARGUI(0)
				ENDIF
			ENDIF
		CASE $MSG = $ATUALIZARGUI
			IF($SERIALSPLIT = "2804") OR($SERIALSPLIT = "0707") OR($SERIALSPLIT = "1609") THEN
				GUICTRLSETSTATE($ATUALIZARGUI, 128)
				GUICTRLSETDATA($ATUALIZARGUI, "Checking...")
				DOUPDATE(1)
				GUICTRLSETSTATE($ATUALIZARGUI, 64)
				GUICTRLSETDATA($ATUALIZARGUI, "Check for Update")
			ELSE
				MSGBOX(64, $FILENAME, "To check for updates, please first TYPE your serial")
			ENDIF
		CASE $MSG = $PICKITGUI
			SHELLEXECUTE(@SCRIPTDIR & "\pickit\items.ini")
		CASE $MSG = $RODARGUI
			IF($SERIALSPLIT = "2804") OR($SERIALSPLIT = "0707") OR($SERIALSPLIT = "1609") THEN
				IF NOT FILEEXISTS($EXECUTAVEL) THEN
					MSGBOX(48, $FILENAME, $EXECUTAVEL & @CRLF & @CRLF & "Not Found")
				ELSEIF($TEMPOPARACRIAR2 < $TEMPOPARACRIAR1) THEN
					MSGBOX(48, $FILENAME, 'Wrong number in "Extra Time Before Creating a Game".' & @CRLF & @CRLF & "The first number needs to be lower than the second one.")
				ELSEIF($TEMPOEXTRA2 < $TEMPOEXTRA1) THEN
					MSGBOX(48, $FILENAME, 'Wrong number in "Extra Time per Run".' & @CRLF & @CRLF & "The first number needs to be lower than the second one.")
				ELSEIF($DIFFICULT <> "Hell" AND $DIFFICULT <> "Nightmare" AND $DIFFICULT <> "Normal" AND $DIFFICULT <> "Offline") THEN
					MSGBOX(48, $FILENAME, "You have set a WRONG difficult. (" & $DIFFICULT & ")")
				ELSEIF($ERRORSCHEDULE > 0) THEN
					IF($ERRORSCHEDULE = 1) THEN
						MSGBOX(48, $FILENAME, "You have set a WRONG schedule")
					ELSE
						MSGBOX(64, $FILENAME, "You have to set at least one schedule to run the bot")
					ENDIF
				ELSE
					BLOQUEARGUI(0)
					ATUALIZARINI(1)
					DOUPDATE(0)
					IF($FIRSTTIMERUNNING) THEN
						$MSG2 = MSGBOX(BITOR(4, 32), $FILENAME, "First time running the bot?")
						IF $MSG2 = 6 THEN
							WINCLOSE("Diablo II: Resurrected")
							SLEEP2(1000)
						ELSE
							$FIRSTTIMERUNNING = 0
						ENDIF
					ENDIF
					LOCAL $ARQUIVOJSON = PROCURARD2SETTING()
					IF($ARQUIVOJSON) THEN
						$ISTATUS = FILECOPY($PASTATEMP & "Settings.json", $ARQUIVOJSON, 1)
						IF $ISTATUS = 0 THEN
							LOGREG("Error changing SETTINGS on D2R")
						ELSE
							LOGREG("OK changing SETTINGS on D2R")
							$FIRSTTIMERUNNING = 0
						ENDIF
					ENDIF
					HOTKEYSET("e", "PARAR")
					HOTKEYSET("!e", "PARAR")
					HOTKEYSET("+e", "PARAR")
					HOTKEYSET("p", "PAUSA")
					HOTKEYSET("!p", "PAUSA")
					HOTKEYSET("+p", "PAUSA")
					HOTKEYSET("v", "VISUAL")
					HOTKEYSET("!v", "VISUAL")
					HOTKEYSET("+v", "VISUAL")
					IF($PAROU) THEN
						$VEIOAPOSPARAR = 1
						$PAROU = 0
						LOGREG("Started " & $FILENAME)
						_GUI_TOTRAY()
						$RUNNINGTIME = TIMERINIT()
						IF($VISUAL = 2) THEN
							GUISETSTATE(@SW_SHOW, $WINDOW2)
						ENDIF
						$TOOLTIP = "Starting"
						IF WINEXISTS("Diablo II: Resurrected") THEN
							WINACTIVATE("Diablo II: Resurrected")
							SLEEP2(500)
							$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\ingame.png", 1, 319, 986, 359, 1016, $X, $Y, 70)
							IF $RESULT > 0 THEN
								QUITAR()
							ENDIF
							$SAIU = 1
							SLEEP2(1000)
						ENDIF
						IF NOT($REGISTROUADLIB) THEN
							$REGISTROUADLIB = 1
							ADLIBREGISTER("VerificarCrash")
							ADLIBREGISTER("VerificarInternet", 1000)
						ENDIF
					ENDIF
					BLOQUEARGUI(3)
					$FINTERRUPT = 0
					$CLICOUSTART = 1
				ENDIF
			ELSE
				MSGBOX(64, $FILENAME, "Wrong serial")
			ENDIF
		CASE $MSG = $PARARGUI
			PARAR()
	ENDSELECT
ENDFUNC
FUNC PROCURARD2SETTING()
	$AARRAY = _FILELISTTOARRAYREC(@USERPROFILEDIR, "*Settings.json||AppData", $FLTAR_FILES, $FLTAR_RECUR, $FLTAR_SORT, $FLTAR_FULLPATH)
	IF @ERROR THEN
		LOGREG("No D2R settings file found. 1")
		RETURN 0
	ELSE
		LOCAL $ACHOUSETTINGS = 0
		FOR $I = 0 TO UBOUND($AARRAY) - 1
			IF STRINGINSTR($AARRAY[$I], "Diablo") THEN
				$ACHOUSETTINGS = 1
				EXITLOOP
			ENDIF
		NEXT
		IF($ACHOUSETTINGS) THEN
			RETURN $AARRAY[$I]
		ELSE
			LOGREG("No D2R settings file found. 2")
			RETURN 0
		ENDIF
	ENDIF
ENDFUNC
FUNC BLOQUEARGUI($VARIAVEL)
	GUICTRLSETSTATE($RODARGUI, ($VARIAVEL = 3) ? 32 : 16)
	GUICTRLSETSTATE($RODARGUI, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	IF $VARIAVEL <> 3 THEN
		GUICTRLSETSTATE($PARARGUI, 32)
	ELSE
		GUICTRLSETSTATE($PARARGUI, ($VARIAVEL = 3) ? 16 : 32)
	ENDIF
	GUICTRLSETSTATE($SERIALGUI, ($VARIAVEL = 3) ? 128 : 64)
	GUICTRLSETSTATE($EXECUTAVELGUI, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($SEARCHGAMEGUI, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($DIFFICULTGUI, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($ATUALIZARGUI, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($HINICIO, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($HFIM, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($HINICIO2, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($HFIM2, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($HINICIO3, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($HFIM3, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($PARARSEMGOLDSIM, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($PARARSEMGOLDNAO, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($TELEPORTSIM, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($TELEPORTNAO, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($MERCENARYSIM, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($MERCENARYNAO, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($USARCTASIM, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($USARCTANAO, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($PCDEVAGARSIM, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($PCDEVAGARNAO, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($VISUAL3, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($VISUAL2, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($VISUAL1, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($PARARSTASHFULLSIM, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($PARARSTASHFULLNAO, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($TEXTRA1, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($TEXTRA2, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($TPARACRIAR1, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($TPARACRIAR2, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($PINDLESIM, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($PINDLENAO, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($HOTKEY0GUI, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($HOTKEY7GUI, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($HOTKEY1GUI, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($HOTKEY2GUI, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($HOTKEY3GUI, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($HOTKEY4GUI, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($HOTKEY5GUI, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($HOTKEY6GUI, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($UNIQUESSIM, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($UNIQUESNAO, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($SETSSIM, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($SETSNAO, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($RARESSIM, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($RARESNAO, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($MAGICSSIM, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($MAGICSNAO, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($RUNESSIM, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($RUNESNAO, ($VARIAVEL = 3 OR $VARIAVEL = 0) ? 128 : 64)
	GUICTRLSETSTATE($ELDRITCHSIM, ($VARIAVEL = 2 OR $VARIAVEL = 4) ? 64 : 128)
	GUICTRLSETSTATE($ELDRITCHNAO, ($VARIAVEL = 2 OR $VARIAVEL = 4) ? 64 : 128)
	GUICTRLSETSTATE($HINICIO4, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($HFIM4, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($HINICIO5, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($HFIM5, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($HINICIO6, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($HFIM6, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($SHENKSIM, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($SHENKNAO, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($TRAVSIM, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($TRAVNAO, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($PINDLEPATHSIM, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($PINDLEPATHNAO, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($CHANGEACTSIM, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($CHANGEACTNAO, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($PAUSESIM, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($PAUSENAO, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($CHICKENSIM, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($CHICKENNAO, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($USECHATSIM, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($USECHATNAO, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($SVDOWNSIM, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($SVDOWNNAO, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($GAMEPASSSIM, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($GAMEPASSNAO, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($RANDMOUSESIM, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($RANDMOUSENAO, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($APPSIM, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($APPNAO, ($VARIAVEL = 2) ? 64 : 128)
	GUICTRLSETSTATE($PICKITGUI, ($VARIAVEL = 2) ? 64 : 128)
ENDFUNC
FUNC READGUICTRL()
	$SERIAL = GUICTRLREAD($SERIALGUI)
	#$SERIALSPLIT = STRINGSPLIT($SERIAL, ":")[1]
	$EXECUTAVEL = GUICTRLREAD($EXECUTAVELGUI)
	$DIFFICULT = GUICTRLREAD($DIFFICULTGUI)
	$HOTKEY0 = (GUICTRLREAD($HOTKEY0GUI) <> "-" ? GUICTRLREAD($HOTKEY0GUI) : "-")
	$HOTKEY7 = (GUICTRLREAD($HOTKEY7GUI) <> "-" ? GUICTRLREAD($HOTKEY7GUI) : "-")
	$HOTKEY4 = (GUICTRLREAD($HOTKEY4GUI) <> "-" ? GUICTRLREAD($HOTKEY4GUI) : "-")
	$HOTKEY1 = (GUICTRLREAD($HOTKEY1GUI) <> "-" ? GUICTRLREAD($HOTKEY1GUI) : "SPACE")
	$HOTKEY2 = (GUICTRLREAD($HOTKEY2GUI) <> "-" ? GUICTRLREAD($HOTKEY2GUI) : "SPACE")
	$HOTKEY3 = (GUICTRLREAD($HOTKEY3GUI) <> "-" ? GUICTRLREAD($HOTKEY3GUI) : "SPACE")
	$HOTKEY5 = (GUICTRLREAD($HOTKEY5GUI) <> "-" ? GUICTRLREAD($HOTKEY5GUI) : "SPACE")
	$HOTKEY6 = (GUICTRLREAD($HOTKEY6GUI) <> "-" ? GUICTRLREAD($HOTKEY6GUI) : "SPACE")
	$HORAINICIO = GUICTRLREAD($HINICIO)
	$HORAFIM = GUICTRLREAD($HFIM)
	$HORAINICIO2 = GUICTRLREAD($HINICIO2)
	$HORAFIM2 = GUICTRLREAD($HFIM2)
	$HORAINICIO3 = GUICTRLREAD($HINICIO3)
	$HORAFIM3 = GUICTRLREAD($HFIM3)
	$HORAINICIO4 = GUICTRLREAD($HINICIO4)
	$HORAFIM4 = GUICTRLREAD($HFIM4)
	$HORAINICIO5 = GUICTRLREAD($HINICIO5)
	$HORAFIM5 = GUICTRLREAD($HFIM5)
	$HORAINICIO6 = GUICTRLREAD($HINICIO6)
	$HORAFIM6 = GUICTRLREAD($HFIM6)
	IF($SERIALSPLIT <> "0707") THEN
		$HORAINICIO4 = "-"
		$HORAINICIO5 = "-"
		$HORAINICIO6 = "-"
		$HORAFIM4 = "-"
		$HORAFIM5 = "-"
		$HORAFIM6 = "-"
	ENDIF
	IF($HORAINICIO <> "-" AND(STRINGINSTR($HORAINICIO, " AM") > 0 OR STRINGINSTR($HORAINICIO, " PM") > 0)) OR($HORAINICIO2 <> "-" AND(STRINGINSTR($HORAINICIO2, " AM") > 0 OR STRINGINSTR($HORAINICIO2, " PM") > 0)) OR($HORAINICIO3 <> "-" AND(STRINGINSTR($HORAINICIO3, " AM") > 0 OR STRINGINSTR($HORAINICIO3, " PM") > 0)) OR($HORAINICIO4 <> "-" AND(STRINGINSTR($HORAINICIO4, " AM") > 0 OR STRINGINSTR($HORAINICIO4, " PM") > 0)) OR($HORAINICIO5 <> "-" AND(STRINGINSTR($HORAINICIO5, " AM") > 0 OR STRINGINSTR($HORAINICIO5, " PM") > 0)) OR($HORAINICIO6 <> "-" AND(STRINGINSTR($HORAINICIO6, " AM") > 0 OR STRINGINSTR($HORAINICIO6, " PM") > 0)) OR($HORAFIM <> "-" AND(STRINGINSTR($HORAFIM, " AM") > 0 OR STRINGINSTR($HORAFIM, " PM") > 0)) OR($HORAFIM2 <> "-" AND(STRINGINSTR($HORAFIM2, " AM") > 0 OR STRINGINSTR($HORAFIM2, " PM") > 0)) OR($HORAFIM3 <> "-" AND(STRINGINSTR($HORAFIM3, " AM") > 0 OR STRINGINSTR($HORAFIM3, " PM") > 0)) OR($HORAFIM4 <> "-" AND(STRINGINSTR($HORAFIM4, " AM") > 0 OR STRINGINSTR($HORAFIM4, " PM") > 0)) OR($HORAFIM5 <> "-" AND(STRINGINSTR($HORAFIM5, " AM") > 0 OR STRINGINSTR($HORAFIM5, " PM") > 0)) OR($HORAFIM6 <> "-" AND(STRINGINSTR($HORAFIM6, " AM") > 0 OR STRINGINSTR($HORAFIM6, " PM") > 0)) THEN
		$ERRORSCHEDULE = 0
	ELSE
		$ERRORSCHEDULE = 1
	ENDIF
	IF($HORAINICIO = "-" AND $HORAINICIO2 = "-" AND $HORAINICIO3 = "-" AND $HORAINICIO4 = "-" AND $HORAINICIO5 = "-" AND $HORAINICIO6 = "-" AND $HORAFIM = "-" AND $HORAFIM2 = "-" AND $HORAFIM3 = "-" AND $HORAFIM4 = "-" AND $HORAFIM5 = "-" AND $HORAFIM6 = "-") THEN
		$ERRORSCHEDULE = 2
	ENDIF
	$TEMPOEXTRA1 = INT(GUICTRLREAD($TEXTRA1))
	$TEMPOEXTRA2 = INT(GUICTRLREAD($TEXTRA2))
	$TEMPOPARACRIAR1 = INT(GUICTRLREAD($TPARACRIAR1))
	$TEMPOPARACRIAR2 = INT(GUICTRLREAD($TPARACRIAR2))
	IF(BITAND(GUICTRLREAD($VISUAL3), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$VISUAL = 2
	ELSEIF(BITAND(GUICTRLREAD($VISUAL2), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$VISUAL = 1
	ELSE
		$VISUAL = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($PARARSEMGOLDSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$PARARSEMGOLD = 1
	ELSE
		$PARARSEMGOLD = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($MERCENARYSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$MERCENARY = 1
	ELSE
		$MERCENARY = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($TELEPORTSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$TELEPORT = 1
	ELSE
		$TELEPORT = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($USARCTASIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$USARCTA = 1
	ELSE
		$USARCTA = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($PCDEVAGARSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$PCDEVAGAR = 1
	ELSE
		$PCDEVAGAR = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($PARARSTASHFULLSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$PARARSTASHFULL = 1
	ELSE
		$PARARSTASHFULL = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($PINDLESIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$MATARPINDLE = 1
	ELSE
		$MATARPINDLE = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($ELDRITCHSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$MATARELDRITCH = 1
	ELSE
		$MATARELDRITCH = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($SHENKSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$MATARSHENK = 1
	ELSE
		$MATARSHENK = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($TRAVSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$MATARTRAVINCAL = 1
	ELSE
		$MATARTRAVINCAL = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($PINDLEPATHSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$PINDLEPATH = 1
	ELSE
		$PINDLEPATH = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($CHANGEACTSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$CHANGEACT = 1
	ELSE
		$CHANGEACT = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($PAUSESIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$RANDOMPAUSE = 1
	ELSE
		$RANDOMPAUSE = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($CHICKENSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$CHICKEN = 1
	ELSE
		$CHICKEN = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($USECHATSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$RANDOMUSECHAT = 1
	ELSE
		$RANDOMUSECHAT = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($SVDOWNSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$STOPSERVERDOWN = 1
	ELSE
		$STOPSERVERDOWN = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($GAMEPASSSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$RANDOMGAMEPASS = 1
	ELSE
		$RANDOMGAMEPASS = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($RANDMOUSESIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$RANDOMMOUSEMOVE = 1
	ELSE
		$RANDOMMOUSEMOVE = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($APPSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$APPSTATS = 1
	ELSE
		$APPSTATS = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($UNIQUESSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$UNIQUES = 1
	ELSE
		$UNIQUES = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($SETSSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$SETS = 1
	ELSE
		$SETS = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($RARESSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$RARES = 1
	ELSE
		$RARES = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($MAGICSSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$MAGICS = 1
	ELSE
		$MAGICS = 0
	ENDIF
	IF(BITAND(GUICTRLREAD($RUNESSIM), $GUI_CHECKED) = $GUI_CHECKED) THEN
		$RUNES = 1
	ELSE
		$RUNES = 0
	ENDIF
ENDFUNC
WHILE 1
	IF $CLICOUSTART THEN
		EXITLOOP
	ENDIF
	SLEEP(10)
WEND
IF(CHECARORIGINALIDADE(1) = 7) THEN
	#ADLIBREGISTER("VerificarOriginalidade", 1000 * 60 * 20)
	LOGREG("Started " & $FILENAME)
	_GUI_TOTRAY()
	$RUNNINGTIME = TIMERINIT()
	ADLIBREGISTER("DoTip", 1000)
	IF($VISUAL = 2) THEN
		GUISETSTATE(@SW_SHOW, $WINDOW2)
	ENDIF
	$TOOLTIP = "Starting"
	LOCAL $Z = 0
	WHILE 1
		$Z += 1
		$PODECHICKEN = 0
		$NAOPODEPARAR = 0
		IF($SERIALSPLIT = "0707") AND($APPSTATS OR $STOPSERVERDOWN) AND NOT $REGISTROUADLIBPREMIUM THEN
			$REGISTROUADLIBPREMIUM = 1
			PREMIUM()
			ADLIBREGISTER("Premium", 5000)
		ENDIF
		IF(@HOUR >= CONVERT24H($HORAINICIO) AND @HOUR < CONVERT24H($HORAFIM) AND CONVERT24H($HORAINICIO) < CONVERT24H($HORAFIM)) OR((@HOUR < CONVERT24H($HORAFIM) OR @HOUR >= CONVERT24H($HORAINICIO)) AND CONVERT24H($HORAINICIO) > CONVERT24H($HORAFIM)) OR(@HOUR >= CONVERT24H($HORAINICIO2) AND @HOUR < CONVERT24H($HORAFIM2) AND CONVERT24H($HORAINICIO2) < CONVERT24H($HORAFIM2)) OR((@HOUR < CONVERT24H($HORAFIM2) OR @HOUR >= CONVERT24H($HORAINICIO2)) AND CONVERT24H($HORAINICIO2) > CONVERT24H($HORAFIM2)) OR(@HOUR >= CONVERT24H($HORAINICIO3) AND @HOUR < CONVERT24H($HORAFIM3) AND CONVERT24H($HORAINICIO3) < CONVERT24H($HORAFIM3)) OR((@HOUR < CONVERT24H($HORAFIM3) OR @HOUR >= CONVERT24H($HORAINICIO3)) AND CONVERT24H($HORAINICIO3) > CONVERT24H($HORAFIM3)) OR((@HOUR < CONVERT24H($HORAFIM4) OR @HOUR >= CONVERT24H($HORAINICIO4)) AND CONVERT24H($HORAINICIO4) > CONVERT24H($HORAFIM4)) OR(@HOUR >= CONVERT24H($HORAINICIO4) AND @HOUR < CONVERT24H($HORAFIM4) AND CONVERT24H($HORAINICIO4) < CONVERT24H($HORAFIM4)) OR((@HOUR < CONVERT24H($HORAFIM5) OR @HOUR >= CONVERT24H($HORAINICIO5)) AND CONVERT24H($HORAINICIO5) > CONVERT24H($HORAFIM5)) OR(@HOUR >= CONVERT24H($HORAINICIO5) AND @HOUR < CONVERT24H($HORAFIM5) AND CONVERT24H($HORAINICIO5) < CONVERT24H($HORAFIM5)) OR((@HOUR < CONVERT24H($HORAFIM6) OR @HOUR >= CONVERT24H($HORAINICIO6)) AND CONVERT24H($HORAINICIO6) > CONVERT24H($HORAFIM6)) OR(@HOUR >= CONVERT24H($HORAINICIO6) AND @HOUR < CONVERT24H($HORAFIM6) AND CONVERT24H($HORAINICIO6) < CONVERT24H($HORAFIM6)) OR((CONVERT24H($HORAINICIO) = CONVERT24H($HORAFIM)) AND(CONVERT24H($HORAINICIO) <> "-" AND CONVERT24H($HORAFIM) <> "-")) OR((CONVERT24H($HORAINICIO2) = CONVERT24H($HORAFIM2)) AND(CONVERT24H($HORAINICIO2) <> "-" AND CONVERT24H($HORAFIM2) <> "-")) OR((CONVERT24H($HORAINICIO3) = CONVERT24H($HORAFIM3)) AND(CONVERT24H($HORAINICIO3) <> "-" AND CONVERT24H($HORAFIM3) <> "-")) OR((CONVERT24H($HORAINICIO4) = CONVERT24H($HORAFIM4)) AND(CONVERT24H($HORAINICIO4) <> "-" AND CONVERT24H($HORAFIM4) <> "-")) OR((CONVERT24H($HORAINICIO5) = CONVERT24H($HORAFIM5)) AND(CONVERT24H($HORAINICIO5) <> "-" AND CONVERT24H($HORAFIM5) <> "-")) OR((CONVERT24H($HORAINICIO6) = CONVERT24H($HORAFIM6)) AND(CONVERT24H($HORAINICIO6) <> "-" AND CONVERT24H($HORAFIM6) <> "-")) THEN
			IF WINEXISTS("Diablo II: Resurrected") THEN
				IF NOT($REGISTROUADLIB) THEN
					$REGISTROUADLIB = 1
					ADLIBREGISTER("VerificarCrash", 500)
					ADLIBREGISTER("VerificarInternet", 1000)
				ENDIF
				IF WINACTIVE("Diablo II: Resurrected") THEN
					CRIARSALA()
					DENTROSALA()
				ELSE
					$TOOLTIP = "Starting"
					WINACTIVATE("Diablo II: Resurrected")
					SLEEP2(500)
				ENDIF
			ELSE
				INICIARD2()
			ENDIF
		ELSE
			IF $REGISTROUADLIB THEN
				LOGREG("Waiting for the schedule you set")
				ADLIBUNREGISTER("VerificarCrash")
				ADLIBUNREGISTER("VerificarInternet")
				$REGISTROUADLIB = 0
			ENDIF
			IF $Z > 60 THEN
				$TOOLTIP = "Waiting for the schedule you set"
				WINCLOSE("Diablo II: Resurrected")
			ELSE
				$TOOLTIP = "Waiting for the schedule you set" & (WINEXISTS("Diablo II: Resurrected") ? " - Closing the game in " & 60 - $Z & " - Press P or E to avoid closing" : "")
			ENDIF
			IF($VEIOAPOSPARAR) THEN
				$VEIOAPOSPARAR = 0
			ENDIF
			SLEEP2(1000)
		ENDIF
	WEND
ENDIF
FUNC INICIARD2()
	SEND2("{LCTRL}")
	SLEEP2(20)
	SEND2("{LSHIFT}")
	SLEEP2(20)
	IF NOT PROCESSEXISTS("Battle.net.exe") THEN
		MSGBOX(64, $FILENAME, "We recommend leaving B.N3T open and logged while botting")
	ENDIF
	IF NOT WINEXISTS("Diablo II: Resurrected") THEN
		SLEEP2(3000)
		LOCAL $IPOSITION = STRINGINSTR($EXECUTAVEL, "D2R.exe")
		IF NOT $IPOSITION THEN $EXECUTAVEL = $EXECUTAVEL & "\D2R.exe"
		RUN($EXECUTAVEL)
	ENDIF
	$TOOLTIP = "Waiting for game"
	WINWAIT("Diablo II: Resurrected", "", 30)
	$TOOLTIP = "Running"
	IF NOT($REGISTROUADLIB) THEN
		$REGISTROUADLIB = 1
		ADLIBREGISTER("VerificarCrash", 500)
		ADLIBREGISTER("VerificarInternet", 1000)
	ENDIF
	LOGREG("Started D2R")
	$TOOLTIP = "Starting"
	SLEEP2(RANDOM(2000, 3000, 1))
	WINACTIVATE("Diablo II: Resurrected")
	SLEEP2(RANDOM(200, 400, 1))
	CLICK(RANDOM(0, 1800, 1), RANDOM(0, 1000, 1), 0)
	$CRASHOU = 0
	$SAIU = 0
	$LOGAR = 0
	$A3 = 0
	WHILE 1
		$A3 += 1
		$TOOLTIP = $A3 & " - Logging"
		$RESULT2 = _IMAGESEARCHAREA($PASTATEMP & "png\ok.png", 1, 927, 563, 991, 602, $X, $Y, 70)
		IF $RESULT2 > 0 THEN
			SLEEP2(3000)
			WINCLOSE("Diablo II: Resurrected")
			$TOOLTIP = "Waiting 5-10 min to try to connect again"
			LOGREG("B.N3T is off. Waiting to try again in 5-10 minutes.")
			SLEEP2(RANDOM(57000 * 5, 63000 * 10, 1))
		ENDIF
		$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\fila.png", 1, 824, 521, 1098, 544, $X, $Y, 70)
		IF $RESULT > 0 THEN
			$TOOLTIP = $A3 & " - Line"
			SLEEP2(1000 * 10)
		ELSE
			SEND2("{SPACE}")
			SLEEP2(RANDOM(500, 1000, 1))
		ENDIF
		$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
		$RESULT = PIXELSEARCH(94, 435, 101, 443, 4048877, 20, DEFAULT, $D2HANDLE)
		IF NOT @ERROR THEN
			EXITLOOP
		ENDIF
		IF($A3 > 10000 + (($PCDEVAGAR) ? 2000 : 0) OR $CRASHOU) THEN
			WINCLOSE("Diablo II: Resurrected")
			SLEEP2(3000)
			EXITLOOP
		ENDIF
		SLEEP2(50)
	WEND
ENDFUNC
FUNC CRIARSALA()
	IF NOT($CRASHOU) THEN
		LOGREG("Making game")
		$SAIU = 0
		$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\ingame.png", 1, 319, 986, 359, 1016, $X, $Y, 70)
		IF $RESULT > 0 THEN
			RETURN
		ENDIF
		IF $DIFFICULT <> "Offline" THEN
			$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\lobby.png", 1, 1070, 950, 1177, 987, $X, $Y, 70)
			IF $RESULT = 0 THEN
				CLICK(1638, 53, 0)
				SLEEP2(1000)
			ENDIF
		ENDIF
		$A = 0
		WHILE 1
			$A += 1
			$TOOLTIP = "Waiting for Lobby - " & $A
			$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
			$RESULT = PIXELSEARCH(183, 767, 184, 768, 14137980, 20, DEFAULT, $D2HANDLE)
			IF NOT @ERROR THEN
				LOCAL $WAITING = RANDOM(5, 15, 1)
				$TOOLTIP = "Waiting " & $WAITING & " sec"
				SLEEP2($WAITING * 1000)
				SEND2("{ESC}")
				SLEEP2(2000)
			ENDIF
			$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
			$RESULT = PIXELSEARCH(94, 435, 101, 443, 4048877, 20, DEFAULT, $D2HANDLE)
			IF NOT @ERROR THEN
				EXITLOOP
			ENDIF
			$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\ok.png", 1, 927, 563, 991, 602, $X, $Y, 70)
			IF $RESULT > 0 THEN
				$CANNOTCONNECT += 1
				$TOOLTIP = "Connot connect to Server - Waiting 15 sec"
				SLEEP2(RANDOM(14000, 17000, 1))
				CLICK(958, 581, 0)
				SLEEP2(500)
				IF $DIFFICULT <> "Offline" THEN
					CLICK(1638, 53, 0)
				ENDIF
			ENDIF
			IF($A > 200 + (($PCDEVAGAR) ? 2000 : 0) OR $CRASHOU) THEN
				WINCLOSE("Diablo II: Resurrected")
				SLEEP2(3000)
				$CRASHOU = 1
				EXITLOOP
			ENDIF
			IF($VEIOAPOSPARAR) THEN
				$VEIOAPOSPARAR = 0
				EXITLOOP
			ENDIF
			SLEEP2(100)
		WEND
		IF NOT($CRASHOU) THEN
			IF($TEMPOPARACRIAR2 > 0 AND $TEMPOPARACRIAR2 >= $TEMPOPARACRIAR1) THEN
				LOCAL $TEMPOPARACRIAR = RANDOM($TEMPOPARACRIAR1, $TEMPOPARACRIAR2, 1)
				$TOOLTIP = "Waiting " & $TEMPOPARACRIAR & " sec"
				SLEEP2($TEMPOPARACRIAR * 1000)
				$TOOLTIP = "Running"
			ENDIF
			IF $DIFFICULT <> "Offline" THEN
				$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\lobby.png", 1, 1070, 950, 1177, 987, $X, $Y, 70)
				IF $RESULT = 0 THEN
					$CANNOTCONNECT += 1
					$TOOLTIP = "Seems to be offline"
					CLICK(1638, 53, 0)
					SLEEP2(5000)
					$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\ok.png", 1, 927, 563, 991, 602, $X, $Y, 70)
					IF $RESULT > 0 THEN
						$CANNOTCONNECT += 1
						SLEEP2(RANDOM(14000, 17000, 1))
						CLICK(958, 581, 0)
					ENDIF
					CLICK(1638, 53, 0)
					SLEEP2(7000)
					$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\lobby.png", 1, 1070, 950, 1177, 987, $X, $Y, 70)
					IF $RESULT = 0 THEN
						$CANNOTCONNECT += 1
						IF($CANNOTCONNECT > 7) THEN
							$CANNOTCONNECT = 0
							$TOOLTIP = "Will wait 1 minutes to try again"
							IF $REGISTROUADLIB THEN
								ADLIBUNREGISTER("VerificarCrash")
								ADLIBUNREGISTER("VerificarInternet")
								$REGISTROUADLIB = 0
							ENDIF
							WINCLOSE("Diablo II: Resurrected")
							SLEEP2(1000 * 60)
							$TOOLTIP = "Running"
							IF NOT($REGISTROUADLIB) THEN
								$REGISTROUADLIB = 1
								ADLIBREGISTER("VerificarCrash", 500)
								ADLIBREGISTER("VerificarInternet", 1000)
							ENDIF
						ELSE
							$TOOLTIP = "Restarting D2R"
							WINCLOSE("Diablo II: Resurrected")
							SLEEP2(3000)
							$CRASHOU = 1
						ENDIF
					ENDIF
					$TOOLTIP = "Running"
				ENDIF
			ELSE
				CLICK(1804, 51, 0)
				SLEEP2(200)
			ENDIF
			IF NOT($CRASHOU) THEN
				$A = 0
				WHILE 1
					$A += 1
					$TOOLTIP = "Making a game - " & $A
					MOUSEMOVER(804, 973, 0)
					SLEEP2(RANDOM(500, 700, 1))
					$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\remaining.png", 1, 583, 869, 1045, 959, $X, $Y, 70)
					IF $RESULT = 0 THEN
						EXITLOOP
					ENDIF
					IF($A > 100 + (($PCDEVAGAR) ? 1000 : 0) OR $CRASHOU) THEN
						WINCLOSE("Diablo II: Resurrected")
						SLEEP2(3000)
						$CRASHOU = 1
						EXITLOOP
					ENDIF
					IF($VEIOAPOSPARAR) THEN
						$VEIOAPOSPARAR = 0
						EXITLOOP
					ENDIF
					SLEEP2(1000)
				WEND
				IF(0 = RANDOM(0, 6, 1)) AND $RANDOMGAMEPASS AND($SERIALSPLIT = "0707") AND($DIFFICULT <> "Offline") THEN
					CLICK(1123, 971, 0)
					SLEEP2(2000)
					CLICK(1279, 75, 0)
					SLEEP2(200)
					CLICK(1358, 172, 0)
					SEND2(_RANDOMSTRING(8))
					SLEEP2(200)
					SEND2("{TAB}")
					SLEEP2(200)
					SEND2("1")
					IF($DIFFICULT = "Normal") THEN
						CLICK(1345, 374, 0)
					ELSEIF($DIFFICULT = "Nightmare") THEN
						CLICK(1468, 376, 0)
					ELSE
						CLICK(1591, 377, 0)
					ENDIF
					SLEEP2(100)
					CLICK(1477, 648, 0)
				ELSE
					SLEEP2(200)
					IF $DIFFICULT <> "Offline" THEN
						CLICK(801, 968, 0)
					ELSE
						CLICK(956, 981, 0)
					ENDIF
					SLEEP2(200)
					IF($DIFFICULT = "Normal") THEN
						CLICK(960, 451, 0)
					ELSEIF($DIFFICULT = "Nightmare") THEN
						CLICK(961, 518, 0)
					ELSE
						CLICK(960, 588, 0)
					ENDIF
					SLEEP2(100)
				ENDIF
			ENDIF
		ENDIF
		IF NOT($CRASHOU) THEN
			$A = 0
			WHILE 1
				$A += 1
				$TOOLTIP = $A & " - Creating"
				$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\ingame.png", 1, 319, 986, 359, 1016, $X, $Y, 70)
				IF $RESULT > 0 THEN
					EXITLOOP
				ENDIF
				$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\ok.png", 1, 927, 563, 991, 602, $X, $Y, 70)
				IF $RESULT > 0 THEN
					$TOOLTIP = "Waiting 15 sec"
					SLEEP2(RANDOM(14000, 17000, 1))
					CLICK(958, 581, 0)
					SLEEP2(500)
					CLICK(958, 581, 0)
					$TOOLTIP = "Running"
				ENDIF
				IF($VEIOAPOSPARAR) THEN
					$VEIOAPOSPARAR = 0
					EXITLOOP
				ENDIF
				IF($A > 600 + (($PCDEVAGAR) ? 2000 : 0) OR $CRASHOU) THEN
					WINCLOSE("Diablo II: Resurrected")
					SLEEP2(3000)
					$CRASHOU = 1
					EXITLOOP
				ENDIF
				SLEEP2(25)
			WEND
		ENDIF
	ENDIF
ENDFUNC
FUNC DENTROSALA()
	IF NOT($CRASHOU OR $SAIU) THEN
		$GUARDOUCASH = 0
		$USOULIFE = 0
		$USOUMANA = 0
		$USOULIFEMERC = 0
		$MATOU = 0
		$QUANTASRUNS += 1
		IF($TEMPOEXTRA2 > 0 AND $TEMPOEXTRA2 >= $TEMPOEXTRA1) THEN
			LOCAL $TEMPOEXTRA = RANDOM($TEMPOEXTRA1, $TEMPOEXTRA2, 1)
			$TOOLTIP = "Waiting " & $TEMPOEXTRA & " sec"
			SLEEP2($TEMPOEXTRA * 1000)
		ENDIF
		$TOOLTIP = "Running"
		SEND2("{LCTRL}")
		SLEEP2(20)
		SEND2("{LSHIFT}")
		SLEEP2(20)
		ALEATORIEDADES()
		MORREU(0)
		ALEATORIEDADES()
		AUTOHEAL(1)
		$VERIFICARLIFEANTESDARUN = VERIFICARLIFEANTESDARUN()
		$VERIFICARMERCANTESDARUN = VERIFICARMERCANTESDARUN()
		$VERIFICARINVANTESDARUN = VERIFICARINVANTESDARUN()
		$IRDIRETOPARARUN = 0
		IF NOT $VERIFICARLIFEANTESDARUN AND NOT $VERIFICARMERCANTESDARUN AND NOT $VERIFICARINVANTESDARUN THEN
			$IRDIRETOPARARUN = 1
		ENDIF
		VERIFICARATO()
		IF NOT $IRDIRETOPARARUN THEN
			ALEATORIEDADES()
			IF $VERIFICARMERCANTESDARUN THEN CHECARMERC()
			ALEATORIEDADES()
			IF $VERIFICARLIFEANTESDARUN THEN CHECARPOCAO(0)
			ALEATORIEDADES()
			IF $VERIFICARINVANTESDARUN THEN CHECARINVENTORIO(0)
			ALEATORIEDADES()
		ENDIF
		PRECAST(1)
		PINDLE()
		MATARELDRITCH()
		MATARSHENK()
		TRAVINCAL()
		MORREU(1)
		QUITAR()
		WINACTIVATE("Diablo II: Resurrected")
	ENDIF
ENDFUNC
FUNC MORREU($FINAL)
	IF NOT($CRASHOU OR $SAIU) THEN
		IF($FINAL) THEN
			$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\died.png", 1, 600, 255, 1300, 630, $X, $Y, 50)
			IF $RESULT > 0 THEN
				$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\continue.png", 1, 600, 255, 1300, 700, $X, $Y, 50)
				IF $RESULT > 0 THEN
					CLICK($X, $Y, 0)
					$PODECHICKEN = 0
					MUDANCADETELA()
					QUITAR()
					SLEEP2(1000)
					$SAIU = 1
				ENDIF
			ENDIF
		ELSE
			MOUSEMOVER(960, 481, 0)
			SLEEP2(500)
			$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\corpse.png", 1, 709, 246, 1203, 567, $X, $Y, 70)
			IF $RESULT > 0 THEN
				LOGREG("Died")
				$MORTES += 1
				CLICK(960, 481, 0)
				SLEEP2(30)
				SEND2("{SPACE}")
				SLEEP2(50)
				SEND2("i")
				SLEEP2(300)
				$A = 0
				WHILE $A <= 3
					CLICK(1293, 573 + (46 * $A), 1)
					$A += 1
					SLEEP2(100)
				WEND
				$A = 0
				WHILE $A <= 3
					CLICK(1293 + (46 * 1), 573 + (46 * $A), 1)
					$A += 1
					SLEEP2(100)
				WEND
				$A = 0
				WHILE $A <= 3
					CLICK(1293 + (46 * 2), 573 + (46 * $A), 1)
					$A += 1
					SLEEP2(100)
				WEND
				$A = 0
				WHILE $A <= 3
					CLICK(1293 + (46 * 3), 573 + (46 * $A), 1)
					$A += 1
					SLEEP2(100)
				WEND
				SEND2("{SPACE}")
			ENDIF
		ENDIF
	ENDIF
ENDFUNC
FUNC VERIFICARATO()
	IF NOT($CRASHOU OR $SAIU) THEN
		LOCAL $ATO4 = 0
		LOCAL $ACHOUATO = 0
		$VEIOOUTROATO = 0
		SEND2("{TAB}")
		SLEEP2(RANDOM(400, 500, 1))
		$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\larzuk.png", 1, 965, 544, 1195, 740, $X, $Y, 60)
		IF $RESULT > 0 THEN
			$REPARARITEMS += 1
			IF($REPARARITEMS > 50) THEN REPARARITEMS()
			$ACHOUATO = 1
			SEND2("{TAB}")
			RETURN
		ENDIF
		$VEIOOUTROATO = 1
		CONSOLEWRITE("verificar ato 1")
		$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\charsi.png", 1, 772, 336, 962, 493, $X, $Y, 50)
		IF $RESULT > 0 THEN
			$ACHOUATO = 1
			$TOOLTIP = "In Act 1"
			LOGREG($TOOLTIP)
			SEND2("{TAB}")
			CLICK(1392, 255, 0)
			SLEEP2(1500)
			$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
			$RESULT = PIXELSEARCH(615, 21, 1089, 224, 12124159, 10, DEFAULT, $D2HANDLE)
			IF NOT @ERROR THEN
				CLICK($RESULT[0] + 10, $RESULT[1] + 10, 0)
				SLEEP2(2000)
			ELSE
				CLICK(514, 814, 0)
				SLEEP2(1300)
				CLICK(1800, 795, 0)
				SLEEP2(1700)
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULT = PIXELSEARCH(1183, 73, 1685, 436, 12124159, 10, DEFAULT, $D2HANDLE)
				IF NOT @ERROR THEN
					CLICK($RESULT[0] - 5, $RESULT[1] + 10, 0)
					SLEEP2(2000)
				ENDIF
			ENDIF
		ELSE
			CONSOLEWRITE("verificar ato 2")
			$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\warriv.png", 1, 957, 403, 1085, 619, $X, $Y, 30)
			IF $RESULT > 0 THEN
				$ACHOUATO = 1
				$TOOLTIP = "In Act 2"
				LOGREG($TOOLTIP)
				CLICK(1101, 34, 0)
				SLEEP2(1500)
				CLICK(560, 336, 0)
				SLEEP2(1200)
				CLICK(1472, 303, 0)
				SLEEP2(1400)
				CLICK(849, 31, 0)
				SLEEP2(1500)
				CLICK(1653, 61, 0)
				SLEEP2(2000)
				CLICK(1237, 52, 0)
				SLEEP2(2000)
				SEND2("{TAB}")
				CLICK(960, 298, 0)
				SLEEP2(1000)
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULT = PIXELSEARCH(596, 27, 1239, 421, 12124159, 10, DEFAULT, $D2HANDLE)
				IF NOT @ERROR THEN
					CLICK($RESULT[0], $RESULT[1] + 10, 0)
					SLEEP2(2000)
				ENDIF
			ELSE
				CONSOLEWRITE("verificar ato 3")
				$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\meshif.png", 1, 856, 437, 1025, 562, $X, $Y, 50)
				IF $RESULT > 0 THEN
					$ACHOUATO = 1
					$TOOLTIP = "In Act 3"
					LOGREG($TOOLTIP)
					CLICK(1842, 503, 0)
					SLEEP2(1500)
					CLICK(1835, 83, 0)
					SLEEP2(2000)
					CLICK(1511, 232, 0)
					SLEEP2(1400)
					CLICK(1841, 587, 0)
					SLEEP2(1500)
					CLICK(1815, 271, 0)
					SLEEP2(1700)
					SEND2("{TAB}")
					CLICK(1174, 488, 0)
					SLEEP2(700)
					$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
					$RESULT = PIXELSEARCH(990, 307, 1662, 489, 12124159, 10, DEFAULT, $D2HANDLE)
					IF NOT @ERROR THEN
						CLICK($RESULT[0] + 10, $RESULT[1] + 10, 0)
						SLEEP2(2000)
					ENDIF
				ELSE
					CONSOLEWRITE("verificar ato 4")
					$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\tyrael2.png", 1, 872, 387, 1004, 464, $X, $Y, 50)
					IF $RESULT > 0 THEN
						$ACHOUATO = 1
						$VEIOOUTROATO = 0
						$TOOLTIP = "In Act 4"
						LOGREG($TOOLTIP)
						$ATO4 = 1
						CLICK(899, 159, 0)
						SLEEP2(2000)
						SEND2("{TAB}")
						CLICK(902, 70, 0)
						SLEEP2(2400)
						$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\tyrael.png", 1, 30, 30, 1900, 1079, $X, $Y, 70)
						IF $RESULT > 0 THEN
							IF $VERIFICARMERCANTESDARUN THEN
								CHECARMERC(1)
							ELSE
								CLICK($X, $Y, 0)
							ENDIF
						ENDIF
						MUDANCADETELA()
					ENDIF
				ENDIF
			ENDIF
		ENDIF
		IF($ACHOUATO) THEN
			$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\waypoint.png", 1, 318, 136, 490, 167, $X, $Y, 70)
			IF $RESULT > 0 AND NOT $ATO4 THEN
				IF NOT $IRDIRETOPARARUN THEN
					IF $VERIFICARMERCANTESDARUN THEN
						CLICK(493, 218, 0)
						SLEEP2(100)
						CLICK(416, 267, 0)
						MUDANCADETELA()
						CHECARMERC()
					ELSE
						CLICK(581, 219, 0)
						SLEEP2(100)
						CLICK(427, 266, 0)
						MUDANCADETELA()
						CLICK(1316, 41, 0)
						SLEEP2(1700)
						CLICK(1479, 132, 0)
						SLEEP2(1700)
					ENDIF
				ELSE
					IF $MATARPINDLE THEN
						CLICK(581, 219, 0)
						SLEEP2(100)
						CLICK(427, 266, 0)
					ELSEIF $MATARELDRITCH OR $MATARSHENK THEN
						CLICK(581, 219, 0)
						SLEEP2(100)
						CLICK(414, 329, 0)
					ELSEIF $MATARTRAVINCAL THEN
						CLICK(406, 218, 0)
						SLEEP2(100)
						CLICK(412, 698, 0)
					ENDIF
					MUDANCADETELA()
				ENDIF
			ENDIF
		ELSE
			$TOOLTIP = "Can't detect act. Watch the tutorial on DISCORD"
			LOGREG($TOOLTIP)
		ENDIF
	ENDIF
ENDFUNC
FUNC VERIFICARLIFEANTESDARUN()
	IF NOT($CRASHOU OR $SAIU) THEN
		$PORTAL += 1
		$LIFE1 = 0
		$LIFE2 = 0
		$MANA1 = 0
		SEND2("{" & $HOTKEY3 & "}")
		SLEEP2(250)
		$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
		$RESULT = PIXELSEARCH(997, 1052, 1021, 1070, 7237375, 20, DEFAULT, $D2HANDLE)
		IF @ERROR THEN
			$SEMPORTAL = 1
		ENDIF
		$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
		$RESULT = PIXELSEARCH(1097, 1025, 1132, 1053, 13183532, 70, DEFAULT, $D2HANDLE)
		IF @ERROR THEN
			$LIFE2 = 1
			$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
			$RESULT = PIXELSEARCH(1097, 1025, 1132, 1053, 13644500, 70, DEFAULT, $D2HANDLE)
			IF NOT @ERROR THEN
				$LIFE2 = 0
			ENDIF
		ENDIF
		IF NOT($LIFE1) THEN
			$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
			$RESULT = PIXELSEARCH(1158, 1024, 1196, 1059, 13183532, 70, DEFAULT, $D2HANDLE)
			IF @ERROR THEN
				$LIFE1 = 1
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULT = PIXELSEARCH(1158, 1024, 1196, 1059, 13644500, 70, DEFAULT, $D2HANDLE)
				IF NOT @ERROR THEN
					$LIFE1 = 0
				ENDIF
			ENDIF
		ENDIF
		IF NOT($LIFE1) THEN
			$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
			$RESULT = PIXELSEARCH(1220, 1024, 1257, 1058, 13183532, 70, DEFAULT, $D2HANDLE)
			IF @ERROR THEN
				$LIFE1 = 1
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULT = PIXELSEARCH(1220, 1024, 1257, 1058, 13644500, 70, DEFAULT, $D2HANDLE)
				IF NOT @ERROR THEN
					$LIFE1 = 0
				ENDIF
			ENDIF
		ENDIF
		$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
		$RESULT = PIXELSEARCH(1283, 1025, 1320, 1058, 4279762, 70, DEFAULT, $D2HANDLE)
		IF @ERROR THEN
			$MANA1 = 1
			$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
			$RESULT = PIXELSEARCH(1283, 1025, 1320, 1058, 13644500, 70, DEFAULT, $D2HANDLE)
			IF NOT @ERROR THEN
				$MANA1 = 0
			ENDIF
		ENDIF
		IF $LIFE1 OR $MANA1 OR($PORTAL >= RANDOM(13, 15, 1)) OR $SEMPORTAL THEN
			RETURN 1
		ELSE
			RETURN 0
		ENDIF
	ENDIF
ENDFUNC
FUNC ACHARLARZUK()
	IF NOT($CRASHOU OR $SAIU) THEN
		$A = 3
		WHILE $A >= 1
			MOUSEMOVER(922, 188 * $A, 2)
			$A2 = 0
			WHILE 1
				$A2 += 1
				$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\larzuk2.png", 1, 1, 1, 1900, 1079, $X, $Y, 70)
				IF $RESULT > 0 THEN
					MOUSECLICK("left", $X - 10, $Y + 70, 1, 2)
					SLEEP2(100)
					RETURN TRUE
				ENDIF
				$MOUSEPOS = MOUSEGETPOS()
				MOUSEMOVER($MOUSEPOS[0] + 40, $MOUSEPOS[1], 2)
				IF($MOUSEPOS[0] > 1450) THEN EXITLOOP
				IF($A2 > 100 + (($PCDEVAGAR) ? 1000 : 0) OR $CRASHOU OR $SAIU) THEN
					QUITAR()
					SLEEP2(1000)
					$SAIU = 1
					EXITLOOP
				ENDIF
			WEND
			$A -= 1
		WEND
	ENDIF
ENDFUNC
FUNC REPARARITEMS()
	IF NOT($CRASHOU OR $SAIU) THEN
		$REPARARITEMS = 0
		$TOOLTIP = "Repair items"
		CLICK(596, 908, 0)
		SLEEP2(1300)
		CLICK(1567, 694, 0)
		SLEEP2(1300)
		CLICK(1118, 760, 0)
		SLEEP2(700)
		ACHARLARZUK()
		SLEEP2(200)
		MOUSEMOVER(1599, 850, 0)
		$A2 = 0
		WHILE 1
			$A2 += 1
			$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\traderepair.png", 1, 30, 30, 1900, 1079, $X, $Y, 70)
			IF $RESULT > 0 THEN
				SLEEP2(200)
				CLICK($X, $Y, 0)
				SLEEP2(500)
				EXITLOOP
			ENDIF
			IF($A2 = 20 + (($PCDEVAGAR) ? 200 : 0) OR $CRASHOU OR $SAIU) THEN
				CLICK(977, 437, 0)
				SLEEP2(500)
				ACHARLARZUK()
				SLEEP2(200)
				MOUSEMOVER(1699, 850, 0)
			ENDIF
			IF($A2 > 40 + (($PCDEVAGAR) ? 400 : 0) OR $CRASHOU OR $SAIU) THEN
				QUITAR()
				SLEEP2(1000)
				$SAIU = 1
				EXITLOOP
			ENDIF
			SLEEP2(50)
		WEND
		$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\larzuk3.png", 1, 356, 138, 453, 167, $X, $Y, 70)
		IF $RESULT > 0 THEN
			CLICK(584, 768, 0)
			SLEEP2(300)
		ENDIF
		$TOOLTIP = "Running"
		SEND2("{SPACE}")
		SLEEP2(500)
		$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
		$RESULT = PIXELSEARCH(1122, 38, 1624, 670, 16750906, 10, DEFAULT, $D2HANDLE)
		IF NOT @ERROR THEN
			CLICK($RESULT[0] - 860, $RESULT[1] + 185, 0)
			SLEEP2(1000)
		ELSE
			CLICK(755, 383, 0)
			SLEEP2(1000)
		ENDIF
		CLICK(684, 212, 0)
		SLEEP2(700)
		CLICK(579, 409, 0)
		SLEEP2(700)
		CLICK(1260, 216, 0)
		SLEEP2(700)
	ENDIF
ENDFUNC
FUNC ACHARMALAH()
	IF NOT($CRASHOU OR $SAIU) THEN
		$A = 6
		WHILE $A >= 1
			MOUSEMOVER(673, 70 * $A, 2)
			$A2 = 0
			WHILE 1
				$A2 += 1
				$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\malah.png", 1, 1, 1, 1900, 1079, $X, $Y, 70)
				IF $RESULT > 0 THEN
					MOUSECLICK("left", $X - 10, $Y + 70, 1, 2)
					SLEEP2(100)
					RETURN TRUE
				ENDIF
				$MOUSEPOS = MOUSEGETPOS()
				MOUSEMOVER($MOUSEPOS[0] + 40, $MOUSEPOS[1], 2)
				IF($MOUSEPOS[0] > 1100) THEN EXITLOOP
				IF($A2 > 100 + (($PCDEVAGAR) ? 1000 : 0) OR $CRASHOU OR $SAIU) THEN
					QUITAR()
					SLEEP2(1000)
					$SAIU = 1
					EXITLOOP
				ENDIF
			WEND
			$A -= 1
		WEND
	ENDIF
ENDFUNC
FUNC CHECARPOCAO($SEMATOUBOSS)
	IF NOT($CRASHOU OR $SAIU) THEN
		IF(VERIFICARLIFEANTESDARUN()) THEN
			IF $LIFE1 THEN $TOOLTIP = "Going to buy Life"
			IF $MANA1 THEN $TOOLTIP = "Going to buy Mana"
			IF $SEMPORTAL THEN $TOOLTIP = "Without portal"
			IF NOT $MANA1 AND NOT $LIFE1 AND NOT $SEMPORTAL THEN $TOOLTIP = "Going to buy Portal"
			$PORTAL = 0
			$SEMPORTAL = 0
			IF($SEMATOUBOSS) THEN
				CLICK(809, 273, 0)
				SLEEP2(800)
				CLICK(365, 535, 0)
				SLEEP2(1200)
			ELSE
				CLICK(227, 345, 0)
				SLEEP2(1400)
			ENDIF
			ACHARMALAH()
			SLEEP2(200)
			MOUSEMOVER(1599, 850, 0)
			$A2 = 0
			WHILE 1
				$A2 += 1
				$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\trade.png", 1, 30, 30, 1900, 1079, $X, $Y, 70)
				IF $RESULT > 0 THEN
					SLEEP2(200)
					CLICK($X, $Y, 0)
					SLEEP2(500)
					EXITLOOP
				ENDIF
				IF($A2 = 20 + (($PCDEVAGAR) ? 200 : 0) OR $CRASHOU OR $SAIU) THEN
					CLICK(977, 437, 0)
					SLEEP2(500)
					ACHARMALAH()
					SLEEP2(200)
					MOUSEMOVER(1699, 850, 0)
				ENDIF
				IF($A2 > 40 + (($PCDEVAGAR) ? 400 : 0) OR $CRASHOU OR $SAIU) THEN
					QUITAR()
					SLEEP2(1000)
					$SAIU = 1
					EXITLOOP
				ENDIF
				SLEEP2(50)
			WEND
			$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\malah2.png", 1, 356, 138, 453, 167, $X, $Y, 70)
			IF $RESULT > 0 THEN
				IF($DIFFICULT <> "Hell" AND $DIFFICULT <> "Offline") THEN
					$QUALPOCAOLIFE = $PASTATEMP & "png\life2.png"
					$QUALPOCAOMANA = $PASTATEMP & "png\mana2.png"
				ELSE
					$QUALPOCAOLIFE = $PASTATEMP & "png\life.png"
					$QUALPOCAOMANA = $PASTATEMP & "png\mana.png"
				ENDIF
				CONSOLEWRITE($QUALPOCAOMANA)
				$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\portal.png", 1, 124, 105, 658, 714, $X, $Y, 100)
				IF $RESULT > 0 THEN
					SEND2("{SHIFTDOWN}")
					CLICK($X, $Y, 1)
					SEND2("{SHIFTUP}")
					SLEEP2(500)
					$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\portal.png", 1, 1270, 552, 1465, 747, $X, $Y, 100)
					IF $RESULT > 0 THEN
						SEND2("{CTRLDOWN}")
						CLICK($X, $Y, 0)
						SEND2("{CTRLUP}")
						SLEEP2(200)
					ENDIF
					MOUSEMOVER(RANDOM(966, 977, 1), RANDOM(477, 488, 1), 0)
				ENDIF
				IF($MANA1) THEN
					$RESULT = _IMAGESEARCHAREA($QUALPOCAOMANA, 1, 124, 105, 658, 714, $X, $Y, 100)
					IF $RESULT > 0 THEN
						CLICK($X, $Y, 1)
						SLEEP2(500)
						$RESULT = _IMAGESEARCHAREA($QUALPOCAOMANA, 1, 1087, 1015, 1268, 1068, $X, $Y, 100)
						IF $RESULT > 0 THEN
							CLICK($X, $Y, 0)
							SLEEP2(200)
							CLICK(1302, 1042, 0)
							SLEEP2(200)
						ENDIF
					ENDIF
					MOUSEMOVER(RANDOM(966, 977, 1), RANDOM(477, 488, 1), 0)
				ENDIF
				IF($LIFE1 OR $LIFE2) THEN
					$RESULT = _IMAGESEARCHAREA($QUALPOCAOLIFE, 1, 124, 105, 658, 714, $X, $Y, 70)
					IF $RESULT > 0 THEN
						SEND2("{SHIFTDOWN}")
						CLICK($X, $Y, 1)
						SEND2("{SHIFTUP}")
						SLEEP2(500)
					ENDIF
					MOUSEMOVER(RANDOM(966, 977, 1), RANDOM(477, 488, 1), 0)
				ENDIF
				IF($MANA1) THEN
					$RESULT = _IMAGESEARCHAREA($QUALPOCAOMANA, 1, 124, 105, 658, 714, $X, $Y, 100)
					IF $RESULT > 0 THEN
						SEND2("{SHIFTDOWN}")
						CLICK($X, $Y, 1)
						SEND2("{SHIFTUP}")
						SLEEP2(500)
					ENDIF
				ENDIF
			ENDIF
			$TOOLTIP = "Running"
			SEND2("{SPACE}")
			SLEEP2(200)
			CLICK(837, 680, 0)
			SLEEP2(1000)
			CLICK(1234, 886, 0)
			SLEEP2(1700)
			CLICK(701, 604, 0)
			SLEEP2(1000)
			$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
			$RESULT = PIXELSEARCH(720, 0, 1800, 254, 15932928, 20, DEFAULT, $D2HANDLE)
			IF NOT @ERROR THEN
				CLICK($RESULT[0] + 78, $RESULT[1] + 440, 0)
			ELSE
				CLICK(1598, 474, 0)
			ENDIF
			SLEEP2(1900)
		ENDIF
	ENDIF
ENDFUNC
FUNC VERIFICARMERCANTESDARUN()
	IF NOT($CRASHOU OR $SAIU) THEN
		IF($MERCENARY) THEN
			IF($SEMGOLD > 0) THEN $SEMGOLD += 1
			IF($SEMGOLD > 10) THEN $SEMGOLD = 0
			$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
			$RESULT = PIXELSEARCH(24, 36, 25, 37, 4732962, 10, DEFAULT, $D2HANDLE)
			IF @ERROR AND $SEMGOLD = 0 THEN
				RETURN 1
			ELSE
				RETURN 0
			ENDIF
		ENDIF
	ENDIF
ENDFUNC
FUNC CHECARMERC($QUAL = 0)
	IF NOT($CRASHOU OR $SAIU) THEN
		IF(VERIFICARMERCANTESDARUN()) THEN
			$VERIFICARMERCANTESDARUN = 0
			$TOOLTIP = "Going to revive MERC"
			LOGREG("Going to revive MERC")
			IF NOT $VEIOOUTROATO THEN
				SLEEP2(1000)
				CLICK(589, 894, 0)
				SLEEP2(1300)
				CLICK(488, 767, 0)
				SLEEP2(1700)
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULT = PIXELSEARCH(648, 540, 998, 830, 12124159, 20, DEFAULT, $D2HANDLE)
				IF NOT @ERROR THEN
					CLICK($RESULT[0] - 30, $RESULT[1] + 70, 0)
					SLEEP2(500)
				ENDIF
				CLICK(496, 219, 0)
				SLEEP2(300)
				CLICK(411, 267, 0)
				MUDANCADETELA()
			ENDIF
			IF NOT($QUAL) THEN
				SLEEP2(500)
				CLICK(308, 562, 0)
				SLEEP2(2000)
				CLICK(902, 70, 0)
				SLEEP2(2000)
			ENDIF
			$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\tyrael.png", 1, 30, 30, 1900, 1079, $X, $Y, 70)
			IF $RESULT > 0 THEN
				LOCAL $TRAVELTOX = $X
				LOCAL $TRAVELTOY = $Y
				$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\resurrect.png", 1, 30, 30, 1900, 1079, $X, $Y, 70)
				IF $RESULT > 0 THEN
					$REVIVEUMERC += 1
					CLICK($X, $Y, 0)
					SLEEP2(100)
					MOUSEMOVER(1298, 196, 0)
					SLEEP2(500)
					$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
					$RESULT = PIXELSEARCH(24, 36, 25, 39, 4732962, 10, DEFAULT, $D2HANDLE)
					IF @ERROR THEN
						$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\continue2.png", 1, 30, 30, 1900, 1079, $X, $Y, 70)
						IF $RESULT > 0 THEN
							$SEMGOLD = 1
							IF $PARARSEMGOLD THEN
								$TOOLTIP = "It'll close the game in 10 sec because no GOLD for HIRE"
								SLEEP2(10000)
								IF $REGISTROUADLIB THEN
									ADLIBUNREGISTER("VerificarCrash")
									ADLIBUNREGISTER("VerificarInternet")
									$REGISTROUADLIB = 0
								ENDIF
								WINCLOSE("Diablo II: Resurrected")
								LOGREG("Paused without GOLD for MERC")
								PAUSA()
							ENDIF
							CLICK($X, $Y, 0)
							SLEEP2(100)
							MOUSEMOVER(1298, 196, 0)
							SLEEP2(400)
						ENDIF
					ENDIF
					CLICK($TRAVELTOX, $TRAVELTOY, 0)
				ENDIF
			ELSE
				LOGREG("Couldn't find Tyrael on Act 4")
				CLICK(1352, 692, 0)
				SLEEP2(700)
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULT = PIXELSEARCH(1101, 424, 1598, 818, 12124159, 10, DEFAULT, $D2HANDLE)
				IF NOT @ERROR THEN
					CLICK($RESULT[0], $RESULT[1] + 50, 0)
					SLEEP2(800)
					CLICK(578, 219, 0)
					SLEEP2(300)
					CLICK(439, 265, 0)
					SLEEP2(50)
					MUDANCADETELA()
					QUITAR()
					SLEEP2(1000)
					$SAIU = 1
					RETURN
				ENDIF
			ENDIF
			MUDANCADETELA()
		ENDIF
	ENDIF
ENDFUNC
FUNC VERIFICARCHAR()
	IF NOT($CRASHOU OR $SAIU) THEN
		$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\hammerdin.png", 1, 862, 1010, 924, 1072, $X, $Y, 70)
		IF $RESULT > 0 THEN
			$TOOLTIP = "Hammerdin"
			$HAMMERDIN = 1
			$DRUID = 0
		ELSE
			$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\tornado.png", 1, 862, 1010, 924, 1072, $X, $Y, 70)
			IF $RESULT > 0 THEN
				$TOOLTIP = "Druid"
				$DRUID = 1
			ENDIF
			$HAMMERDIN = 0
		ENDIF
	ENDIF
ENDFUNC
FUNC PINDLE()
	IF(($SERIALSPLIT = "0707" OR $SERIALSPLIT = "1609") AND $MATARPINDLE) OR($SERIALSPLIT <> "0707" AND $SERIALSPLIT <> "1609") THEN
		IF NOT($CRASHOU OR $SAIU) THEN
			$TOOLTIP = "Pindle"
			LOGREG($TOOLTIP)
			IF($SERIALSPLIT = "0707") AND $PINDLEPATH AND(0 = RANDOM(0, 5, 1)) AND NOT $STASH AND(NOT $IRDIRETOPARARUN OR NOT $VEIOOUTROATO) THEN
				CLICK(250, 349, 0)
				SLEEP2(1500)
				ALEATORIEDADES()
				CLICK(120, 683, 0)
				SLEEP2(1500)
				ALEATORIEDADES()
				CLICK(565, 856, 0)
				SLEEP2(1500)
				ALEATORIEDADES()
				CLICK(570, 872, 0)
				SLEEP2(1500)
				ALEATORIEDADES()
				CLICK(220, 895, 0)
				SLEEP2(2000)
				ALEATORIEDADES()
				CLICK(990, 919, 0)
				SLEEP2(1500)
				ALEATORIEDADES()
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULT = PIXELSEARCH(1293, 352, 1712, 847, 15225431, 30, DEFAULT, $D2HANDLE)
				IF NOT @ERROR THEN
					CLICK($RESULT[0], $RESULT[1] + 100, 0)
					SLEEP2(500)
				ENDIF
			ELSE
				IF NOT $IRDIRETOPARARUN OR NOT $VEIOOUTROATO THEN
					IF NOT($STASH) THEN
						CLICK(552, 871, 0)
						SLEEP2(1400)
						CLICK(488, 767, 0)
						SLEEP2(1500)
					ELSE
						$STASH = 0
						CLICK(504, 410, 0)
						SLEEP2(1300)
					ENDIF
				ENDIF
				$VEIOOUTROATO = 0
				CLICK(683, 962, 0)
				SLEEP2(1700)
				CLICK(1075, 908, 0)
				SLEEP2(1000)
				CLICK(124, 914, 0)
				SLEEP2(2300)
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULT = PIXELSEARCH(161, 44, 915, 355, 15225431, 30, DEFAULT, $D2HANDLE)
				IF NOT @ERROR THEN
					CLICK($RESULT[0] + 30, $RESULT[1] + 70, 0)
					SLEEP2(500)
				ELSE
					CLICK(1153, 535, 0)
					SLEEP2(1000)
					CLICK(124, 914, 0)
					SLEEP2(2300)
					$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
					$RESULT = PIXELSEARCH(161, 44, 915, 355, 15225431, 30, DEFAULT, $D2HANDLE)
					IF NOT @ERROR THEN
						CLICK($RESULT[0] + 30, $RESULT[1] + 70, 0)
						SLEEP2(500)
					ELSE
						CLICK(1550, 688, 0)
						SLEEP2(2000)
						CLICK(124, 914, 0)
						SLEEP2(2300)
						$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
						$RESULT = PIXELSEARCH(161, 44, 915, 355, 15225431, 30, DEFAULT, $D2HANDLE)
						IF NOT @ERROR THEN
							CLICK($RESULT[0] + 30, $RESULT[1] + 70, 0)
							SLEEP2(500)
						ENDIF
					ENDIF
				ENDIF
			ENDIF
			$NAOPODEPARAR = 1
			MUDANCADETELA()
			$PODECHICKEN = 1
			VERIFICARCHAR()
			USARCTA()
			PRECAST()
			IF($TELEPORT) THEN
				SEND2("{" & $HOTKEY2 & "}")
				SLEEP2(20)
				CLICK(1566, 57, 1)
				SLEEP2(450)
				CLICK(1566, 57, 1)
				SLEEP2(450)
				CLICK(1550, 127, 1)
				SLEEP2(450)
				IF($HAMMERDIN) THEN
					CLICK(1247, 395, 1)
					SLEEP2(450)
				ENDIF
			ELSE
				CLICK(995, 171, 0)
				SLEEP2(800)
				CLICK(1803, 196, 0)
				SLEEP2(1800)
				CLICK(1550, 59, 0)
				SLEEP2(1800)
				CLICK(1250, 383, 0)
				SLEEP2(700)
				IF($HAMMERDIN) THEN
					CLICK(1247, 395, 0)
					SLEEP2(800)
				ENDIF
			ENDIF
			SEND2("{" & $HOTKEY1 & "}")
			SLEEP2(20)
			IF NOT $HAMMERDIN THEN
				CLICK(1223, 352, 1)
			ENDIF
			LOCAL $I = 1
			WHILE $I <= RANDOM(3, 4, 1)
				IF NOT($CRASHOU OR $SAIU) THEN
					IF NOT($HAMMERDIN) THEN
						MOUSEMOVER(1049, 448, 2)
					ELSE
						IF($I = 3) THEN
							IF($TELEPORT) THEN
								SEND2("{" & $HOTKEY2 & "}")
								SLEEP2(20)
								CLICK(1052, 523, 1)
							ELSE
								SLEEP2(20)
								CLICK(1052, 523, 0)
							ENDIF
							SLEEP2(450)
							SEND2("{" & $HOTKEY1 & "}")
							SLEEP2(20)
						ENDIF
						MOUSEMOVER(1866, 53, 2)
					ENDIF
					SLEEP2(50)
					SEND2("{SHIFTDOWN}")
					SLEEP2(50)
					MOUSEDOWN("left")
					IF NOT($HAMMERDIN) THEN
						SLEEP2(450)
						IF RANDOM(0, 1, 1) = 1 THEN
							MOUSEMOVER(1090, 485, 2)
						ELSE
							MOUSEMOVER(1049, 448, 2)
						ENDIF
						SLEEP2(450)
						IF RANDOM(0, 1, 1) = 1 THEN
							MOUSEMOVER(1090, 485, 2)
						ELSE
							MOUSEMOVER(1049, 448, 2)
						ENDIF
						SLEEP2(450)
					ELSE
						SLEEP2(1400)
					ENDIF
					MOUSEUP("left")
					SLEEP2(50)
					SEND2("{SHIFTUP}")
					SLEEP2(20)
					IF NOT($HAMMERDIN) THEN
						IF RANDOM(0, 1, 1) = 1 THEN
							CLICK(1203, 404, 1)
						ELSE
							CLICK(1223, 352, 1)
						ENDIF
					ENDIF
					MORREU(1)
				ENDIF
				$I += 1
			WEND
			CLICK(1667, 495, 0)
			SLEEP2(100)
			LOOT(0)
			$PODECHICKEN = 0
		ENDIF
	ENDIF
ENDFUNC
FUNC MATARELDRITCH()
	IF($SERIALSPLIT = "0707" OR $SERIALSPLIT = "1609") AND $MATARELDRITCH THEN
		IF NOT($CRASHOU OR $SAIU) THEN
			$TOOLTIP = "Eldritch"
			LOGREG($TOOLTIP)
			IF NOT $IRDIRETOPARARUN OR NOT $VEIOOUTROATO THEN
				IF $MATARPINDLE THEN
					SEND2("{" & $HOTKEY3 & "}")
					SLEEP2(20)
					CLICK(968, 530, 1)
					SLEEP2(100)
					MOUSEMOVER(RANDOM(0, 300, 1), RANDOM(0, 600, 1), 0)
					MORREU(1)
					PORTAL()
					$NAOPODEPARAR = 0
					ALEATORIEDADES()
					CHECARMERC()
					ALEATORIEDADES()
					CHECARPOCAO(1)
					ALEATORIEDADES()
					PRECAST(1)
				ENDIF
				$NAOPODEPARAR = 0
				ALEATORIEDADES()
				IF($STASH) THEN
					$STASH = 0
					CLICK(520, 393, 0)
					SLEEP2(800)
				ELSE
					CLICK(501, 865, 0)
					SLEEP2(1700)
					ALEATORIEDADES()
					CLICK(744, 824, 0)
					SLEEP2(1700)
					ALEATORIEDADES()
				ENDIF
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULT = PIXELSEARCH(648, 540, 998, 830, 12124159, 20, DEFAULT, $D2HANDLE)
				IF NOT @ERROR THEN
					CLICK($RESULT[0], $RESULT[1] + 20, 0)
					SLEEP2(700)
				ENDIF
				RANDOMCHANGEACT()
				$NAOPODEPARAR = 1
				CLICK(362, 331, 0)
				MUDANCADETELA()
			ENDIF
			$NAOPODEPARAR = 1
			$VEIOOUTROATO = 0
			$PODECHICKEN = 1
			VERIFICARCHAR()
			USARCTA()
			PRECAST()
			IF($TELEPORT) THEN
				SEND2("{" & $HOTKEY2 & "}")
				SLEEP2(20)
				CLICK(922, 45, 1)
				SLEEP2(450)
				CLICK(922, 45, 1)
				SLEEP2(450)
				IF($HAMMERDIN) THEN
					CLICK(1130, 201, 1)
					SLEEP2(370)
				ENDIF
			ELSE
				CLICK(922, 45, 0)
				SLEEP2(1800)
				CLICK(922, 45, 0)
				SLEEP2(1700)
				IF($HAMMERDIN) THEN
					CLICK(1130, 201, 0)
					SLEEP2(1500)
				ENDIF
			ENDIF
			SEND2("{" & $HOTKEY1 & "}")
			SLEEP2(20)
			IF NOT $HAMMERDIN THEN
				CLICK(922, 45, 1)
			ENDIF
			LOCAL $I = 1
			WHILE $I <= RANDOM(4, 5, 1)
				IF NOT($CRASHOU OR $SAIU) THEN
					IF NOT $HAMMERDIN THEN
						MOUSEMOVER(957, 395, 2)
					ELSE
						IF($I = 3) THEN
							IF($TELEPORT) THEN
								SEND2("{" & $HOTKEY2 & "}")
								SLEEP2(20)
								CLICK(1052, 523, 1)
							ELSE
								SLEEP2(20)
								CLICK(1052, 523, 0)
							ENDIF
							SLEEP2(450)
							SEND2("{" & $HOTKEY1 & "}")
							SLEEP2(20)
						ENDIF
						MOUSEMOVER(1866, 53, 2)
					ENDIF
					SLEEP2(50)
					SEND2("{SHIFTDOWN}")
					SLEEP2(50)
					MOUSEDOWN("left")
					IF NOT $HAMMERDIN THEN
						SLEEP2(450)
						IF RANDOM(0, 1, 1) = 1 THEN
							MOUSEMOVER(957, 395, 2)
						ELSE
							MOUSEMOVER(859, 386, 2)
						ENDIF
						SLEEP2(450)
						IF RANDOM(0, 1, 1) = 1 THEN
							MOUSEMOVER(957, 395, 2)
						ELSE
							MOUSEMOVER(859, 386, 2)
						ENDIF
						SLEEP2(450)
					ELSE
						SLEEP2(1400)
					ENDIF
					MOUSEUP("left")
					SLEEP2(50)
					SEND2("{SHIFTUP}")
					SLEEP2(20)
					IF NOT $HAMMERDIN THEN
						IF RANDOM(0, 1, 1) = 1 THEN
							CLICK(966, 222, 1)
						ELSE
							CLICK(926, 222, 1)
						ENDIF
						SLEEP2(100)
					ENDIF
					MORREU(1)
				ENDIF
				$I += 1
			WEND
			LOOT(1)
			$PODECHICKEN = 0
		ENDIF
	ENDIF
ENDFUNC
FUNC MATARSHENK()
	IF($SERIALSPLIT = "0707") AND $MATARSHENK THEN
		IF NOT($CRASHOU OR $SAIU) THEN
			$TOOLTIP = "Shenk"
			LOGREG($TOOLTIP)
			IF NOT $IRDIRETOPARARUN OR NOT $VEIOOUTROATO THEN
				IF $MATARPINDLE OR $MATARELDRITCH THEN
					SEND2("{" & $HOTKEY3 & "}")
					SLEEP2(20)
					CLICK(968, 530, 1)
					SLEEP2(100)
					MOUSEMOVER(RANDOM(0, 300, 1), RANDOM(0, 600, 1), 0)
					MORREU(1)
					PORTAL()
					$NAOPODEPARAR = 0
					ALEATORIEDADES()
					CHECARMERC()
					ALEATORIEDADES()
					CHECARPOCAO(1)
					ALEATORIEDADES()
					PRECAST(1)
				ENDIF
				$NAOPODEPARAR = 0
				ALEATORIEDADES()
				IF($STASH) THEN
					$STASH = 0
					CLICK(520, 393, 0)
					SLEEP2(800)
				ELSE
					CLICK(501, 865, 0)
					SLEEP2(1700)
					ALEATORIEDADES()
					CLICK(744, 824, 0)
					SLEEP2(1700)
					ALEATORIEDADES()
				ENDIF
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULT = PIXELSEARCH(648, 540, 998, 830, 12124159, 20, DEFAULT, $D2HANDLE)
				IF NOT @ERROR THEN
					CLICK($RESULT[0], $RESULT[1] + 20, 0)
					SLEEP2(500)
				ENDIF
				RANDOMCHANGEACT()
				$NAOPODEPARAR = 1
				CLICK(362, 331, 0)
				MUDANCADETELA()
			ENDIF
			$NAOPODEPARAR = 1
			$VEIOOUTROATO = 0
			$PODECHICKEN = 1
			VERIFICARCHAR()
			USARCTA()
			PRECAST()
			IF($TELEPORT) THEN
				SEND2("{" & $HOTKEY2 & "}")
				SLEEP2(20)
				CLICK(1830, 660, 1)
				SLEEP2(370)
				CLICK(1430, 860, 1)
				SLEEP2(370)
				CLICK(1133, 936, 1)
				SLEEP2(370)
				CLICK(1259, 914, 1)
				SLEEP2(370)
				CLICK(1758, 843, 1)
				SLEEP2(370)
				IF($HAMMERDIN) THEN
					CLICK(1813, 720, 1)
					SLEEP2(370)
				ELSEIF($DRUID) THEN
					CLICK(1153, 586, 1)
					SLEEP2(370)
				ENDIF
			ELSE
				CLICK(1830, 660, 0)
				SLEEP2(370)
				CLICK(1430, 860, 0)
				SLEEP2(370)
				CLICK(1133, 936, 0)
				SLEEP2(370)
				CLICK(1259, 914, 0)
				SLEEP2(370)
				CLICK(1758, 843, 0)
				SLEEP2(370)
				IF($HAMMERDIN) THEN
					CLICK(1813, 720, 0)
					SLEEP2(1400)
				ELSEIF($DRUID) THEN
					CLICK(1153, 586, 0)
					SLEEP2(370)
				ENDIF
			ENDIF
			SEND2("{" & $HOTKEY1 & "}")
			SLEEP2(20)
			CLICK(1813, 720, 1)
			LOCAL $I = 1
			WHILE $I <= RANDOM(4, 5, 1)
				IF NOT($CRASHOU OR $SAIU) THEN
					IF NOT $HAMMERDIN THEN
						MOUSEMOVER(1813, 720, 2)
					ELSE
						IF($I = 3) THEN
							IF($TELEPORT) THEN
								SEND2("{" & $HOTKEY2 & "}")
								SLEEP2(20)
								CLICK(1052, 523, 1)
							ELSE
								SLEEP2(20)
								CLICK(1052, 523, 0)
							ENDIF
							SLEEP2(450)
							SEND2("{" & $HOTKEY1 & "}")
							SLEEP2(20)
						ENDIF
						MOUSEMOVER(1866, 53, 2)
					ENDIF
					SLEEP2(50)
					SEND2("{SHIFTDOWN}")
					SLEEP2(50)
					MOUSEDOWN("left")
					SLEEP2(1370)
					MOUSEUP("left")
					SLEEP2(50)
					SEND2("{SHIFTUP}")
					SLEEP2(20)
					IF NOT $HAMMERDIN THEN
						CLICK(1813, 720, 1)
						SLEEP2(150)
					ENDIF
					MORREU(1)
				ENDIF
				$I += 1
			WEND
			SLEEP2(200)
			IF NOT $HAMMERDIN THEN
				IF($TELEPORT) THEN
					SEND2("{" & $HOTKEY2 & "}")
					SLEEP2(20)
					CLICK(1813, 720, 1)
					SLEEP2(370)
				ELSE
					CLICK(1813, 720, 0)
					SLEEP2(1800)
				ENDIF
			ENDIF
			LOOT(3)
			$PODECHICKEN = 0
		ENDIF
	ENDIF
ENDFUNC
FUNC TRAVINCAL()
	IF($SERIALSPLIT = "0707") AND $MATARTRAVINCAL THEN
		IF NOT($CRASHOU OR $SAIU) THEN
			$TOOLTIP = "Travincal"
			LOGREG($TOOLTIP)
			IF NOT $IRDIRETOPARARUN OR NOT $VEIOOUTROATO THEN
				IF($MATARPINDLE OR $MATARELDRITCH OR $MATARSHENK) THEN
					SEND2("{" & $HOTKEY3 & "}")
					SLEEP2(20)
					CLICK(968, 530, 1)
					SLEEP2(100)
					MOUSEMOVER(RANDOM(0, 300, 1), RANDOM(0, 600, 1), 0)
					MORREU(1)
					PORTAL()
					$NAOPODEPARAR = 0
					ALEATORIEDADES()
					CHECARMERC()
					ALEATORIEDADES()
					CHECARPOCAO(1)
					ALEATORIEDADES()
					PRECAST(1)
				ENDIF
				$NAOPODEPARAR = 0
				IF($STASH) THEN
					$STASH = 0
					ALEATORIEDADES()
					CLICK(495, 414, 0)
					SLEEP2(1000)
				ELSE
					CLICK(501, 865, 0)
					SLEEP2(1700)
					ALEATORIEDADES()
					CLICK(744, 824, 0)
					SLEEP2(1700)
					ALEATORIEDADES()
				ENDIF
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULT = PIXELSEARCH(648, 540, 998, 830, 12124159, 20, DEFAULT, $D2HANDLE)
				IF NOT @ERROR THEN
					CLICK($RESULT[0], $RESULT[1] + 20, 0)
					SLEEP2(500)
				ENDIF
				$NAOPODEPARAR = 1
				CLICK(408, 219, 0)
				SLEEP2(300)
				CLICK(416, 699, 0)
				MUDANCADETELA()
			ENDIF
			$VEIOOUTROATO = 0
			$NAOPODEPARAR = 1
			$PODECHICKEN = 1
			VERIFICARCHAR()
			USARCTA()
			PRECAST()
			IF($TELEPORT) THEN
				SEND2("{" & $HOTKEY2 & "}")
				SLEEP2(20)
				CLICK(1781, 55, 1)
				SLEEP2(250)
				CLICK(1710, 50, 1)
				SLEEP2(250)
				CLICK(1731, 108, 1)
				SLEEP2(250)
				CLICK(1853, 406, 1)
				SLEEP2(250)
				CLICK(1894, 277, 1)
				SLEEP2(250)
				CLICK(1860, 922, 1)
				SLEEP2(250)
				CLICK(1837, 966, 1)
				SLEEP2(250)
				CLICK(200, 597, 1)
				SLEEP2(250)
				CLICK(52, 677, 1)
				SLEEP2(1500)
				CLICK(1670, 906, 1)
				SLEEP2(250)
			ELSE
				CLICK(1331, 851, 0)
				SLEEP2(1400)
				CLICK(1807, 211, 0)
				SLEEP2(1400)
				CLICK(1743, 128, 0)
				SLEEP2(1600)
				CLICK(1680, 61, 0)
				SLEEP2(400)
				CLICK(1787, 982, 0)
				SLEEP2(1700)
				CLICK(1836, 969, 0)
				SLEEP2(1600)
				CLICK(1389, 807, 0)
				SLEEP2(750)
				CLICK(1619, 43, 0)
				SLEEP2(1300)
				CLICK(1233, 338, 0)
				SLEEP2(500)
				CLICK(436, 315, 0)
				SLEEP2(400)
			ENDIF
			SEND2("{" & $HOTKEY1 & "}")
			SLEEP2(20)
			LOCAL $I = 0
			WHILE $I <= (($TELEPORT) ? 12 : 8)
				IF NOT($CRASHOU OR $SAIU) THEN
					IF($TELEPORT) THEN
						IF($I = 2) THEN
							SEND2("{" & $HOTKEY2 & "}")
							SLEEP2(20)
							CLICK(988, 665, 1)
							SLEEP2(250)
							SEND2("{" & $HOTKEY1 & "}")
							SLEEP2(20)
						ELSEIF($I = 4) THEN
							SEND2("{" & $HOTKEY2 & "}")
							SLEEP2(20)
							CLICK(869, 548, 1)
							SLEEP2(250)
							SEND2("{" & $HOTKEY1 & "}")
							SLEEP2(20)
						ELSEIF($I = 6) THEN
							SEND2("{" & $HOTKEY2 & "}")
							SLEEP2(20)
							CLICK(119, 707, 1)
							SLEEP2(250)
							SEND2("{" & $HOTKEY1 & "}")
							SLEEP2(20)
						ELSEIF($I = 8) THEN
							SEND2("{" & $HOTKEY2 & "}")
							SLEEP2(20)
							CLICK(1024, 570, 1)
							SLEEP2(250)
							SEND2("{" & $HOTKEY1 & "}")
							SLEEP2(20)
						ELSEIF($I = 10) THEN
							SEND2("{" & $HOTKEY2 & "}")
							SLEEP2(20)
							CLICK(1551, 231, 1)
							SLEEP2(250)
							SEND2("{" & $HOTKEY1 & "}")
							SLEEP2(20)
						ENDIF
					ENDIF
					MOUSEMOVER(RANDOM(10, 30, 1), RANDOM(124, 150, 1), 2)
					SLEEP2(50)
					SEND2("{SHIFTDOWN}")
					SLEEP2(50)
					MOUSEDOWN("left")
					SLEEP2(1370)
					MOUSEUP("left")
					SLEEP2(50)
					SEND2("{SHIFTUP}")
					SLEEP2(20)
					MORREU(1)
				ENDIF
				$I += 1
			WEND
			IF($TELEPORT) THEN
				LOOT(2)
				SEND2("{" & $HOTKEY2 & "}")
				SLEEP2(20)
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULT = PIXELSEARCH(854, 632, 1163, 886, 16777125, 5, DEFAULT, $D2HANDLE)
				IF NOT @ERROR THEN
					CLICK($RESULT[0] - 700, $RESULT[1], 1)
					SLEEP2(250)
				ELSE
					CLICK(1038, 510, 1)
					SLEEP2(800)
					$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
					$RESULT = PIXELSEARCH(854, 632, 1163, 886, 16777125, 5, DEFAULT, $D2HANDLE)
					IF NOT @ERROR THEN
						CLICK($RESULT[0] - 700, $RESULT[1], 1)
						SLEEP2(250)
					ELSE
						CLICK(301, 818, 1)
					ENDIF
				ENDIF
				LOOT(2)
				CLICK(1551, 231, 1)
				SLEEP2(250)
			ENDIF
			LOOT(2)
			SLEEP2(100)
			SEND2("{" & $HOTKEY3 & "}")
			SLEEP2(20)
			CLICK(968, 530, 1)
			SLEEP2(100)
			MOUSEMOVER(RANDOM(0, 300, 1), RANDOM(0, 600, 1), 0)
			MORREU(1)
			$PODECHICKEN = 0
			PORTAL()
			SLEEP2(100)
			$NAOPODEPARAR = 0
			$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
			$RESULT = PIXELSEARCH(1274, 88, 1823, 442, 12124159, 10, DEFAULT, $D2HANDLE)
			IF NOT @ERROR THEN
				CLICK($RESULT[0], $RESULT[1] + 20, 0)
				SLEEP2(1500)
			ENDIF
			CLICK(580, 220, 0)
			SLEEP2(300)
			CLICK(431, 266, 0)
			SLEEP2(300)
			MUDANCADETELA()
		ENDIF
	ENDIF
ENDFUNC
FUNC VERIFICARCHICKEN()
	IF NOT($CRASHOU OR $SAIU) THEN
		IF($SERIALSPLIT = "0707") AND $CHICKEN AND $PODECHICKEN THEN
			$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
			$RESULTADOBUSCA = PIXELSEARCH(516, 1020, 517, 1021, 3473665, 20, DEFAULT, $D2HANDLE)
			IF @ERROR THEN
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULTADOBUSCA = PIXELSEARCH(516, 1020, 517, 1021, 602880, 20, DEFAULT, $D2HANDLE)
				IF @ERROR THEN
					$QUANTASCHICKEN += 1
					LOGREG("Chicken Exit")
					QUITAR()
					$SAIU = 1
					SLEEP2(1000)
				ENDIF
			ENDIF
		ENDIF
	ENDIF
ENDFUNC
FUNC AUTOHEAL($QUAL = 0)
	IF NOT($CRASHOU OR $SAIU) AND($PODECHICKEN OR $QUAL) THEN
		LOCAL $SHIFTAPERTADO = 0
		IF _ISPRESSED(10) THEN
			$SHIFTAPERTADO = 1
		ENDIF
		$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
		$RESULTADOBUSCA = PIXELSEARCH(1465, 972, 1467, 972, 1711042, 50, DEFAULT, $D2HANDLE)
		IF @ERROR THEN
			$USOUMANA += 1
			IF($USOUMANA = 1) THEN
				IF $SHIFTAPERTADO THEN
					SEND2("{SHIFTUP}")
					SLEEP2(20)
				ENDIF
				SEND2("4")
				SLEEP2(20)
			ELSEIF($USOUMANA > 5) THEN
				$USOUMANA = 0
			ENDIF
		ENDIF
		LOCAL $FOILIFE = 0
		$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
		$RESULTADOBUSCA = PIXELSEARCH(480, 930, 485, 935, 12535883, 20, DEFAULT, $D2HANDLE)
		IF @ERROR THEN
			$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
			$RESULTADOBUSCA = PIXELSEARCH(480, 930, 485, 935, 5822006, 40, DEFAULT, $D2HANDLE)
			IF @ERROR THEN
				$USOULIFE += 1
				IF($USOULIFE = 1) THEN
					$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
					$RESULTADOBUSCA = PIXELSEARCH(1116, 1040, 1117, 1041, 1184274, 10, DEFAULT, $D2HANDLE)
					IF @ERROR THEN
						IF $SHIFTAPERTADO THEN
							SEND2("{SHIFTUP}")
							SLEEP2(20)
						ENDIF
						SEND2("1")
						SLEEP2(20)
						$FOILIFE = 1
					ENDIF
					IF NOT($FOILIFE) THEN
						$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
						$RESULTADOBUSCA = PIXELSEARCH(1116 + (61 * 1), 1040, 1117 + (61 * 1), 1041, 1184274, 10, DEFAULT, $D2HANDLE)
						IF @ERROR THEN
							IF $SHIFTAPERTADO THEN
								SEND2("{SHIFTUP}")
								SLEEP2(20)
							ENDIF
							SEND2("2")
							SLEEP2(20)
							$FOILIFE = 1
						ENDIF
					ENDIF
					IF NOT($FOILIFE) THEN
						$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
						$RESULTADOBUSCA = PIXELSEARCH(1116 + (61 * 2), 1040, 1117 + (61 * 2), 1041, 1184274, 10, DEFAULT, $D2HANDLE)
						IF @ERROR THEN
							IF $SHIFTAPERTADO THEN
								SEND2("{SHIFTUP}")
								SLEEP2(20)
							ENDIF
							SEND2("3")
							SLEEP2(20)
							$FOILIFE = 1
						ENDIF
					ENDIF
				ELSEIF($USOULIFE > 5) THEN
					$USOULIFE = 0
				ENDIF
			ENDIF
		ENDIF
		IF($MERCENARY) THEN
			$FOILIFE = 0
			$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
			$RESULTADOBUSCA = PIXELSEARCH(24, 24, 78, 28, 13665312, 20, DEFAULT, $D2HANDLE)
			IF NOT @ERROR THEN
				$USOULIFEMERC += 1
				IF($USOULIFEMERC = 1) THEN
					$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
					$RESULTADOBUSCA = PIXELSEARCH(1116, 1040, 1117, 1041, 1184274, 10, DEFAULT, $D2HANDLE)
					IF @ERROR THEN
						IF $SHIFTAPERTADO THEN
							SEND2("{SHIFTUP}")
							SLEEP2(20)
						ENDIF
						SEND2("{SHIFTDOWN}")
						SLEEP2(20)
						SEND2("1")
						SLEEP2(20)
						SEND2("{SHIFTUP}")
						$FOILIFE = 1
					ENDIF
					IF NOT($FOILIFE) THEN
						$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
						$RESULTADOBUSCA = PIXELSEARCH(1116 + (61 * 1), 1040, 1117 + (61 * 1), 1041, 1184274, 10, DEFAULT, $D2HANDLE)
						IF @ERROR THEN
							IF $SHIFTAPERTADO THEN
								SEND2("{SHIFTUP}")
								SLEEP2(20)
							ENDIF
							SEND2("{SHIFTDOWN}")
							SLEEP2(20)
							SEND2("2")
							SLEEP2(20)
							SEND2("{SHIFTUP}")
							$FOILIFE = 1
						ENDIF
					ENDIF
					IF NOT($FOILIFE) THEN
						$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
						$RESULTADOBUSCA = PIXELSEARCH(1116 + (61 * 2), 1040, 1117 + (61 * 2), 1041, 1184274, 10, DEFAULT, $D2HANDLE)
						IF @ERROR THEN
							IF $SHIFTAPERTADO THEN
								SEND2("{SHIFTUP}")
								SLEEP2(20)
							ENDIF
							SEND2("{SHIFTDOWN}")
							SLEEP2(20)
							SEND2("3")
							SLEEP2(20)
							SEND2("{SHIFTUP}")
							$FOILIFE = 1
						ENDIF
					ENDIF
				ELSEIF($USOULIFEMERC > 5) THEN
					$USOULIFEMERC = 0
				ENDIF
			ENDIF
		ENDIF
		IF $SHIFTAPERTADO THEN
			$SHIFTAPERTADO = 0
			SEND2("{SHIFTDOWN}")
			SLEEP2(20)
		ENDIF
	ENDIF
ENDFUNC
FUNC MUDANCADETELA($QUAL = 0)
	$PODECHICKEN = 0
	LOCAL $TOOLTIPANTERIOR = $TOOLTIP
	LOCAL $A55 = 0
	WHILE 1
		$A55 += 1
		$TOOLTIP = $A55 & " - 1"
		$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\ingame.png", 1, 319, 986, 359, 1016, $X, $Y, 70)
		IF $RESULT = 0 THEN
			EXITLOOP
		ENDIF
		IF($QUAL AND($A55 = 50 OR $A55 = 100 OR $A55 = 150)) THEN
			IF $A55 = 100 THEN
				SEND2("{" & $HOTKEY3 & "}")
				SLEEP2(20)
				CLICK(300, 600, 1)
				SLEEP2(100)
				MORREU(1)
			ENDIF
			PORTAL(1)
		ENDIF
		IF($A55 > 200 + (($PCDEVAGAR) ? 2000 : 0) OR $CRASHOU OR $SAIU) THEN
			QUITAR()
			SLEEP2(1000)
			$SAIU = 1
			EXITLOOP
		ENDIF
		SLEEP2(50)
	WEND
	$A55 = 0
	WHILE 1
		$A55 += 1
		$TOOLTIP = $A55 & " - 2"
		$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\ingame.png", 1, 319, 986, 359, 1016, $X, $Y, 70)
		IF $RESULT > 0 THEN
			EXITLOOP
		ENDIF
		IF($A55 > 200 + (($PCDEVAGAR) ? 2000 : 0) OR $CRASHOU OR $SAIU) THEN
			QUITAR()
			SLEEP2(1000)
			$SAIU = 1
			EXITLOOP
		ENDIF
		SLEEP2(50)
	WEND
	$TOOLTIP = $TOOLTIPANTERIOR
ENDFUNC
FUNC PORTAL($QUAL = 0)
	IF NOT($CRASHOU OR $SAIU) THEN
		SLEEP2(150)
		$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
		$RESULT = PIXELSEARCH(585, 246, 1085, 746, 7502079, 20, DEFAULT, $D2HANDLE)
		IF NOT @ERROR THEN
			LOCAL $POSX = $RESULT[0] + 10
			LOCAL $POSY = $RESULT[1] + 70
			MOUSEMOVER($POSX, $POSY, 0)
			SLEEP2(300)
			LOCAL $ACHOUNOMECIDADE = 0
			$RESULT2 = _IMAGESEARCHAREA($PASTATEMP & "png\harrogath.png", 1, 492, 188, 1389, 665, $X, $Y, 70)
			IF $RESULT2 > 0 THEN
				$ACHOUNOMECIDADE = 1
			ENDIF
			$RESULT2 = _IMAGESEARCHAREA($PASTATEMP & "png\kurast-docks.png", 1, 492, 188, 1389, 665, $X, $Y, 70)
			IF $RESULT2 > 0 THEN
				$ACHOUNOMECIDADE = 1
			ENDIF
			$PODECHICKEN = 0
			IF $ACHOUNOMECIDADE > 0 THEN
				CLICK($POSX, $POSY, 0)
			ELSE
				SLEEP2(3000)
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULT = PIXELSEARCH(585, 246, 1085, 746, 7502079, 20, DEFAULT, $D2HANDLE)
				IF NOT @ERROR THEN
					CLICK($RESULT[0] + 10, $RESULT[1] + 70, 0)
				ELSE
					MOUSECLICK("left", 940, 452, 1, 1)
					SLEEP2(20)
					MOUSECLICK("left", 992, 445, 1, 1)
				ENDIF
			ENDIF
		ENDIF
		IF NOT $QUAL THEN MUDANCADETELA(1)
	ENDIF
ENDFUNC
FUNC QUITAR()
	IF NOT($CRASHOU OR $SAIU) THEN
		$TOOLTIP = "Leaving"
		$PODECHICKEN = 0
		LOGREG("Quit")
		SLEEP2(100)
		SEND2("{ESC}")
		SLEEP2(300)
		MOUSECLICK("left", 955 + RANDOM(0, 5, 0), 473 + RANDOM(0, 5, 0), 1, RANDOM(1, 3, 0))
		SLEEP2(1000)
	ENDIF
ENDFUNC
FUNC USARCTA()
	IF NOT($CRASHOU OR $SAIU) THEN
		IF($USARCTA) THEN
			SLEEP2(250)
			SEND2("w")
			SLEEP2(250)
			SEND2("{" & $HOTKEY5 & "}")
			SLEEP2(400)
			$RESULT2 = _IMAGESEARCHAREA($PASTATEMP & "png\bo.png", 1, 1000, 1013, 1059, 1071, $X, $Y, 100)
			IF $RESULT2 = 0 THEN
				SEND2("w")
				SLEEP2(250)
				SEND2("{" & $HOTKEY5 & "}")
				SLEEP2(20)
			ENDIF
			CLICK(968, 530, 1)
			SLEEP2(700)
			SEND2("{" & $HOTKEY6 & "}")
			SLEEP2(20)
			CLICK(968, 530, 1)
			SLEEP2(700)
			SEND2("w")
			SLEEP2(250)
		ENDIF
	ENDIF
ENDFUNC
FUNC PRECAST($QUAL = 0)
	IF NOT($CRASHOU OR $SAIU) THEN
		IF($QUAL) THEN
			IF($HOTKEY0 <> "-") THEN
				SEND2("{" & $HOTKEY0 & "}")
				SLEEP2(20)
				CLICK(960, 481, 1)
				SLEEP2(100)
			ENDIF
			IF($HOTKEY7 <> "-") THEN
				SLEEP2(200)
				SEND2("{" & $HOTKEY7 & "}")
				SLEEP2(20)
				CLICK(960, 481, 1)
				SLEEP2(100)
			ENDIF
		ELSE
			IF($HOTKEY4 <> "-") THEN
				SEND2("{" & $HOTKEY4 & "}")
				SLEEP2(20)
				CLICK(960, 481, 1)
				SLEEP2(100)
			ENDIF
		ENDIF
	ENDIF
ENDFUNC
FUNC LOOT($QUALLOOT)
	IF NOT($CRASHOU OR $SAIU) THEN
		$TOOLTIP = "Looting"
		SEND2("{LCTRL}")
		SLEEP2(20)
		SEND2("{LSHIFT}")
		SLEEP2(20)
		SEND2("{ALT}")
		SLEEP2(20)
		LOCAL $B = 3
		IF $STASH THEN
			$B = 2
		ENDIF
		IF $QUALLOOT = 2 OR $QUALLOOT = 3 THEN
			$B = 1
		ENDIF
		MOUSEMOVER(RANDOM(0, 100, 1), RANDOM(83, 900, 1), 0)
		SEND2("{" & $HOTKEY2 & "}")
		SLEEP2(20)
		LOCAL $A = 0
		WHILE $A <= $B
			$A += 1
			IF NOT($CRASHOU OR $SAIU) THEN
				IF($A = 1) THEN
					PEGARITEM("Gold.png", 100)
				ENDIF
				MORREU(1)
				FOR $SCOLORITENS IN $ASCOLORSITENS
					$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
					LOCAL $BCOORD = PIXELSEARCH(165, 45, 1657, 854, $SCOLORITENS, 10, 3, $D2HANDLE)
					IF NOT @ERROR THEN
						IF $SCOLORITENS = "0xC7B377" AND $UNIQUES THEN
							LOCAL $FINDIMAGE1[4] = ["uniq-a.png", "uniq-e.png", "uniq-o.png", "uniq-u.png"]
							FOR $I = 0 TO UBOUND($FINDIMAGE1) - 1
								PEGARITEM($FINDIMAGE1[$I], 40)
							NEXT
							PEGARITEM("uniq-i.png", 20)
						ELSEIF $SCOLORITENS = "0x00FC00" AND $SETS THEN
							PEGARITEM("tal-armor.png", 100)
							PEGARITEM("amulet-set.png", 100)
							PEGARITEM("sacredarmor.png", 100)
						ELSEIF $SCOLORITENS = "0xFFFF64" AND $RARES THEN
							PEGARITEM("amulet.png", 100)
							PEGARITEM("ring.png", 100)
							PEGARITEM("jewel2.png", 100)
							PEGARITEM("circlet.png", 100)
							PEGARITEM("coronet.png", 100)
							PEGARITEM("diadem.png", 100)
							PEGARITEM("tiara.png", 100)
						ELSEIF $SCOLORITENS = "0x6E6EFF" AND $MAGICS THEN
							PEGARITEM("charm.png", 100)
							PEGARITEM("jewel.png", 100)
						ELSEIF $SCOLORITENS = "0xFFA800" AND $RUNES THEN
							PEGARITEM("rune.png", 100)
						ENDIF
					ENDIF
				NEXT
				IF($SERIALSPLIT = "0707") THEN
					PICKITINI()
				ENDIF
				MORREU(1)
				IF($A = 1) THEN
					IF $QUALLOOT = 0 THEN
						CLICK(371, 215, 0)
						SLEEP2(600)
					ENDIF
				ENDIF
				IF($A = 2) THEN
					IF $QUALLOOT = 0 THEN
						CLICK(1324, 930, 0)
						SLEEP2(600)
					ELSEIF $QUALLOOT = 1 THEN
						IF($TELEPORT) THEN
							CLICK(962, 334, 1)
							SLEEP2(100)
							MOUSEMOVER(RANDOM(0, 100, 1), RANDOM(83, 900, 1), 0)
							SLEEP2(100)
						ELSE
							CLICK(1700, 334, 0)
							SLEEP2(700)
						ENDIF
					ENDIF
				ENDIF
				IF $A = 3 OR($B = 2 AND $A = 2) THEN
					IF $QUALLOOT = 0 THEN
						CLICK(RANDOM(418, 845, 1), 45, 1)
						SLEEP2(250)
						EXITLOOP
					ENDIF
				ENDIF
			ENDIF
		WEND
		SEND2("{ALT}")
		SLEEP2(20)
		$MATOU = 1
		$VERIFICARINVANTESDARUN = VERIFICARINVANTESDARUN()
		IF $VERIFICARINVANTESDARUN THEN CHECARINVENTORIO($QUALLOOT)
	ENDIF
ENDFUNC
FUNC PICKITINI()
	IF FILEEXISTS($FILEINIPICKIT) THEN
		LOCAL $INIPICKIT = INIREADSECTION($FILEINIPICKIT, "Items")
		IF @ERROR THEN
			LOGREG("Error reading Items INI file")
			MSGBOX(48, $FILENAME, "Error reading Items INI file")
		ELSE
			FOR $I = 1 TO $INIPICKIT[0][0]
				IF($INIPICKIT[$I][1] = 1) THEN
					PEGARITEM($INIPICKIT[$I][0] & ".png", 70)
				ENDIF
			NEXT
		ENDIF
	ENDIF
ENDFUNC
FUNC VERIFICARINVANTESDARUN()
	IF NOT($CRASHOU OR $SAIU) THEN
		$STASH = 0
		SEND2("{SPACE}")
		SLEEP2(20)
		SEND2("i")
		SLEEP2(300)
		COLOCARJUVCINTO(1)
		LOCAL $BFOUND = FALSE
		FOR $SCOLOR IN $ASCOLORS
			$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
			$AICOORD = PIXELSEARCH(1268, 552, 1465, 745, $SCOLOR, 5, DEFAULT, $D2HANDLE)
			IF ISARRAY($AICOORD) THEN
				$BFOUND = TRUE
				EXITLOOP
			ENDIF
		NEXT
		IF($MATOU) THEN
			$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\stashFree.png", 1, 1268, 551, 1463, 746, $X, $Y, 100)
			IF($RESULT > 0) OR($NAOPARARSTASH = 1) THEN
				$BFOUND = FALSE
			ENDIF
		ENDIF
		SEND2("{SPACE}")
		SLEEP2(20)
		IF $BFOUND THEN
			RETURN 1
		ELSE
			RETURN 0
		ENDIF
	ENDIF
ENDFUNC
FUNC CHECARINVENTORIO($QUALLOOT)
	IF NOT($CRASHOU OR $SAIU) THEN
		IF($VERIFICARINVANTESDARUN) THEN
			$TOOLTIP = "Going to stash"
			SEND2("{SPACE}")
			SLEEP2(20)
			IF($MATOU) THEN
				SEND2("{" & $HOTKEY3 & "}")
				SLEEP2(20)
				CLICK(300, 600, 1)
				SLEEP2(100)
				MORREU(1)
				PORTAL()
				SLEEP2(200)
				IF $QUALLOOT <> 2 THEN CLICK(596, 760, 0)
			ELSE
				CLICK(552, 871, 0)
			ENDIF
			IF $QUALLOOT <> 2 THEN
				SLEEP2(1400)
				CLICK(488, 767, 0)
				SLEEP2(1700)
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULT = PIXELSEARCH(1249, 359, 1671, 855, 16732929, 10, DEFAULT, $D2HANDLE)
				IF NOT @ERROR THEN
					CLICK($RESULT[0] + 50, $RESULT[1] + 170, 0)
				ENDIF
			ELSE
				CLICK(785, 87, 0)
			ENDIF
			SLEEP2(1300)
			LOCAL $STASHFULL = 0
			LOCAL $A88 = 0
			LOCAL $TENTOUVARIASX = 0
			WHILE 1
				$A88 += 1
				LOCAL $ACHOUSTASH = 0
				$TOOLTIP = "Stash - " & $A88
				IF NOT($CRASHOU OR $SAIU) THEN
					$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\stash.png", 1, 357, 136, 450, 165, $X, $Y, 70)
					IF $RESULT > 0 THEN
						$ACHOUSTASH = 1
					ENDIF
					IF NOT($ACHOUSTASH) THEN
						$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
						$RESULT = PIXELSEARCH(670, 110, 676, 115, 12663324, 30, DEFAULT, $D2HANDLE)
						IF NOT @ERROR THEN
							$ACHOUSTASH = 1
						ENDIF
					ENDIF
					IF $ACHOUSTASH THEN
						COLOCARJUVCINTO(0)
						$ACHOUSTASH = 0
						SLEEP2(100)
						IF NOT($GUARDOUCASH) THEN
							$GUARDOUCASH = 1
							CLICK(1449, 788, 0)
							SLEEP2(30)
							CLICK(820, 581, 0)
							SLEEP2(30)
						ENDIF
						SLEEP2(100)
						IF $STASHFULL = 0 THEN CLICK(595, 202, 0)
						SLEEP2(200)
						MOUSEMOVER(RANDOM(966, 977, 1), RANDOM(477, 488, 1), 0)
						SLEEP2(200)
						$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\stashFree.png", 1, 161, 219, 655, 712, $X, $Y, 100)
						IF($RESULT > 0) AND($TENTOUVARIASX <= 16) THEN
							LOCAL $BFOUND = FALSE
							FOR $SCOLOR IN $ASCOLORS
								$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
								$AICOORD = PIXELSEARCH(1268, 552, 1465, 745, $SCOLOR, 5, DEFAULT, $D2HANDLE)
								IF ISARRAY($AICOORD) THEN
									$BFOUND = TRUE
									EXITLOOP
								ENDIF
							NEXT
							IF $BFOUND THEN
								$TENTOUVARIASX += 1
								LOCAL $COORDX = $AICOORD[0]
								LOCAL $COORDY = $AICOORD[1]
								MOUSEMOVER($COORDX, $COORDY, 0)
								SLEEP2(300)
								$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\ringmail.png", 1, 1071, 290, 1787, 753, $X, $Y, 70)
								IF $RESULT > 0 THEN
									MOUSECLICK("left", $COORDX, $COORDY + 5)
									SLEEP2(150)
									CLICK(948, 622, 0)
								ELSE
									$GUARDOUITEM += 1
									SEND2("{CTRLDOWN}")
									SLEEP2(20)
									MOUSECLICK("left", $COORDX, $COORDY + 5)
									SLEEP2(100)
									SEND2("{CTRLUP}")
									SLEEP2(20)
								ENDIF
							ELSE
								SEND2("{SPACE}")
								IF($MATOU) THEN
									IF $QUALLOOT <> 2 THEN
										SLEEP2(200)
										CLICK(517, 381, 0)
										SLEEP2(1500)
										CLICK(1519, 31, 0)
										SLEEP2(2700)
										$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
										$RESULT = PIXELSEARCH(863, 10, 1484, 616, 7502079, 30, DEFAULT, $D2HANDLE)
										IF NOT @ERROR THEN
											CLICK($RESULT[0] + 30, $RESULT[1] + 70, 0)
										ENDIF
									ELSE
										CLICK(1108, 762, 0)
										SLEEP2(2000)
									ENDIF
									MUDANCADETELA()
								ENDIF
								$STASH = 1
								$TOOLTIP = "Running"
								EXITLOOP
							ENDIF
						ELSE
							$TENTOUVARIASX = 0
							$STASHFULL += 1
							SLEEP2(200)
							IF $STASHFULL = 1 THEN CLICK(467, 203, 0)
							IF $STASHFULL = 2 THEN CLICK(345, 203, 0)
							IF $STASHFULL = 3 THEN CLICK(218, 201, 0)
							IF $STASHFULL >= 4 THEN
								IF $PARARSTASHFULL THEN
									LOGREG("All Stashes FULL")
									$TOOLTIP = "Stashes FULL - Paused"
									IF $REGISTROUADLIB THEN
										ADLIBUNREGISTER("VerificarCrash")
										ADLIBUNREGISTER("VerificarInternet")
										$REGISTROUADLIB = 0
									ENDIF
									WINCLOSE("Diablo II: Resurrected")
									$PAROUSTASHEFULL = 1
									PAUSA()
								ELSE
									$NAOPARARSTASH = 1
									EXITLOOP
								ENDIF
							ENDIF
							SLEEP2(200)
							MOUSEMOVER(RANDOM(966, 977, 1), RANDOM(477, 488, 1), 0)
						ENDIF
					ENDIF
					IF($A88 > 100 + (($PCDEVAGAR) ? 1000 : 0) OR $CRASHOU OR $SAIU) THEN
						QUITAR()
						$SAIU = 1
						SLEEP2(1000)
						EXITLOOP
					ENDIF
				ENDIF
				IF($A88 > 100 + (($PCDEVAGAR) ? 1000 : 0) OR $CRASHOU OR $SAIU) THEN
					QUITAR()
					$SAIU = 1
					SLEEP2(1000)
					EXITLOOP
				ENDIF
			WEND
			IF($MATOU) THEN
				$PODECHICKEN = 1
				SEND2("{" & $HOTKEY1 & "}")
				SLEEP2(20)
				CLICK(959, 534, 1)
				LOOT(0)
				$PODECHICKEN = 0
			ENDIF
		ELSE
			SEND2("{SPACE}")
			$MATOU = 0
		ENDIF
	ENDIF
ENDFUNC
FUNC COLOCARJUVCINTO($QUAL)
	$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
	$RESULT = PIXELSEARCH(1268, 552, 1465, 745, 13644500, 70, DEFAULT, $D2HANDLE)
	IF NOT @ERROR AND($MATOU = 0 OR $QUAL = 0) THEN
		LOCAL $FIRSTTIME = 0
		LOCAL $NACHACINTO = 0
		WHILE 1
			LOCAL $X1, $X2, $Y1, $Y2
			$RESULT1 = _IMAGESEARCHAREA($PASTATEMP & "png\Rejuvenation1.png", 1, 1268, 552, 1465, 745, $X1, $Y1, 70)
			$RESULT2 = _IMAGESEARCHAREA($PASTATEMP & "png\Rejuvenation2.png", 1, 1268, 552, 1465, 745, $X2, $Y2, 70)
			IF $RESULT1 > 0 OR $RESULT2 > 0 THEN
				IF($DIFFICULT <> "Hell" AND $DIFFICULT <> "Offline") THEN
					$QUALPOCAOLIFE = $PASTATEMP & "png\life2.png"
				ELSE
					$QUALPOCAOLIFE = $PASTATEMP & "png\life.png"
				ENDIF
				IF($RESULT1 > 0) THEN
					LOCAL $COORDX = $X1
					LOCAL $COORDY = $Y1
				ELSE
					LOCAL $COORDX = $X2
					LOCAL $COORDY = $Y2
				ENDIF
				IF NOT($FIRSTTIME) THEN
					SEND2("'")
					SLEEP2(350)
					$FIRSTTIME = 1
				ENDIF
				$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
				$RESULT = PIXELSEARCH(1294, 958, 1295, 959, 12365711, 10, DEFAULT, $D2HANDLE)
				IF NOT @ERROR THEN
					$RESULT3 = _IMAGESEARCHAREA($QUALPOCAOLIFE, 1, 1088, 1014, 1270, 1067, $X, $Y, 70)
					IF $RESULT3 > 0 THEN
						MOUSECLICK("left", $COORDX, $COORDY + 5)
						SLEEP2(200)
						MOUSECLICK("left", $X, $Y)
						SLEEP2(200)
						CLICK(948, 622, 0)
					ELSE
						$RESULT3 = _IMAGESEARCHAREA($QUALPOCAOLIFE, 1, 1085, 845, 1270, 1067, $X, $Y, 70)
						IF $RESULT3 > 0 THEN
							MOUSECLICK("left", $COORDX, $COORDY + 5)
							SLEEP2(200)
							MOUSECLICK("left", $X, $Y)
							SLEEP2(200)
							CLICK(948, 622, 0)
						ELSE
							MOUSECLICK("left", $COORDX, $COORDY + 5)
							SLEEP2(200)
							CLICK(948, 622, 0)
						ENDIF
					ENDIF
				ELSE
					$NACHACINTO += 1
					SLEEP2(20)
					SEND2("'")
					SLEEP2(20)
				ENDIF
				IF($NACHACINTO > 3) THEN
					MOUSEMOVER(1329, 1065, 0)
					SLEEP2(300)
					$RESULT3 = _IMAGESEARCHAREA($QUALPOCAOLIFE, 1, 1088, 1014, 1270, 1067, $X, $Y, 70)
					IF $RESULT3 > 0 THEN
						MOUSECLICK("left", $COORDX, $COORDY + 5)
						SLEEP2(200)
						MOUSEMOVER(1329, 1065, 0)
						SLEEP2(200)
						MOUSECLICK("left", $X, $Y)
						SLEEP2(200)
						CLICK(948, 622, 0)
					ELSE
						$RESULT3 = _IMAGESEARCHAREA($QUALPOCAOLIFE, 1, 1085, 845, 1270, 1067, $X, $Y, 70)
						IF $RESULT3 > 0 THEN
							MOUSECLICK("left", $COORDX, $COORDY + 5)
							SLEEP2(200)
							MOUSEMOVER(1329, 1065, 0)
							SLEEP2(200)
							MOUSECLICK("left", $X, $Y)
							SLEEP2(200)
							CLICK(948, 622, 0)
						ELSE
							MOUSECLICK("left", $COORDX, $COORDY + 5)
							SLEEP2(200)
							CLICK(948, 622, 0)
						ENDIF
					ENDIF
				ENDIF
			ELSE
				IF($FIRSTTIME) THEN
					SLEEP2(100)
					SEND2("'")
					SLEEP2(100)
				ENDIF
				EXITLOOP
			ENDIF
		WEND
	ENDIF
ENDFUNC
FUNC RANDOMCHANGEACT()
	IF($SERIALSPLIT = "0707") AND $CHANGEACT AND(0 = RANDOM(0, 10, 1)) THEN
		IF NOT($CRASHOU OR $SAIU) THEN
			$TOOLTIP = "Random Act Change"
			LOCAL $RANDX = RANDOM(1, 4, 1)
			SELECT
				CASE $RANDX = 1
					CLICK(236, 219, 0)
				CASE $RANDX = 2
					CLICK(236, 219, 0)
				CASE $RANDX = 3
					CLICK(410, 218, 0)
				CASE $RANDX = 4
					CLICK(497, 220, 0)
			ENDSELECT
			SLEEP2(200)
			CLICK(339, 268, 0)
			MUDANCADETELA()
			$TOOLTIP = "Random Wait in Diff Act"
			SLEEP2(RANDOM(2000, 25000))
			$D2HANDLE = WINGETHANDLE("Diablo II: Resurrected")
			$RESULT = PIXELSEARCH(755, 358, 1172, 542, 12124159, 20, DEFAULT, $D2HANDLE)
			IF NOT @ERROR THEN
				CLICK($RESULT[0], $RESULT[1] + 50, 0)
				SLEEP2(500)
			ENDIF
			SLEEP2(500)
			CLICK(580, 220, 0)
			SLEEP2(400)
			$TOOLTIP = "Running"
		ENDIF
	ENDIF
ENDFUNC
FUNC CHECARORIGINALIDADE($SAIR)
	RETURN 7
	IF _ISINTERNETCONNECTED() THEN
		LOCAL $SPUBLICIP = _GETIP()
		LOCAL $IDUNICO = _WINAPI_UNIQUEHARDWAREID(BITOR($UHID_MB, $UHID_BIOS))
		$OHTTP = OBJCREATE("winhttp.winhttprequest.5.1")
		$OHTTP.Open("GET", "https://www.d2rmab.com/ajax/verificar.php?user=" & @USERNAME & "&versao=" & $VERSAO & "&pc=" & @COMPUTERNAME & "&serial=" & $SERIAL & "&ip=" & $SPUBLICIP & "&iprede=" & @IPADDRESS1 & "&IDunico=" & $IDUNICO, FALSE)
		IF @ERROR THEN
			LOGREG("SERVER Error 15")
			IF($SAIR) THEN WINCLOSE("Diablo II: Resurrected")
			MSGBOX(16, $FILENAME, "Something went wrong with SERVER. Error 15 - pdb2.0@outlook.com")
			IF($SAIR) THEN SAIR()
		ENDIF
		$OHTTP.SetTimeouts(120000, 120000, 120000, 120000)
		IF @ERROR THEN
			LOGREG("SERVER Error 18")
			IF($SAIR) THEN WINCLOSE("Diablo II: Resurrected")
			MSGBOX(16, $FILENAME, "Something went wrong with SERVER. Error 18 - pdb2.0@outlook.com")
			IF($SAIR) THEN SAIR()
		ENDIF
		$OHTTP.Send()
		IF @ERROR THEN
			LOGREG("SERVER Error 16")
			IF($SAIR) THEN WINCLOSE("Diablo II: Resurrected")
			MSGBOX(16, $FILENAME, "Something went wrong with SERVER. Error 16 - pdb2.0@outlook.com")
			IF($SAIR) THEN SAIR()
		ENDIF
		$ORECEIVED = $OHTTP.ResponseText
		$OSTATUSCODE = $OHTTP.Status
		IF @ERROR THEN
			LOGREG("SERVER Error 17")
			IF($SAIR) THEN WINCLOSE("Diablo II: Resurrected")
			MSGBOX(16, $FILENAME, "Something went wrong with SERVER. Error 17 - pdb2.0@outlook.com")
			IF($SAIR) THEN SAIR()
		ENDIF
		$OHTTP = 0
		IF($OSTATUSCODE == 200) THEN
			IF($ORECEIVED <> "") THEN
				LOCAL $ORECEIVEDSPLIT = STRINGSPLIT($ORECEIVED, "|")
				IF($ORECEIVEDSPLIT[1] = 7) AND $ORECEIVEDSPLIT[2] = $IDUNICO THEN
					RETURN $ORECEIVEDSPLIT[1]
				ELSE
					LOGREG("Error 1 - pdb2.0@outlook.com")
					IF($SAIR) THEN WINCLOSE("Diablo II: Resurrected")
					MSGBOX(48, $FILENAME, "Error 1 - pdb2.0@outlook.com" & @CRLF & @CRLF & "Try checking if there is any update available.")
					IF($SAIR) THEN SAIR()
				ENDIF
			ELSE
				LOGREG("Error 4 - pdb2.0@outlook.com")
				IF($SAIR) THEN WINCLOSE("Diablo II: Resurrected")
				MSGBOX(48, $FILENAME, "Error 4 - pdb2.0@outlook.com" & @CRLF & @CRLF & "Try checking if there is any update available.")
				IF($SAIR) THEN SAIR()
			ENDIF
		ELSE
			LOGREG("Error 2 - pdb2.0@outlook.com")
			IF($SAIR) THEN WINCLOSE("Diablo II: Resurrected")
			MSGBOX(48, $FILENAME, "Error 2 - pdb2.0@outlook.com" & @CRLF & @CRLF & "Try checking if there is any update available.")
			IF($SAIR) THEN SAIR()
		ENDIF
	ELSE
		LOGREG("Error 3 - pdb2.0@outlook.com")
		IF($SAIR) THEN WINCLOSE("Diablo II: Resurrected")
		MSGBOX(48, $FILENAME, "Error 3 - pdb2.0@outlook.com" & @CRLF & @CRLF & "Try checking if there is any update available.")
		IF($SAIR) THEN SAIR()
	ENDIF
	BLOQUEARGUI(0)
	RETURN 0
ENDFUNC
FUNC VERIFICARCRASH()
	AUTOHEAL()
	VERIFICARCHICKEN()
	IF NOT WINEXISTS("Diablo II: Resurrected") THEN
		$CRASHOU = 1
		IF($LOGAR = 0) THEN
			$LOGAR = 1
			LOGREG("D2R Closed")
		ENDIF
	ELSE
		IF NOT WINACTIVE("Diablo II: Resurrected") THEN
			$JANELANAOATIVA += 1
			$TOOLTIP = "It will set D2 on TOP - " & 60 - $JANELANAOATIVA
			IF($JANELANAOATIVA > 60) THEN
				$JANELANAOATIVA = 0
				WINACTIVATE("Diablo II: Resurrected")
			ENDIF
		ENDIF
	ENDIF
ENDFUNC
FUNC VERIFICARINTERNET()
	IF _ISINTERNETCONNECTED() THEN
		IF($SEMINTERNET) THEN
			$LOGAR = 0
			$SEMINTERNET = 0
			LOGREG("INTERNET is back")
			WINCLOSE("Diablo II: Resurrected")
			$TOOLTIP = "Running"
		ENDIF
	ELSE
		$SEMINTERNET = 1
		IF($LOGAR = 0) THEN
			$LOGAR = 1
			LOGREG("No INTERNET")
		ENDIF
		$TOOLTIP = "No Internet Connection - Waiting for Connection"
		WHILE 1
			IF _ISINTERNETCONNECTED() THEN
				EXITLOOP
			ENDIF
			SLEEP2(5000)
		WEND
	ENDIF
ENDFUNC
FUNC VERIFICARORIGINALIDADE()
	CONSOLEWRITE("Ok")
	#IF(CHECARORIGINALIDADE(1) = 7) THEN
	#	CONSOLEWRITE("Ok")
	#ELSE
	#	FILEDELETE($FILEINI)
	#	WINCLOSE("Diablo II: Resurrected")
	#	MSGBOX(48, $FILENAME, "Error 23 - pdb2.0@outlook.com")
	#	SAIR()
	#ENDIF
ENDFUNC
FUNC PEGARITEM($ITEM, $TOLERANCIA)
	IF NOT($CRASHOU OR $SAIU) THEN
		IF $PCDEVAGAR THEN
			SLEEP(100)
		ENDIF
		$RESULT = _IMAGESEARCHAREA($PASTATEMP & "png\" & $ITEM, 1, 165, 45, 1657, 854, $X, $Y, $TOLERANCIA)
		IF $RESULT > 0 THEN
			LOCAL $ITEMPEGO = STRINGSPLIT($ITEM, ".")
			LOGREG("Grabing Item " & $ITEMPEGO[1])
			MOUSECLICK("left", $X, $Y, 1, 3)
			SLEEP2(1000)
			MOUSEMOVER(RANDOM(0, 100, 1), RANDOM(83, 900, 1), 0)
		ENDIF
	ENDIF
ENDFUNC
FUNC MOUSEMOVER($X, $Y, $VELOCIDADE)
	IF NOT($CRASHOU OR $SAIU) THEN
		IF $PCDEVAGAR THEN
			SLEEP(100)
		ENDIF
		IF NOT($VELOCIDADE) THEN
			IF($SERIALSPLIT = "0707") AND $RANDOMMOUSEMOVE THEN
				MOUSEMOVE2($X + RANDOM(0, 1, 1), $Y + RANDOM(0, 1, 1))
			ELSE
				MOUSEMOVE($X + RANDOM(0, 1, 1), $Y + RANDOM(0, 1, 1), RANDOM(6, 10, 1))
			ENDIF
		ELSE
			MOUSEMOVE($X + RANDOM(0, 1, 1), $Y + RANDOM(0, 1, 1), $VELOCIDADE)
		ENDIF
	ENDIF
ENDFUNC
FUNC CLICK($X, $Y, $MOUSE)
	IF NOT($CRASHOU OR $SAIU) THEN
		IF $PCDEVAGAR THEN
			SLEEP(100)
		ENDIF
		IF NOT($MOUSE) THEN
			IF($SERIALSPLIT = "0707") AND $RANDOMMOUSEMOVE AND NOT $NAOPODEPARAR THEN
				MOUSEMOVE2($X + RANDOM(0, 6, 1), $Y + RANDOM(0, 6, 1))
				MOUSECLICK("left", $X + RANDOM(0, 6, 1), $Y + RANDOM(0, 6, 1), 1, RANDOM(1, 3, 1))
			ELSE
				MOUSECLICK("left", $X + RANDOM(0, 6, 1), $Y + RANDOM(0, 6, 1), 1, RANDOM(8, 10, 1))
			ENDIF
		ELSE
			MOUSECLICK("right", $X + RANDOM(0, 6, 1), $Y + RANDOM(0, 6, 1), 1, RANDOM(9, 10, 1))
		ENDIF
	ENDIF
ENDFUNC
FUNC SLEEP2($TEMPO)
	IF NOT($CRASHOU OR $SAIU) THEN
		IF $PCDEVAGAR THEN
			SLEEP(100)
		ENDIF
		IF($TEMPO <= 50) THEN
			SLEEP(RANDOM($TEMPO, $TEMPO + 10, 1))
		ELSE
			SLEEP(RANDOM($TEMPO - 70, $TEMPO + 200, 1))
		ENDIF
	ENDIF
ENDFUNC
FUNC SEND2($KEY)
	IF NOT($CRASHOU OR $SAIU) THEN
		IF $PCDEVAGAR THEN
			SLEEP(100)
		ENDIF
		SLEEP(10)
		SEND($KEY)
		SLEEP(10)
	ENDIF
ENDFUNC
FUNC LOGREG($TEXTO)
	CONSOLEWRITE($TEXTO)
	LOCAL $NEWDATA = STRINGREGEXPREPLACE(_NOWDATE(), "\A(\d*)/(\d*)/(\d*)", "$3-$2-$1")
	IF NOT FILEEXISTS(@SCRIPTDIR & "\log\") THEN
		DO
			DIRCREATE(@SCRIPTDIR & "\log\")
		UNTIL FILEEXISTS(@SCRIPTDIR & "\log\")
	ENDIF
	LOCAL $HFILE = FILEOPEN(@SCRIPTDIR & "\log\" & $NEWDATA & ".log", 1)
	_FILEWRITELOG($HFILE, $TEXTO)
	FILECLOSE($HFILE)
ENDFUNC
FUNC _RANDOMSTRING($ILENGTH)
	$ACHARS = STRINGSPLIT("ABCDFGHIJKLMNOQRSTUWXYZ0123456789", "")
	$SSTRING = ""
	WHILE $ILENGTH > STRINGLEN($SSTRING)
		IF $SSTRING < "A" THEN $SSTRING = ""
		$SSTRING &= $ACHARS[RANDOM(1, $ACHARS[0], 1)]
	WEND
	RETURN $SSTRING
ENDFUNC
FUNC ALEATORIEDADES()
	IF($SERIALSPLIT = "0707") AND NOT $NAOPODEPARAR THEN
		IF(0 = RANDOM(0, 10, 1)) AND $RANDOMMOUSEMOVE THEN
			$TOOLTIP = "Random Mouse Move"
			SLEEP2(200)
			MOUSEMOVE2(RANDOM(0, 1920, 1), RANDOM(0, 1080, 1))
			$TOOLTIP = "Running"
		ENDIF
		IF(0 = RANDOM(0, 40, 1)) AND $RANDOMUSECHAT THEN
			$TOOLTIP = "Random Chat"
			SLEEP2(100)
			SEND2("{ENTER}")
			SLEEP2(1000)
			SEND2(RANDOMWORD())
			SLEEP2(1000)
			SEND2("{ENTER}")
			SLEEP2(600)
			$TOOLTIP = "Running"
		ENDIF
		IF(0 = RANDOM(0, 20, 1)) AND $RANDOMPAUSE THEN
			$TOOLTIP = "Random Pause Between Moves"
			SLEEP2(RANDOM(500, 4000))
			$TOOLTIP = "Running"
		ENDIF
	ENDIF
ENDFUNC
FUNC PARAR()
	$PAROU = 1
	$PAUSAR = 0
	IF $REGISTROUADLIB THEN
		ADLIBUNREGISTER("VerificarCrash")
		ADLIBUNREGISTER("VerificarInternet")
		$REGISTROUADLIB = 0
	ENDIF
	IF($SERIALSPLIT = "0707") AND($APPSTATS OR $STOPSERVERDOWN) AND $REGISTROUADLIBPREMIUM THEN
		$REGISTROUADLIBPREMIUM = 0
		ADLIBUNREGISTER("Premium")
	ENDIF
	TOOLTIP("")
	GUISETSTATE(@SW_HIDE, $WINDOW2)
	_GUI_RESTORE()
	SEND2("{LCTRL}")
	SLEEP2(20)
	SEND2("{LSHIFT}")
	SLEEP2(20)
	CRIARLOGFILE()
	IF($SERIAL <> "") THEN
		IF($SERIALSPLIT = "2804") THEN
			BLOQUEARGUI(1)
		ELSEIF($SERIALSPLIT = "0707") THEN
			BLOQUEARGUI(2)
		ELSEIF($SERIALSPLIT = "1609") THEN
			BLOQUEARGUI(4)
		ELSE
			BLOQUEARGUI(0)
		ENDIF
	ENDIF
	HOTKEYSET("e")
	HOTKEYSET("!e")
	HOTKEYSET("+e")
	HOTKEYSET("p")
	HOTKEYSET("!p")
	HOTKEYSET("+p")
	HOTKEYSET("v")
	HOTKEYSET("!v")
	HOTKEYSET("+v")
	$FINTERRUPT = 0
	WHILE $PAROU
		IF($FINTERRUPT = 2) THEN
			$FINTERRUPT = 0
			EXITLOOP
		ENDIF
		SLEEP(10)
	WEND
ENDFUNC
FUNC PAUSA()
	SEND2("{LCTRL}")
	SLEEP2(20)
	SEND2("{LSHIFT}")
	SLEEP2(20)
	$PAUSAR = NOT $PAUSAR
	IF $PAUSAR THEN
		$TOOLTIP = "Press P to continue"
		$NAOPARARSTASH = 0
		IF $REGISTROUADLIB THEN
			ADLIBUNREGISTER("VerificarCrash")
			ADLIBUNREGISTER("VerificarInternet")
			$REGISTROUADLIB = 0
		ENDIF
		IF($SERIALSPLIT = "0707") AND($APPSTATS OR $STOPSERVERDOWN) AND $REGISTROUADLIBPREMIUM THEN
			$REGISTROUADLIBPREMIUM = 0
			ADLIBUNREGISTER("Premium")
		ENDIF
	ELSE
		IF NOT($REGISTROUADLIB) AND WINEXISTS("Diablo II: Resurrected") THEN
			$REGISTROUADLIB = 1
			ADLIBREGISTER("VerificarCrash")
			ADLIBREGISTER("VerificarInternet", 1000)
		ENDIF
		IF($SERIALSPLIT = "0707") AND($APPSTATS OR $STOPSERVERDOWN) AND NOT $REGISTROUADLIBPREMIUM THEN
			$REGISTROUADLIBPREMIUM = 1
			ADLIBREGISTER("Premium", 5000)
		ENDIF
		$TOOLTIP = "Running"
	ENDIF
	IF($SEMGOLD > 0) THEN
		$SEMGOLD = 0
		$TOOLTIP = "No Gold for Hire - Paused"
	ENDIF
	IF $PAROUSTASHEFULL THEN
		$PAROUSTASHEFULL = 0
		$TOOLTIP = "Stashes FULL - Paused"
	ENDIF
	LOCAL $ONCE = 1
	WHILE $PAUSAR
		IF NOT WINEXISTS("Diablo II: Resurrected") THEN
			$PAUSAR = 0
			PARAR()
		ENDIF
		IF NOT WINACTIVE("Diablo II: Resurrected") THEN
			IF($ONCE) THEN
				$ONCE = 0
				HOTKEYSET("e")
				HOTKEYSET("!e")
				HOTKEYSET("+e")
				HOTKEYSET("p")
				HOTKEYSET("!p")
				HOTKEYSET("+p")
				HOTKEYSET("v")
				HOTKEYSET("!v")
				HOTKEYSET("+v")
				HOTKEYSET("p", "MSGPAUSAP")
				HOTKEYSET("!p", "MSGPAUSAP")
				HOTKEYSET("+p", "MSGPAUSAP")
				HOTKEYSET("v", "MSGPAUSAV")
				HOTKEYSET("!v", "MSGPAUSAV")
				HOTKEYSET("+v", "MSGPAUSAV")
				HOTKEYSET("e", "MSGPAUSAE")
				HOTKEYSET("!e", "MSGPAUSAE")
				HOTKEYSET("+e", "MSGPAUSAE")
				$TOOLTIP = "Back to the game to unpause/exit " & $FILENAME
			ENDIF
		ELSE
			IF NOT($ONCE) THEN
				$ONCE = 1
				HOTKEYSET("e")
				HOTKEYSET("!e")
				HOTKEYSET("+e")
				HOTKEYSET("p")
				HOTKEYSET("!p")
				HOTKEYSET("+p")
				HOTKEYSET("v")
				HOTKEYSET("!v")
				HOTKEYSET("+v")
				HOTKEYSET("e", "PARAR")
				HOTKEYSET("!e", "PARAR")
				HOTKEYSET("+e", "PARAR")
				HOTKEYSET("p", "PAUSA")
				HOTKEYSET("!p", "PAUSA")
				HOTKEYSET("+p", "PAUSA")
				HOTKEYSET("v", "VISUAL")
				HOTKEYSET("!v", "VISUAL")
				HOTKEYSET("+v", "VISUAL")
				TOOLTIP("")
				$TOOLTIP = "Press P to continue"
			ENDIF
		ENDIF
		SLEEP(10)
	WEND
ENDFUNC
FUNC MSGPAUSAP()
	HOTKEYSET("p")
	HOTKEYSET("!p")
	HOTKEYSET("+p")
	SEND("p")
	HOTKEYSET("p", "MSGPAUSAP")
	HOTKEYSET("!p", "MSGPAUSAP")
	HOTKEYSET("+p", "MSGPAUSAP")
	TOOLTIP("Back to the game to unpause/exit " & $FILENAME, (@DESKTOPWIDTH / 2), 8, "", -1, 2)
ENDFUNC
FUNC MSGPAUSAV()
	HOTKEYSET("v")
	HOTKEYSET("!v")
	HOTKEYSET("+v")
	SEND("v")
	HOTKEYSET("v", "MSGPAUSAV")
	HOTKEYSET("!v", "MSGPAUSAV")
	HOTKEYSET("+v", "MSGPAUSAV")
	TOOLTIP("Back to the game to unpause/exit " & $FILENAME, (@DESKTOPWIDTH / 2), 8, "", -1, 2)
ENDFUNC
FUNC MSGPAUSAE()
	HOTKEYSET("e")
	HOTKEYSET("!e")
	HOTKEYSET("+e")
	SEND("e")
	HOTKEYSET("e", "MSGPAUSAE")
	HOTKEYSET("!e", "MSGPAUSAE")
	HOTKEYSET("+e", "MSGPAUSAE")
	TOOLTIP("Back to the game to unpause/exit " & $FILENAME, (@DESKTOPWIDTH / 2), 8, "", -1, 2)
ENDFUNC
FUNC VISUAL()
	IF $VISUAL > 0 THEN
		$VISUAL = 0
		GUISETSTATE(@SW_HIDE, $WINDOW2)
	ELSE
		$VISUAL = 2
		GUISETSTATE(@SW_SHOW, $WINDOW2)
	ENDIF
	ATUALIZARINI(1)
	WINACTIVATE("Diablo II: Resurrected")
ENDFUNC
FUNC SAIR()
	SEND2("{LCTRL}")
	SLEEP2(20)
	SEND2("{LSHIFT}")
	SLEEP2(20)
	CRIARLOGFILE()
	WINCLOSE("Premium")
	WINCLOSE("AutoIt Error")
	PROCESSCLOSE("Premium.exe")
	EXIT
ENDFUNC
FUNC PREMIUM()
	CRIARLOGFILE()
	LOCAL $FILEPREM = @SCRIPTDIR & "\log\Premium.txt"
	WHILE 1
		$QTOSVERIFICARACAO += 1
		WINCLOSE("AutoIt Error")
		WINCLOSE("Premium")
		PROCESSCLOSE("Premium.exe")
		IF NOT WINEXISTS("Premium") THEN
			IF FILEEXISTS(@SCRIPTDIR & "\Premium.exe") THEN
				IF($QTOSVERIFICARACAO > RANDOM(10, 15, 1)) THEN
					$QTOSVERIFICARACAO = 2
					SHELLEXECUTE(@SCRIPTDIR & "\Premium.exe", "", "", "", @SW_HIDE)
				ENDIF
			ENDIF
		ENDIF
		IF NOT FILEEXISTS($FILEPREM) THEN
			LOCAL $HFILEOPEN = FILEOPEN($FILEPREM, ($QTOSVERIFICARACAO = 1) ? 128 + 2 : 0)
			IF $HFILEOPEN = -1 THEN
				LOGREG("erro ao abrir arquivo Premium.txt")
				EXITLOOP
			ELSE
				FILEWRITE($HFILEOPEN, "0|0|1")
				FILECLOSE($HFILEOPEN)
			ENDIF
		ELSE
			IF _FILEISUSES($FILEPREM) THEN RETURN
			LOCAL $HFILEOPEN = FILEOPEN($FILEPREM, ($QTOSVERIFICARACAO = 1) ? 128 + 2 : 0)
			IF $HFILEOPEN = -1 THEN
				CONSOLEWRITE("erro ao abrir arquivo Premium.txt")
				EXITLOOP
			ELSE
				IF($QTOSVERIFICARACAO = 1) THEN
					FILEWRITE($HFILEOPEN, "0|0|1")
					FILECLOSE($HFILEOPEN)
					EXITLOOP
				ELSE
					LOCAL $SFILEREAD = FILEREAD($HFILEOPEN)
					FILECLOSE($HFILEOPEN)
					IF NOT @ERROR THEN
						LOCAL $VERIFICARACAO = STRINGSPLIT($SFILEREAD, "|")
						IF($VERIFICARACAO[1] = "1") THEN
							IF NOT($NAOPODEPARAR) THEN
								$TOOLTIP = "Received online PAUSE. Press Unpause BUTTON online"
								IF($LOGAR = 0) THEN
									$LOGAR = 1
									LOGREG($TOOLTIP)
									CRIARLOGFILE()
								ENDIF
								SLEEP2(1000)
							ELSE
								$TOOLTIP = "Received online PAUSE. Will pause when its safe."
								EXITLOOP
							ENDIF
						ENDIF
						IF($VERIFICARACAO[2] = "1") THEN
							IF $REGISTROUADLIB THEN
								ADLIBUNREGISTER("VerificarCrash")
								ADLIBUNREGISTER("VerificarInternet")
								$REGISTROUADLIB = 0
							ENDIF
							WINCLOSE("Diablo II: Resurrected")
							$TOOLTIP = "Received online STOP. Press Start BUTTON online"
							IF($LOGAR = 0) THEN
								$LOGAR = 1
								LOGREG($TOOLTIP)
								CRIARLOGFILE()
							ENDIF
							SLEEP2(1000)
						ENDIF
						IF($VERIFICARACAO[3] = "0") THEN
							IF $REGISTROUADLIB THEN
								ADLIBUNREGISTER("VerificarCrash")
								ADLIBUNREGISTER("VerificarInternet")
								$REGISTROUADLIB = 0
							ENDIF
							WINCLOSE("Diablo II: Resurrected")
							$TOOLTIP = "Received online SERVER IS DOWN. Awaiting to SERVER is UP"
							IF($LOGAR = 0) THEN
								$LOGAR = 1
								LOGREG($TOOLTIP)
								CRIARLOGFILE()
							ENDIF
							SLEEP2(1000)
						ENDIF
						IF($VERIFICARACAO[1] = "0" AND $VERIFICARACAO[2] = "0" AND $VERIFICARACAO[3] = "1") THEN
							IF NOT($REGISTROUADLIB) THEN
								$TOOLTIP = "Running"
								$LOGAR = 0
								$REGISTROUADLIB = 1
								ADLIBREGISTER("VerificarCrash", 500)
								ADLIBREGISTER("VerificarInternet", 1000)
							ENDIF
							EXITLOOP
						ENDIF
					ENDIF
				ENDIF
			ENDIF
		ENDIF
		DOTIP()
	WEND
ENDFUNC
FUNC CRIARLOGFILE()
	IF NOT FILEEXISTS(@SCRIPTDIR & "\log\") THEN
		DO
			DIRCREATE(@SCRIPTDIR & "\log\")
		UNTIL FILEEXISTS(@SCRIPTDIR & "\log\")
	ENDIF
	LOCAL $H_FILE = FILEOPEN(@SCRIPTDIR & "\log\stats.txt", 128 + 2)
	FILEWRITE($H_FILE, DOTIP())
	FILECLOSE($H_FILE)
ENDFUNC
FUNC DOTIP()
	LOCAL $TTSTRING = $TOOLTIP & " | Runs: " & $QUANTASRUNS & " | Deaths: " & $MORTES & " | Merc Deaths: " & $REVIVEUMERC & " | Chicken: " & $QUANTASCHICKEN & " | Items: " & $GUARDOUITEM & " | Running time: " & CALCULARTEMPO()
	LOCAL $X = (@DESKTOPWIDTH / 2)
	LOCAL $TOP = 8
	LOCAL $OP = 2
	IF $VISUAL > 0 THEN
		IF($VISUAL = 2) THEN
			GUICTRLSETDATA($STATUSATT1, $TOOLTIP)
			GUICTRLSETDATA($STATUSATT2, CALCULARTEMPO())
			GUICTRLSETDATA($STATUSATT3, $QUANTASRUNS)
			GUICTRLSETDATA($STATUSATT4, $MORTES)
			GUICTRLSETDATA($STATUSATT5, $REVIVEUMERC)
			GUICTRLSETDATA($STATUSATT6, $QUANTASCHICKEN)
			GUICTRLSETDATA($STATUSATT7, $GUARDOUITEM)
			IF $SERIALSPLIT = "0707" THEN
				GUICTRLSETDATA($STATUSATT8, "Premium")
				GUICTRLSETCOLOR(-1, 16020482)
			ELSEIF $SERIALSPLIT = "1609" THEN
				GUICTRLSETDATA($STATUSATT8, "Pindle + Eld")
				GUICTRLSETCOLOR(-1, 10494192)
			ELSE
				GUICTRLSETDATA($STATUSATT8, "Pindle")
			ENDIF
		ELSE
			TOOLTIP($TTSTRING, $X, $TOP, "", -1, $OP)
		ENDIF
	ELSE
		TOOLTIP("", $X, $TOP, "", -1, $OP)
	ENDIF
	RETURN $TTSTRING
ENDFUNC
FUNC CALCULARTEMPO()
	$ISEC = TIMERDIFF($RUNNINGTIME) / 1000
	$DAYS = INT($ISEC / (24 * 60 * 60))
	$REMAIN = MOD($ISEC, (24 * 60 * 60))
	$HOURS = INT($REMAIN / (60 * 60))
	$REMAIN = MOD($REMAIN, (60 * 60))
	$MINS = INT($REMAIN / 60)
	$SECS = INT(MOD($REMAIN, 60))
	$HOURS = ($HOURS < 10) ? "0" & $HOURS : $HOURS
	$MINS = ($MINS < 10) ? "0" & $MINS : $MINS
	$SECS = ($SECS < 10) ? "0" & $SECS : $SECS
	RETURN(($DAYS <> 0) ? $DAYS & "d " : "") & (($HOURS <> 0) ? $HOURS & "h " : "") & (($MINS <> 0) ? $MINS & "m " : "") & $SECS & "s"
ENDFUNC
FUNC ATUALIZARINI($ATUALIZARINI)
	IF NOT FILEEXISTS($FILEINI) THEN
		INIWRITESECTION($FILEINI, "Geral", "Versao=" & $VERSAO & @LF & "Visual=2" & @LF & "Serial=" & @LF & "Executavel=" & $DEFAULTD2RFOLDER & @LF & "Dificuldade=Hell" & @LF & "PararSemGold=1" & @LF & "UsarCTA=0" & @LF & "PcDevagar=0" & @LF & "PararStashFull=1" & @LF & "FirstTimeRunning=1" & @LF & "Teleport=1" & @LF & "Mercenary=1")
		INIWRITESECTION($FILEINI, "Time", "HoraInicio=10 PM" & @LF & "HoraFim=2 AM" & @LF & "HoraInicio2=4 AM" & @LF & "HoraFim2=6 AM" & @LF & "HoraInicio3=8 AM" & @LF & "HoraFim3=9 AM" & @LF & "HoraInicio4=-" & @LF & "HoraFim4=-" & @LF & "HoraInicio5=-" & @LF & "HoraFim5=-" & @LF & "HoraInicio6=-" & @LF & "HoraFim6=-" & @LF & "TempoExtra1=5" & @LF & "TempoExtra2=120" & @LF & "TempoParaCriar1=5" & @LF & "TempoParaCriar2=120")
		INIWRITESECTION($FILEINI, "Binds", "BindKey0=" & $HOTKEY0 & @LF & "BindKey7=" & $HOTKEY7 & @LF & "BindKey1=" & $HOTKEY1 & @LF & "BindKey2=" & $HOTKEY2 & @LF & "BindKey3=" & $HOTKEY3 & @LF & "BindKey4=" & $HOTKEY4 & @LF & "BindKey5=" & $HOTKEY5 & @LF & "BindKey6=" & $HOTKEY6)
		INIWRITESECTION($FILEINI, "Items", "Uniques=1" & @LF & "Sets=1" & @LF & "Rares=1" & @LF & "Magics=1" & @LF & "Runes=1")
		INIWRITESECTION($FILEINI, "Premium", "MatarPindle=1" & @LF & "MatarEldritch=0" & @LF & "MatarShenk=0" & @LF & "MatarTravincal=0" & @LF & "PindlePath=0" & @LF & "ChangeAct=0" & @LF & "RandomPause=0" & @LF & "Chicken=0" & @LF & "RandomUseChat=0" & @LF & "StopServerDown=0" & @LF & "RandomGamePass=0" & @LF & "RandomMouseMove=0" & @LF & "AppStats=0")
	ENDIF
	IF $ATUALIZARINI THEN
		IF $EXECUTAVEL = "" THEN $EXECUTAVEL = $DEFAULTD2RFOLDER
		INIWRITESECTION($FILEINI, "Geral", "Versao=" & $VERSAO & @LF & "Visual=" & $VISUAL & @LF & "Serial=" & $SERIAL & @LF & "Executavel=" & $EXECUTAVEL & @LF & "Dificuldade=" & $DIFFICULT & @LF & "PararSemGold=" & $PARARSEMGOLD & @LF & "UsarCTA=" & $USARCTA & @LF & "PcDevagar=" & $PCDEVAGAR & @LF & "PararStashFull=" & $PARARSTASHFULL & @LF & "FirstTimeRunning=" & $FIRSTTIMERUNNING & @LF & "Teleport=" & $TELEPORT & @LF & "Mercenary=" & $MERCENARY)
		INIWRITESECTION($FILEINI, "Time", "HoraInicio=" & $HORAINICIO & @LF & "HoraFim=" & $HORAFIM & @LF & "HoraInicio2=" & $HORAINICIO2 & @LF & "HoraFim2=" & $HORAFIM2 & @LF & "HoraInicio3=" & $HORAINICIO3 & @LF & "HoraFim3=" & $HORAFIM3 & @LF & "HoraInicio4=" & $HORAINICIO4 & @LF & "HoraFim4=" & $HORAFIM4 & @LF & "HoraInicio5=" & $HORAINICIO5 & @LF & "HoraFim5=" & $HORAFIM5 & @LF & "HoraInicio6=" & $HORAINICIO6 & @LF & "HoraFim6=" & $HORAFIM6 & @LF & "TempoExtra1=" & $TEMPOEXTRA1 & @LF & "TempoExtra2=" & $TEMPOEXTRA2 & @LF & "TempoParaCriar1=" & $TEMPOPARACRIAR1 & @LF & "TempoParaCriar2=" & $TEMPOPARACRIAR2)
		INIWRITESECTION($FILEINI, "Binds", "BindKey0=" & $HOTKEY0 & @LF & "BindKey7=" & $HOTKEY7 & @LF & "BindKey1=" & $HOTKEY1 & @LF & "BindKey2=" & $HOTKEY2 & @LF & "BindKey3=" & $HOTKEY3 & @LF & "BindKey4=" & $HOTKEY4 & @LF & "BindKey5=" & $HOTKEY5 & @LF & "BindKey6=" & $HOTKEY6)
		INIWRITESECTION($FILEINI, "Items", "Uniques=" & $UNIQUES & @LF & "Sets=" & $SETS & @LF & "Rares=" & $RARES & @LF & "Magics=" & $MAGICS & @LF & "Runes=" & $RUNES)
		INIWRITESECTION($FILEINI, "Premium", "MatarPindle=" & $MATARPINDLE & @LF & "MatarEldritch=" & $MATARELDRITCH & @LF & "MatarShenk=" & $MATARSHENK & @LF & "MatarTravincal=" & $MATARTRAVINCAL & @LF & "PindlePath=" & $PINDLEPATH & @LF & "ChangeAct=" & $CHANGEACT & @LF & "RandomPause=" & $RANDOMPAUSE & @LF & "Chicken=" & $CHICKEN & @LF & "RandomUseChat=" & $RANDOMUSECHAT & @LF & "StopServerDown=" & $STOPSERVERDOWN & @LF & "RandomGamePass=" & $RANDOMGAMEPASS & @LF & "RandomMouseMove=" & $RANDOMMOUSEMOVE & @LF & "AppStats=" & $APPSTATS)
	ENDIF
ENDFUNC
FUNC LERINI()
	LOCAL $INIGERAL = INIREADSECTION($FILEINI, "Geral")
	IF @ERROR THEN
		FILEDELETE($FILEINI)
		WHILE 1
			SLEEP(100)
			IF NOT FILEEXISTS($FILEINI) THEN
				ATUALIZARINI(0)
				EXITLOOP
			ENDIF
		WEND
		LOGREG("Ini 1")
		WHILE 1
			SLEEP(100)
			IF FILEEXISTS($FILEINI) THEN
				EXITLOOP
			ENDIF
		WEND
		LERINI()
		RETURN
	ENDIF
	IF NOT @ERROR THEN
		FOR $I = 1 TO $INIGERAL[0][0]
			IF($INIGERAL[$I][0] = "Visual") THEN
				$VISUAL = INT($INIGERAL[$I][1])
			ENDIF
			IF($INIGERAL[$I][0] = "Serial") THEN
				$SERIAL = $INIGERAL[$I][1]
				#$SERIALSPLIT = STRINGSPLIT($SERIAL, ":")[1]
			ENDIF
			IF($INIGERAL[$I][0] = "Executavel") THEN
				$EXECUTAVEL = $INIGERAL[$I][1]
			ENDIF
			IF($INIGERAL[$I][0] = "Dificuldade") THEN
				$DIFFICULT = $INIGERAL[$I][1]
			ENDIF
			IF($INIGERAL[$I][0] = "PararSemGold") THEN
				$PARARSEMGOLD = INT($INIGERAL[$I][1])
			ENDIF
			IF($INIGERAL[$I][0] = "UsarCTA") THEN
				$USARCTA = INT($INIGERAL[$I][1])
			ENDIF
			IF($INIGERAL[$I][0] = "PcDevagar") THEN
				$PCDEVAGAR = INT($INIGERAL[$I][1])
			ENDIF
			IF($INIGERAL[$I][0] = "PararStashFull") THEN
				$PARARSTASHFULL = INT($INIGERAL[$I][1])
			ENDIF
			IF($INIGERAL[$I][0] = "FirstTimeRunning") THEN
				$FIRSTTIMERUNNING = INT($INIGERAL[$I][1])
			ENDIF
			IF($INIGERAL[$I][0] = "Teleport") THEN
				$TELEPORT = INT($INIGERAL[$I][1])
			ENDIF
			IF($INIGERAL[$I][0] = "Mercenary") THEN
				$MERCENARY = INT($INIGERAL[$I][1])
			ENDIF
		NEXT
	ENDIF
	LOCAL $INIBINDS = INIREADSECTION($FILEINI, "Binds")
	IF @ERROR THEN
		FILEDELETE($FILEINI)
		WHILE 1
			SLEEP(100)
			IF NOT FILEEXISTS($FILEINI) THEN
				ATUALIZARINI(0)
				EXITLOOP
			ENDIF
		WEND
		LOGREG("Ini 2")
		WHILE 1
			SLEEP(100)
			IF FILEEXISTS($FILEINI) THEN
				EXITLOOP
			ENDIF
		WEND
		LERINI()
		RETURN
	ENDIF
	IF NOT @ERROR THEN
		FOR $I = 1 TO $INIBINDS[0][0]
			IF($INIBINDS[$I][0] = "BindKey0") THEN
				$HOTKEY0 = $INIBINDS[$I][1]
			ENDIF
			IF($INIBINDS[$I][0] = "BindKey7") THEN
				$HOTKEY7 = $INIBINDS[$I][1]
			ENDIF
			IF($INIBINDS[$I][0] = "BindKey1") THEN
				$HOTKEY1 = $INIBINDS[$I][1]
			ENDIF
			IF($INIBINDS[$I][0] = "BindKey2") THEN
				$HOTKEY2 = $INIBINDS[$I][1]
			ENDIF
			IF($INIBINDS[$I][0] = "BindKey3") THEN
				$HOTKEY3 = $INIBINDS[$I][1]
			ENDIF
			IF($INIBINDS[$I][0] = "BindKey4") THEN
				$HOTKEY4 = $INIBINDS[$I][1]
			ENDIF
			IF($INIBINDS[$I][0] = "BindKey5") THEN
				$HOTKEY5 = $INIBINDS[$I][1]
			ENDIF
			IF($INIBINDS[$I][0] = "BindKey6") THEN
				$HOTKEY6 = $INIBINDS[$I][1]
			ENDIF
		NEXT
	ENDIF
	LOCAL $INITIME = INIREADSECTION($FILEINI, "Time")
	IF @ERROR THEN
		FILEDELETE($FILEINI)
		WHILE 1
			SLEEP(100)
			IF NOT FILEEXISTS($FILEINI) THEN
				ATUALIZARINI(0)
				EXITLOOP
			ENDIF
		WEND
		LOGREG("Ini 3")
		WHILE 1
			SLEEP(100)
			IF FILEEXISTS($FILEINI) THEN
				EXITLOOP
			ENDIF
		WEND
		LERINI()
		RETURN
	ENDIF
	IF NOT @ERROR THEN
		FOR $I = 1 TO $INITIME[0][0]
			IF($INITIME[$I][0] = "HoraInicio") THEN
				$HORAINICIO = $INITIME[$I][1]
			ENDIF
			IF($INITIME[$I][0] = "HoraFim") THEN
				$HORAFIM = $INITIME[$I][1]
			ENDIF
			IF($INITIME[$I][0] = "HoraInicio2") THEN
				$HORAINICIO2 = $INITIME[$I][1]
			ENDIF
			IF($INITIME[$I][0] = "HoraFim2") THEN
				$HORAFIM2 = $INITIME[$I][1]
			ENDIF
			IF($INITIME[$I][0] = "HoraInicio3") THEN
				$HORAINICIO3 = $INITIME[$I][1]
			ENDIF
			IF($INITIME[$I][0] = "HoraFim3") THEN
				$HORAFIM3 = $INITIME[$I][1]
			ENDIF
			IF($INITIME[$I][0] = "HoraInicio4") THEN
				$HORAINICIO4 = $INITIME[$I][1]
			ENDIF
			IF($INITIME[$I][0] = "HoraFim4") THEN
				$HORAFIM4 = $INITIME[$I][1]
			ENDIF
			IF($INITIME[$I][0] = "HoraInicio5") THEN
				$HORAINICIO5 = $INITIME[$I][1]
			ENDIF
			IF($INITIME[$I][0] = "HoraFim5") THEN
				$HORAFIM5 = $INITIME[$I][1]
			ENDIF
			IF($INITIME[$I][0] = "HoraInicio6") THEN
				$HORAINICIO6 = $INITIME[$I][1]
			ENDIF
			IF($INITIME[$I][0] = "HoraFim6") THEN
				$HORAFIM6 = $INITIME[$I][1]
			ENDIF
			IF($INITIME[$I][0] = "TempoExtra1") THEN
				$TEMPOEXTRA1 = INT($INITIME[$I][1])
			ENDIF
			IF($INITIME[$I][0] = "TempoExtra2") THEN
				$TEMPOEXTRA2 = INT($INITIME[$I][1])
			ENDIF
			IF($INITIME[$I][0] = "TempoParaCriar1") THEN
				$TEMPOPARACRIAR1 = INT($INITIME[$I][1])
			ENDIF
			IF($INITIME[$I][0] = "TempoParaCriar2") THEN
				$TEMPOPARACRIAR2 = INT($INITIME[$I][1])
			ENDIF
		NEXT
	ENDIF
	LOCAL $INIITEMS = INIREADSECTION($FILEINI, "Items")
	IF @ERROR THEN
		FILEDELETE($FILEINI)
		WHILE 1
			SLEEP(100)
			IF NOT FILEEXISTS($FILEINI) THEN
				ATUALIZARINI(0)
				EXITLOOP
			ENDIF
		WEND
		LOGREG("Ini 4")
		WHILE 1
			SLEEP(100)
			IF FILEEXISTS($FILEINI) THEN
				EXITLOOP
			ENDIF
		WEND
		LERINI()
		RETURN
	ENDIF
	IF NOT @ERROR THEN
		FOR $I = 1 TO $INIITEMS[0][0]
			IF($INIITEMS[$I][0] = "Uniques") THEN
				$UNIQUES = INT($INIITEMS[$I][1])
			ENDIF
			IF($INIITEMS[$I][0] = "Sets") THEN
				$SETS = INT($INIITEMS[$I][1])
			ENDIF
			IF($INIITEMS[$I][0] = "Rares") THEN
				$RARES = INT($INIITEMS[$I][1])
			ENDIF
			IF($INIITEMS[$I][0] = "Magics") THEN
				$MAGICS = INT($INIITEMS[$I][1])
			ENDIF
			IF($INIITEMS[$I][0] = "Runes") THEN
				$RUNES = INT($INIITEMS[$I][1])
			ENDIF
		NEXT
	ENDIF
	LOCAL $INIPREMIUM = INIREADSECTION($FILEINI, "Premium")
	IF @ERROR THEN
		FILEDELETE($FILEINI)
		WHILE 1
			SLEEP(100)
			IF NOT FILEEXISTS($FILEINI) THEN
				ATUALIZARINI(0)
				EXITLOOP
			ENDIF
		WEND
		LOGREG("Ini 5")
		WHILE 1
			SLEEP(100)
			IF FILEEXISTS($FILEINI) THEN
				EXITLOOP
			ENDIF
		WEND
		LERINI()
		RETURN
	ENDIF
	IF NOT @ERROR THEN
		FOR $I = 1 TO $INIPREMIUM[0][0]
			IF($INIPREMIUM[$I][0] = "MatarPindle") THEN
				$MATARPINDLE = INT($INIPREMIUM[$I][1])
			ENDIF
			IF($INIPREMIUM[$I][0] = "MatarEldritch") THEN
				$MATARELDRITCH = INT($INIPREMIUM[$I][1])
			ENDIF
			IF($INIPREMIUM[$I][0] = "MatarShenk") THEN
				$MATARSHENK = INT($INIPREMIUM[$I][1])
			ENDIF
			IF($INIPREMIUM[$I][0] = "MatarTravincal") THEN
				$MATARTRAVINCAL = INT($INIPREMIUM[$I][1])
			ENDIF
			IF($INIPREMIUM[$I][0] = "PindlePath") THEN
				$PINDLEPATH = INT($INIPREMIUM[$I][1])
			ENDIF
			IF($INIPREMIUM[$I][0] = "ChangeAct") THEN
				$CHANGEACT = INT($INIPREMIUM[$I][1])
			ENDIF
			IF($INIPREMIUM[$I][0] = "RandomPause") THEN
				$RANDOMPAUSE = INT($INIPREMIUM[$I][1])
			ENDIF
			IF($INIPREMIUM[$I][0] = "Chicken") THEN
				$CHICKEN = INT($INIPREMIUM[$I][1])
			ENDIF
			IF($INIPREMIUM[$I][0] = "RandomUseChat") THEN
				$RANDOMUSECHAT = INT($INIPREMIUM[$I][1])
			ENDIF
			IF($INIPREMIUM[$I][0] = "StopServerDown") THEN
				$STOPSERVERDOWN = INT($INIPREMIUM[$I][1])
			ENDIF
			IF($INIPREMIUM[$I][0] = "RandomGamePass") THEN
				$RANDOMGAMEPASS = INT($INIPREMIUM[$I][1])
			ENDIF
			IF($INIPREMIUM[$I][0] = "RandomMouseMove") THEN
				$RANDOMMOUSEMOVE = INT($INIPREMIUM[$I][1])
			ENDIF
			IF($INIPREMIUM[$I][0] = "AppStats") THEN
				$APPSTATS = INT($INIPREMIUM[$I][1])
			ENDIF
		NEXT
	ENDIF
	IF($INIGERAL[1][0] = "Versao" AND $INIGERAL[1][1] <> $VERSAO) THEN
		ATUALIZARINI(1)
		SLEEP2(500)
		LOGREG("Ini 6")
		LERINI()
		RETURN
	ENDIF
ENDFUNC
FUNC DOUPDATE($CLICOUUPDATE)
	IF _ISINTERNETCONNECTED() THEN
		$OHTTP = OBJCREATE("winhttp.winhttprequest.5.1")
		$OHTTP.Open("GET", "https://www.d2rmab.com/ajax/verificar.php?update=1", FALSE)
		IF @ERROR THEN RETURN SETERROR(1, @ERROR, 0)
		$OHTTP.Send()
		IF @ERROR THEN RETURN SETERROR(2, @ERROR, 105)
		$ORECEIVED = $OHTTP.ResponseText
		$OSTATUSCODE = $OHTTP.Status
		IF @ERROR THEN RETURN SETERROR(3, @ERROR, 118)
		$OHTTP = 0
		IF($OSTATUSCODE == 200) THEN
			LOCAL $SPLITDOWNLOAD = STRINGSPLIT($ORECEIVED, "|")
			IF($SPLITDOWNLOAD[1] <> $VERSAO) THEN
				$MSG2 = MSGBOX(BITOR(4, 32), $FILENAME, "Would you like to update from version " & $VERSAO & " to " & $SPLITDOWNLOAD[1] & "?")
				IF $MSG2 = 6 THEN
					FILEINSTALL("D:\OneDrive\Programacao\Autoit\Diablo2\OneDrive\updater\Updater.exe", @SCRIPTDIR & "\", 1)
					LOGREG("Downloading Update")
					$DLHANDLE = INETGET($SPLITDOWNLOAD[2], @SCRIPTDIR & "\OneDrive-v" & $SPLITDOWNLOAD[1] & ".zip", 1, 1)
					LOCAL $H_FILE2 = FILEOPEN(@SCRIPTDIR & "\update.txt", 128 + 2)
					FILEWRITE($H_FILE2, "OneDrive-v" & $SPLITDOWNLOAD[1] & ".zip")
					FILECLOSE($H_FILE2)
					PROGRESSON($FILENAME, "Downloading Updates", "", -1, -1, 16)
					$SIZE = INETGETSIZE($SPLITDOWNLOAD[2], 1)
					WHILE NOT INETGETINFO($DLHANDLE, 2)
						$PERCENT = INT((INETGETINFO($DLHANDLE, 0) / $SIZE) * 100)
						PROGRESSSET($PERCENT, $PERCENT & " percent")
						SLEEP(1)
					WEND
					PROGRESSSET(100, $FILENAME, "Download complete, please wait...")
					SLEEP2(500)
					PROGRESSOFF()
					INETCLOSE($DLHANDLE)
					IF FILEEXISTS(@SCRIPTDIR & "\Updater.exe") THEN RUN(@SCRIPTDIR & "\Updater.exe")
					LOGREG("Download finished")
					EXIT
				ENDIF
			ELSE
				IF $CLICOUUPDATE THEN MSGBOX(64, $FILENAME, "There is no update available!")
			ENDIF
		ELSE
			MSGBOX(48, $FILENAME, "The server seems to be offline. Check your internet connection.")
		ENDIF
	ELSE
		MSGBOX(48, $FILENAME, "Check your internet connection.")
	ENDIF
ENDFUNC
FUNC _FILEISUSES($SFILE)
	LOCAL $HFILE = _WINAPI_CREATEFILE($SFILE, 2, 2, 0)
	IF $HFILE THEN
		_WINAPI_CLOSEHANDLE($HFILE)
		RETURN 0
	ENDIF
	LOCAL $ERROR = _WINAPI_GETLASTERROR()
	SWITCH $ERROR
		CASE 32
			RETURN 1
		CASE ELSE
			RETURN SETERROR($ERROR, 0, 0)
	ENDSWITCH
ENDFUNC
FUNC __CALCI1($I, $SM)
	RETURN $I ^ $SM
ENDFUNC
FUNC __CALCI2($I, $SM)
	RETURN 1 - ((1 - $I) ^ $SM)
ENDFUNC
FUNC __CALCI($I, $SM)
	IF($I < 0.5) THEN
		RETURN __CALCI1($I * 2, $SM) / 2
	ELSE
		RETURN(__CALCI2(($I - 0.5) * 2, $SM) / 2) + 0.5
	ENDIF
ENDFUNC
FUNC __CALOF($I, $SM)
	IF($I < 0.5) THEN
		RETURN __CALCI($I * 2, $SM)
	ELSE
		RETURN __CALCI((1 - $I) * 2, $SM)
	ENDIF
ENDFUNC
FUNC MOUSEMOVE2($X2, $Y2)
	$X1 = MOUSEGETPOS(0)
	$Y1 = MOUSEGETPOS(1)
	$XV = RANDOM(-100, 100)
	$YV = RANDOM(-100, 100)
	$SM = RANDOM(1.5, 2.5)
	$M = RANDOM(35, 55)
	FOR $I = 0 TO $M
		$CI = __CALCI($I / $M, $SM)
		$CO = __CALOF($I / $M, $SM)
		$CX = $X1 + (($X2 - $X1) * $CI) + ($XV * $CO)
		$CY = $Y1 + (($Y2 - $Y1) * $CI) + ($YV * $CO)
		MOUSEMOVE($CX, $CY, 1)
	NEXT
ENDFUNC
FUNC RANDOMWORD()
	LOCAL $PATTERN[8] = ["Xo", "Xoxo", "Xoxoxo", "Xoo", "Ooxo", "Xoxoo", "Xoxoxoxo", "Xoooxoxo"]
	LOCAL $I = 0
	LOCAL $FRASE = ""
	WHILE $I <= RANDOM(1, 10, 1)
		$FRASE &= _RANDOMWORD($PATTERN[RANDOM(0, UBOUND($PATTERN) - 1, 1)]) & " "
		$I += 1
	WEND
	RETURN $FRASE
ENDFUNC
FUNC _RANDOMWORD($SPATTERN)
	LOCAL $ASPLIT = STRINGSPLIT($SPATTERN, "")
	LOCAL $AXLIST = STRINGSPLIT("bcdfghjklmnqrstwxyz", "")
	LOCAL $AOLIST = STRINGSPLIT("aiou", "")
	LOCAL $SRETURN = ""
	FOR $I = 1 TO $ASPLIT[0]
		IF($ASPLIT[$I] == "X") THEN
			$SRETURN &= STRINGUPPER($AXLIST[RANDOM(1, $AXLIST[0], 1)])
		ELSEIF($ASPLIT[$I] == "x") THEN
			$SRETURN &= $AXLIST[RANDOM(1, $AXLIST[0], 1)]
		ELSEIF($ASPLIT[$I] == "O") THEN
			$SRETURN &= STRINGUPPER($AOLIST[RANDOM(1, $AOLIST[0], 1)])
		ELSEIF($ASPLIT[$I] == "o") THEN
			$SRETURN &= $AOLIST[RANDOM(1, $AOLIST[0], 1)]
		ENDIF
	NEXT
	RETURN $SRETURN
ENDFUNC
FUNC _ISINTERNETCONNECTED()
	LOCAL $ARETURN = DLLCALL("connect.dll", "long", "IsInternetConnected")
	IF @ERROR THEN
		RETURN SETERROR(1, 0, FALSE)
	ENDIF
	RETURN $ARETURN[0] = 0
ENDFUNC
FUNC _IMAGESEARCHAREA($FINDIMAGE, $RESULTPOSITION, $X1, $Y1, $RIGHT, $BOTTOM, BYREF $X, BYREF $Y, $TOLERANCE)
	IF $TOLERANCE > 0 THEN $FINDIMAGE = "*" & $TOLERANCE & " " & $FINDIMAGE
	$FINDIMAGE = "*TRANSBLACK " & $FINDIMAGE
	$RESULT = DLLCALL($FILENAME & ".dll", "str", "ImageSearch", "int", $X1, "int", $Y1, "int", $RIGHT, "int", $BOTTOM, "str", $FINDIMAGE)
	IF $RESULT = "0" THEN
		RETURN 0
	ENDIF
	$ARRAY = STRINGSPLIT($RESULT[0], "|")
	IF(UBOUND($ARRAY) >= 4) THEN
		$X = INT(NUMBER($ARRAY[2]))
		$Y = INT(NUMBER($ARRAY[3]))
		IF $RESULTPOSITION = 1 THEN
			$X = $X + INT(NUMBER($ARRAY[4]) / 2)
			$Y = $Y + INT(NUMBER($ARRAY[5]) / 2)
		ENDIF
		RETURN 1
	ENDIF
ENDFUNC
FUNC _COMERRFUNC()
	LOGREG("Server ERROR " & @ERROR)
ENDFUNC
FUNC CONVERT24H($TIME2)
	IF($TIME2 <> "-") AND($TIME2 <> "") THEN
		LOCAL $SPLIT = STRINGSPLIT($TIME2, " ")
		LOCAL $TIME = INT($SPLIT[1])
		LOCAL $AMPM = $SPLIT[2]
		IF($TIME2 = "12 PM") THEN RETURN 12
		IF $AMPM = "AM" THEN RETURN MOD($TIME, 12)
		RETURN MOD($TIME + 12, 24)
	ELSE
		RETURN "-"
	ENDIF
ENDFUNC
FUNC _GUI_TOTRAY()
	GUISETSTATE(@SW_HIDE, $WINDOW1)
	TRAYSETONEVENT($TRAY_EVENT_PRIMARYUP, "_GUI_Restore")
	OPT("TrayIconHide", 0)
	RETURN $WINDOW1
ENDFUNC
FUNC _GUI_RESTORE()
	GUISETSTATE(@SW_SHOW, $WINDOW1)
	WINACTIVATE($WINDOW1)
	TRAYSETSTATE(2)
	OPT("TrayIconHide", 1)
ENDFUNC
; DeTokenise by myAut2Exe >The Open Source AutoIT/AutoHotKey script decompiler< 2.15 build(212)
